require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

require('../../../../thirdparty/jquery/jquery.js');
require('../../../../thirdparty/jquery-ondemand/jquery.ondemand.js');
require('../../src/sspath.js');
require('../../../../thirdparty/jquery-ui/jquery-ui.js');
require('../../../../thirdparty/json-js/json2.js');
require('../../../../thirdparty/jquery-entwine/dist/jquery.entwine-dist.js');
require('../../../../thirdparty/jquery-cookie/jquery.cookie.js');
require('../../../../thirdparty/jquery-query/jquery.query.js');
require('../../../../thirdparty/jquery-form/jquery.form.js');
require('../../../thirdparty/jquery-notice/jquery.notice.js');
require('../../../thirdparty/jsizes/lib/jquery.sizes.js');
require('../../../thirdparty/jlayout/lib/jlayout.border.js');
require('../../../thirdparty/jlayout/lib/jquery.jlayout.js');
require('../../../thirdparty/history-js/scripts/uncompressed/history.js');
require('../../../thirdparty/history-js/scripts/uncompressed/history.adapter.jquery.js');
require('../../../thirdparty/history-js/scripts/uncompressed/history.html4.js');
require('../../../../thirdparty/jstree/jquery.jstree.js');
require('../../../thirdparty/chosen/chosen/chosen.jquery.js');
require('../../../thirdparty/jquery-hoverIntent/jquery.hoverIntent.js');
require('../../../../thirdparty/jquery-changetracker/lib/jquery.changetracker.js');
require('../../../../javascript/src/TreeDropdownField.js');
require('../../../../javascript/src/DateField.js');
require('../../../../javascript/src/HtmlEditorField.js');
require('../../../../javascript/src/TabSet.js');
require('../../src/ssui.core.js');
require('../../../../javascript/src/GridField.js');

},{"../../../../javascript/src/DateField.js":13,"../../../../javascript/src/GridField.js":14,"../../../../javascript/src/HtmlEditorField.js":15,"../../../../javascript/src/TabSet.js":16,"../../../../javascript/src/TreeDropdownField.js":17,"../../../../thirdparty/jquery-changetracker/lib/jquery.changetracker.js":18,"../../../../thirdparty/jquery-cookie/jquery.cookie.js":19,"../../../../thirdparty/jquery-entwine/dist/jquery.entwine-dist.js":20,"../../../../thirdparty/jquery-form/jquery.form.js":21,"../../../../thirdparty/jquery-ondemand/jquery.ondemand.js":22,"../../../../thirdparty/jquery-query/jquery.query.js":23,"../../../../thirdparty/jquery-ui/jquery-ui.js":24,"../../../../thirdparty/jquery/jquery.js":25,"../../../../thirdparty/json-js/json2.js":26,"../../../../thirdparty/jstree/jquery.jstree.js":27,"../../../thirdparty/chosen/chosen/chosen.jquery.js":4,"../../../thirdparty/history-js/scripts/uncompressed/history.adapter.jquery.js":5,"../../../thirdparty/history-js/scripts/uncompressed/history.html4.js":6,"../../../thirdparty/history-js/scripts/uncompressed/history.js":7,"../../../thirdparty/jlayout/lib/jlayout.border.js":8,"../../../thirdparty/jlayout/lib/jquery.jlayout.js":9,"../../../thirdparty/jquery-hoverIntent/jquery.hoverIntent.js":10,"../../../thirdparty/jquery-notice/jquery.notice.js":11,"../../../thirdparty/jsizes/lib/jquery.sizes.js":12,"../../src/sspath.js":2,"../../src/ssui.core.js":3}],2:[function(require,module,exports){
'use strict';

var _jQuery = require('jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $window = (0, _jQuery2.default)(window),
    $html = (0, _jQuery2.default)('html'),
    $head = (0, _jQuery2.default)('head'),
    path = {
	urlParseRE: /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

	parseUrl: function parseUrl(url) {
		if (_jQuery2.default.type(url) === "object") {
			return url;
		}

		var matches = path.urlParseRE.exec(url || "") || [];

		return {
			href: matches[0] || "",
			hrefNoHash: matches[1] || "",
			hrefNoSearch: matches[2] || "",
			domain: matches[3] || "",
			protocol: matches[4] || "",
			doubleSlash: matches[5] || "",
			authority: matches[6] || "",
			username: matches[8] || "",
			password: matches[9] || "",
			host: matches[10] || "",
			hostname: matches[11] || "",
			port: matches[12] || "",
			pathname: matches[13] || "",
			directory: matches[14] || "",
			filename: matches[15] || "",
			search: matches[16] || "",
			hash: matches[17] || ""
		};
	},

	makePathAbsolute: function makePathAbsolute(relPath, absPath) {
		if (relPath && relPath.charAt(0) === "/") {
			return relPath;
		}

		relPath = relPath || "";
		absPath = absPath ? absPath.replace(/^\/|(\/[^\/]*|[^\/]+)$/g, "") : "";

		var absStack = absPath ? absPath.split("/") : [],
		    relStack = relPath.split("/");
		for (var i = 0; i < relStack.length; i++) {
			var d = relStack[i];
			switch (d) {
				case ".":
					break;
				case "..":
					if (absStack.length) {
						absStack.pop();
					}
					break;
				default:
					absStack.push(d);
					break;
			}
		}
		return "/" + absStack.join("/");
	},

	isSameDomain: function isSameDomain(absUrl1, absUrl2) {
		return path.parseUrl(absUrl1).domain === path.parseUrl(absUrl2).domain;
	},

	isRelativeUrl: function isRelativeUrl(url) {
		return path.parseUrl(url).protocol === "";
	},

	isAbsoluteUrl: function isAbsoluteUrl(url) {
		return path.parseUrl(url).protocol !== "";
	},

	makeUrlAbsolute: function makeUrlAbsolute(relUrl, absUrl) {
		if (!path.isRelativeUrl(relUrl)) {
			return relUrl;
		}

		var relObj = path.parseUrl(relUrl),
		    absObj = path.parseUrl(absUrl),
		    protocol = relObj.protocol || absObj.protocol,
		    doubleSlash = relObj.protocol ? relObj.doubleSlash : relObj.doubleSlash || absObj.doubleSlash,
		    authority = relObj.authority || absObj.authority,
		    hasPath = relObj.pathname !== "",
		    pathname = path.makePathAbsolute(relObj.pathname || absObj.filename, absObj.pathname),
		    search = relObj.search || !hasPath && absObj.search || "",
		    hash = relObj.hash;

		return protocol + doubleSlash + authority + pathname + search + hash;
	},

	addSearchParams: function addSearchParams(url, params) {
		var u = path.parseUrl(url),
		    params = typeof params === "string" ? path.convertSearchToArray(params) : params,
		    newParams = _jQuery2.default.extend(path.convertSearchToArray(u.search), params);
		return u.hrefNoSearch + '?' + _jQuery2.default.param(newParams) + (u.hash || "");
	},

	getSearchParams: function getSearchParams(url) {
		var u = path.parseUrl(url);
		return path.convertSearchToArray(u.search);
	},

	convertSearchToArray: function convertSearchToArray(search) {
		var params = {},
		    search = search.replace(/^\?/, ''),
		    parts = search ? search.split('&') : [],
		    i,
		    tmp;
		for (i = 0; i < parts.length; i++) {
			tmp = parts[i].split('=');
			params[tmp[0]] = tmp[1];
		}
		return params;
	},

	convertUrlToDataUrl: function convertUrlToDataUrl(absUrl) {
		var u = path.parseUrl(absUrl);
		if (path.isEmbeddedPage(u)) {
			return u.hash.split(dialogHashKey)[0].replace(/^#/, "");
		} else if (path.isSameDomain(u, document)) {
			return u.hrefNoHash.replace(document.domain, "");
		}
		return absUrl;
	},

	get: function get(newPath) {
		if (newPath === undefined) {
			newPath = location.hash;
		}
		return path.stripHash(newPath).replace(/[^\/]*\.[^\/*]+$/, '');
	},

	getFilePath: function getFilePath(path) {
		var splitkey = '&' + _jQuery2.default.mobile.subPageUrlKey;
		return path && path.split(splitkey)[0].split(dialogHashKey)[0];
	},

	set: function set(path) {
		location.hash = path;
	},

	isPath: function isPath(url) {
		return (/\//.test(url)
		);
	},

	clean: function clean(url) {
		return url.replace(document.domain, "");
	},

	stripHash: function stripHash(url) {
		return url.replace(/^#/, "");
	},

	cleanHash: function cleanHash(hash) {
		return path.stripHash(hash.replace(/\?.*$/, "").replace(dialogHashKey, ""));
	},

	isExternal: function isExternal(url) {
		var u = path.parseUrl(url);
		return u.protocol && u.domain !== document.domain ? true : false;
	},

	hasProtocol: function hasProtocol(url) {
		return (/^(:?\w+:)/.test(url)
		);
	}
};

_jQuery2.default.path = path;

},{"jQuery":"jQuery"}],3:[function(require,module,exports){
'use strict';

var _jQuery = require('jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.widget('ssui.button', _jQuery2.default.ui.button, {
	options: {
		alternate: {
			icon: null,
			text: null
		},
		showingAlternate: false
	},

	toggleAlternate: function toggleAlternate() {
		if (this._trigger('ontogglealternate') === false) return;

		if (!this.options.alternate.icon && !this.options.alternate.text) return;

		this.options.showingAlternate = !this.options.showingAlternate;
		this.refresh();
	},

	_refreshAlternate: function _refreshAlternate() {
		this._trigger('beforerefreshalternate');

		if (!this.options.alternate.icon && !this.options.alternate.text) return;

		if (this.options.showingAlternate) {
			this.element.find('.ui-button-icon-primary').hide();
			this.element.find('.ui-button-text').hide();
			this.element.find('.ui-button-icon-alternate').show();
			this.element.find('.ui-button-text-alternate').show();
		} else {
			this.element.find('.ui-button-icon-primary').show();
			this.element.find('.ui-button-text').show();
			this.element.find('.ui-button-icon-alternate').hide();
			this.element.find('.ui-button-text-alternate').hide();
		}

		this._trigger('afterrefreshalternate');
	},

	_resetButton: function _resetButton() {
		var iconPrimary = this.element.data('icon-primary'),
		    iconSecondary = this.element.data('icon-secondary');

		if (!iconPrimary) iconPrimary = this.element.data('icon');

		if (iconPrimary) this.options.icons.primary = 'btn-icon-' + iconPrimary;
		if (iconSecondary) this.options.icons.secondary = 'btn-icon-' + iconSecondary;

		_jQuery2.default.ui.button.prototype._resetButton.call(this);

		if (!this.options.alternate.text) {
			this.options.alternate.text = this.element.data('text-alternate');
		}
		if (!this.options.alternate.icon) {
			this.options.alternate.icon = this.element.data('icon-alternate');
		}
		if (!this.options.showingAlternate) {
			this.options.showingAlternate = this.element.hasClass('ss-ui-alternate');
		}

		if (this.options.alternate.icon) {
			this.buttonElement.append("<span class='ui-button-icon-alternate ui-button-icon-primary ui-icon btn-icon-" + this.options.alternate.icon + "'></span>");
		}
		if (this.options.alternate.text) {
			this.buttonElement.append("<span class='ui-button-text-alternate ui-button-text'>" + this.options.alternate.text + "</span>");
		}

		this._refreshAlternate();
	},

	refresh: function refresh() {
		_jQuery2.default.ui.button.prototype.refresh.call(this);

		this._refreshAlternate();
	},

	destroy: function destroy() {
		this.element.find('.ui-button-text-alternate').remove();
		this.element.find('.ui-button-icon-alternate').remove();

		_jQuery2.default.ui.button.prototype.destroy.call(this);
	}
});

_jQuery2.default.widget("ssui.ssdialog", _jQuery2.default.ui.dialog, {
	options: {
		iframeUrl: '',
		reloadOnOpen: true,
		dialogExtraClass: '',

		modal: true,
		bgiframe: true,
		autoOpen: false,
		autoPosition: true,
		minWidth: 500,
		maxWidth: 800,
		minHeight: 300,
		maxHeight: 700,
		widthRatio: 0.8,
		heightRatio: 0.8,
		resizable: false
	},
	_create: function _create() {
		_jQuery2.default.ui.dialog.prototype._create.call(this);

		var self = this;

		var iframe = (0, _jQuery2.default)('<iframe marginWidth="0" marginHeight="0" frameBorder="0" scrolling="auto"></iframe>');
		iframe.bind('load', function (e) {
			if ((0, _jQuery2.default)(this).attr('src') == 'about:blank') return;

			iframe.addClass('loaded').show();
			self._resizeIframe();
			self.uiDialog.removeClass('loading');
		}).hide();

		if (this.options.dialogExtraClass) this.uiDialog.addClass(this.options.dialogExtraClass);
		this.element.append(iframe);

		if (this.options.iframeUrl) this.element.css('overflow', 'hidden');
	},
	open: function open() {
		_jQuery2.default.ui.dialog.prototype.open.call(this);

		var self = this,
		    iframe = this.element.children('iframe');

		if (this.options.iframeUrl && (!iframe.hasClass('loaded') || this.options.reloadOnOpen)) {
			iframe.hide();
			iframe.attr('src', this.options.iframeUrl);
			this.uiDialog.addClass('loading');
		}

		(0, _jQuery2.default)(window).bind('resize.ssdialog', function () {
			self._resizeIframe();
		});
	},
	close: function close() {
		_jQuery2.default.ui.dialog.prototype.close.call(this);

		this.uiDialog.unbind('resize.ssdialog');
		(0, _jQuery2.default)(window).unbind('resize.ssdialog');
	},
	_resizeIframe: function _resizeIframe() {
		var opts = {},
		    newWidth,
		    newHeight,
		    iframe = this.element.children('iframe');;
		if (this.options.widthRatio) {
			newWidth = (0, _jQuery2.default)(window).width() * this.options.widthRatio;
			if (this.options.minWidth && newWidth < this.options.minWidth) {
				opts.width = this.options.minWidth;
			} else if (this.options.maxWidth && newWidth > this.options.maxWidth) {
				opts.width = this.options.maxWidth;
			} else {
				opts.width = newWidth;
			}
		}
		if (this.options.heightRatio) {
			newHeight = (0, _jQuery2.default)(window).height() * this.options.heightRatio;
			if (this.options.minHeight && newHeight < this.options.minHeight) {
				opts.height = this.options.minHeight;
			} else if (this.options.maxHeight && newHeight > this.options.maxHeight) {
				opts.height = this.options.maxHeight;
			} else {
				opts.height = newHeight;
			}
		}

		if (!jQuery.isEmptyObject(opts)) {
			this._setOptions(opts);

			iframe.attr('width', opts.width - parseFloat(this.element.css('paddingLeft')) - parseFloat(this.element.css('paddingRight')));
			iframe.attr('height', opts.height - parseFloat(this.element.css('paddingTop')) - parseFloat(this.element.css('paddingBottom')));

			if (this.options.autoPosition) {
				this._setOption("position", this.options.position);
			}
		}
	}
});

_jQuery2.default.widget("ssui.titlebar", {
	_create: function _create() {
		this.originalTitle = this.element.attr('title');

		var self = this;
		var options = this.options;

		var title = options.title || this.originalTitle || '&nbsp;';
		var titleId = _jQuery2.default.ui.dialog.getTitleId(this.element);

		this.element.parent().addClass('ui-dialog');

		var uiDialogTitlebar = this.element.addClass('ui-dialog-titlebar ' + 'ui-widget-header ' + 'ui-corner-all ' + 'ui-helper-clearfix');

		if (options.closeButton) {
			var uiDialogTitlebarClose = (0, _jQuery2.default)('<a href="#"/>').addClass('ui-dialog-titlebar-close ' + 'ui-corner-all').attr('role', 'button').hover(function () {
				uiDialogTitlebarClose.addClass('ui-state-hover');
			}, function () {
				uiDialogTitlebarClose.removeClass('ui-state-hover');
			}).focus(function () {
				uiDialogTitlebarClose.addClass('ui-state-focus');
			}).blur(function () {
				uiDialogTitlebarClose.removeClass('ui-state-focus');
			}).mousedown(function (ev) {
				ev.stopPropagation();
			}).appendTo(uiDialogTitlebar);

			var uiDialogTitlebarCloseText = (this.uiDialogTitlebarCloseText = (0, _jQuery2.default)('<span/>')).addClass('ui-icon ' + 'ui-icon-closethick').text(options.closeText).appendTo(uiDialogTitlebarClose);
		}

		var uiDialogTitle = (0, _jQuery2.default)('<span/>').addClass('ui-dialog-title').attr('id', titleId).html(title).prependTo(uiDialogTitlebar);

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();
	},

	destroy: function destroy() {
		this.element.unbind('.dialog').removeData('dialog').removeClass('ui-dialog-content ui-widget-content').hide().appendTo('body');

		this.originalTitle && this.element.attr('title', this.originalTitle);
	}
});

_jQuery2.default.extend(_jQuery2.default.ssui.titlebar, {
	version: "0.0.1",
	options: {
		title: '',
		closeButton: false,
		closeText: 'close'
	},

	uuid: 0,

	getTitleId: function getTitleId($el) {
		return 'ui-dialog-title-' + ($el.attr('id') || ++this.uuid);
	}
});

},{"jQuery":"jQuery"}],4:[function(require,module,exports){
// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
// 
// Version 0.9.8
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// based on version 0.9.8, applied a very simple patch that fixes percentage width support on select tag, and enables rise-up functionality
// This file is generated by `cake build`, do not edit it by hand.
(function() {
  var SelectParser;

  SelectParser = (function() {

    // Origional - You can't assign to functions like this in strict mode.
    //SelectParser.name = 'SelectParser';

    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    // SilverStripe custom
    SelectParser.prototype.name = 'SelectParser';

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: group.label,
        children: 0,
        disabled: group.disabled
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        // workaround for https://github.com/harvesthq/chosen/issues/2125
        if (!option.text.match(/^\s*$/g)) {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  this.SelectParser = SelectParser;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function() {
  var AbstractChosen, root;

  root = this;

  AbstractChosen = (function() {

    // Origional - You can't assign to functions like this in strict mode.
    //AbstractChosen.name = 'AbstractChosen';

    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      this.set_default_values();
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.finish_setup();
    }

    // SilverStripe custom
    AbstractChosen.prototype.name = 'AbstractChosen';

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null)
			  && (this.form_field.options[0] != null)
			  // workaround for https://github.com/harvesthq/chosen/issues/2125
			  && this.form_field.options[0].text.match(/^\s*$/g)
				? this.options.allow_single_deselect
				: false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.search_contains = this.options.search_contains || false;
      this.choices = 0;
      this.single_backstroke_delete = this.options.single_backstroke_delete || false;
      return this.max_selected_options = this.options.max_selected_options || Infinity;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || "Select Some Options";
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || "Select an Option";
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || "No results match";
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, style;
      if (!option.disabled) {
        option.dom_id = this.container_id + "_o_" + option.array_index;
        classes = option.selected && this.is_multiple ? [] : ["active-result"];
        if (option.selected) {
          classes.push("result-selected");
        }
        if (option.group_array_index != null) {
          classes.push("group-option");
        }
        if (option.classes !== "") {
          classes.push(option.classes);
        }
        style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
        return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
      } else {
        return "";
      }
    };

    AbstractChosen.prototype.results_update_field = function() {
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.result_single_selected = null;
      return this.results_build();
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.generate_field_id = function() {
      var new_id;
      new_id = this.generate_random_id();
      this.form_field.id = new_id;
      return new_id;
    };

    AbstractChosen.prototype.generate_random_char = function() {
      var chars, newchar, rand;
      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      rand = Math.floor(Math.random() * chars.length);
      return newchar = chars.substring(rand, rand + 1);
    };

    return AbstractChosen;

  })();

  root.AbstractChosen = AbstractChosen;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function() {
  var $, Chosen, get_side_border_padding, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = this;

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if ($.browser.msie && ($.browser.version === "6.0" || ($.browser.version === "7.0" && document.documentMode === 7))) {
        return this;
      }
      return this.each(function(input_field) {
        var $this;
        $this = $(this);
        if (!$this.hasClass("chzn-done")) {
          return $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {

    __extends(Chosen, _super);

    // Origional - You can't assign to functions like this in strict mode.
    //Chosen.name = 'Chosen';

    function Chosen() {
      return Chosen.__super__.constructor.apply(this, arguments);
    }

    // SilverStripe custom
    Chosen.prototype.name = 'Chosen';

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_value = this.form_field_jq.val();
      return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
    };

    Chosen.prototype.finish_setup = function() {
      return this.form_field_jq.addClass("chzn-done");
    };

    Chosen.prototype.set_up_html = function() {
      var container_div, dd_top, dd_width, rise, sf_width;
      this.container_id = this.form_field.id.length ? this.form_field.id.replace(/(:|\.)/g, '_') : this.generate_field_id();
      this.container_id += "_chzn";
      this.f_width = this.form_field_jq.outerWidth();
      this.default_text = this.form_field_jq.data('placeholder') ? this.form_field_jq.data('placeholder') : this.default_text_default;
      container_div = $("<div />", {
        id: this.container_id,
        "class": "chzn-container" + (this.is_rtl ? ' chzn-rtl' : ''),
        style: 'width: ' + (this.options.width || this.f_width) + 'px;'
      });
      if (this.is_multiple) {
        container_div.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>');
      } else {
        container_div.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
      }
      this.form_field_jq.hide().after(container_div);
      this.container = $('#' + this.container_id);
      this.container.addClass("chzn-container-" + (this.is_multiple ? "multi" : "single"));
      this.dropdown = this.container.find('div.chzn-drop').first();
      /*
            CALL CUSTOM FUNCTION: rise_up
              # if rise-up true, reverse drop-up direction
      */

      rise = this.rise_up(this.container, this.dropdown);
      dd_top = rise ? -this.container.find('.chzn-drop').height() : this.container.height();
      dd_width = this.container.width() - get_side_border_padding(this.dropdown);
      this.dropdown.css({
        "width": dd_width + "px",
        "top": dd_top + "px"
      });
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chzn-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chzn-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chzn-search').first();
        this.selected_item = this.container.find('.chzn-single').first();
        sf_width = dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field);
        this.search_field.css({
          "width": sf_width + "px"
        });
      }
      this.results_build();
      this.set_tab_index();
      return this.form_field_jq.trigger("liszt:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.mousedown(function(evt) {
        return _this.container_mousedown(evt);
      });
      this.container.mouseup(function(evt) {
        return _this.container_mouseup(evt);
      });
      this.container.mouseenter(function(evt) {
        return _this.mouse_enter(evt);
      });
      this.container.mouseleave(function(evt) {
        return _this.mouse_leave(evt);
      });
      this.search_results.mouseup(function(evt) {
        return _this.search_results_mouseup(evt);
      });
      this.search_results.mouseover(function(evt) {
        return _this.search_results_mouseover(evt);
      });
      this.search_results.mouseout(function(evt) {
        return _this.search_results_mouseout(evt);
      });
      this.form_field_jq.bind("liszt:updated", function(evt) {
        return _this.results_update_field(evt);
      });
      this.form_field_jq.bind("liszt:activate", function(evt) {
        return _this.activate_field(evt);
      });
      this.form_field_jq.bind("liszt:open", function(evt) {
        return _this.container_mousedown(evt);
      });
      this.search_field.blur(function(evt) {
        return _this.input_blur(evt);
      });
      this.search_field.keyup(function(evt) {
        return _this.keyup_checker(evt);
      });
      this.search_field.keydown(function(evt) {
        return _this.keydown_checker(evt);
      });
      this.search_field.focus(function(evt) {
        return _this.input_focus(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.click(function(evt) {
          return _this.choices_click(evt);
        });
      } else {
        return this.container.click(function(evt) {
          return evt.preventDefault();
        });
      }
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chzn-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chzn-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      var target_closelink;
      if (!this.is_disabled) {
        target_closelink = evt != null ? ($(evt.target)).hasClass("search-choice-close") : false;
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.stopPropagation();
        }
        if (!this.pending_destroy_click && !target_closelink) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(document).click(this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        } else {
          return this.pending_destroy_click = false;
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chzn-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(document).unbind("click", this.click_test_action);
      if (!this.is_multiple) {
        this.selected_item.attr("tabindex", this.search_field.attr("tabindex"));
        this.search_field.attr("tabindex", -1);
      }
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chzn-container-active");
      this.winnow_results_clear();
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      this.container.addClass("chzn-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      if ($(evt.target).parents('#' + this.container_id).length) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      var content, data, _i, _len, _ref;
      this.parsing = true;
      this.results_data = root.SelectParser.select_to_array(this.form_field);
      if (this.is_multiple && this.choices > 0) {
        this.search_choices.find("li.search-choice").remove();
        this.choices = 0;
      } else if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.container.addClass("chzn-container-single-nosearch");
        } else {
          this.container.removeClass("chzn-container-single-nosearch");
        }
      }
      content = '';
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else if (!data.empty) {
          content += this.result_add_option(data);
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.selected_item.removeClass("chzn-default").find("span").text(data.text);
            if (this.allow_single_deselect) {
              this.single_deselect_control_build();
            }
          }
        }
      }
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      this.search_results.html(content);
      return this.parsing = false;
    };

    Chosen.prototype.result_add_group = function(group) {
      if (!group.disabled) {
        group.dom_id = this.container_id + "_g_" + group.array_index;
        return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
      } else {
        return "";
      }
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      var dd_top, dd_width, rise;
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-single-with-drop");
        if (this.result_single_selected) {
          this.result_do_highlight(this.result_single_selected);
        }
      }
      dd_width = this.container.width() - get_side_border_padding(this.dropdown);
      /*
            CALL CUSTOM FUNCTION: rise_up
              # if rise-up true, reverse drop-up direction
      */

      rise = this.rise_up(this.container, this.dropdown);
      dd_top = rise ? -this.container.find('.chzn-drop').height() : this.is_multiple ? this.container.height() : this.container.height() - 1;
      this.form_field_jq.trigger("liszt:showing_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "top": dd_top + "px",
        "left": 0
      });
      this.results_showing = true;
      this.search_field.css('width', (dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field)) + 'px');
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };

    Chosen.prototype.results_hide = function() {
      if (!this.is_multiple) {
        this.selected_item.removeClass("chzn-single-with-drop");
      }
      this.result_clear_highlight();
      this.form_field_jq.trigger("liszt:hiding_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "left": "-9000px"
      });
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field_jq.attr("tabindex")) {
        ti = this.form_field_jq.attr("tabindex");
        this.form_field_jq.attr("tabindex", -1);
        return this.search_field.attr("tabindex", ti);
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (this.active_field && !($(evt.target).hasClass("search-choice" || $(evt.target).parents('.search-choice').first)) && !this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice_id, html, link,
        _this = this;
      choice_id = this.container_id + "_c_" + item.array_index;
      this.choices += 1;
      if (item.disabled) {
        html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
      } else {
        html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
      }
      this.search_container.before(html);
      link = $('#' + choice_id).find("a").first();
      return link.click(function(evt) {
        return _this.choice_destroy_link_click(evt);
      });
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      if (!this.is_disabled) {
        this.pending_destroy_click = true;
        return this.choice_destroy($(evt.target));
      } else {
        return evt.stopPropagation;
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link.attr("rel"))) {
        this.choices -= 1;
        this.show_search_field_default();
        if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        return link.parents('li').first().remove();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.form_field.options[0].selected = true;
      this.selected_item.find("span").text(this.default_text);
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default");
      }
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_value = this.form_field_jq.val();
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, high_id, item, position;
      if (this.result_highlight) {
        high = this.result_highlight;
        high_id = high.attr("id");
        this.result_clear_highlight();
        if (this.is_multiple) {
          this.result_deactivate(high);
        } else {
          this.search_results.find(".result-selected").removeClass("result-selected");
          this.result_single_selected = high;
          this.selected_item.removeClass("chzn-default");
        }
        high.addClass("result-selected");
        position = high_id.substr(high_id.lastIndexOf("_") + 1);
        item = this.results_data[position];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.selected_item.find("span").first().text(item.text);
          if (this.allow_single_deselect) {
            this.single_deselect_control_build();
          }
        }
        if (!(evt.metaKey && this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val("");
        if (this.is_multiple || this.form_field_jq.val() !== this.current_value) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_value = this.form_field_jq.val();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.result_activate = function(el) {
      return el.addClass("active-result");
    };

    Chosen.prototype.result_deactivate = function(el) {
      return el.removeClass("active-result");
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result, result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        result = $("#" + this.container_id + "_o_" + pos);
        result.removeClass("result-selected").addClass("active-result").show();
        this.result_clear_highlight();
        this.winnow_results();
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
        return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
    };

    Chosen.prototype.winnow_results = function() {
      var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (!option.disabled && !option.empty) {
          if (option.group) {
            $('#' + option.dom_id).css('display', 'none');
          } else if (!(this.is_multiple && option.selected)) {
            found = false;
            result_id = option.dom_id;
            result = $("#" + result_id);
            if (regex.test(option.html)) {
              found = true;
              results += 1;
            } else if (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0) {
              parts = option.html.replace(/\[|\]/g, "").split(" ");
              if (parts.length) {
                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                  part = parts[_j];
                  if (regex.test(part)) {
                    found = true;
                    results += 1;
                  }
                }
              }
            }
            if (found) {
              if (searchText.length) {
                startpos = option.html.search(zregex);
                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              } else {
                text = option.html;
              }
              result.html(text);
              this.result_activate(result);
              if (option.group_array_index != null) {
                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
              }
            } else {
              if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                this.result_clear_highlight();
              }
              this.result_deactivate(result);
            }
          }
        }
      }
      if (results < 1 && searchText.length) {
        return this.no_results(searchText);
      } else {
        return this.winnow_results_set_highlight();
      }
    };

    Chosen.prototype.winnow_results_clear = function() {
      var li, lis, _i, _len, _results;
      this.search_field.val("");
      lis = this.search_results.find("li");
      _results = [];
      for (_i = 0, _len = lis.length; _i < _len; _i++) {
        li = lis[_i];
        li = $(li);
        if (li.hasClass("group-result")) {
          _results.push(li.css('display', 'auto'));
        } else if (!this.is_multiple || !li.hasClass("result-selected")) {
          _results.push(this.result_activate(li));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      if (!this.result_highlight) {
        selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
        do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
        if (do_high != null) {
          return this.result_do_highlight(do_high);
        }
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var first_active, next_sib;
      if (!this.result_highlight) {
        first_active = this.search_results.find("li.active-result").first();
        if (first_active) {
          this.result_do_highlight($(first_active));
        }
      } else if (this.results_showing) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          this.result_do_highlight(next_sib);
        }
      }
      if (!this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          evt.preventDefault();
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var dd_top, div, h, rise, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        if (w > this.f_width - 10) {
          w = this.f_width - 10;
        }
        this.search_field.css({
          'width': w + 'px'
        });
        /*
                CALL CUSTOM FUNCTION: rise_up
                  # if rise-up true, reverse drop-up direction
        */

        rise = this.rise_up(this.container, this.dropdown);
        dd_top = rise ? -this.container.find('.chzn-drop').height() : this.container.height();
        return this.dropdown.css({
          "top": dd_top + "px"
        });
      }
    };

    Chosen.prototype.generate_random_id = function() {
      var string;
      string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
      while ($("#" + string).length > 0) {
        string += this.generate_random_char();
      }
      return string;
    };

    /*
      SILVERSTRIPE CUSTOM FUNCTION
        Rise_up function handles the case where a dropdown exceeds the height of the window
          # Adds class if true, returns true
          # Removes class if false, returns false 
        This facilitates the behaviour where the drop-down will drop up if there is no room 
        to drop down
    */


    Chosen.prototype.rise_up = function(container, dropdown) {
      var elHeight, elPos, endOfWindow, trigger;
      trigger = container.find('a.chzn-single');
      if (trigger.length > 0) {
        endOfWindow = ($(window).height() + $(document).scrollTop()) - container.find('a').innerHeight();
        elPos = trigger.offset().top;
        elHeight = dropdown.innerHeight();
        if (elPos + elHeight > endOfWindow && elPos - elHeight > 0) {
          container.addClass('chzn-with-rise');
          return true;
        } else {
          container.removeClass('chzn-with-rise');
          return false;
        }
      } else {
        return false;
      }
    };

    return Chosen;

  })(AbstractChosen);

  get_side_border_padding = function(elmt) {
    var side_border_padding;
    return side_border_padding = elmt.outerWidth() - elmt.width();
  };

  root.get_side_border_padding = get_side_border_padding;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

},{}],5:[function(require,module,exports){
/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var
		History = window.History = window.History||{},
		jQuery = window.jQuery;

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);


},{}],6:[function(require,module,exports){
/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.isHashEqual(newHash, oldHash)
		 * Checks to see if two hashes are functionally equal
		 * @param {string} newHash
		 * @param {string} oldHash
		 * @return {boolean} true
		 */
		History.isHashEqual = function(newHash, oldHash){
			newHash = encodeURIComponent(newHash).replace(/%25/g, "%");
			oldHash = encodeURIComponent(oldHash).replace(/%25/g, "%");
			return newHash === oldHash;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardedState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning,
					startedWithHash = Boolean(History.getHash());

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					// IE 6 requires iframe to have a src on HTTPS pages, otherwise it will throw a
					// "This page contains both secure and nonsecure items" warning.
					iframe.setAttribute('id', iframeId);
					iframe.setAttribute('src', '#');
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var
							documentHash = History.getHash(),
							iframeHash = History.getHash(iframe.contentWindow.document.location);

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;
							
							// If there is no iframe hash that means we're at the original
							// iframe state.
							// And if there was a hash on the original request, the original
							// iframe state was replaced instantly, so skip this state and take
							// the user back to where they came from.
							if (startedWithHash && iframeHash === '') {
								History.back();
							}
							else {
								// Update the Hash
								History.setHash(iframeHash,false);
							}
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash()||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || History.getLocationHref()),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||History.getLocationHref()),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,encodeURI(currentState.url),false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash(),
					wasExpected = History.expectedStateId == newState.id;

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				if(!wasExpected)
					History.Adapter.trigger(window,'statechange');

				// Update HTML4 Hash
				if ( !History.isHashEqual(newStateHash, html4Hash) && !History.isHashEqual(newStateHash, History.getShortUrl(History.getLocationHref())) ) {
					History.setHash(newStateHash,false);
				}
				
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState        = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// If the url hasn't changed, just store and save the state
				// and fire a statechange event to be consistent with the
				// html 5 api
				if ( newStateHash === oldStateHash ) {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;
	
					// Recycle the State
					History.recycleState(newState);
	
					// Force update of the title
					History.setTitle(newState);
					
					// Update HTML5 State
					History.saveState(newState);

					// Fire HTML5 Event
					//History.debug('History.pushState: trigger popstate');
					History.Adapter.trigger(window,'statechange');
					History.busy(false);
				}
				else {
					// Alias to PushState
					History.pushState(newState.data,newState.title,newState.url,false);
				}

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try to Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

},{}],7:[function(require,module,exports){
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = window.sessionStorage||false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	try {
		sessionStorage.setItem('TEST', '1');
		sessionStorage.removeItem('TEST');
	} catch(e) {
		sessionStorage = false;
	}

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(options){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(options){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.disableSuid
		 * Force History not to append suid
		 */
		History.options.disableSuid = History.options.disableSuid || false;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;

		/**
		 * History.options.html4Mode
		 * If true, will force HTMl4 mode (hashtags)
		 */
		History.options.html4Mode = History.options.html4Mode || false;

		/**
		 * History.options.delayInit
		 * Want to override default options and call init manually.
		 */
		History.options.delayInit = History.options.delayInit || false;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */

		if (History.options.html4Mode) {
			History.emulated = {
				pushState : true,
				hashChange: true
			};
		}

		else {

			History.emulated = {
				pushState: !Boolean(
					window.history && window.history.pushState && window.history.replaceState
					&& !(
						(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
						|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
					)
				),
				hashChange: Boolean(
					!(('onhashchange' in window) || ('onhashchange' in document))
					||
					(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
				)
			};
		}

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				if ( obj.hasOwnProperty(name) ) {
					return false;
				}
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||History.getLocationHref(),
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};

		/**
		 * History.getLocationHref(document)
		 * Returns a normalized version of document.location.href
		 * accounting for browser inconsistencies, etc.
		 *
		 * This URL will be URI-encoded and will include the hash
		 *
		 * @param {object} document
		 * @return {string} url
		 */
		History.getLocationHref = function(doc) {
			doc = doc || document;

			// most of the time, this will be true
			if (doc.URL === doc.location.href)
				return doc.location.href;

			// some versions of webkit URI-decode document.location.href
			// but they leave document.URL in an encoded state
			if (doc.location.href === decodeURIComponent(doc.URL))
				return doc.URL;

			// FF 3.6 only updates document.URL when a page is reloaded
			// document.location.href is updated correctly
			if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
				return doc.location.href;

			if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
				return doc.location.href;
			
			return doc.URL || doc.location.href;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(oldState.url?decodeURIComponent(oldState.url):(History.getLocationHref()));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url, tmp;

			// Extract
			
			// If the URL has a #, use the id from before the #
			if (url_or_hash.indexOf('#') != -1)
			{
				tmp = url_or_hash.split("#")[0];
			}
			else
			{
				tmp = url_or_hash;
			}
			
			parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};
		
		/**
		 * History.getCurrentIndex()
		 * Gets the current index
		 * @return (integer)
		*/
		History.getCurrentIndex = function(){
			// Prepare
			var index = null;
			
			// No states saved
			if(History.savedStates.length < 1) {
				index = 0;
			}
			else {
				index = History.savedStates.length-1;
			}
			return index;
		};

		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * @param {Location=} location
		 * Gets the current document hash
		 * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
		 * @return {string}
		 */
		History.getHash = function(doc){
			var url = History.getLocationHref(doc),
				hash;
			hash = History.getHashByUrl(url);
			return hash;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = decodeURIComponent(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( History.getHash() !== hash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+hash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = hash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.encodeURIComponent(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(History.getLocationHref()),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash = History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||History.getLocationHref(),true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(History.getLocationHref());
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,History.getLocationHref());
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item, currentStoreString;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// In Safari, going into Private Browsing mode causes the
				// Session Storage object to still exist but if you try and use
				// or set any property/function of it it throws the exception
				// "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
				// add something to storage that exceeded the quota." infinitely
				// every second.
				currentStoreString = JSON.stringify(currentStore);
				try {
					// Store
					sessionStorage.setItem('History.store', currentStoreString);
				}
				catch (e) {
					// Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
					// removing/resetting the storage can work.
					if (/QUOTA_EXCEEDED_ERR/.test(e.message)) {
						sessionStorage.removeItem('History.store');
						sessionStorage.setItem('History.store', currentStoreString);
					} else {
						throw e;
					}
				}
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try to Initialise History
	if (!History.options || !History.options.delayInit) {
		History.init();
	}

})(window);

},{}],8:[function(require,module,exports){
/**
 * @preserve jLayout Border Layout - JavaScript Layout Algorithms v0.4
 *
 * Licensed under the new BSD License.
 * Copyright 2008-2009, Bram Stein
 * All rights reserved.
 */
/*global jLayout:true */
(function () {
	// Customised
	// Defining global alias because Browserify adds 'use strict'
	// which throws a runtime error if globals are undefined and not declared.

	// Original
	// jLayout = (typeof jLayout === 'undefined') ? {} : jLayout;

	window.jLayout = (typeof window.jLayout === 'undefined') ? {} : window.jLayout;

	jLayout.border = function (spec) {
		var my = {},
			that = {},
			east = spec.east,
			west = spec.west,
			north = spec.north,
			south = spec.south,
			center = spec.center;

		my.hgap = spec.hgap || 0;
		my.vgap = spec.vgap || 0;

		that.items = function () {
			var items = [];
			if (east) {
				items.push(east);
			}

			if (west) {
				items.push(west);
			}

			if (north) {
				items.push(north);
			}

			if (south) {
				items.push(south);
			}

			if (center) {
				items.push(center);
			}
			return items;
		};		

		that.layout = function (container) {
			var size = container.bounds(),
				insets = container.insets(),
				top = insets.top,
				bottom = size.height - insets.bottom,
				left = insets.left,
				right = size.width - insets.right,
				tmp;

			if (north && north.isVisible()) {
				tmp = north.preferredSize();
				north.bounds({'x': left, 'y': top, 'width': right - left, 'height': tmp.height});
				north.doLayout();

				top += tmp.height + my.vgap;
			}
			if (south && south.isVisible()) {
				tmp = south.preferredSize();
				south.bounds({'x': left, 'y': bottom - tmp.height, 'width': right - left, 'height': tmp.height});
				south.doLayout();

				bottom -= tmp.height + my.vgap;
			}
			if (east && east.isVisible()) {
				tmp = east.preferredSize();
				east.bounds({'x': right - tmp.width, 'y': top, 'width': tmp.width, 'height': bottom - top});
				east.doLayout();

				right -= tmp.width + my.hgap;
			}
			if (west && west.isVisible()) {
				tmp = west.preferredSize();
				west.bounds({'x': left, 'y': top, 'width': tmp.width, 'height': bottom - top});
				west.doLayout();

				left += tmp.width + my.hgap;
			}
			if (center && center.isVisible()) {
				center.bounds({'x': left, 'y': top, 'width': right - left, 'height': bottom - top});
				center.doLayout();
			}
			return container;
		};

		function typeLayout(type) {
			return function (container) {
				var insets = container.insets(),
					width = 0,
					height = 0,
					type_size;

				if (east && east.isVisible()) {
					type_size = east[type + 'Size']();
					width += type_size.width + my.hgap;
					height = type_size.height;
				}
				if (west && west.isVisible()) {
					type_size = west[type + 'Size']();
					width += type_size.width + my.hgap;
					height = Math.max(type_size.height, height);
				}
				if (center && center.isVisible()) {
					type_size = center[type + 'Size']();
					width += type_size.width;
					height = Math.max(type_size.height, height);
				}
				if (north && north.isVisible()) {
					type_size = north[type + 'Size']();
					width = Math.max(type_size.width, width);
					height += type_size.height + my.vgap;
				}
				if (south && south.isVisible()) {
					type_size = south[type + 'Size']();
					width = Math.max(type_size.width, width);
					height += type_size.height + my.vgap;
				}

				return {
					'width': width + insets.left + insets.right, 
					'height': height + insets.top + insets.bottom
				};
			};
		}
		that.preferred = typeLayout('preferred');
		that.minimum = typeLayout('minimum');
		that.maximum = typeLayout('maximum');
		return that;
	};
}());

},{}],9:[function(require,module,exports){
/**
 * @preserve jLayout JQuery Plugin v0.17
 *
 * Licensed under the new BSD License.
 * Copyright 2008-2009 Bram Stein
 * All rights reserved.
 */
/*global jQuery jLayout*/

// Customised
// Defining global alias because Browserify adds 'use strict'
// which throws a runtime error if globals are undefined and not declared.
var jQuery = window.jQuery,
	jLayout = window.jLayout;

if (jQuery && jLayout) {
	(function ($) {
		/**
		 * This wraps jQuery objects in another object that supplies
		 * the methods required for the layout algorithms.
		 */
		// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
		// function wrap(item, resize) {
		var wrap = $.jLayoutWrap = function(item, resize) {
		// CUSTOM END
			var that = {};
			// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
			that.item = item;
			// CUSTOM END

			$.each(['min', 'max'], function (i, name) {
				that[name + 'imumSize'] = function (value) {
                    var l = item.data('jlayout');
                    
					if (l) {
						return l[name + 'imum'](that);
					} else {
						return item[name + 'Size'](value);
					}
				};
			});

			$.extend(that, {
				doLayout: function () {
					// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
					//var l = item.data('jlayout');
					//
					//if (l) {
					//	l.layout(that);
					//}
					//
					var l = item.data('jlayout');
					if (l) l.layout(that);
					else if (item.is('[data-layout-type]')) {
						item.layout({resize: false});
					}
					// CUSTOM END

					item.css({position: 'absolute'});
				},
				isVisible: function () {
					return item.isVisible();
				},
				insets: function () {
					var p = item.padding(),
						b = item.border();

					return {
                        'top': p.top, 
						'bottom': p.bottom + b.bottom + b.top, 
						'left': p.left, 
						'right': p.right + b.right + b.left
                    };
				},
				bounds: function (value) {
					var tmp = {};

					if (value) {
						if (typeof value.x === 'number') {
							tmp.left = value.x;
						}
						if (typeof value.y === 'number') {
							tmp.top = value.y;
						}
						if (typeof value.width === 'number') {
							tmp.width = (value.width - (item.outerWidth(true) - item.width()));
							tmp.width = (tmp.width >= 0) ? tmp.width : 0;
						}
						if (typeof value.height === 'number') {
							tmp.height = value.height - (item.outerHeight(true) - item.height());
							tmp.height = (tmp.height >= 0) ? tmp.height : 0;
						}
						item.css(tmp);
						return item;
					} else {
						tmp = item.position();
						return {
							'x': tmp.left,
							'y': tmp.top,
							'width': item.outerWidth(false),
							'height': item.outerHeight(false)
                        };
					}
				},
				preferredSize: function () {
					var minSize,
						maxSize,
						margin = item.margin(),
						size = {width: 0, height: 0},
                        l = item.data('jlayout');

					if (l && resize) {
						size = l.preferred(that);

						minSize = that.minimumSize();
						maxSize = that.maximumSize();

						size.width += margin.left + margin.right;
						size.height += margin.top + margin.bottom;

						if (size.width < minSize.width || size.height < minSize.height) {
							size.width = Math.max(size.width, minSize.width);
							size.height = Math.max(size.height, minSize.height);
						} else if (size.width > maxSize.width || size.height > maxSize.height) {
							size.width = Math.min(size.width, maxSize.width);
							size.height = Math.min(size.height, maxSize.height);
						}
					} else {
                        size = that.bounds();
						size.width += margin.left + margin.right;
						size.height += margin.top + margin.bottom;
					}
					return size;
				}
			});
			return that;
		}

		$.fn.layout = function (options) {
			var opts = $.extend({}, $.fn.layout.defaults, options);
			return $.each(this, function () {
				var element = $(this),
					o = $.metadata && element.metadata().layout ? $.extend(opts, element.metadata().layout) : opts,
					// CUSTOM ischommer 2012-16-02 Allow type setting throgh built-in jQuery HTML5 data getters, to avoid including jQuery.metadata.js
					o = element.data('layoutType') ? $.extend(o, {type: element.data('layoutType')}) : o,
					// CUSTOM END
					elementWrapper = wrap(element, o.resize);
				if (o.type === 'border' && typeof jLayout.border !== 'undefined') {                
					$.each(['north', 'south', 'west', 'east', 'center'], function (i, name) {
						if (element.children().hasClass(name)) {
							o[name] = wrap(element.children('.' + name + ':first'));
						}
					});
					element.data('jlayout', jLayout.border(o));
				} else if (o.type === 'grid' && typeof jLayout.grid !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.grid(o));
				} else if (o.type === 'flexGrid' && typeof jLayout.flexGrid !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.flexGrid(o));
				} else if (o.type === 'column' && typeof jLayout.column !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.column(o));
				} else if (o.type === 'flow' && typeof jLayout.flow !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.flow(o));					
				}
                
				if (o.resize) {
					elementWrapper.bounds(elementWrapper.preferredSize());
				}
                
				elementWrapper.doLayout();
				element.css({position: 'relative'});
				if ($.ui !== undefined) {
					element.addClass('ui-widget');
				}
			});
		};

		$.fn.layout.defaults = {
			resize: true,
			type: 'grid'
		};
	}(jQuery));
}

},{}],10:[function(require,module,exports){
/**
* hoverIntent is similar to jQuery's built-in "hover" function except that
* instead of firing the onMouseOver event immediately, hoverIntent checks
* to see if the user's mouse has slowed down (beneath the sensitivity
* threshold) before firing the onMouseOver event.
*
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
*
* hoverIntent is currently available for use in all personal or commercial
* projects under both MIT and GPL licenses. This means that you can choose
* the license that best suits your project, and use it accordingly.
*
* // basic usage (just like .hover) receives onMouseOver and onMouseOut functions
* $("ul li").hoverIntent( showNav , hideNav );
*
* // advanced usage receives configuration object only
* $("ul li").hoverIntent({
*	sensitivity: 7, // number = sensitivity threshold (must be 1 or higher)
*	interval: 100,   // number = milliseconds of polling interval
*	over: showNav,  // function = onMouseOver callback (required)
*	timeout: 350,   // number = milliseconds delay before onMouseOut function call
*	out: hideNav    // function = onMouseOut callback (required)
* });
*
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($) {
	$.fn.hoverIntent = function(f,g) {
		// default configuration options
		var cfg = {
			sensitivity: 7,
			interval: 100,
			timeout: 350
		};
		// override configuration options with user supplied object
		cfg = $.extend(cfg, g ? { over: f, out: g } : f );

		// instantiate variables
		// cX, cY = current X and Y position of mouse, updated by mousemove event
		// pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
		var cX, cY, pX, pY;

		// A private function for getting mouse position
		var track = function(ev) {
			cX = ev.pageX;
			cY = ev.pageY;
		};

		// A private function for comparing current and previous mouse position
		var compare = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			// compare mouse positions to see if they've crossed the threshold
			if ( ( Math.abs(pX-cX) + Math.abs(pY-cY) ) < cfg.sensitivity ) {
				$(ob).unbind("mousemove",track);
				// set hoverIntent state to true (so mouseOut can be called)
				ob.hoverIntent_s = 1;
				return cfg.over.apply(ob,[ev]);
			} else {
				// set previous coordinates for next time
				pX = cX; pY = cY;
				// use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
				ob.hoverIntent_t = setTimeout( function(){compare(ev, ob);} , cfg.interval );
			}
		};

		// A private function for delaying the mouseOut function
		var delay = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			ob.hoverIntent_s = 0;
			return cfg.out.apply(ob,[ev]);
		};

		// A private function for handling mouse 'hovering'
		var handleHover = function(e) {
			// copy objects to be passed into t (required for event object to be passed in IE)
			var ev = jQuery.extend({},e);
			var ob = this;

			// cancel hoverIntent timer if it exists
			if (ob.hoverIntent_t) { ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); }

			// if e.type == "mouseenter"
			if (e.type == "mouseenter") {
				// set "previous" X and Y position based on initial entry point
				pX = ev.pageX; pY = ev.pageY;
				// update "current" X and Y position based on mousemove
				$(ob).bind("mousemove",track);
				// start polling interval (self-calling timeout) to compare mouse coordinates over time
				if (ob.hoverIntent_s != 1) { ob.hoverIntent_t = setTimeout( function(){compare(ev,ob);} , cfg.interval );}

			// else e.type == "mouseleave"
			} else {
				// unbind expensive mousemove event
				$(ob).unbind("mousemove",track);
				// if hoverIntent state is true, then call the mouseOut function after the specified delay
				if (ob.hoverIntent_s == 1) { ob.hoverIntent_t = setTimeout( function(){delay(ev,ob);} , cfg.timeout );}
			}
		};

		// bind the function to the two event listeners
		return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover);
	};
})(jQuery);
},{}],11:[function(require,module,exports){
/**
*	jQuery.noticeAdd() and jQuery.noticeRemove()
*	These functions create and remove growl-like notices
*		
*   Copyright (c) 2009 Tim Benniks
*
*	Permission is hereby granted, free of charge, to any person obtaining a copy
*	of this software and associated documentation files (the "Software"), to deal
*	in the Software without restriction, including without limitation the rights
*	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*	copies of the Software, and to permit persons to whom the Software is
*	furnished to do so, subject to the following conditions:
*
*	The above copyright notice and this permission notice shall be included in
*	all copies or substantial portions of the Software.
*
*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*	THE SOFTWARE.
*	
*	@author 	Tim Benniks <tim@timbenniks.com>
* 	@copyright  2009 timbenniks.com
*	@version    $Id: jquery.notice.js 1 2009-01-24 12:24:18Z timbenniks $
**/
(function(jQuery)
{
	jQuery.extend({			
		noticeAdd: function(options)
		{	
			var defaults = {
				inEffect: 			{opacity: 'show'},	// in effect
				inEffectDuration: 	600,				// in effect duration in miliseconds
				stayTime: 			3000,				// time in miliseconds before the item has to disappear
				text: 				'',					// content of the item
				stay: 				false,				// should the notice item stay or not?
				type: 				'notice' 			// could also be error, succes
			}
			
			// declare varaibles
			var options, noticeWrapAll, noticeItemOuter, noticeItemInner, noticeItemClose, hover = false;
			
			options 		= jQuery.extend({}, defaults, options);
			noticeWrapAll	= (!jQuery('.notice-wrap').length) ? jQuery('<div></div>').addClass('notice-wrap').appendTo('body') : jQuery('.notice-wrap');
			noticeItemOuter	= jQuery('<div></div>').addClass('notice-item-wrapper');
			noticeItemInner	= jQuery('<div></div>').hide().addClass('notice-item ' + options.type).appendTo(noticeWrapAll).html('<p>'+options.text+'</p>').animate(options.inEffect, options.inEffectDuration).wrap(noticeItemOuter);
			noticeItemClose	= jQuery('<div></div>').addClass('notice-item-close').prependTo(noticeItemInner).html('x').click(function() { jQuery.noticeRemove(noticeItemInner) });
			
			noticeItemInner.hover(function() {
				hover = true;
			}, function () {
				hover = false;
			});

			if (!options.stay) {
				setTimeout( function () {
					var noticeHover = setInterval(function () {
						if(!hover) {
							jQuery.noticeRemove(noticeItemInner);
							clearInterval(noticeHover);
						}
					}, 1000);
				}, options.stayTime);
			}
		},
		
		noticeRemove: function(obj)
		{
			obj.animate({opacity: '0'}, 600, function()
			{
				obj.parent().animate({height: '0px'}, 300, function()
				{
					obj.parent().remove();
				});
			});
		}
	});
})(jQuery);
},{}],12:[function(require,module,exports){
/**
 * @preserve JSizes - JQuery plugin v0.33
 *
 * Licensed under the revised BSD License.
 * Copyright 2008-2010 Bram Stein
 * All rights reserved.
 */
/*global jQuery*/
(function ($) {
	'use strict';
	var num = function (value) {
			return parseInt(value, 10) || 0;
		};

	/**
	 * Sets or gets the values for min-width, min-height, max-width
	 * and max-height.
	 */
	$.each(['min', 'max'], function (i, name) {
		$.fn[name + 'Size'] = function (value) {
			var width, height;
			if (value) {
				if (value.width !== undefined) {
					this.css(name + '-width', value.width);
				}
				if (value.height !== undefined) {
					this.css(name + '-height', value.height);
				}
			} else {
				width = this.css(name + '-width');
				height = this.css(name + '-height');
				// Apparently:
				//  * Opera returns -1px instead of none
				//  * IE6 returns undefined instead of none
				return {'width': (name === 'max' && (width === undefined || width === 'none' || num(width) === -1) && Number.MAX_VALUE) || num(width), 
						'height': (name === 'max' && (height === undefined || height === 'none' || num(height) === -1) && Number.MAX_VALUE) || num(height)};
			}
			return this;
		};
	});

	/**
	 * Returns whether or not an element is visible.
	 */
	$.fn.isVisible = function () {
		return this.is(':visible');
	};

	/**
	 * Sets or gets the values for border, margin and padding.
	 */
	$.each(['border', 'margin', 'padding'], function (i, name) {
		$.fn[name] = function (value) {
			if (value) {
				if (value.top !== undefined) {
					this.css(name + '-top' + (name === 'border' ? '-width' : ''), value.top);
				}
				if (value.bottom !== undefined) {
					this.css(name + '-bottom' + (name === 'border' ? '-width' : ''), value.bottom);
				}
				if (value.left !== undefined) {
					this.css(name + '-left' + (name === 'border' ? '-width' : ''), value.left);
				}
				if (value.right !== undefined) {
					this.css(name + '-right' + (name === 'border' ? '-width' : ''), value.right);
				}
			} else {
				return {top: num(this.css(name + '-top' + (name === 'border' ? '-width' : ''))),
						bottom: num(this.css(name + '-bottom' + (name === 'border' ? '-width' : ''))),
						left: num(this.css(name + '-left' + (name === 'border' ? '-width' : ''))),
						right: num(this.css(name + '-right' + (name === 'border' ? '-width' : '')))};
			}
			return this;
		};
	});
}(jQuery));

},{}],13:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.fn.extend({
	ssDatepicker: function ssDatepicker(opts) {
		return (0, _jQuery2.default)(this).each(function () {
			if ((0, _jQuery2.default)(this).data('datepicker')) return;

			(0, _jQuery2.default)(this).siblings("button").addClass("ui-icon ui-icon-calendar");

			var holder = (0, _jQuery2.default)(this).parents('.field.date:first'),
			    config = _jQuery2.default.extend(opts || {}, (0, _jQuery2.default)(this).data(), (0, _jQuery2.default)(this).data('jqueryuiconfig'), {});
			if (!config.showcalendar) return;

			if (config.locale && _jQuery2.default.datepicker.regional[config.locale]) {
				config = _jQuery2.default.extend(config, _jQuery2.default.datepicker.regional[config.locale], {});
			}

			if (config.min) config.minDate = _jQuery2.default.datepicker.parseDate('yy-mm-dd', config.min);
			if (config.max) config.maxDate = _jQuery2.default.datepicker.parseDate('yy-mm-dd', config.max);

			config.dateFormat = config.jquerydateformat;
			(0, _jQuery2.default)(this).datepicker(config);
		});
	}
});

(0, _jQuery2.default)(document).on("click", ".field.date input.text,input.text.date", function () {
	(0, _jQuery2.default)(this).ssDatepicker();

	if ((0, _jQuery2.default)(this).data('datepicker')) {
		(0, _jQuery2.default)(this).datepicker('show');
	}
});

},{"./jQuery":"jQuery"}],14:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	$('.ss-gridfield').entwine({

		reload: function reload(ajaxOpts, successCallback) {
			var self = this,
			    form = this.closest('form'),
			    focusedElName = this.find(':input:focus').attr('name'),
			    data = form.find(':input').serializeArray();

			if (!ajaxOpts) ajaxOpts = {};
			if (!ajaxOpts.data) ajaxOpts.data = [];
			ajaxOpts.data = ajaxOpts.data.concat(data);

			if (window.location.search) {
				ajaxOpts.data = window.location.search.replace(/^\?/, '') + '&' + $.param(ajaxOpts.data);
			}

			if (!window.history || !window.history.pushState) {
				if (window.location.hash && window.location.hash.indexOf('?') != -1) {
					ajaxOpts.data = window.location.hash.substring(window.location.hash.indexOf('?') + 1) + '&' + $.param(ajaxOpts.data);
				}
			}

			form.addClass('loading');

			$.ajax($.extend({}, {
				headers: { "X-Pjax": 'CurrentField' },
				type: "POST",
				url: this.data('url'),
				dataType: 'html',
				success: function success(data) {
					self.empty().append($(data).children());

					if (focusedElName) self.find(':input[name="' + focusedElName + '"]').focus();

					if (self.find('.filter-header').length) {
						var content;
						if (ajaxOpts.data[0].filter == "show") {
							content = '<span class="non-sortable"></span>';
							self.addClass('show-filter').find('.filter-header').show();
						} else {
							content = '<button type="button" name="showFilter" class="ss-gridfield-button-filter trigger"></button>';
							self.removeClass('show-filter').find('.filter-header').hide();
						}

						self.find('.sortable-header th:last').html(content);
					}

					form.removeClass('loading');
					if (successCallback) successCallback.apply(this, arguments);
					self.trigger('reload', self);
				},
				error: function error(e) {
					alert(_i18n2.default._t('GRIDFIELD.ERRORINTRANSACTION'));
					form.removeClass('loading');
				}
			}, ajaxOpts));
		},
		showDetailView: function showDetailView(url) {
			window.location.href = url;
		},
		getItems: function getItems() {
			return this.find('.ss-gridfield-item');
		},

		setState: function setState(k, v) {
			var state = this.getState();
			state[k] = v;
			this.find(':input[name="' + this.data('name') + '[GridState]"]').val(JSON.stringify(state));
		},

		getState: function getState() {
			return JSON.parse(this.find(':input[name="' + this.data('name') + '[GridState]"]').val());
		}
	});

	$('.ss-gridfield *').entwine({
		getGridField: function getGridField() {
			return this.closest('.ss-gridfield');
		}
	});

	$('.ss-gridfield :button[name=showFilter]').entwine({
		onclick: function onclick(e) {
			$('.filter-header').show('slow').find(':input:first').focus();
			this.closest('.ss-gridfield').addClass('show-filter');
			this.parent().html('<span class="non-sortable"></span>');
			e.preventDefault();
		}
	});

	$('.ss-gridfield .ss-gridfield-item').entwine({
		onclick: function onclick(e) {
			if ($(e.target).closest('.action').length) {
				this._super(e);
				return false;
			}

			var editLink = this.find('.edit-link');
			if (editLink.length) this.getGridField().showDetailView(editLink.prop('href'));
		},
		onmouseover: function onmouseover() {
			if (this.find('.edit-link').length) this.css('cursor', 'pointer');
		},
		onmouseout: function onmouseout() {
			this.css('cursor', 'default');
		}
	});

	$('.ss-gridfield .action').entwine({
		onclick: function onclick(e) {
			var filterState = 'show';
			if (this.button('option', 'disabled')) {
				e.preventDefault();
				return;
			}

			if (this.hasClass('ss-gridfield-button-close') || !this.closest('.ss-gridfield').hasClass('show-filter')) {
				filterState = 'hidden';
			}

			this.getGridField().reload({ data: [{ name: this.attr('name'), value: this.val(), filter: filterState }] });
			e.preventDefault();
		}
	});

	$('.ss-gridfield .add-existing-autocompleter').entwine({
		onbuttoncreate: function onbuttoncreate() {
			var self = this;

			this.toggleDisabled();

			this.find('input[type="text"]').on('keyup', function () {
				self.toggleDisabled();
			});
		},
		onunmatch: function onunmatch() {
			this.find('input[type="text"]').off('keyup');
		},
		toggleDisabled: function toggleDisabled() {
			var $button = this.find('.ss-ui-button'),
			    $input = this.find('input[type="text"]'),
			    inputHasValue = $input.val() !== '',
			    buttonDisabled = $button.is(':disabled');

			if (inputHasValue && buttonDisabled || !inputHasValue && !buttonDisabled) {
				$button.button("option", "disabled", !buttonDisabled);
			}
		}
	});

	$('.ss-gridfield .col-buttons .action.gridfield-button-delete, .cms-edit-form .Actions button.action.action-delete').entwine({
		onclick: function onclick(e) {
			if (!confirm(_i18n2.default._t('TABLEFIELD.DELETECONFIRMMESSAGE'))) {
				e.preventDefault();
				return false;
			} else {
				this._super(e);
			}
		}
	});

	$('.ss-gridfield .action.gridfield-button-print').entwine({
		UUID: null,
		onmatch: function onmatch() {
			this._super();
			this.setUUID(new Date().getTime());
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onclick: function onclick(e) {
			var btn = this.closest(':button'),
			    grid = this.getGridField(),
			    form = this.closest('form'),
			    data = form.find(':input.gridstate').serialize();;

			data += "&" + encodeURIComponent(btn.attr('name')) + '=' + encodeURIComponent(btn.val());

			if (window.location.search) {
				data = window.location.search.replace(/^\?/, '') + '&' + data;
			}

			var connector = grid.data('url').indexOf('?') == -1 ? '?' : '&';

			var url = $.path.makeUrlAbsolute(grid.data('url') + connector + data, $('base').attr('href'));

			var newWindow = window.open(url);

			return false;
		}
	});

	$('.ss-gridfield-print-iframe').entwine({
		onmatch: function onmatch() {
			this._super();

			this.hide().bind('load', function () {
				this.focus();
				var ifWin = this.contentWindow || this;
				ifWin.print();
			});
		},
		onunmatch: function onunmatch() {
			this._super();
		}
	});

	$('.ss-gridfield .action.no-ajax').entwine({
		onclick: function onclick(e) {
			var self = this,
			    btn = this.closest(':button'),
			    grid = this.getGridField(),
			    form = this.closest('form'),
			    data = form.find(':input.gridstate').serialize();

			data += "&" + encodeURIComponent(btn.attr('name')) + '=' + encodeURIComponent(btn.val());

			if (window.location.search) {
				data = window.location.search.replace(/^\?/, '') + '&' + data;
			}

			var connector = grid.data('url').indexOf('?') == -1 ? '?' : '&';

			window.location.href = $.path.makeUrlAbsolute(grid.data('url') + connector + data, $('base').attr('href'));

			return false;
		}
	});

	$('.ss-gridfield .action-detail').entwine({
		onclick: function onclick() {
			this.getGridField().showDetailView($(this).prop('href'));
			return false;
		}
	});

	$('.ss-gridfield[data-selectable]').entwine({
		getSelectedItems: function getSelectedItems() {
			return this.find('.ss-gridfield-item.ui-selected');
		},

		getSelectedIDs: function getSelectedIDs() {
			return $.map(this.getSelectedItems(), function (el) {
				return $(el).data('id');
			});
		}
	});
	$('.ss-gridfield[data-selectable] .ss-gridfield-items').entwine({
		onadd: function onadd() {
			this._super();

			this.selectable();
		},
		onremove: function onremove() {
			this._super();
			if (this.data('selectable')) this.selectable('destroy');
		}
	});

	$('.ss-gridfield .filter-header :input').entwine({
		onmatch: function onmatch() {
			var filterbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-filter'),
			    resetbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-reset');

			if (this.val()) {
				filterbtn.addClass('filtered');
				resetbtn.addClass('filtered');
			}
			this._super();
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onkeydown: function onkeydown(e) {
			if (this.closest('.ss-gridfield-button-reset').length) return;

			var filterbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-filter'),
			    resetbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-reset');

			if (e.keyCode == '13') {
				var btns = this.closest('.filter-header').find('.ss-gridfield-button-filter');
				var filterState = 'show';
				if (this.hasClass('ss-gridfield-button-close') || !this.closest('.ss-gridfield').hasClass('show-filter')) {
					filterState = 'hidden';
				}

				this.getGridField().reload({ data: [{ name: btns.attr('name'), value: btns.val(), filter: filterState }] });
				return false;
			} else {
				filterbtn.addClass('hover-alike');
				resetbtn.addClass('hover-alike');
			}
		}
	});

	$(".ss-gridfield .relation-search").entwine({
		onfocusin: function onfocusin(event) {
			this.autocomplete({
				source: function source(request, response) {
					var searchField = $(this.element);
					var form = $(this.element).closest("form");
					$.ajax({
						headers: {
							"X-Pjax": 'Partial'
						},
						type: "GET",
						url: $(searchField).data('searchUrl'),
						data: encodeURIComponent(searchField.attr('name')) + '=' + encodeURIComponent(searchField.val()),
						success: function success(data) {
							response(JSON.parse(data));
						},
						error: function error(e) {
							alert(_i18n2.default._t('GRIDFIELD.ERRORINTRANSACTION', 'An error occured while fetching data from the server\n Please try again later.'));
						}
					});
				},
				select: function select(event, ui) {
					$(this).closest(".ss-gridfield").find("#action_gridfield_relationfind").replaceWith('<input type="hidden" name="relationID" value="' + ui.item.id + '" id="relationID"/>');
					var addbutton = $(this).closest(".ss-gridfield").find("#action_gridfield_relationadd");
					if (addbutton.data('button')) {
						addbutton.button('enable');
					} else {
						addbutton.removeAttr('disabled');
					}
				}
			});
		}
	});

	$(".ss-gridfield .pagination-page-number input").entwine({
		onkeydown: function onkeydown(event) {
			if (event.keyCode == 13) {
				var newpage = parseInt($(this).val(), 10);

				var gridfield = $(this).getGridField();
				gridfield.setState('GridFieldPaginator', { currentPage: newpage });
				gridfield.reload();

				return false;
			}
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],15:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ss = typeof window.ss !== 'undefined' ? window.ss : {};

ss.editorWrappers = {};
ss.editorWrappers.tinyMCE = function () {
	var editorID;

	return {
		init: function init(ID) {
			editorID = ID;

			this.create();
		},

		destroy: function destroy() {
			tinymce.EditorManager.execCommand('mceRemoveEditor', false, editorID);
		},

		getInstance: function getInstance() {
			return tinymce.EditorManager.get(editorID);
		},

		onopen: function onopen() {},

		onclose: function onclose() {},

		getConfig: function getConfig() {
			var selector = "#" + editorID,
			    config = (0, _jQuery2.default)(selector).data('config'),
			    self = this;

			config.selector = selector;

			config.setup = function (ed) {
				ed.on('change', function () {
					self.save();
				});
			};
			return config;
		},

		save: function save() {
			var instance = this.getInstance();
			instance.save();

			(0, _jQuery2.default)(instance.getElement()).trigger("change");
		},

		create: function create() {
			var config = this.getConfig();

			if (typeof config.baseURL !== 'undefined') {
				tinymce.EditorManager.baseURL = config.baseURL;
			}
			tinymce.init(config);
		},

		repaint: function repaint() {},

		isDirty: function isDirty() {
			return this.getInstance().isDirty();
		},

		getContent: function getContent() {
			return this.getInstance().getContent();
		},

		getDOM: function getDOM() {
			return this.getInstance().getElement();
		},

		getContainer: function getContainer() {
			return this.getInstance().getContainer();
		},

		getSelectedNode: function getSelectedNode() {
			return this.getInstance().selection.getNode();
		},

		selectNode: function selectNode(node) {
			this.getInstance().selection.select(node);
		},

		setContent: function setContent(html, opts) {
			this.getInstance().setContent(html, opts);
		},

		insertContent: function insertContent(html, opts) {
			this.getInstance().insertContent(html, opts);
		},

		replaceContent: function replaceContent(html, opts) {
			this.getInstance().execCommand('mceReplaceContent', false, html, opts);
		},

		insertLink: function insertLink(attrs, opts) {
			this.getInstance().execCommand("mceInsertLink", false, attrs, opts);
		},

		removeLink: function removeLink() {
			this.getInstance().execCommand('unlink', false);
		},

		cleanLink: function cleanLink(href, node) {
			var settings = this.getConfig,
			    cb = settings['urlconverter_callback'];
			if (cb) href = eval(cb + "(href, node, true);");

			if (href.match(new RegExp('^' + tinyMCE.settings['document_base_url'] + '(.*)$'))) {
				href = RegExp.$1;
			}

			if (href.match(/^javascript:\s*mctmp/)) href = '';

			return href;
		},

		createBookmark: function createBookmark() {
			return this.getInstance().selection.getBookmark();
		},

		moveToBookmark: function moveToBookmark(bookmark) {
			this.getInstance().selection.moveToBookmark(bookmark);
			this.getInstance().focus();
		},

		blur: function blur() {
			this.getInstance().selection.collapse();
		},

		addUndo: function addUndo() {
			this.getInstance().undoManager.add();
		}
	};
};

ss.editorWrappers['default'] = ss.editorWrappers.tinyMCE;

_jQuery2.default.entwine('ss', function ($) {
	$('textarea.htmleditor').entwine({

		Editor: null,

		onadd: function onadd() {
			var edClass = this.data('editor') || 'default',
			    ed = ss.editorWrappers[edClass]();
			this.setEditor(ed);

			ed.init(this.attr('id'));

			this._super();
		},

		onremove: function onremove() {
			this.getEditor().destroy();
			this._super();
		},

		'from .cms-edit-form': {
			onbeforesubmitform: function onbeforesubmitform() {
				this.getEditor().save();
				this._super();
			}
		},

		openLinkDialog: function openLinkDialog() {
			this.openDialog('link');
		},

		openMediaDialog: function openMediaDialog() {
			this.openDialog('media');
		},

		openDialog: function openDialog(type) {
			var capitalize = function capitalize(text) {
				return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
			};

			var self = this,
			    url = $('#cms-editor-dialogs').data('url' + capitalize(type) + 'form'),
			    dialog = $('.htmleditorfield-' + type + 'dialog');

			if (dialog.length) {
				dialog.getForm().setElement(this);
				dialog.html('');
				dialog.addClass('loading');
				dialog.open();
			} else {
				dialog = $('<div class="htmleditorfield-dialog htmleditorfield-' + type + 'dialog loading">');
				$('body').append(dialog);
			}

			$.ajax({
				url: url,
				complete: function complete() {
					dialog.removeClass('loading');
				},
				success: function success(html) {
					dialog.html(html);
					dialog.getForm().setElement(self);
					dialog.trigger('ssdialogopen');
				}
			});
		}
	});

	$('.htmleditorfield-dialog').entwine({
		onadd: function onadd() {
			if (!this.is('.ui-dialog-content')) {
				this.ssdialog({
					autoOpen: true,
					buttons: {
						'insert': {
							text: _i18n2.default._t('HtmlEditorField.INSERT', 'Insert'),
							'data-icon': 'accept',
							class: 'ss-ui-action-constructive media-insert',
							click: function click() {
								$(this).find('form').submit();
							}
						}
					}
				});
			}

			this._super();
		},

		getForm: function getForm() {
			return this.find('form');
		},
		open: function open() {
			this.ssdialog('open');
		},
		close: function close() {
			this.ssdialog('close');
		},
		toggle: function toggle(bool) {
			if (this.is(':visible')) this.close();else this.open();
		},
		onscroll: function onscroll() {
			this.animate({
				scrollTop: this.find('form').height()
			}, 500);
		}
	});

	$('form.htmleditorfield-form').entwine({
		Selection: null,

		Bookmark: null,

		Element: null,

		setSelection: function setSelection(node) {
			return this._super($(node));
		},

		onadd: function onadd() {
			var titleEl = this.find(':header:first');
			this.getDialog().attr('title', titleEl.text());

			this._super();
		},
		onremove: function onremove() {
			this.setSelection(null);
			this.setBookmark(null);
			this.setElement(null);

			this._super();
		},

		getDialog: function getDialog() {
			return this.closest('.htmleditorfield-dialog');
		},

		fromDialog: {
			onssdialogopen: function onssdialogopen() {
				var ed = this.getEditor();

				this.setSelection(ed.getSelectedNode());
				this.setBookmark(ed.createBookmark());

				ed.blur();

				this.find(':input:not(:submit)[data-skip-autofocus!="true"]').filter(':visible:enabled').eq(0).focus();

				this.redraw();
				this.updateFromEditor();
			},

			onssdialogclose: function onssdialogclose() {
				var ed = this.getEditor();

				ed.moveToBookmark(this.getBookmark());

				this.setSelection(null);
				this.setBookmark(null);

				this.resetFields();
			}
		},

		getEditor: function getEditor() {
			return this.getElement().getEditor();
		},

		modifySelection: function modifySelection(callback) {
			var ed = this.getEditor();

			ed.moveToBookmark(this.getBookmark());
			callback.call(this, ed);

			this.setSelection(ed.getSelectedNode());
			this.setBookmark(ed.createBookmark());

			ed.blur();
		},

		updateFromEditor: function updateFromEditor() {},
		redraw: function redraw() {},
		resetFields: function resetFields() {
			this.find('.tree-holder').empty();
		}
	});

	$('form.htmleditorfield-linkform').entwine({
		onsubmit: function onsubmit(e) {
			this.insertLink();
			this.getDialog().close();
			return false;
		},
		resetFields: function resetFields() {
			this._super();

			this[0].reset();
		},
		redraw: function redraw() {
			this._super();

			var linkType = this.find(':input[name=LinkType]:checked').val();

			this.addAnchorSelector();

			this.resetFileField();

			this.find('div.content .field').hide();
			this.find('.field[id$="LinkType"]').show();
			this.find('.field[id$="' + linkType + '_Holder"]').show();

			if (linkType == 'internal' || linkType == 'anchor') {
				this.find('.field[id$="Anchor_Holder"]').show();
			}

			if (linkType == 'email') {
				this.find('.field[id$="Subject_Holder"]').show();
			} else {
				this.find('.field[id$="TargetBlank_Holder"]').show();
			}

			if (linkType == 'anchor') {
				this.find('.field[id$="AnchorSelector_Holder"]').show();
			}
			this.find('.field[id$="Description_Holder"]').show();
		},

		getLinkAttributes: function getLinkAttributes() {
			var href,
			    target = null,
			    subject = this.find(':input[name=Subject]').val(),
			    anchor = this.find(':input[name=Anchor]').val();

			if (this.find(':input[name=TargetBlank]').is(':checked')) {
				target = '_blank';
			}

			switch (this.find(':input[name=LinkType]:checked').val()) {
				case 'internal':
					href = '[sitetree_link,id=' + this.find(':input[name=internal]').val() + ']';

					if (anchor) {
						href += '#' + anchor;
					}

					break;

				case 'anchor':
					href = '#' + anchor;
					break;

				case 'file':
					href = '[file_link,id=' + this.find('.ss-uploadfield .ss-uploadfield-item').attr('data-fileid') + ']';
					break;

				case 'email':
					href = 'mailto:' + this.find(':input[name=email]').val();
					if (subject) {
						href += '?subject=' + encodeURIComponent(subject);
					}
					target = null;
					break;

				default:
					href = this.find(':input[name=external]').val();

					if (href.indexOf('://') == -1) href = 'http://' + href;
					break;
			}

			return {
				href: href,
				target: target,
				title: this.find(':input[name=Description]').val()
			};
		},
		insertLink: function insertLink() {
			this.modifySelection(function (ed) {
				ed.insertLink(this.getLinkAttributes());
			});
		},
		removeLink: function removeLink() {
			this.modifySelection(function (ed) {
				ed.removeLink();
			});

			this.resetFileField();
			this.close();
		},

		resetFileField: function resetFileField() {
			var fileField = this.find('.ss-uploadfield[id$="file_Holder"]'),
			    fileUpload = fileField.data('fileupload'),
			    currentItem = fileField.find('.ss-uploadfield-item[data-fileid]');

			if (currentItem.length) {
				fileUpload._trigger('destroy', null, { context: currentItem });
				fileField.find('.ss-uploadfield-addfile').removeClass('borderTop');
			}
		},

		addAnchorSelector: function addAnchorSelector() {
			if (this.find(':input[name=AnchorSelector]').length) return;

			var self = this;
			var anchorSelector = $('<select id="Form_EditorToolbarLinkForm_AnchorSelector" name="AnchorSelector"></select>');
			this.find(':input[name=Anchor]').parent().append(anchorSelector);

			this.updateAnchorSelector();

			anchorSelector.change(function (e) {
				self.find(':input[name="Anchor"]').val($(this).val());
			});
		},

		getAnchors: function getAnchors() {
			var linkType = this.find(':input[name=LinkType]:checked').val();
			var dfdAnchors = $.Deferred();

			switch (linkType) {
				case 'anchor':
					var collectedAnchors = [];
					var ed = this.getEditor();


					if (ed) {
						var raw = ed.getContent().match(/\s+(name|id)\s*=\s*(["'])([^\2\s>]*?)\2|\s+(name|id)\s*=\s*([^"']+)[\s +>]/gim);
						if (raw && raw.length) {
							for (var i = 0; i < raw.length; i++) {
								var indexStart = raw[i].indexOf('id=') == -1 ? 7 : 5;
								collectedAnchors.push(raw[i].substr(indexStart).replace(/"$/, ''));
							}
						}
					}

					dfdAnchors.resolve(collectedAnchors);
					break;

				case 'internal':
					var pageId = this.find(':input[name=internal]').val();

					if (pageId) {
						$.ajax({
							url: $.path.addSearchParams(this.attr('action').replace('LinkForm', 'getanchors'), { 'PageID': parseInt(pageId) }),
							success: function success(body, status, xhr) {
								dfdAnchors.resolve($.parseJSON(body));
							},
							error: function error(xhr, status) {
								dfdAnchors.reject(xhr.responseText);
							}
						});
					} else {
						dfdAnchors.resolve([]);
					}
					break;

				default:
					dfdAnchors.reject(_i18n2.default._t('HtmlEditorField.ANCHORSNOTSUPPORTED', 'Anchors are not supported for this link type.'));
					break;
			}

			return dfdAnchors.promise();
		},

		updateAnchorSelector: function updateAnchorSelector() {
			var self = this;
			var selector = this.find(':input[name=AnchorSelector]');
			var dfdAnchors = this.getAnchors();

			selector.empty();
			selector.append($('<option value="" selected="1">' + _i18n2.default._t('HtmlEditorField.LOOKINGFORANCHORS', 'Looking for anchors...') + '</option>'));

			dfdAnchors.done(function (anchors) {
				selector.empty();
				selector.append($('<option value="" selected="1">' + _i18n2.default._t('HtmlEditorField.SelectAnchor') + '</option>'));

				if (anchors) {
					for (var j = 0; j < anchors.length; j++) {
						selector.append($('<option value="' + anchors[j] + '">' + anchors[j] + '</option>'));
					}
				}
			}).fail(function (message) {
				selector.empty();
				selector.append($('<option value="" selected="1">' + message + '</option>'));
			});

			if ($.browser.msie) selector.hide().show();
		},

		updateFromEditor: function updateFromEditor() {
			var htmlTagPattern = /<\S[^><]*>/g,
			    fieldName,
			    data = this.getCurrentLink();

			if (data) {
				for (fieldName in data) {
					var el = this.find(':input[name=' + fieldName + ']'),
					    selected = data[fieldName];

					if (typeof selected == 'string') selected = selected.replace(htmlTagPattern, '');

					if (el.is(':checkbox')) {
						el.prop('checked', selected).change();
					} else if (el.is(':radio')) {
						el.val([selected]).change();
					} else if (fieldName == 'file') {
						el = this.find(':input[name="' + fieldName + '[Uploads][]"]');

						el = el.parents('.ss-uploadfield');

						(function attach(el, selected) {
							if (!el.getConfig()) {
								setTimeout(function () {
									attach(el, selected);
								}, 50);
							} else {
								el.attachFiles([selected]);
							}
						})(el, selected);
					} else {
						el.val(selected).change();
					}
				}
			}
		},

		getCurrentLink: function getCurrentLink() {
			var selectedEl = this.getSelection(),
			    href = "",
			    target = "",
			    title = "",
			    action = "insert",
			    style_class = "";

			var linkDataSource = null;
			if (selectedEl.length) {
				if (selectedEl.is('a')) {
					linkDataSource = selectedEl;
				} else {
						linkDataSource = selectedEl = selectedEl.parents('a:first');
					}
			}
			if (linkDataSource && linkDataSource.length) this.modifySelection(function (ed) {
				ed.selectNode(linkDataSource[0]);
			});

			if (!linkDataSource.attr('href')) linkDataSource = null;

			if (linkDataSource) {
				href = linkDataSource.attr('href');
				target = linkDataSource.attr('target');
				title = linkDataSource.attr('title');
				style_class = linkDataSource.attr('class');
				href = this.getEditor().cleanLink(href, linkDataSource);
				action = "update";
			}

			if (href.match(/^mailto:(.*)$/)) {
				return {
					LinkType: 'email',
					email: RegExp.$1,
					Description: title
				};
			} else if (href.match(/^(assets\/.*)$/) || href.match(/^\[file_link\s*(?:\s*|%20|,)?id=([0-9]+)\]?(#.*)?$/)) {
				return {
					LinkType: 'file',
					file: RegExp.$1,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href.match(/^#(.*)$/)) {
				return {
					LinkType: 'anchor',
					Anchor: RegExp.$1,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href.match(/^\[sitetree_link(?:\s*|%20|,)?id=([0-9]+)\]?(#.*)?$/i)) {
				return {
					LinkType: 'internal',
					internal: RegExp.$1,
					Anchor: RegExp.$2 ? RegExp.$2.substr(1) : '',
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href) {
				return {
					LinkType: 'external',
					external: href,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else {
				return null;
			}
		}
	});

	$('form.htmleditorfield-linkform input[name=LinkType]').entwine({
		onclick: function onclick(e) {
			this.parents('form:first').redraw();
			this._super();
		},
		onchange: function onchange() {
			this.parents('form:first').redraw();

			var linkType = this.parent().find(':checked').val();
			if (linkType === 'anchor' || linkType === 'internal') {
				this.parents('form.htmleditorfield-linkform').updateAnchorSelector();
			}
			this._super();
		}
	});

	$('form.htmleditorfield-linkform input[name=internal]').entwine({
		onvalueupdated: function onvalueupdated() {
			this.parents('form.htmleditorfield-linkform').updateAnchorSelector();
			this._super();
		}
	});

	$('form.htmleditorfield-linkform :submit[name=action_remove]').entwine({
		onclick: function onclick(e) {
			this.parents('form:first').removeLink();
			this._super();
			return false;
		}
	});

	$('form.htmleditorfield-mediaform').entwine({
		toggleCloseButton: function toggleCloseButton() {
			var updateExisting = Boolean(this.find('.ss-htmleditorfield-file').length);
			this.find('.overview .action-delete')[updateExisting ? 'hide' : 'show']();
		},
		onsubmit: function onsubmit() {
			this.modifySelection(function (ed) {
				this.find('.ss-htmleditorfield-file').each(function () {
					$(this).insertHTML(ed);
				});
			});

			this.getDialog().close();
			return false;
		},
		updateFromEditor: function updateFromEditor() {
			var self = this,
			    node = this.getSelection();

			if (node.is('img')) {
				this.showFileView(node.data('url') || node.attr('src')).done(function (filefield) {
					filefield.updateFromNode(node);
					self.toggleCloseButton();
					self.redraw();
				});
			}
			this.redraw();
		},
		redraw: function redraw(updateExisting) {
			this._super();

			var node = this.getSelection(),
			    hasItems = Boolean(this.find('.ss-htmleditorfield-file').length),
			    editingSelected = node.is('img'),
			    insertingURL = this.hasClass('insertingURL'),
			    header = this.find('.header-edit');

			header[hasItems ? 'show' : 'hide']();

			this.closest('ui-dialog').find('ui-dialog-buttonpane .media-insert').button(hasItems ? 'enable' : 'disable').toggleClass('ui-state-disabled', !hasItems);

			this.find('.htmleditorfield-default-panel')[editingSelected || insertingURL ? 'hide' : 'show']();
			this.find('.htmleditorfield-web-panel')[editingSelected || !insertingURL ? 'hide' : 'show']();

			var mediaFormHeading = this.find('.htmleditorfield-mediaform-heading.insert');

			if (editingSelected) {
				mediaFormHeading.hide();
			} else if (insertingURL) {
				mediaFormHeading.show().text(_i18n2.default._t("HtmlEditorField.INSERTURL")).prepend('<button class="back-button font-icon-left-open no-text" title="' + _i18n2.default._t("HtmlEditorField.BACK") + '"></button>');

				this.find('.htmleditorfield-web-panel input.remoteurl').focus();
			} else {
				mediaFormHeading.show().text(_i18n2.default._t("HtmlEditorField.INSERTFROM")).find('.back-button').remove();
			}

			this.find('.htmleditorfield-mediaform-heading.update')[editingSelected ? 'show' : 'hide']();
			this.find('.ss-uploadfield-item-actions')[editingSelected ? 'hide' : 'show']();
			this.find('.ss-uploadfield-item-name')[editingSelected ? 'hide' : 'show']();
			this.find('.ss-uploadfield-item-preview')[editingSelected ? 'hide' : 'show']();
			this.find('.Actions .media-update')[editingSelected ? 'show' : 'hide']();
			this.find('.ss-uploadfield-item-editform').toggleEditForm(editingSelected);
			this.find('.htmleditorfield-from-cms .field.treedropdown').css('left', $('.htmleditorfield-mediaform-heading:visible').outerWidth());
			this.closest('.ui-dialog').addClass('ss-uploadfield-dropzone');
			this.closest('.ui-dialog').find('.ui-dialog-buttonpane .media-insert .ui-button-text').text([editingSelected ? _i18n2.default._t('HtmlEditorField.UPDATE', 'Update') : _i18n2.default._t('HtmlEditorField.INSERT', 'Insert')]);
		},
		resetFields: function resetFields() {
			this.find('.ss-htmleditorfield-file').remove();
			this.find('.ss-gridfield-items .ui-selected').removeClass('ui-selected');
			this.find('li.ss-uploadfield-item').remove();
			this.redraw();

			this._super();
		},
		getFileView: function getFileView(idOrUrl) {
			return this.find('.ss-htmleditorfield-file[data-id=' + idOrUrl + ']');
		},
		showFileView: function showFileView(idOrUrl) {
			var self = this,
			    params = Number(idOrUrl) == idOrUrl ? { ID: idOrUrl } : { FileURL: idOrUrl };

			var item = $('<div class="ss-htmleditorfield-file loading" />');
			this.find('.content-edit').prepend(item);

			var dfr = $.Deferred();

			$.ajax({
				url: $.path.addSearchParams(this.attr('action').replace(/MediaForm/, 'viewfile'), params),
				success: function success(html, status, xhr) {
					var newItem = $(html).filter('.ss-htmleditorfield-file');
					item.replaceWith(newItem);
					self.redraw();
					dfr.resolve(newItem);
				},
				error: function error() {
					item.remove();
					dfr.reject();
				}
			});

			return dfr.promise();
		}
	});

	$('form.htmleditorfield-mediaform div.ss-upload .upload-url').entwine({
		onclick: function onclick() {
			var form = this.closest('form');

			form.addClass('insertingURL');
			form.redraw();
		}
	});

	$('form.htmleditorfield-mediaform .htmleditorfield-mediaform-heading .back-button').entwine({
		onclick: function onclick() {
			var form = this.closest('form');

			form.removeClass('insertingURL');
			form.redraw();
		}
	});

	$('form.htmleditorfield-mediaform .ss-gridfield-items').entwine({
		onselectableselected: function onselectableselected(e, ui) {
			var form = this.closest('form'),
			    item = $(ui.selected);
			if (!item.is('.ss-gridfield-item')) return;
			form.closest('form').showFileView(item.data('id'));
			form.redraw();

			form.parent().trigger('scroll');
		},
		onselectableunselected: function onselectableunselected(e, ui) {
			var form = this.closest('form'),
			    item = $(ui.unselected);
			if (!item.is('.ss-gridfield-item')) return;
			form.getFileView(item.data('id')).remove();
			form.redraw();
		}
	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform div.ss-assetuploadfield').entwine({
		onfileuploadstop: function onfileuploadstop(e) {
			var form = this.closest('form');

			var editFieldIDs = [];
			form.find('div.content-edit').find('div.ss-htmleditorfield-file').each(function () {
				editFieldIDs.push($(this).data('id'));
			});

			var uploadedFiles = $('.ss-uploadfield-files', this).children('.ss-uploadfield-item');
			uploadedFiles.each(function () {
				var uploadedID = $(this).data('fileid');
				if (uploadedID && $.inArray(uploadedID, editFieldIDs) == -1) {
					$(this).remove();
					form.showFileView(uploadedID);
				}
			});

			form.parent().trigger('scroll');

			form.redraw();
		}

	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform input.remoteurl').entwine({
		onadd: function onadd() {
			this._super();
			this.validate();
		},

		onkeyup: function onkeyup() {
			this.validate();
		},

		onchange: function onchange() {
			this.validate();
		},

		getAddButton: function getAddButton() {
			return this.closest('.CompositeField').find('button.add-url');
		},

		validate: function validate() {
			var val = this.val(),
			    orig = val;

			val = $.trim(val);
			val = val.replace(/^https?:\/\//i, '');
			if (orig !== val) this.val(val);

			this.getAddButton().button(!!val ? 'enable' : 'disable');
			return !!val;
		}
	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform .add-url').entwine({
		getURLField: function getURLField() {
			return this.closest('.CompositeField').find('input.remoteurl');
		},

		onclick: function onclick(e) {
			var urlField = this.getURLField(),
			    container = this.closest('.CompositeField'),
			    form = this.closest('form');

			if (urlField.validate()) {
				container.addClass('loading');
				form.showFileView('http://' + urlField.val()).done(function () {
					container.removeClass('loading');

					form.parent().trigger('scroll');
				});
				form.redraw();
			}

			return false;
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file').entwine({
		getAttributes: function getAttributes() {},

		getExtraData: function getExtraData() {},

		getHTML: function getHTML() {
			return $('<div>').append($('<a/>').attr({ href: this.data('url') }).text(this.find('.name').text())).html();
		},

		insertHTML: function insertHTML(ed) {
			ed.replaceContent(this.getHTML());
		},

		updateFromNode: function updateFromNode(node) {},

		updateDimensions: function updateDimensions(constrainBy, maxW, maxH) {
			var widthEl = this.find(':input[name=Width]'),
			    heightEl = this.find(':input[name=Height]'),
			    w = widthEl.val(),
			    h = heightEl.val(),
			    aspect;

			if (w && h) {
				if (constrainBy) {
					aspect = heightEl.getOrigVal() / widthEl.getOrigVal();

					if (constrainBy == 'Width') {
						if (maxW && w > maxW) w = maxW;
						h = Math.floor(w * aspect);
					} else if (constrainBy == 'Height') {
						if (maxH && h > maxH) h = maxH;
						w = Math.ceil(h / aspect);
					}
				} else {
					if (maxW && w > maxW) w = maxW;
					if (maxH && h > maxH) h = maxH;
				}

				widthEl.val(w);
				heightEl.val(h);
			}
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.image').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find(':input[name=URL]').val(),
				'alt': this.find(':input[name=AltText]').val(),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'title': this.find(':input[name=Title]').val(),
				'class': this.find(':input[name=CSSClass]').val(),
				'data-fileid': this.find(':input[name=FileID]').val()
			};
		},
		getExtraData: function getExtraData() {
			return {
				'CaptionText': this.find(':input[name=CaptionText]').val()
			};
		},
		getHTML: function getHTML() {},

		insertHTML: function insertHTML(ed) {
			var form = this.closest('form');
			var node = form.getSelection();
			if (!ed) ed = form.getEditor();

			var attrs = this.getAttributes(),
			    extraData = this.getExtraData();

			var replacee = node && node.is('img') ? node : null;
			if (replacee && replacee.parent().is('.captionImage')) replacee = replacee.parent();

			var img = node && node.is('img') ? node : $('<img />');
			img.attr(attrs);

			var container = img.parent('.captionImage'),
			    caption = container.find('.caption');

			if (extraData.CaptionText) {
				if (!container.length) {
					container = $('<div></div>');
				}

				container.attr('class', 'captionImage ' + attrs['class']).css('width', attrs.width);

				if (!caption.length) {
					caption = $('<p class="caption"></p>').appendTo(container);
				}

				caption.attr('class', 'caption ' + attrs['class']).text(extraData.CaptionText);
			} else {
					container = caption = null;
				}

			var replacer = container ? container : img;

			if (replacee && replacee.not(replacer).length) {
				replacee.replaceWith(replacer);
			}

			if (container) {
				container.prepend(img);
			}

			if (!replacee) {
				ed.repaint();
				ed.insertContent($('<div />').append(replacer).html(), { skip_undo: 1 });
			}

			ed.addUndo();
			ed.repaint();
		},
		updateFromNode: function updateFromNode(node) {
			this.find(':input[name=AltText]').val(node.attr('alt'));
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=CSSClass]').val(node.attr('class'));
			this.find(':input[name=Width]').val(node.width());
			this.find(':input[name=Height]').val(node.height());
			this.find(':input[name=CaptionText]').val(node.siblings('.caption:first').text());
			this.find(':input[name=FileID]').val(node.data('fileid'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.flash').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find(':input[name=URL]').val(),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'data-fileid': this.find(':input[name=FileID]').val()
			};
		},
		getHTML: function getHTML() {
			var attrs = this.getAttributes();

			var el = tinyMCE.activeEditor.plugins.media.dataToImg({
				'type': 'flash',
				'width': attrs.width,
				'height': attrs.height,
				'params': { 'src': attrs.src },
				'video': { 'sources': [] }
			});

			return $('<div />').append(el).html();
		},
		updateFromNode: function updateFromNode(node) {}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.embed').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find('.thumbnail-preview').attr('src'),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'class': this.find(':input[name=CSSClass]').val(),
				'alt': this.find(':input[name=AltText]').val(),
				'title': this.find(':input[name=Title]').val(),
				'data-fileid': this.find(':input[name=FileID]').val()
			};
		},
		getExtraData: function getExtraData() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'CaptionText': this.find(':input[name=CaptionText]').val(),
				'Url': this.find(':input[name=URL]').val(),
				'thumbnail': this.find('.thumbnail-preview').attr('src'),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'cssclass': this.find(':input[name=CSSClass]').val()
			};
		},
		getHTML: function getHTML() {
			var el,
			    attrs = this.getAttributes(),
			    extraData = this.getExtraData(),
			    imgEl = $('<img />').attr(attrs).addClass('ss-htmleditorfield-file embed');

			$.each(extraData, function (key, value) {
				imgEl.attr('data-' + key, value);
			});

			if (extraData.CaptionText) {
				el = $('<div style="width: ' + attrs['width'] + 'px;" class="captionImage ' + attrs['class'] + '"><p class="caption">' + extraData.CaptionText + '</p></div>').prepend(imgEl);
			} else {
				el = imgEl;
			}
			return $('<div />').append(el).html();
		},
		updateFromNode: function updateFromNode(node) {
			this.find(':input[name=AltText]').val(node.attr('alt'));
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=Width]').val(node.width());
			this.find(':input[name=Height]').val(node.height());
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=CSSClass]').val(node.data('cssclass'));
			this.find(':input[name=FileID]').val(node.data('fileid'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file .dimensions :input').entwine({
		OrigVal: null,
		onmatch: function onmatch() {
			this._super();

			this.setOrigVal(parseInt(this.val(), 10));
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onfocusout: function onfocusout(e) {
			this.closest('.ss-htmleditorfield-file').updateDimensions(this.attr('name'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-uploadfield-item .ss-uploadfield-item-cancel').entwine({
		onclick: function onclick(e) {
			var form = this.closest('form'),
			    file = this.closest('ss-uploadfield-item');
			form.find('.ss-gridfield-item[data-id=' + file.data('id') + ']').removeClass('ui-selected');
			this.closest('.ss-uploadfield-item').remove();
			form.redraw();
			e.preventDefault();
		}
	});

	$('div.ss-assetuploadfield .ss-uploadfield-item-edit, div.ss-assetuploadfield .ss-uploadfield-item-name').entwine({
		getEditForm: function getEditForm() {
			return this.closest('.ss-uploadfield-item').find('.ss-uploadfield-item-editform');
		},

		fromEditForm: {
			onchange: function onchange(e) {
				var form = $(e.target);
				form.removeClass('edited');
				form.addClass('edited');
			}
		},

		onclick: function onclick(e) {
			var editForm = this.getEditForm();

			if (this.closest('.ss-uploadfield-item').hasClass('ss-htmleditorfield-file')) {
				editForm.parent('ss-uploadfield-item').removeClass('ui-state-warning');

				editForm.toggleEditForm();

				e.preventDefault();

				return false;
			}

			this._super(e);
		}
	});

	$('div.ss-assetuploadfield .ss-uploadfield-item-editform').entwine({
		toggleEditForm: function toggleEditForm(bool) {
			var itemInfo = this.prev('.ss-uploadfield-item-info'),
			    status = itemInfo.find('.ss-uploadfield-item-status');
			var text = "";

			if (bool === true || bool !== false && this.height() === 0) {
				text = _i18n2.default._t('UploadField.Editing', "Editing ...");
				this.height('auto');
				itemInfo.find('.toggle-details-icon').addClass('opened');
				status.removeClass('ui-state-success-text').removeClass('ui-state-warning-text');
			} else {
				this.height(0);
				itemInfo.find('.toggle-details-icon').removeClass('opened');
				if (!this.hasClass('edited')) {
					text = _i18n2.default._t('UploadField.NOCHANGES', 'No Changes');
					status.addClass('ui-state-success-text');
				} else {
					text = _i18n2.default._t('UploadField.CHANGESSAVED', 'Changes Made');
					this.removeClass('edited');
					status.addClass('ui-state-success-text');
				}
			}
			status.attr('title', text).text(text);
		}
	});

	$('form.htmleditorfield-mediaform .field[id$="ParentID_Holder"] .TreeDropdownField').entwine({
		onadd: function onadd() {
			this._super();

			var self = this;
			this.bind('change', function () {
				var fileList = self.closest('form').find('.ss-gridfield');
				fileList.setState('ParentID', self.getValue());
				fileList.reload();
			});
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],16:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	$('.ss-tabset').entwine({
		IgnoreTabState: false,

		onadd: function onadd() {
			var hash = window.location.hash;

			this.redrawTabs();

			if (hash !== '') {
				this.openTabFromURL(hash);
			}

			this._super();
		},

		onremove: function onremove() {
			if (this.data('tabs')) this.tabs('destroy');
			this._super();
		},

		redrawTabs: function redrawTabs() {
			this.rewriteHashlinks();
			this.tabs();
		},

		openTabFromURL: function openTabFromURL(hash) {
			var $trigger;

			$.each(this.find('.cms-panel-link'), function () {
				if (this.href.indexOf(hash) !== -1 && $(hash).length === 1) {
					$trigger = $(this);
					return false;
				}
			});

			if ($trigger === void 0) {
				return;
			}

			$(window).one('ajaxComplete', function () {
				$trigger.click();
			});
		},

		rewriteHashlinks: function rewriteHashlinks() {
			$(this).find('ul a').each(function () {
				if (!$(this).attr('href')) return;

				var matches = $(this).attr('href').match(/#.*/);
				if (!matches) return;
				$(this).attr('href', document.location.href.replace(/#.*/, '') + matches[0]);
			});
		}
	});
});

},{"./jQuery":"jQuery"}],17:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	var windowWidth, windowHeight;
	$(window).bind('resize.treedropdownfield', function () {
		var cb = function cb() {
			$('.TreeDropdownField').closePanel();
		};

		if ($.browser.msie && parseInt($.browser.version, 10) < 9) {
			var newWindowWidth = $(window).width(),
			    newWindowHeight = $(window).height();
			if (newWindowWidth != windowWidth || newWindowHeight != windowHeight) {
				windowWidth = newWindowWidth;
				windowHeight = newWindowHeight;
				cb();
			}
		} else {
			cb();
		}
	});

	var strings = {
		'openlink': _i18n2.default._t('TreeDropdownField.OpenLink'),
		'fieldTitle': '(' + _i18n2.default._t('TreeDropdownField.FieldTitle') + ')',
		'searchFieldTitle': '(' + _i18n2.default._t('TreeDropdownField.SearchFieldTitle') + ')'
	};

	var _clickTestFn = function _clickTestFn(e) {
		if (!$(e.target).parents('.TreeDropdownField').length) $('.TreeDropdownField').closePanel();
	};

	$('.TreeDropdownField').entwine({
		CurrentXhr: null,

		onadd: function onadd() {
			this.append('<span class="treedropdownfield-title"></span>' + '<div class="treedropdownfield-toggle-panel-link"><a href="#" class="ui-icon ui-icon-triangle-1-s"></a></div>' + '<div class="treedropdownfield-panel"><div class="tree-holder"></div></div>');

			var linkTitle = strings.openLink;
			if (linkTitle) this.find("treedropdownfield-toggle-panel-link a").attr('title', linkTitle);
			if (this.data('title')) this.setTitle(this.data('title'));

			this.getPanel().hide();
			this._super();
		},
		getPanel: function getPanel() {
			return this.find('.treedropdownfield-panel');
		},
		openPanel: function openPanel() {
			$('.TreeDropdownField').closePanel();

			$('body').bind('click', _clickTestFn);

			var panel = this.getPanel(),
			    tree = this.find('.tree-holder');

			panel.css('width', this.width());

			panel.show();

			var toggle = this.find(".treedropdownfield-toggle-panel-link");
			toggle.addClass('treedropdownfield-open-tree');
			this.addClass("treedropdownfield-open-tree");

			toggle.find("a").removeClass('ui-icon-triangle-1-s').addClass('ui-icon-triangle-1-n');

			if (tree.is(':empty') && !panel.hasClass('loading')) {
				this.loadTree(null, this._riseUp);
			} else {
				this._riseUp();
			}

			this.trigger('panelshow');
		},
		_riseUp: function _riseUp() {
			var container = this,
			    dropdown = this.getPanel(),
			    toggle = this.find(".treedropdownfield-toggle-panel-link"),
			    offsetTop = toggle.innerHeight(),
			    elHeight,
			    elPos,
			    endOfWindow;

			if (toggle.length > 0) {
				endOfWindow = $(window).height() + $(document).scrollTop() - toggle.innerHeight();
				elPos = toggle.offset().top;
				elHeight = dropdown.innerHeight();

				if (elPos + elHeight > endOfWindow && elPos - elHeight > 0) {
					container.addClass('treedropdownfield-with-rise');
					offsetTop = -dropdown.outerHeight();
				} else {
					container.removeClass('treedropdownfield-with-rise');
				}
			}
			dropdown.css({ "top": offsetTop + "px" });
		},
		closePanel: function closePanel() {
			jQuery('body').unbind('click', _clickTestFn);

			var toggle = this.find(".treedropdownfield-toggle-panel-link");
			toggle.removeClass('treedropdownfield-open-tree');
			this.removeClass('treedropdownfield-open-tree treedropdownfield-with-rise');

			toggle.find("a").removeClass('ui-icon-triangle-1-n').addClass('ui-icon-triangle-1-s');

			this.getPanel().hide();
			this.trigger('panelhide');
		},
		togglePanel: function togglePanel() {
			this[this.getPanel().is(':visible') ? 'closePanel' : 'openPanel']();
		},
		setTitle: function setTitle(title) {
			title = title || this.data('title') || strings.fieldTitle;

			this.find('.treedropdownfield-title').html(title);
			this.data('title', title);
		},
		getTitle: function getTitle() {
			return this.find('.treedropdownfield-title').text();
		},

		updateTitle: function updateTitle() {
			var self = this,
			    tree = self.find('.tree-holder'),
			    val = this.getValue();
			var updateFn = function updateFn() {
				var val = self.getValue();
				if (val) {

					var node = tree.find('*[data-id="' + val + '"]'),
					    title = node.children('a').find("span.jstree_pageicon") ? node.children('a').find("span.item").html() : null;
					if (!title) title = node.length > 0 ? tree.jstree('get_text', node[0]) : null;

					if (title) {
						self.setTitle(title);
						self.data('title', title);
					}
					if (node) tree.jstree('select_node', node);
				} else {
					self.setTitle(self.data('empty-title'));
					self.removeData('title');
				}
			};

			if (!tree.is(':empty') || !val) updateFn();else this.loadTree({ forceValue: val }, updateFn);
		},
		setValue: function setValue(val) {
			this.data('metadata', $.extend(this.data('metadata'), { id: val }));
			this.find(':input:hidden').val(val).trigger('valueupdated').trigger('change');
		},
		getValue: function getValue() {
			return this.find(':input:hidden').val();
		},
		loadTree: function loadTree(params, callback) {
			var self = this,
			    panel = this.getPanel(),
			    treeHolder = $(panel).find('.tree-holder'),
			    params = params ? $.extend({}, this.getRequestParams(), params) : this.getRequestParams(),
			    xhr;

			if (this.getCurrentXhr()) this.getCurrentXhr().abort();
			panel.addClass('loading');
			xhr = $.ajax({
				url: this.data('urlTree'),
				data: params,
				complete: function complete(xhr, status) {
					panel.removeClass('loading');
				},
				success: function success(html, status, xhr) {
					treeHolder.html(html);
					var firstLoad = true;
					treeHolder.jstree('destroy').bind('loaded.jstree', function (e, data) {
						var val = self.getValue(),
						    selectNode = treeHolder.find('*[data-id="' + val + '"]'),
						    currentNode = data.inst.get_selected();
						if (val && selectNode != currentNode) data.inst.select_node(selectNode);
						firstLoad = false;
						if (callback) callback.apply(self);
					}).jstree(self.getTreeConfig()).bind('select_node.jstree', function (e, data) {
						var node = data.rslt.obj,
						    id = $(node).data('id');
						if (!firstLoad && self.getValue() == id) {
							self.data('metadata', null);
							self.setTitle(null);
							self.setValue(null);
							data.inst.deselect_node(node);
						} else {
							self.data('metadata', $.extend({ id: id }, $(node).getMetaData()));
							self.setTitle(data.inst.get_text(node));
							self.setValue(id);
						}

						if (!firstLoad) self.closePanel();
						firstLoad = false;
					});

					self.setCurrentXhr(null);
				}
			});
			this.setCurrentXhr(xhr);
		},
		getTreeConfig: function getTreeConfig() {
			var self = this;
			return {
				'core': {
					'html_titles': true,

					'animation': 0
				},
				'html_data': {
					'data': this.getPanel().find('.tree-holder').html(),
					'ajax': {
						'url': function url(node) {
							var url = $.path.parseUrl(self.data('urlTree')).hrefNoSearch;
							return url + '/' + ($(node).data("id") ? $(node).data("id") : 0);
						},
						'data': function data(node) {
							var query = $.query.load(self.data('urlTree')).keys;
							var params = self.getRequestParams();
							params = $.extend({}, query, params, { ajax: 1 });
							return params;
						}
					}
				},
				'ui': {
					"select_limit": 1,
					'initially_select': [this.getPanel().find('.current').attr('id')]
				},
				'themes': {
					'theme': 'apple'
				},
				'types': {
					'types': {
						'default': {
							'check_node': function check_node(node) {
								return !node.hasClass('disabled');
							},
							'uncheck_node': function uncheck_node(node) {
								return !node.hasClass('disabled');
							},
							'select_node': function select_node(node) {
								return !node.hasClass('disabled');
							},
							'deselect_node': function deselect_node(node) {
								return !node.hasClass('disabled');
							}
						}
					}
				},
				'plugins': ['html_data', 'ui', 'themes', 'types']
			};
		},

		getRequestParams: function getRequestParams() {
			return {};
		}
	});

	$('.TreeDropdownField .tree-holder li').entwine({
		getMetaData: function getMetaData() {
			var matches = this.attr('class').match(/class-([^\s]*)/i);
			var klass = matches ? matches[1] : '';
			return { ClassName: klass };
		}
	});

	$('.TreeDropdownField *').entwine({
		getField: function getField() {
			return this.parents('.TreeDropdownField:first');
		}
	});

	$('.TreeDropdownField').entwine({
		onclick: function onclick(e) {
			this.togglePanel();

			return false;
		}
	});

	$('.TreeDropdownField .treedropdownfield-panel').entwine({
		onclick: function onclick(e) {
			return false;
		}
	});

	$('.TreeDropdownField.searchable').entwine({
		onadd: function onadd() {
			this._super();
			var title = _i18n2.default._t('TreeDropdownField.ENTERTOSEARCH');
			this.find('.treedropdownfield-panel').prepend($('<input type="text" class="search treedropdownfield-search" data-skip-autofocus="true" placeholder="' + title + '" value="" />'));
		},
		search: function search(str, callback) {
			this.openPanel();
			this.loadTree({ search: str }, callback);
		},
		cancelSearch: function cancelSearch() {
			this.closePanel();
			this.loadTree();
		}
	});

	$('.TreeDropdownField.searchable input.search').entwine({
		onkeydown: function onkeydown(e) {
			var field = this.getField();
			if (e.keyCode == 13) {
				field.search(this.val());
				return false;
			} else if (e.keyCode == 27) {
				field.cancelSearch();
			}
		}
	});

	$('.TreeDropdownField.multiple').entwine({
		getTreeConfig: function getTreeConfig() {
			var cfg = this._super();
			cfg.checkbox = { override_ui: true, two_state: true };
			cfg.plugins.push('checkbox');
			cfg.ui.select_limit = -1;
			return cfg;
		},
		loadTree: function loadTree(params, callback) {
			var self = this,
			    panel = this.getPanel(),
			    treeHolder = $(panel).find('.tree-holder');
			var params = params ? $.extend({}, this.getRequestParams(), params) : this.getRequestParams(),
			    xhr;

			if (this.getCurrentXhr()) this.getCurrentXhr().abort();
			panel.addClass('loading');
			xhr = $.ajax({
				url: this.data('urlTree'),
				data: params,
				complete: function complete(xhr, status) {
					panel.removeClass('loading');
				},
				success: function success(html, status, xhr) {
					treeHolder.html(html);
					var firstLoad = true;
					self.setCurrentXhr(null);
					treeHolder.jstree('destroy').bind('loaded.jstree', function (e, data) {
						$.each(self.getValue(), function (i, val) {
							data.inst.check_node(treeHolder.find('*[data-id=' + val + ']'));
						});
						firstLoad = false;
						if (callback) callback.apply(self);
					}).jstree(self.getTreeConfig()).bind('uncheck_node.jstree check_node.jstree', function (e, data) {
						var nodes = data.inst.get_checked(null, true);
						self.setValue($.map(nodes, function (el, i) {
							return $(el).data('id');
						}));
						self.setTitle($.map(nodes, function (el, i) {
							return data.inst.get_text(el);
						}));
						self.data('metadata', $.map(nodes, function (el, i) {
							return { id: $(el).data('id'), metadata: $(el).getMetaData() };
						}));
					});
				}
			});
			this.setCurrentXhr(xhr);
		},
		getValue: function getValue() {
			var val = this._super();
			return val.split(/ *, */);
		},
		setValue: function setValue(val) {
			this._super($.isArray(val) ? val.join(',') : val);
		},
		setTitle: function setTitle(title) {
			this._super($.isArray(title) ? title.join(', ') : title);
		},
		updateTitle: function updateTitle() {}
	});

	$('.TreeDropdownField input[type=hidden]').entwine({
		onadd: function onadd() {
			this._super();
			this.bind('change.TreeDropdownField', function () {
				$(this).getField().updateTitle();
			});
		},
		onremove: function onremove() {
			this._super();
			this.unbind('.TreeDropdownField');
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],18:[function(require,module,exports){
// Copyright (c) 2009, SilverStripe Ltd.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY SilverStripe Ltd. ''AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SilverStripe Ltd. BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @class Tracks onchange events on all form fields.
 * 
 * @todo Implement form reset handling
 *  
 * @name jQuery.changetracker
 * @author Ingo Schommer, SilverStripe Ltd.
 * @license BSD License
 */
(function($) {
	$.fn.changetracker = function(_options) {
		var self = this;

		if(this.length > 1){
			this.each(function(i, item) {
				this.changetracker(_options);
			});
			return this;
		}

		this.defaults = {
			fieldSelector: ':input:not(:submit)',
			ignoreFieldSelector: "",
			changedCssClass: 'changed'
		};

		var options = $.extend({}, this.defaults, _options);

		this.initialize = function() {
			// optional metadata plugin support
			if ($.meta) options = $.extend({}, options, this.data());

			// Flag indicating this form was dirtied by an external component
			var dirty = false;

			var onchange = function(e) {
				var $field = $(e.target);
				var origVal = $field.data('changetracker.origVal'), newVal;

				// Determine value based on field type
				if($field.is(':checkbox')) {
					newVal = $field.is(':checked') ? 1 : 0;
				} else {
					newVal = $field.val();
				}

				// Determine changed state based on value comparisons
				if(origVal === null || newVal != origVal) {
					$field.addClass(options.changedCssClass);
					self.addClass(options.changedCssClass);
				} else {
					$field.removeClass(options.changedCssClass);
					// Unset changed state on all radio buttons of the same name
					if($field.is(':radio')) {
						self.find(':radio[name=' + $field.attr('name') + ']').removeClass(options.changedCssClass);
					}
					// Only unset form state if no other fields are changed as well and the form isn't explicitly dirty
					if(!dirty && !self.getFields().filter('.' + options.changedCssClass).length) {
						self.removeClass(options.changedCssClass);
					}
				}
			};

			// setup original values
			var fields = this.getFields(), origVal;
			fields.filter(':radio,:checkbox').bind('click.changetracker', onchange);
			fields.not(':radio,:checkbox').bind('change.changetracker', onchange);
			fields.each(function() {
				if($(this).is(':radio,:checkbox')) {
					origVal = self.find(':input[name=' + $(this).attr('name') + ']:checked').val();
				} else {
					origVal = $(this).val();
				}
				$(this).data('changetracker.origVal', origVal);
			});

			self.bind('dirty.changetracker', function() {
				dirty = true;
				self.addClass(options.changedCssClass);
			});

			this.data('changetracker', true);
		};

		this.destroy = function() {
			this.getFields()
				.unbind('.changetracker')
				.removeClass(options.changedCssClass)
				.removeData('changetracker.origVal');
			this.unbind('.changetracker')
				.removeData('changetracker');
		};

		/**
		 * Reset change state of all form fields and the form itself.
		 */
		this.reset = function() {
			this.getFields().each(function() {
				self.resetField(this);
			});

			this.removeClass(options.changedCssClass);
		};

		/**
		 * Reset the change single form field.
		 * Does not reset to the original value.
		 *
		 * @param DOMElement field
		 */
		this.resetField = function(field) {
			return $(field).removeData('changetracker.origVal').removeClass('changed');
		};

		/**
		 * @return jQuery Collection of fields
		 */
		this.getFields = function() {
			return this.find(options.fieldSelector).not(options.ignoreFieldSelector);
		};

		// Support invoking "public" methods as string arguments
		if (typeof arguments[0] === 'string') {
			var property = arguments[1];
			var args = Array.prototype.slice.call(arguments);
			args.splice(0, 1);
			return this[arguments[0]].apply(this, args);
		} else {
			return this.initialize();
		}

	};
}(jQuery));

},{}],19:[function(require,module,exports){
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options = jQuery.extend({}, options); // clone object since it's unexpected behavior if the expired property were changed
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // NOTE Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
},{}],20:[function(require,module,exports){
/* jQuery.Entwine - Copyright 2009-2011 Hamish Friedlander and SilverStripe. Version . */

/* vendor/jquery.selector/jquery.class.js */

/**
 * Very basic Class utility. Based on base and jquery.class.
 * 
 * Class definition: var Foo = Base.extend({ init: function(){ Constructor }; method_name: function(){ Method } });
 *
 * Inheritance: var Bar = Foo.extend({ method_name: function(){ this._super(); } });
 * 
 * new-less Constructor: new Foo(arg) <-same as-> Foo(arg)
 */  	

var Base;

(function(){
	
	var marker = {}, fnTest = /xyz/.test(function(){var xyz;}) ? /\b_super\b/ : /.*/;

	// The base Class implementation (does nothing)
	Base = function(){};
 
	Base.addMethod = function(name, func) {
		var parent = this._super && this._super.prototype;
		
		if (parent && fnTest.test(func)) {
			this.prototype[name] = function(){
				var tmp = this._super;
				this._super = parent[name];
				try {
					var ret = func.apply(this, arguments);
				}
				finally {
					this._super = tmp;
				}
				return ret;
			};
		}
		else this.prototype[name] = func;
	};

	Base.addMethods = function(props) {
		for (var name in props) {
			if (typeof props[name] == 'function') this.addMethod(name, props[name]);
			else this.prototype[name] = props[name];
		}
	};

	Base.subclassOf = function(parentkls) {
		var kls = this;
		while (kls) {
			if (kls === parentkls) return true;
			kls = kls._super;
		}
	};
 
	// Create a new Class that inherits from this class
	Base.extend = function(props) {
  	
		// The dummy class constructor
		var Kls = function() {
			if (arguments[0] === marker) return;
			
			if (this instanceof Kls) {
				if (this.init) this.init.apply(this, arguments);
			}
			else {
				var ret = new Kls(marker); if (ret.init) ret.init.apply(ret, arguments); return ret;
			}
		};
   
		// Add the common class variables and methods
		Kls.constructor = Kls;
		Kls.extend = Base.extend;
		Kls.addMethod = Base.addMethod;
		Kls.addMethods = Base.addMethods;
		Kls.subclassOf = Base.subclassOf;
		
		Kls._super = this;
	
		// Attach the parent object to the inheritance chain
		Kls.prototype = new this(marker);
		Kls.prototype.constructor = Kls;

		// Copy the properties over onto the new prototype
		Kls.addMethods(props);
		
		return Kls;
	}; 
})();;


/* vendor/jquery.selector/jquery.selector.js */

(function($){

	var tokens = {
		UNICODE: /\\[0-9a-f]{1,6}(?:\r\n|[ \n\r\t\f])?/,
		ESCAPE: /(?:UNICODE)|\\[^\n\r\f0-9a-f]/,
		NONASCII: /[^\x00-\x7F]/,
		NMSTART: /[_a-z]|(?:NONASCII)|(?:ESCAPE)/,
		NMCHAR: /[_a-z0-9-]|(?:NONASCII)|(?:ESCAPE)/,
		IDENT: /-?(?:NMSTART)(?:NMCHAR)*/,
		
		NL: /\n|\r\n|\r|\f/,

		STRING: /(?:STRING1)|(?:STRING2)|(?:STRINGBARE)/,
		STRING1: /"(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\"])*"/,
		STRING2: /'(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\'])*'/,
		STRINGBARE: /(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\]])*/,
		
		FUNCTION: /(?:IDENT)\(\)/,
		
		INTEGER: /[0-9]+/,
		
		WITHN: /([-+])?(INTEGER)?(n)\s*(?:([-+])\s*(INTEGER))?/,
		WITHOUTN: /([-+])?(INTEGER)/
	};
	
	var rx = {
		not: /:not\(/,
		not_end: /\)/,
		
 		tag: /((?:IDENT)|\*)/,
		id: /#(IDENT)/,
		cls: /\.(IDENT)/,
		attr: /\[\s*(IDENT)\s*(?:([^=]?=)\s*(STRING)\s*)?\]/,
		pseudo_el: /(?::(first-line|first-letter|before|after))|(?:::((?:FUNCTION)|(?:IDENT)))/,
		pseudo_cls_nth: /:nth-child\(\s*(?:(?:WITHN)|(?:WITHOUTN)|(odd|even))\s*\)/,
		pseudo_cls: /:(IDENT)/,

		comb: /\s*(\+|~|>)\s*|\s+/,
		comma: /\s*,\s*/,
		important: /\s+!important\s*$/
	};

	/* Replace placeholders with actual regex, and mark all as case insensitive */
	var token = /[A-Z][A-Z0-9]+/;
	for (var k in rx) {
		var m, src = rx[k].source;
		while (m = src.match(token)) src = src.replace(m[0], tokens[m[0]].source);
		rx[k] = new RegExp(src, 'gi');
	}

	/**
	 * A string that matches itself against regexii, and keeps track of how much of itself has been matched
	 */
	var ConsumableString = Base.extend({
		init: function(str) {
			this.str = str;
			this.pos = 0;
		},
		match: function(rx) {
			var m;
			rx.lastIndex = this.pos;
			if ((m = rx.exec(this.str)) && m.index == this.pos ) {
				this.pos = rx.lastIndex ? rx.lastIndex : this.str.length ;
				return m;
			}
			return null;
		},
		peek: function(rx) {
			var m;
			rx.lastIndex = this.pos;
			if ((m = rx.exec(this.str)) && m.index == this.pos ) return m;
			return null;
		},
		showpos: function() {
			return this.str.slice(0,this.pos)+'<HERE>' + this.str.slice(this.pos);
		},
		done: function() {
			return this.pos == this.str.length;
		}
	});
	
	/* A base class that all Selectors inherit off */
	var SelectorBase = Base.extend({});
	
	/**
	 * A class representing a Simple Selector, as per the CSS3 selector spec
	 */
	var SimpleSelector = SelectorBase.extend({
		init: function() {
			this.tag = null;
			this.id = null;
			this.classes = [];
			this.attrs = [];
			this.nots = [];
			this.pseudo_classes = [];
			this.pseudo_els = [];
		},
		parse: function(selector) {
			var m;
			
			/* Pull out the initial tag first, if there is one */
			if (m = selector.match(rx.tag)) this.tag = m[1];
			
			/* Then for each selection type, try and find a match */
			do {
				if (m = selector.match(rx.not)) {
					this.nots[this.nots.length] = SelectorsGroup().parse(selector);
					if (!(m = selector.match(rx.not_end))) {
						throw 'Invalid :not term in selector';
					}
				}
				else if (m = selector.match(rx.id))         this.id = m[1];
				else if (m = selector.match(rx.cls))        this.classes[this.classes.length] = m[1];
				else if (m = selector.match(rx.attr))       this.attrs[this.attrs.length] = [ m[1], m[2], m[3] ];
				else if (m = selector.match(rx.pseudo_el))  this.pseudo_els[this.pseudo_els.length] = m[1] || m[2];
				else if (m = selector.match(rx.pseudo_cls_nth)) {
					if (m[3]) {
						var a = parseInt((m[1]||'')+(m[2]||'1'));
						var b = parseInt((m[4]||'')+(m[5]||'0'));
					}
					else {
						var a = m[8] ? 2 : 0;
						var b = m[8] ? (4-m[8].length) : parseInt((m[6]||'')+m[7]);
					}
					this.pseudo_classes[this.pseudo_classes.length] = ['nth-child', [a, b]];
				}
				else if (m = selector.match(rx.pseudo_cls)) this.pseudo_classes[this.pseudo_classes.length] = [m[1]];
				
			} while(m && !selector.done());
			
			return this;
		}
	});

	/**
	 * A class representing a Selector, as per the CSS3 selector spec
	 */
	var Selector = SelectorBase.extend({ 
		init: function(){
			this.parts = [];
		},
		parse: function(cons){
			this.parts[this.parts.length] = SimpleSelector().parse(cons);
			
			while (!cons.done() && !cons.peek(rx.comma) && (m = cons.match(rx.comb))) {
				this.parts[this.parts.length] = m[1] || ' ';
				this.parts[this.parts.length] = SimpleSelector().parse(cons);
			}
			
			return this.parts.length == 1 ? this.parts[0] : this;
		}
	});
	
	/**
	 * A class representing a sequence of selectors, as per the CSS3 selector spec
	 */
	var SelectorsGroup = SelectorBase.extend({ 
		init: function(){
			this.parts = [];
		},
		parse: function(cons){
			this.parts[this.parts.length] = Selector().parse(cons);
			
			while (!cons.done() && (m = cons.match(rx.comma))) {
				this.parts[this.parts.length] = Selector().parse(cons);
			}
			
			return this.parts.length == 1 ? this.parts[0] : this;
		}
	});

	
	$.selector = function(s){
		var cons = ConsumableString(s);
		var res = SelectorsGroup().parse(cons); 
		
		res.selector = s;
		
		if (!cons.done()) throw 'Could not parse selector - ' + cons.showpos() ;
		else return res;
	};
	
	$.selector.SelectorBase = SelectorBase;
	$.selector.SimpleSelector = SimpleSelector;
	$.selector.Selector = Selector;
	$.selector.SelectorsGroup = SelectorsGroup;
	
})(jQuery);
;


/* vendor/jquery.selector/jquery.selector.specifity.js */

(function($) {

	$.selector.SimpleSelector.addMethod('specifity', function() {
		if (this.spec) return this.spec;
		
		var spec = [
			this.id ? 1 : 0, 
			this.classes.length + this.attrs.length + this.pseudo_classes.length, 
			((this.tag && this.tag != '*') ? 1 : 0) + this.pseudo_els.length
		];
		$.each(this.nots, function(i,not){
			var ns = not.specifity(); spec[0] += ns[0]; spec[1] += ns[1]; spec[2] += ns[2]; 
		});
		
		return this.spec = spec;
	});

	$.selector.Selector.addMethod('specifity', function(){
		if (this.spec) return this.spec;
		
		var spec = [0,0,0];
		$.each(this.parts, function(i,part){
			if (i%2) return;
			var ps = part.specifity(); spec[0] += ps[0]; spec[1] += ps[1]; spec[2] += ps[2]; 
		});
		
		return this.spec = spec;	
	});
	
	$.selector.SelectorsGroup.addMethod('specifity', function(){
		if (this.spec) return this.spec;
		
		var spec = [0,0,0];
		$.each(this.parts, function(i,part){
			var ps = part.specifity(); spec[0] += ps[0]; spec[1] += ps[1]; spec[2] += ps[2]; 
		});
		
		return this.spec = spec;	
	});
	
	
})(jQuery);
;


/* vendor/jquery.selector/jquery.selector.matches.js */

/*
This attempts to do the opposite of Sizzle.
Sizzle is good for finding elements for a selector, but not so good for telling if an individual element matches a selector
*/

(function($) {
	
	/**** CAPABILITY TESTS ****/
	var div = document.createElement('div');
	div.innerHTML = '<form id="test"><input name="id" type="text"/></form>';
	
	// In IE 6-7, getAttribute often does the wrong thing (returns similar to el.attr), so we need to use getAttributeNode on that browser
	var getAttributeDodgy = div.firstChild.getAttribute('id') !== 'test';
	
	// Does browser support Element.firstElementChild, Element.previousElementSibling, etc.
	var hasElementTraversal = div.firstElementChild && div.firstElementChild.tagName == 'FORM';
	
	// Does browser support Element.children
	var hasChildren = div.children && div.children[0].tagName == 'FORM';

	/**** INTRO ****/
	
	var GOOD = /GOOD/g;
	var BAD = /BAD/g;
	
	var STARTS_WITH_QUOTES = /^['"]/g;
	
	var join = function(js) {
		return js.join('\n');
	};
	
	var join_complex = function(js) {
		var code = new String(js.join('\n')); // String objects can have properties set. strings can't
		code.complex = true;
		return code;
	};
	
	/**** ATTRIBUTE ACCESSORS ****/
	
	// Not all attribute names can be used as identifiers, so we encode any non-acceptable characters as hex
	var varForAttr = function(attr) {
		return '_' + attr.replace(/^[^A-Za-z]|[^A-Za-z0-9]/g, function(m){ return '_0x' + m.charCodeAt(0).toString(16) + '_'; });
	};
	
	var getAttr;
	
	// Good browsers
	if (!getAttributeDodgy) {
		getAttr = function(attr){ return 'var '+varForAttr(attr)+' = el.getAttribute("'+attr+'");' ; };
	}
	// IE 6, 7
	else {
		// On IE 6 + 7, getAttribute still has to be called with DOM property mirror name, not attribute name. Map attributes to those names
		var getAttrIEMap = { 'class': 'className', 'for': 'htmlFor' };
		
		getAttr = function(attr) {
			var ieattr = getAttrIEMap[attr] || attr;
			return 'var '+varForAttr(attr)+' = el.getAttribute("'+ieattr+'",2) || (el.getAttributeNode("'+attr+'")||{}).nodeValue;';
		};
	}
	
	/**** ATTRIBUTE COMPARITORS ****/
	
	var attrchecks = {
		'-':  '!K',
		'=':  'K != "V"',
		'!=': 'K == "V"',
		'~=': '_WS_K.indexOf(" V ") == -1',
		'^=': '!K || K.indexOf("V") != 0',
		'*=': '!K || K.indexOf("V") == -1',
		'$=': '!K || K.substr(K.length-"V".length) != "V"'
	};

	/**** STATE TRACKER ****/
	
	var State = $.selector.State = Base.extend({
		init: function(){ 
			this.reset(); 
		},
		reset: function() {
			this.attrs = {}; this.wsattrs = {};
		},

		prev: function(){
			this.reset();
			if (hasElementTraversal) return 'el = el.previousElementSibling';
			return 'while((el = el.previousSibling) && el.nodeType != 1) {}';
		},
		next: function() {
			this.reset();
			if (hasElementTraversal) return 'el = el.nextElementSibling';
			return 'while((el = el.nextSibling) && el.nodeType != 1) {}';
		},
		prevLoop: function(body){
			this.reset();
			if (hasElementTraversal) return join([ 'while(el = el.previousElementSibling){', body]);
			return join([
				'while(el = el.previousSibling){',
					'if (el.nodeType != 1) continue;',
					body
			]);
		},
		parent: function() {
			this.reset();
			return 'el = el.parentNode;';
		},
		parentLoop: function(body) {
			this.reset();
			return join([
				'while((el = el.parentNode) && el.nodeType == 1){',
					body,
				'}'
			]);
		},
		
		uses_attr: function(attr) {
			if (this.attrs[attr]) return;
			this.attrs[attr] = true;
			return getAttr(attr); 
		},
		uses_wsattr: function(attr) {
			if (this.wsattrs[attr]) return;
			this.wsattrs[attr] = true;
			return join([this.uses_attr(attr), 'var _WS_'+varForAttr(attr)+' = " "+'+varForAttr(attr)+'+" ";']); 
		},

		uses_jqueryFilters: function() {
			if (this.jqueryFiltersAdded) return;
			this.jqueryFiltersAdded = true;
			return 'var _$filters = jQuery.find.selectors.filters;';
		},

		save: function(lbl) {
			return 'var el'+lbl+' = el;';
		},
		restore: function(lbl) {
			this.reset();
			return 'el = el'+lbl+';';
		}
	});
	
	/**** PSEUDO-CLASS DETAILS ****/
	
	var pseudoclschecks = {
		'first-child': join([
			'var cel = el;',
			'while(cel = cel.previousSibling){ if (cel.nodeType === 1) BAD; }'
		]),
		'last-child': join([
			'var cel = el;',
			'while(cel = cel.nextSibling){ if (cel.nodeType === 1) BAD; }'
		]),
		'nth-child': function(a,b) {
			var get_i = join([
				'var i = 1, cel = el;',
				'while(cel = cel.previousSibling){',
					'if (cel.nodeType === 1) i++;',
				'}'
			]);
			
			if (a == 0) return join([
				get_i,
				'if (i- '+b+' != 0) BAD;'
			]);
			else if (b == 0 && a >= 0) return join([
				get_i,
				'if (i%'+a+' != 0 || i/'+a+' < 0) BAD;'
			]);
			else if (b == 0 && a < 0) return join([
				'BAD;'
			]);
			else return join([
				get_i,
				'if ((i- '+b+')%'+a+' != 0 || (i- '+b+')/'+a+' < 0) BAD;'
			]);
		}
	};
	
	// Needs to refence contents of object, so must be injected after definition
	pseudoclschecks['only-child'] = join([
		pseudoclschecks['first-child'],
		pseudoclschecks['last-child']
	]);
	
	/**** SimpleSelector ****/
	
	$.selector.SimpleSelector.addMethod('compile', function(el) {
		var js = [];
		
		/* Check against element name */			
		if (this.tag && this.tag != '*') {
			js[js.length] = 'if (el.tagName != "'+this.tag.toUpperCase()+'") BAD;';
		}

		/* Check against ID */
		if (this.id) {
			js[js.length] = el.uses_attr('id');
			js[js.length] = 'if (_id !== "'+this.id+'") BAD;';
		}
		
		/* Build className checking variable */
		if (this.classes.length) {
			js[js.length] = el.uses_wsattr('class');
			
			/* Check against class names */
			$.each(this.classes, function(i, cls){
				js[js.length] = 'if (_WS__class.indexOf(" '+cls+' ") == -1) BAD;';
			});
		}
		
		/* Check against attributes */
		$.each(this.attrs, function(i, attr){
			js[js.length] = (attr[1] == '~=') ? el.uses_wsattr(attr[0]) : el.uses_attr(attr[0]);
			var check = attrchecks[ attr[1] || '-' ];
			check = check.replace( /K/g, varForAttr(attr[0])).replace( /V/g, attr[2] && attr[2].match(STARTS_WITH_QUOTES) ? attr[2].slice(1,-1) : attr[2] );
			js[js.length] = 'if ('+check+') BAD;';
		});
		
		/* Check against nots */
		$.each(this.nots, function(i, not){
			var lbl = ++lbl_id;
			var func = join([
				'l'+lbl+':{',
					not.compile(el).replace(BAD, 'break l'+lbl).replace(GOOD, 'BAD'),
				'}'
			]);
			
			if (!(not instanceof $.selector.SimpleSelector)) func = join([
				el.save(lbl),
				func,
				el.restore(lbl)
			]);
				
			js[js.length] = func;
		});
		
		/* Check against pseudo-classes */
		$.each(this.pseudo_classes, function(i, pscls){
			var check = pseudoclschecks[pscls[0]];
			if (check) {
				js[js.length] = ( typeof check == 'function' ? check.apply(this, pscls[1]) : check );
			}
			else if (check = $.find.selectors.filters[pscls[0]]) {
				js[js.length] = el.uses_jqueryFilters();
				js[js.length] = 'if (!_$filters.'+pscls[0]+'(el)) BAD;';
			}
		});
		
		js[js.length] = 'GOOD';
		
		/* Pass */
		return join(js);
	});
	
	var lbl_id = 0;
	/** Turns an compiled fragment into the first part of a combination */
	function as_subexpr(f) {
		if (f.complex)
			return join([
				'l'+(++lbl_id)+':{',
					f.replace(GOOD, 'break l'+lbl_id),
				'}'
			]);
		else
			return f.replace(GOOD, '');
	}
	
	var combines = {
		' ': function(el, f1, f2) {
			return join_complex([
				f2,
				'while(true){',
					el.parent(),
					'if (!el || el.nodeType !== 1) BAD;',
					f1.compile(el).replace(BAD, 'continue'),
				'}'
			]);
		},
		
		'>': function(el, f1, f2) {
			return join([
				f2,
				el.parent(),
				'if (!el || el.nodeType !== 1) BAD;',
				f1.compile(el)
			]);
		},
		
		'~': function(el, f1, f2) {
			return join_complex([
				f2,
				el.prevLoop(),
					f1.compile(el).replace(BAD, 'continue'),
				'}',
				'BAD;'
			]);
		},
		
		'+': function(el, f1, f2) {
			return join([
				f2,
				el.prev(),
				'if (!el) BAD;',
				f1.compile(el)
			]);
		}
	};
	
	$.selector.Selector.addMethod('compile', function(el) {
		var l = this.parts.length;
		
		var expr = this.parts[--l].compile(el);
		while (l) {
			var combinator = this.parts[--l];
			expr = combines[combinator](el, this.parts[--l], as_subexpr(expr));
		}
		
		return expr;
	});

	$.selector.SelectorsGroup.addMethod('compile', function(el) {
		var expr = [], lbl = ++lbl_id;
		
		for (var i=0; i < this.parts.length; i++) {
			expr[expr.length] = join([
				i == 0 ? el.save(lbl) : el.restore(lbl), 
				'l'+lbl+'_'+i+':{',
					this.parts[i].compile(el).replace(BAD, 'break l'+lbl+'_'+i),
				'}'
			]);
		}
		
		expr[expr.length] = 'BAD;';
		return join(expr);
	});

	$.selector.SelectorBase.addMethod('matches', function(el){	
		this.matches = new Function('el', join([ 
			'if (!el) return false;',
			this.compile(new State()).replace(BAD, 'return false').replace(GOOD, 'return true')
		]));
		return this.matches(el);
	});
	
})(jQuery);

;


/* src/jquery.selector.affectedby.js */

(function($) {

	// TODO:
	// Make attributes & IDs work

	var DIRECT = /DIRECT/g;
	var CONTEXT = /CONTEXT/g;
	var EITHER = /DIRECT|CONTEXT/g;

	$.selector.SelectorBase.addMethod('affectedBy', function(props) {
		this.affectedBy = new Function('props', ([
			'var direct_classes, context_classes, direct_attrs, context_attrs, t;',
			this.ABC_compile().replace(DIRECT, 'direct').replace(CONTEXT, 'context'),
			'return {classes: {context: context_classes, direct: direct_classes}, attrs: {context: context_attrs, direct: direct_attrs}};'
		]).join("\n"));

		// DEBUG: Print out the compiled funciton
		// console.log(this.selector, ''+this.affectedBy);

		return this.affectedBy(props);
	});

	$.selector.SimpleSelector.addMethod('ABC_compile', function() {
		var parts = [];

		$.each(this.classes, function(i, cls){
			parts[parts.length] = "if (t = props.classes['"+cls+"']) (DIRECT_classes || (DIRECT_classes = {}))['"+cls+"'] = t;";
		});

		$.each(this.nots, function(i, not){
			parts[parts.length] = not.ABC_compile();
		});

		return parts.join("\n");
	});

	$.selector.Selector.addMethod('ABC_compile', function(arg){
		var parts = [];
		var i = this.parts.length-1;

		parts[parts.length] = this.parts[i].ABC_compile();
		while ((i = i - 2) >= 0) parts[parts.length] = this.parts[i].ABC_compile().replace(EITHER, 'CONTEXT');

		return parts.join("\n");
	});

	$.selector.SelectorsGroup.addMethod('ABC_compile', function(){
		var parts = [];

		$.each(this.parts, function(i,part){
			parts[parts.length] = part.ABC_compile();
		});

		return parts.join("\n");
	});


})(jQuery);
;


/* src/jquery.focusinout.js */

(function($){	
	
	/**
	 * Add focusin and focusout support to bind and live for browers other than IE. Designed to be usable in a delegated fashion (like $.live)
	 * Copyright (c) 2007 Jrn Zaefferer
	 */
	if ($.support.focusinBubbles === undefined)  {
		$.support.focusinBubbles = !!($.browser.msie);
	}

	if (!$.support.focusinBubbles && !$.event.special.focusin) {
		// Emulate focusin and focusout by binding focus and blur in capturing mode
		$.each({focus: 'focusin', blur: 'focusout'}, function(original, fix){
			$.event.special[fix] = {
				setup: function(){
					if (!this.addEventListener) return false;
					this.addEventListener(original, $.event.special[fix].handler, true);
				},
				teardown: function(){
					if (!this.removeEventListener) return false;
					this.removeEventListener(original, $.event.special[fix].handler, true);
				},
				handler: function(e){
					arguments[0] = $.event.fix(e);
					arguments[0].type = fix;
					return $.event.handle.apply(this, arguments);
				}
			};
		});
	}
		
	(function(){
		//IE has some trouble with focusout with select and keyboard navigation
		var activeFocus = null;
	
		$(document)
			.bind('focusin', function(e){
				var target = e.realTarget || e.target;
				if (activeFocus && activeFocus !== target) {
					e.type = 'focusout';
					$(activeFocus).trigger(e);
					e.type = 'focusin';
					e.target = target;
				}
				activeFocus = target;
			})
			.bind('focusout', function(e){
				activeFocus = null;
			});
	})();
	
})(jQuery);;


/* src/jquery.entwine.js */

try {
	console.log;
}
catch (e) {
	window.console = undefined;
}

(function($) {

	/* Create a subclass of the jQuery object. This was introduced in jQuery 1.5, but removed again in 1.9 */
	var sub = function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}

		jQuery.extend( true, jQuerySub, $ );
		jQuerySub.superclass = $;
		jQuerySub.fn = jQuerySub.prototype = $();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	};

	var namespaces = {};

	$.entwine = function() {
		$.fn.entwine.apply(null, arguments);
	};
	
	/**
	 * A couple of utility functions for accessing the store outside of this closure, and for making things
	 * operate in a little more easy-to-test manner
	 */
	$.extend($.entwine, {
		/**
		 * Get all the namespaces. Useful for introspection? Internal interface of Namespace not guaranteed consistant
		 */
		namespaces: namespaces,
		
		/**
		 * Remove all entwine rules
		 */
		clear_all_rules: function() { 
			// Remove proxy functions
			for (var k in $.fn) { if ($.fn[k].isentwinemethod) delete $.fn[k]; }
			// Remove bound events - TODO: Make this pluggable, so this code can be moved to jquery.entwine.events.js
			$(document).unbind('.entwine');
			$(window).unbind('.entwine');
			// Remove namespaces, and start over again
			for (var k in namespaces) delete namespaces[k];
			for (var k in $.entwine.capture_bindings) delete $.entwine.capture_bindings[k];
		},
		
		WARN_LEVEL_NONE: 0,
		WARN_LEVEL_IMPORTANT: 1,
		WARN_LEVEL_BESTPRACTISE: 2,
		
		/** 
		 * Warning level. Set to a higher level to get warnings dumped to console.
		 */
		warningLevel: 0,
		
		/** Utility to optionally display warning messages depending on level */
		warn: function(message, level) {
			if (level <= $.entwine.warningLevel && console && console.warn) { 
				console.warn(message);
				if (console.trace) console.trace();
			}
		},
		
		warn_exception: function(where, /* optional: */ on, e) {
			if ($.entwine.WARN_LEVEL_IMPORTANT <= $.entwine.warningLevel && console && console.warn) {
				if (arguments.length == 2) { e = on; on = null; }
				
				if (on) console.warn('Uncaught exception',e,'in',where,'on',on);
				else    console.warn('Uncaught exception',e,'in',where);
				
				if (e.stack) console.warn("Stack Trace:\n" + e.stack);
			}
		}
	});
	

	/** Stores a count of definitions, so that we can sort identical selectors by definition order */
	var rulecount = 0;
	
	var Rule = Base.extend({
		init: function(selector, name) {
			this.selector = selector;
			this.specifity = selector.specifity();
			this.important = 0;
			this.name = name;
			this.rulecount = rulecount++;
		}
	});
	
	Rule.compare = function(a, b) {
		var as = a.specifity, bs = b.specifity;
		
		return (a.important - b.important) ||
		       (as[0] - bs[0]) ||
		       (as[1] - bs[1]) ||
		       (as[2] - bs[2]) ||
		       (a.rulecount - b.rulecount) ;
	};

	$.entwine.RuleList = function() {
		var list = [];
		
		list.addRule = function(selector, name){ 
			var rule = Rule(selector, name);
			
			list[list.length] = rule; 
			list.sort(Rule.compare); 
			
			return rule;
		};
		
		return list;
	};

	var handlers = [];
	
	/**
	 * A Namespace holds all the information needed for adding entwine methods to a namespace (including the _null_ namespace)
	 */
	$.entwine.Namespace = Base.extend({
		init: function(name){
			if (name && !name.match(/^[A-Za-z0-9.]+$/)) $.entwine.warn('Entwine namespace '+name+' is not formatted as period seperated identifiers', $.entwine.WARN_LEVEL_BESTPRACTISE);
			name = name || '__base';
			
			this.name = name;
			this.store = {};
			
			namespaces[name] = this;
			
			if (name == "__base") {
				this.injectee = $.fn;
				this.$ = $;
			}
			else {
				// We're in a namespace, so we build a Class that subclasses the jQuery Object Class to inject namespace functions into
				this.$ = $.sub ? $.sub() : sub();
				// Work around bug in sub() - subclass must share cache with root or data won't get cleared by cleanData
				this.$.cache = $.cache;

				this.injectee = this.$.prototype;

				// We override entwine to inject the name of this namespace when defining blocks inside this namespace
				var entwine_wrapper = this.injectee.entwine = function(spacename) {
					var args = arguments;
					
					if (!spacename || typeof spacename != 'string') { args = $.makeArray(args); args.unshift(name); }
					else if (spacename.charAt(0) != '.') args[0] = name+'.'+spacename;
					
					return $.fn.entwine.apply(this, args);
				};
				
				this.$.entwine = function() {
					entwine_wrapper.apply(null, arguments);
				};
				
				for (var i = 0; i < handlers.length; i++) {
					var handler = handlers[i], builder;

					// Inject jQuery object method overrides
					if (builder = handler.namespaceMethodOverrides) {
						var overrides = builder(this);
						for (var k in overrides) this.injectee[k] = overrides[k];
					}
					
					// Inject $.entwine function overrides
					if (builder = handler.namespaceStaticOverrides) {
						var overrides = builder(this);
						for (var k in overrides) this.$.entwine[k] = overrides[k];
					}
				}
			}
		},
		
		/**
		 * Returns a function that does selector matching against the function list for a function name
		 * Used by proxy for all calls, and by ctorProxy to handle _super calls
		 * @param {String} name - name of the function as passed in the construction object
		 * @param {String} funcprop - the property on the Rule object that gives the actual function to call
		 * @param {function} basefunc - the non-entwine function to use as the catch-all function at the bottom of the stack
		 */
		one: function(name, funcprop, basefunc) {
			var namespace = this;
			var funcs = this.store[name];
			
			var one = function(el, args, i){
				if (i === undefined) i = funcs.length;
				while (i--) {
					if (funcs[i].selector.matches(el)) {
						var ret, tmp_i = el.i, tmp_f = el.f;
						el.i = i; el.f = one;
						try { ret = funcs[i][funcprop].apply(namespace.$(el), args); }
						finally { el.i = tmp_i; el.f = tmp_f; }
						return ret;
					}
				}
				// If we didn't find a entwine-defined function, but there is a non-entwine function to use as a base, try that
				if (basefunc) return basefunc.apply(namespace.$(el), args);
			};
			
			return one;
		},
		
		/**
		 * A proxy is a function attached to a callable object (either the base jQuery.fn or a subspace object) which handles
		 * finding and calling the correct function for each member of the current jQuery context
		 * @param {String} name - name of the function as passed in the construction object
		 * @param {function} basefunc - the non-entwine function to use as the catch-all function at the bottom of the stack
		 */
		build_proxy: function(name, basefunc) {
			var one = this.one(name, 'func', basefunc);
			
			var prxy = function() {
				var rv, ctx = $(this); 
				
				var i = ctx.length;
				while (i--) rv = one(ctx[i], arguments);
				return rv;
			};
			
			return prxy;
		},
		
		bind_proxy: function(selector, name, func) {
			var rulelist = this.store[name] || (this.store[name] = $.entwine.RuleList());
			
			var rule = rulelist.addRule(selector, name); rule.func = func;
			
			if (!this.injectee.hasOwnProperty(name) || !this.injectee[name].isentwinemethod) {
				this.injectee[name] = this.build_proxy(name, this.injectee.hasOwnProperty(name) ? this.injectee[name] : null);
				this.injectee[name].isentwinemethod = true;
			}

			if (!this.injectee[name].isentwinemethod) {
				$.entwine.warn('Warning: Entwine function '+name+' clashes with regular jQuery function - entwine function will not be callable directly on jQuery object', $.entwine.WARN_LEVEL_IMPORTANT);
			}
		},
		
		add: function(selector, data) {
			// For every item in the hash, try ever method handler, until one returns true
			for (var k in data) {
				var v = data[k];
				
				for (var i = 0; i < handlers.length; i++) {
					if (handlers[i].bind && handlers[i].bind.call(this, selector, k, v)) break;
				}
			}
		},
		
		has: function(ctx, name) {
			var rulelist = this.store[name];
			if (!rulelist) return false;
			
			/* We go forward this time, since low specifity is likely to knock out a bunch of elements quickly */
			for (var i = 0 ; i < rulelist.length; i++) {
				ctx = ctx.not(rulelist[i].selector);
				if (!ctx.length) return true;
			}
			return false;
		}
	});
	
	/**
	 * A handler is some javascript code that adds support for some time of key / value pair passed in the hash to the Namespace add method.
	 * The default handlers provided (and included by default) are event, ctor and properties
	 */
	$.entwine.Namespace.addHandler = function(handler) {
		for (var i = 0; i < handlers.length && handlers[i].order < handler.order; i++) { /* Pass */ }
		handlers.splice(i, 0, handler);
	};
	
	$.entwine.Namespace.addHandler({
		order: 50,
		
		bind: function(selector, k, v){
			if ($.isFunction(v)) {
				this.bind_proxy(selector, k, v);
				return true;
			}
		}
	});

	$.extend($.fn, {
		/**
		 * Main entwine function. Used for new definitions, calling into a namespace (or forcing the base namespace) and entering a using block
		 * 
		 */
		entwine: function(spacename) {
			var i = 0;
			/* Don't actually work out selector until we try and define something on it - we might be opening a namespace on an function-traveresed object
			   which have non-standard selectors like .parents(.foo).slice(0,1) */
			var selector = null;  
		
			/* By default we operator on the base namespace */
			var namespace = namespaces.__base || $.entwine.Namespace();
			
			/* If the first argument is a string, then it's the name of a namespace. Look it up */
			if (typeof spacename == 'string') {
				if (spacename.charAt('0') == '.') spacename = spacename.substr(1);
				if (spacename) namespace = namespaces[spacename] || $.entwine.Namespace(spacename);
				i=1;
			}
		
			/* All remaining arguments should either be using blocks or definition hashs */
			while (i < arguments.length) {
				var res = arguments[i++];
				
				// If it's a function, call it - either it's a using block or it's a namespaced entwine definition
				if ($.isFunction(res)) {
					if (res.length != 1) $.entwine.warn('Function block inside entwine definition does not take $ argument properly', $.entwine.WARN_LEVEL_IMPORTANT);
					res = res.call(namespace.$(this), namespace.$);
				}
				
				// If we have a entwine definition hash, inject it into namespace
				if (res) {
					if (selector === null) selector = this.selector ? $.selector(this.selector) : false;
					
					if (selector) namespace.add(selector, res);
					else $.entwine.warn('Entwine block given to entwine call without selector. Make sure you call $(selector).entwine when defining blocks', $.entwine.WARN_LEVEL_IMPORTANT);
				}
			}
		
			/* Finally, return the jQuery object 'this' refers to, wrapped in the new namespace */
			return namespace.$(this);
		},
		
		/** 
		 * Calls the next most specific version of the current entwine method
		 */
		_super: function(){
			var rv, i = this.length;
			while (i--) {
				var el = this[0];
				rv = el.f(el, arguments, el.i);
			}
			return rv;
		}
	});
	
})(jQuery);
;


/* src/domevents/jquery.entwine.domevents.addrem.js */

(function($){

	// Gets all the child elements of a particular elements, stores it in an array
	function getElements(store, original) {
		var node, i = store.length, next = original.firstChild;

		while ((node = next)) {
			if (node.nodeType === 1) store[i++] = node;
			next = node.firstChild || node.nextSibling;
			while (!next && (node = node.parentNode) && node !== original) next = node.nextSibling;
		}
	}

	// This might be faster? Or slower? @todo: benchmark.
	function getElementsAlt(store, node) {
		if (node.getElementsByTagName) {
			var els = node.getElementsByTagName('*'), len = els.length, i = 0, j = store.length;
			for(; i < len; i++, j++) {
				store[j] = els[i];
			}
		}
		else if (node.childNodes) {
			var els = node.childNodes, len = els.length, i = 0;
			for(; i < len; i++) {
				getElements(store, els[i]);
			}
		}
	}

	var dontTrigger = false;

	var patchDomManipCallback = function(original) {
		var patched = function(elem){
			var added = [];

			if (!dontTrigger) {
				if (elem.nodeType == 1) added[added.length] = elem;
				getElements(added, elem);
			}

			var rv = original.apply(this, arguments);

			if (!dontTrigger && added.length) {
				var event = $.Event('EntwineElementsAdded');
				event.targets = added;
				$(document).triggerHandler(event);
			}

			return rv;
		}
		patched.patched = true;

		return patched;
	}

	var version = $.prototype.jquery.split('.');
	var callbackIdx = (version[0] > 1 || version[1] >= 10 ? 1 : 2);

	// Monkey patch $.fn.domManip to catch all regular jQuery add element calls
	var _domManip = $.prototype.domManip;
	$.prototype.domManip = function() {
		if (!arguments[callbackIdx].patched) arguments[callbackIdx] = patchDomManipCallback(arguments[callbackIdx]);
		return _domManip.apply(this, arguments);
	}

	// Monkey patch $.fn.html to catch when jQuery sets innerHTML directly
	var _html = $.prototype.html;
	$.prototype.html = function(value) {
		if (value === undefined) return _html.apply(this, arguments);

		dontTrigger = true;
		var res = _html.apply(this, arguments);
		dontTrigger = false;

		var added = [];

		var i = 0, length = this.length;
		for (; i < length; i++ ) getElements(added, this[i]);

		var event = $.Event('EntwineElementsAdded');
		event.targets = added;
		$(document).triggerHandler(event);

		return res;
	}

	// If this is true, we've changed something to call cleanData so that we can catch the elements, but we don't
	// want to call the underlying original $.cleanData
	var supressActualClean = false;

	// Monkey patch $.cleanData to catch element removal
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		// By default we can assume all elements passed are legitimately being removeed
		var removed = elems;

		// Except if we're supressing actual clean - we might be being called by jQuery "being careful" about detaching nodes
		// before attaching them. So we need to check to make sure these nodes currently are in a document
		if (supressActualClean) {
			var i = 0, len = elems.length, removed = [], ri = 0;
			for(; i < len; i++) {
				var node = elems[i], current = node;
				while (current = current.parentNode) {
					if (current.nodeType == 9) { removed[ri++] = node; break; }
				}
			}
		}

		if (removed.length) {
			var event = $.Event('EntwineElementsRemoved');
			event.targets = removed;
			$(document).triggerHandler(event);
		}

		if (!supressActualClean) _cleanData.apply(this, arguments);
	}

	// Monkey patch $.fn.remove to catch when we're just detaching (keepdata == 1) -
	// this doesn't call cleanData but still needs to trigger event
	var _remove = $.prototype.remove;
	$.prototype.remove = function(selector, keepdata) {
		supressActualClean = keepdata;
		var rv = _remove.call(this, selector);
		supressActualClean = false;
		return rv;
	}

	// And on DOM ready, trigger adding once
	$(function(){
		var added = []; getElements(added, document);

		var event = $.Event('EntwineElementsAdded');
		event.targets = added;
		$(document).triggerHandler(event);
	});


})(jQuery);;


/* src/domevents/jquery.entwine.domevents.maybechanged.js */

(function($){

	/** Utility function to monkey-patch a jQuery method */
	var monkey = function( /* method, method, ...., patch */){
		var methods = $.makeArray(arguments);
		var patch = methods.pop();

		$.each(methods, function(i, method){
			var old = $.fn[method];

			$.fn[method] = function() {
				var self = this, args = $.makeArray(arguments);

				var rv = old.apply(self, args);
				patch.apply(self, args);
				return rv;
			}
		});
	}

	/** What to call to run a function 'soon'. Normally setTimeout, but for syncronous mode we override so soon === now */
	var runSoon = window.setTimeout;
	
	/** The timer handle for the asyncronous matching call */
	var ChangeDetails = Base.extend({

		init: function() {
			this.global = false;
			this.attrs = {};
			this.classes = {};
		},

		/** Fire the change event. Only fires on the document node, so bind to that */
		triggerEvent: function() {
			// If we're not the active changes instance any more, don't trigger
			if (changes != this) return;

			// Cancel any pending timeout (if we're directly called in the mean time)
			if (this.check_id) clearTimeout(this.check_id);

			// Reset the global changes object to be a new instance (do before trigger, in case trigger fires changes itself)
			changes = new ChangeDetails();

			// Fire event
			$(document).triggerHandler("EntwineSubtreeMaybeChanged", [this]);
		},

		changed: function() {
			if (!this.check_id) {
				var self = this;
				this.check_id = runSoon(function(){ self.check_id = null; self.triggerEvent(); }, 10);
			}
		},

		addAll: function() {
			if (this.global) return this; // If we've already flagged as a global change, just skip

			this.global = true;
			this.changed();
			return this;
		},

		addSubtree: function(node) {
			return this.addAll();
		},

		/* For now we don't do this. It's expensive, and jquery.entwine.ctors doesn't use this information anyway */
		addSubtreeFuture: function(node) {
			if (this.global) return this; // If we've already flagged as a global change, just skip

			this.subtree = this.subtree ? this.subtree.add(node) : $(node);
			this.changed();
			return this;
		},

		addAttr: function(attr, node) {
			if (this.global) return this;

			this.attrs[attr] = (attr in this.attrs) ? this.attrs[attr].add(node) : $(node);
			this.changed();
			return this;
		},

		addClass: function(klass, node) {
			if (this.global) return this;

			this.classes[klass] = (klass in this.classes) ? this.classes[klass].add(node) : $(node);
			this.changed();
			return this;
		}
	});

	var changes = new ChangeDetails();

	// Element add events trigger maybechanged events

	$(document).bind('EntwineElementsAdded', function(e){ changes.addSubtree(e.targets); });

	// Element remove events trigger maybechanged events, but we have to wait until after the nodes are actually removed
	// (EntwineElementsRemoved fires _just before_ the elements are removed so the data still exists), especially in syncronous mode

	var removed = null;
	$(document).bind('EntwineElementsRemoved', function(e){ removed = e.targets; });

	monkey('remove', 'html', 'empty', function(){
		var subtree = removed; removed = null;
		if (subtree) changes.addSubtree(subtree);
	});

	// We also need to know when an attribute, class, etc changes. Patch the relevant jQuery methods here

	monkey('removeAttr', function(attr){
		changes.addAttr(attr, this);
	});

	monkey('addClass', 'removeClass', 'toggleClass', function(klass){
		if (typeof klass == 'string') changes.addClass(klass, this);
	});

	monkey('attr', function(a, b){
		if (b !== undefined && typeof a == 'string') changes.addAttr(a, this);
		else if (typeof a != 'string') { for (var k in a) changes.addAttr(k, this); }
	});

	// Add some usefull accessors to $.entwine

	$.extend($.entwine, {
		/**
		 * Make onmatch and onunmatch work in synchronous mode - that is, new elements will be detected immediately after
		 * the DOM manipulation that made them match. This is only really useful for during testing, since it's pretty slow
		 * (otherwise we'd make it the default).
		 */
		synchronous_mode: function() {
			if (changes && changes.check_id) clearTimeout(changes.check_id);
			changes = new ChangeDetails();

			runSoon = function(func, delay){ func.call(this); return null; };
		},

		/**
		 * Trigger onmatch and onunmatch now - usefull for after DOM manipulation by methods other than through jQuery.
		 * Called automatically on document.ready
		 */
		triggerMatching: function() {
			changes.addAll();
		}
	});

})(jQuery);;


/* src/jquery.entwine.events.js */

(function($) {	

	/** Taken from jQuery 1.5.2 for backwards compatibility */
	if ($.support.changeBubbles == undefined) {
		$.support.changeBubbles = true;

		var el = document.createElement("div");
		eventName = "onchange";

		if (el.attachEvent) {
			var isSupported = (eventName in el);
			if (!isSupported) {
				el.setAttribute(eventName, "return;");
				isSupported = typeof el[eventName] === "function";
			}

			$.support.changeBubbles = isSupported;
		}
	}

	/* Return true if node b is the same as, or is a descendant of, node a */
	if (document.compareDocumentPosition) {
		var is_or_contains = function(a, b) {
			return a && b && (a == b || !!(a.compareDocumentPosition(b) & 16));
		};
	}
	else {
		var is_or_contains = function(a, b) {
			return a && b && (a == b || (a.contains ? a.contains(b) : true));
		};
	}

	/* Add the methods to handle event binding to the Namespace class */
	$.entwine.Namespace.addMethods({
		build_event_proxy: function(name) {
			var one = this.one(name, 'func');
			
			var prxy = function(e, data) {
				// For events that do not bubble we manually trigger delegation (see delegate_submit below) 
				// If this event is a manual trigger, the event we actually want to bubble is attached as a property of the passed event
				e = e.delegatedEvent || e;
				
				var el = e.target;
				while (el && el.nodeType == 1 && !e.isPropagationStopped()) {
					var ret = one(el, arguments);
					if (ret !== undefined) e.result = ret;
					if (ret === false) { e.preventDefault(); e.stopPropagation(); }
					
					el = el.parentNode;
				}
			};
			
			return prxy;
		},
		
		build_mouseenterleave_proxy: function(name) {
			var one = this.one(name, 'func');
			
			var prxy = function(e) {
				var el = e.target;
				var rel = e.relatedTarget;
				
				while (el && el.nodeType == 1 && !e.isPropagationStopped()) {
					/* We know el contained target. If it also contains relatedTarget then we didn't mouseenter / leave. What's more, every ancestor will also
					contan el and rel, and so we can just stop bubbling */
					if (is_or_contains(el, rel)) break;
					
					var ret = one(el, arguments);
					if (ret !== undefined) e.result = ret;
					if (ret === false) { e.preventDefault(); e.stopPropagation(); }
					
					el = el.parentNode;
				}
			};
			
			return prxy;
		},
		
		build_change_proxy: function(name) {
			var one = this.one(name, 'func');

			/*
			This change bubble emulation code is taken mostly from jQuery 1.6 - unfortunately we can't easily reuse any of
			it without duplication, so we'll have to re-migrate any bugfixes
			*/

			// Get the value of an item. Isn't supposed to be interpretable, just stable for some value, and different
			// once the value changes
			var getVal = function( elem ) {
				var type = elem.type, val = elem.value;

				if (type === "radio" || type === "checkbox") {
					val = elem.checked;
				}
				else if (type === "select-multiple") {
					val = "";
					if (elem.selectedIndex > -1) {
						val = jQuery.map(elem.options, function(elem){ return elem.selected; }).join("-");
					}
				}
				else if (jQuery.nodeName(elem, "select")) {
					val = elem.selectedIndex;
				}

				return val;
			};

			// Test if a node name is a form input
			var rformElems = /^(?:textarea|input|select)$/i;

			// Check if this event is a change, and bubble the change event if it is
			var testChange = function(e) {
				var elem = e.target, data, val;

				if (!rformElems.test(elem.nodeName) || elem.readOnly) return;

				data = jQuery.data(elem, "_entwine_change_data");
				val = getVal(elem);

				// the current data will be also retrieved by beforeactivate
				if (e.type !== "focusout" || elem.type !== "radio") {
					jQuery.data(elem, "_entwine_change_data", val);
				}

				if (data === undefined || val === data) return;

				if (data != null || val) {
					e.type = "change";

					while (elem && elem.nodeType == 1 && !e.isPropagationStopped()) {
						var ret = one(elem, arguments);
						if (ret !== undefined) e.result = ret;
						if (ret === false) { e.preventDefault(); e.stopPropagation(); }

						elem = elem.parentNode;
					}
				}
			};

			// The actual proxy - responds to several events, some of which triger a change check, some
			// of which just store the value for future change checks
			var prxy = function(e) {
				var event = e.type, elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				switch (event) {
					case 'focusout':
					case 'beforedeactivate':
						testChange.apply(this, arguments);
						break;

					case 'click':
						if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
							testChange.apply(this, arguments);
						}
						break;

					// Change has to be called before submit
					// Keydown will be called before keypress, which is used in submit-event delegation
					case 'keydown':
						if (
							(e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
							(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
							type === "select-multiple"
						) {
							testChange.apply(this, arguments);
						}
						break;

					// Beforeactivate happens also before the previous element is blurred
					// with this event you can't trigger a change event, but you can store
					// information
					case 'focusin':
					case 'beforeactivate':
						jQuery.data( elem, "_entwine_change_data", getVal(elem) );
						break;
				}
			}

			return prxy;
		},
		
		bind_event: function(selector, name, func, event) {
			var funcs = this.store[name] || (this.store[name] = $.entwine.RuleList()) ;
			var proxies = funcs.proxies || (funcs.proxies = {});
			
			var rule = funcs.addRule(selector, name); rule.func = func;
			
			if (!proxies[name]) {
				switch (name) {
					case 'onmouseenter':
						proxies[name] = this.build_mouseenterleave_proxy(name);
						event = 'mouseover';
						break;
					case 'onmouseleave':
						proxies[name] = this.build_mouseenterleave_proxy(name);
						event = 'mouseout';
						break;
					case 'onchange':
						if (!$.support.changeBubbles) {
							proxies[name] = this.build_change_proxy(name);
							event = 'click keydown focusin focusout beforeactivate beforedeactivate';
						}
						break;
					case 'onsubmit':
						event = 'delegatedSubmit';
						break;
					case 'onfocus':
					case 'onblur':
						$.entwine.warn('Event '+event+' not supported - using focusin / focusout instead', $.entwine.WARN_LEVEL_IMPORTANT);
				}
				
				// If none of the special handlers created a proxy, use the generic proxy
				if (!proxies[name]) proxies[name] = this.build_event_proxy(name);

				$(document).bind(event.replace(/(\s+|$)/g, '.entwine$1'), proxies[name]);
			}
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 40,
		
		bind: function(selector, k, v){
			var match, event;
			if ($.isFunction(v) && (match = k.match(/^on(.*)/))) {
				event = match[1];
				this.bind_event(selector, k, v, event);
				return true;
			}
		}
	});
	
	// Find all forms and bind onsubmit to trigger on the document too. 
	// This is the only event that can't be grabbed via delegation
	
	var delegate_submit = function(e, data){
		var delegationEvent = $.Event('delegatedSubmit'); delegationEvent.delegatedEvent = e;
		return $(document).trigger(delegationEvent, data); 
	};

	$(document).bind('EntwineElementsAdded', function(e){
		var forms = $(e.targets).filter('form');
		if (!forms.length) return;

		forms.bind('submit.entwine_delegate_submit', delegate_submit);
	});

})(jQuery);
	;


/* src/jquery.entwine.eventcapture.js */

(function($) {

	$.entwine.Namespace.addMethods({
		bind_capture: function(selector, event, name, capture) {
			var store  = this.captures || (this.captures = {});
			var rulelists = store[event] || (store[event] = {});
			var rulelist = rulelists[name] || (rulelists[name] = $.entwine.RuleList());

			var rule = rulelist.addRule(selector, event);
			rule.handler = name;

			this.bind_proxy(selector, name, capture);
		}
	});

	var bindings = $.entwine.capture_bindings = {};

	var event_proxy = function(event) {
		return function(e) {
			var namespace, capturelists, forevent, capturelist, rule, handler, sel;

			for (var k in $.entwine.namespaces) {
				namespace = $.entwine.namespaces[k];
				capturelists = namespace.captures;

				if (capturelists && (forevent = capturelists[event])) {
					for (var k in forevent) {
						var capturelist = forevent[k];
						var triggered = namespace.$([]);

						// Stepping through each selector from most to least specific
						var j = capturelist.length;
						while (j--) {
							rule = capturelist[j];
							handler = rule.handler;
							sel = rule.selector.selector;

							var matching = namespace.$(sel).not(triggered);
							matching[handler].apply(matching, arguments);

							triggered = triggered.add(matching);
						}
					}
				}
			}
		}
	};

	var selector_proxy = function(selector, handler, includechildren) {
		var matcher = $.selector(selector);
		return function(e){
			if (matcher.matches(e.target)) return handler.apply(this, arguments);
		}
	};

	var document_proxy = function(selector, handler, includechildren) {
		return function(e){
			if (e.target === document) return handler.apply(this, arguments);
		}
	};

	var window_proxy = function(selector, handler, includechildren) {
		return function(e){
			if (e.target === window) return handler.apply(this, arguments);
		}
	};

	var property_proxy = function(property, handler, includechildren) {
		var matcher;

		return function(e){
			var match = this['get'+property]();

			if (typeof(match) == 'string') {
				var matcher = (matcher && match == matcher.selector) ? matcher : $.selector(match);
				if (matcher.matches(e.target)) return handler.apply(this, arguments);
			}
			else {
				if ($.inArray(e.target, match) !== -1) return handler.apply(this, arguments);
			}
		}
	};

	$.entwine.Namespace.addHandler({
		order: 10,

		bind: function(selector, k, v) {
			var match;
			if ($.isPlainObject(v) && (match = k.match(/^from\s*(.*)/))) {
				var from = match[1];
				var proxyGen;

				if (from.match(/[^\w]/)) proxyGen = selector_proxy;
				else if (from == 'Window' || from == 'window') proxyGen = window_proxy;
				else if (from == 'Document' || from == 'document') proxyGen = document_proxy;
				else proxyGen = property_proxy;

				for (var onevent in v) {
					var handler = v[onevent];
					match = onevent.match(/^on(.*)/);
					var event = match[1];

					this.bind_capture(selector, event, k + '_' + event, proxyGen(from, handler));

					if (!bindings[event]) {
						var namespaced = event.replace(/(\s+|$)/g, '.entwine$1');
						bindings[event] = event_proxy(event);

						$(proxyGen == window_proxy ? window : document).bind(namespaced, bindings[event]);
					}
				}

				return true;
			}
		}
	});

})(jQuery);
;


/* src/jquery.entwine.ctors.js */

(function($) {	

	/* Add the methods to handle constructor & destructor binding to the Namespace class */
	$.entwine.Namespace.addMethods({
		bind_condesc: function(selector, name, func) {
			var ctors = this.store.ctors || (this.store.ctors = $.entwine.RuleList()) ;
			
			var rule;
			for (var i = 0 ; i < ctors.length; i++) {
				if (ctors[i].selector.selector == selector.selector) {
					rule = ctors[i]; break;
				}
			}
			if (!rule) {
				rule = ctors.addRule(selector, 'ctors');
			}
			
			rule[name] = func;
			
			if (!ctors[name+'proxy']) {
				var one = this.one('ctors', name);
				var namespace = this;
				
				var proxy = function(els, i, func) {
					var j = els.length;
					while (j--) {
						var el = els[j];
						
						var tmp_i = el.i, tmp_f = el.f;
						el.i = i; el.f = one;
						
						try      { func.call(namespace.$(el)); }
						catch(e) { $.entwine.warn_exception(name, el, e); } 
						finally  { el.i = tmp_i; el.f = tmp_f; }					
					}
				};
				
				ctors[name+'proxy'] = proxy;
			}
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 30,
		
		bind: function(selector, k, v) {
			if ($.isFunction(v) && (k == 'onmatch' || k == 'onunmatch')) {
				// When we add new matchers we need to trigger a full global recalc once, regardless of the DOM changes that triggered the event
				this.matchersDirty = true;

				this.bind_condesc(selector, k, v);
				return true;
			}
		}
	});

	/**
	 * Finds all the elements that now match a different rule (or have been removed) and call onmatch on onunmatch as appropriate
	 * 
	 * Because this has to scan the DOM, and is therefore fairly slow, this is normally triggered off a short timeout, so that
	 * a series of DOM manipulations will only trigger this once.
	 * 
	 * The downside of this is that things like:
	 *   $('#foo').addClass('tabs'); $('#foo').tabFunctionBar();
	 * won't work.
	 */
	$(document).bind('EntwineSubtreeMaybeChanged', function(e, changes){
		// var start = (new Date).getTime();

		// For every namespace
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];

			// That has constructors or destructors
			var ctors = namespace.store.ctors;
			if (ctors) {
			
				// Keep a record of elements that have matched some previous more specific rule.
				// Not that we _don't_ actually do that until this is needed. If matched is null, it's not been calculated yet.
				// We also keep track of any elements that have newly been taken or released by a specific rule
				var matched = null, taken = $([]), released = $([]);

				// Updates matched to contain all the previously matched elements as if we'd been keeping track all along
				var calcmatched = function(j){
					if (matched !== null) return;
					matched = $([]);

					var cache, k = ctors.length;
					while ((--k) > j) {
						if (cache = ctors[k].cache) matched = matched.add(cache);
					}
				}

				// Some declared variables used in the loop
				var add, rem, res, rule, sel, ctor, dtor, full;

				// Stepping through each selector from most to least specific
				var j = ctors.length;
				while (j--) {
					// Build some quick-access variables
					rule = ctors[j];
					sel = rule.selector.selector;
					ctor = rule.onmatch; 
					dtor = rule.onunmatch;

					/*
						Rule.cache might be stale or fresh. It'll be stale if
					   - some more specific selector now has some of rule.cache in it
						- some change has happened that means new elements match this selector now
						- some change has happened that means elements no longer match this selector

						The first we can just compare rules.cache with matched, removing anything that's there already.
					*/

					// Reset the "elements that match this selector and no more specific selector with an onmatch rule" to null.
					// Staying null means this selector is fresh.
					res = null;

					// If this gets changed to true, it's too hard to do a delta update, so do a full update
					full = false;

					if (namespace.matchersDirty || changes.global) {
						// For now, just fall back to old version. We need to do something like changed.Subtree.find('*').andSelf().filter(sel), but that's _way_ slower on modern browsers than the below
						full = true;
					}
					else {
						// We don't deal with attributes yet, so any attribute change means we need to do a full recalc
						for (var k in changes.attrs) {	full = true; break; }

						/*
						 If a class changes, but it isn't listed in our selector, we don't care - the change couldn't affect whether or not any element matches

						 If it is listed on our selector
							- If it is on the direct match part, it could have added or removed the node it changed on
							- If it is on the context part, it could have added or removed any node that were previously included or excluded because of a match or failure to match with the context required on that node
							- NOTE: It might be on _both_
						 */

						var method = rule.selector.affectedBy(changes);

						if (method.classes.context) {
							full = true;
						}
						else {
							for (var k in method.classes.direct) {
								calcmatched(j);
								var recheck = changes.classes[k].not(matched);

								if (res === null) {
									res = rule.cache ? rule.cache.not(taken).add(released.filter(sel)) : $([]);
								}

								res = res.not(recheck).add(recheck.filter(sel));
							}
						}
					}

					if (full) {
						calcmatched(j);
						res = $(sel).not(matched);
					}
					else {
						if (!res) {
							// We weren't stale because of any changes to the DOM that affected this selector, but more specific
							// onmatches might have caused stale-ness

							// Do any of the previous released elements match this selector?
							add = released.length && released.filter(sel);

							if (add && add.length) {
								// Yes, so we're stale as we need to include them. Filter for any possible taken value at the same time
								res = rule.cache ? rule.cache.not(taken).add(add) : add;
							}
							else {
								// Do we think we own any of the elements now taken by more specific rules?
								rem = taken.length && rule.cache && rule.cache.filter(taken);

								if (rem && rem.length) {
									// Yes, so we're stale as we need to exclude them.
									res = rule.cache.not(rem);
								}
							}
						}
					}

					// Res will be null if we know we are fresh (no full needed, selector not affectedBy changes)
					if (res === null) {
						// If we are tracking matched, add ourselves
						if (matched && rule.cache) matched = matched.add(rule.cache);
					}
					else {
						// If this selector has a list of elements it matched against last time
						if (rule.cache) {
							// Find the ones that are extra this time
							add = res.not(rule.cache);
							rem = rule.cache.not(res);
						}
						else {
							add = res; rem = null;
						}

						if ((add && add.length) || (rem && rem.length)) {
							if (rem && rem.length) {
								released = released.add(rem);

								if (dtor && !rule.onunmatchRunning) {
									rule.onunmatchRunning = true;
									ctors.onunmatchproxy(rem, j, dtor);
									rule.onunmatchRunning = false;
								}
							}

							// Call the constructor on the newly matched ones
							if (add && add.length) {
								taken = taken.add(add);
								released = released.not(add);

								if (ctor && !rule.onmatchRunning) {
									rule.onmatchRunning = true;
									ctors.onmatchproxy(add, j, ctor);
									rule.onmatchRunning = false;
								}
							}
						}

						// If we are tracking matched, add ourselves
						if (matched) matched = matched.add(res);

						// And remember this list of matching elements again this selector, so next matching we can find the unmatched ones
						rule.cache = res;
					}
				}

				namespace.matchersDirty = false;
			}
		}

		// console.log((new Date).getTime() - start);
	});
	

})(jQuery);
;


/* src/jquery.entwine.addrem.js */

(function($) {

	$.entwine.Namespace.addMethods({
		build_addrem_proxy: function(name) {
			var one = this.one(name, 'func');

			return function() {
				if (this.length === 0){
					return;
				}
				else if (this.length) {
					var rv, i = this.length;
					while (i--) rv = one(this[i], arguments);
					return rv;
				}
				else {
					return one(this, arguments);
				}
			};
		},

		bind_addrem_proxy: function(selector, name, func) {
			var rulelist = this.store[name] || (this.store[name] = $.entwine.RuleList());

			var rule = rulelist.addRule(selector, name); rule.func = func;

			if (!this.injectee.hasOwnProperty(name)) {
				this.injectee[name] = this.build_addrem_proxy(name);
				this.injectee[name].isentwinemethod = true;
			}
		}
	});

	$.entwine.Namespace.addHandler({
		order: 30,

		bind: function(selector, k, v) {
			if ($.isFunction(v) && (k == 'onadd' || k == 'onremove')) {
				this.bind_addrem_proxy(selector, k, v);
				return true;
			}
		}
	});

	$(document).bind('EntwineElementsAdded', function(e){
		// For every namespace
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];
			if (namespace.injectee.onadd) namespace.injectee.onadd.call(e.targets);
		}
	});

	$(document).bind('EntwineElementsRemoved', function(e){
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];
			if (namespace.injectee.onremove) namespace.injectee.onremove.call(e.targets);
		}
	});




})(jQuery);
;


/* src/jquery.entwine.properties.js */

(function($) {	

	var entwine_prepend = '__entwine!';
	
	var getEntwineData = function(el, namespace, property) {
		return el.data(entwine_prepend + namespace + '!' + property);
	};
	
	var setEntwineData = function(el, namespace, property, value) {
		return el.data(entwine_prepend + namespace + '!' + property, value);
	};
	
	var getEntwineDataAsHash = function(el, namespace) {
		var hash = {};
		var id = jQuery.data(el[0]);
		
		var matchstr = entwine_prepend + namespace + '!';
		var matchlen = matchstr.length;
		
		var cache = jQuery.cache[id];
		for (var k in cache) {
			if (k.substr(0,matchlen) == matchstr) hash[k.substr(matchlen)] = cache[k];
		}
		
		return hash;
	};
	
	var setEntwineDataFromHash = function(el, namespace, hash) {
		for (var k in hash) setEntwineData(namespace, k, hash[k]);
	};

	var entwineData = function(el, namespace, args) {
		switch (args.length) {
			case 0:
				return getEntwineDataAsHash(el, namespace);
			case 1:
				if (typeof args[0] == 'string') return getEntwineData(el, namespace, args[0]);
				else                            return setEntwineDataFromHash(el, namespace, args[0]);
			default:
				return setEntwineData(el, namespace, args[0], args[1]);
		}
	};
 
	$.extend($.fn, {
		entwineData: function() {
			return entwineData(this, '__base', arguments);
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 60,
		
		bind: function(selector, k, v) {
			if (k.charAt(0) != k.charAt(0).toUpperCase()) $.entwine.warn('Entwine property '+k+' does not start with a capital letter', $.entwine.WARN_LEVEL_BESTPRACTISE);

			// Create the getters and setters

			var getterName = 'get'+k;
			var setterName = 'set'+k;

			this.bind_proxy(selector, getterName, function() { var r = this.entwineData(k); return r === undefined ? v : r; });
			this.bind_proxy(selector, setterName, function(v){ return this.entwineData(k, v); });
			
			// Get the get and set proxies we just created
			
			var getter = this.injectee[getterName];
			var setter = this.injectee[setterName];
			
			// And bind in the jQuery-style accessor
			
			this.bind_proxy(selector, k, function(v){ return (arguments.length == 1 ? setter : getter).call(this, v) ; });

			return true;
		},
		
		namespaceMethodOverrides: function(namespace){
			return {
				entwineData: function() {
					return entwineData(this, namespace.name, arguments);
				}
			};
		}
	});
	
})(jQuery);
;


/* src/jquery.entwine.legacy.js */

(function($) {	
	
	// Adds back concrete methods for backwards compatibility
	$.concrete = $.entwine;
	$.fn.concrete = $.fn.entwine;
	$.fn.concreteData = $.fn.entwineData;
	
	// Use addHandler to hack in the namespace.$.concrete equivilent to the namespace.$.entwine namespace-injection
	$.entwine.Namespace.addHandler({
		order: 100,
		bind: function(selector, k, v) { return false; },
	
		namespaceMethodOverrides: function(namespace){
			namespace.$.concrete = namespace.$.entwine;
			namespace.injectee.concrete = namespace.injectee.entwine;
			namespace.injectee.concreteData = namespace.injectee.entwineData;
			return {};
		}
	});

})(jQuery);
;


},{}],21:[function(require,module,exports){
/*!
 * jQuery Form Plugin
 * version: 2.96 (16-FEB-2012)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *	http://www.opensource.org/licenses/mit-license.php
 *	http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
	Usage Note:
	-----------
	Do not use both ajaxSubmit and ajaxForm on the same form.  These
	functions are mutually exclusive.  Use ajaxSubmit if you want
	to bind your own submit handler to the form.  For example,

	$(document).ready(function() {
		$('#myForm').bind('submit', function(e) {
			e.preventDefault(); // <-- important
			$(this).ajaxSubmit({
				target: '#output'
			});
		});
	});

	Use ajaxForm when you want the plugin to manage all the event binding
	for you.  For example,

	$(document).ready(function() {
		$('#myForm').ajaxForm({
			target: '#output'
		});
	});
	
	You can also use ajaxForm with delegation (requires jQuery v1.7+), so the
	form does not have to exist when you invoke ajaxForm:

	$('#myForm').ajaxForm({
		delegation: true,
		target: '#output'
	});
	
	When using ajaxForm, the ajaxSubmit function will be invoked for you
	at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
	if (!this.length) {
		log('ajaxSubmit: skipping submit process - no element selected');
		return this;
	}
	
	var method, action, url, $form = this;

	if (typeof options == 'function') {
		options = { success: options };
	}

	method = this.attr('method');
	action = this.attr('action');
	url = (typeof action === 'string') ? $.trim(action) : '';
	url = url || window.location.href || '';
	if (url) {
		// clean url (don't include hash vaue)
		url = (url.match(/^([^#]+)/)||[])[1];
	}

	options = $.extend(true, {
		url:  url,
		success: $.ajaxSettings.success,
		type: method || 'GET',
		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
	}, options);

	// hook for manipulating the form data before it is extracted;
	// convenient for use with rich editors like tinyMCE or FCKEditor
	var veto = {};
	this.trigger('form-pre-serialize', [this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
		return this;
	}

	// provide opportunity to alter form data before it is serialized
	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSerialize callback');
		return this;
	}

	var traditional = options.traditional;
	if ( traditional === undefined ) {
		traditional = $.ajaxSettings.traditional;
	}
	
	var qx,n,v,a = this.formToArray(options.semantic);
	if (options.data) {
		options.extraData = options.data;
		qx = $.param(options.data, traditional);
	}

	// give pre-submit callback an opportunity to abort the submit
	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSubmit callback');
		return this;
	}

	// fire vetoable 'validate' event
	this.trigger('form-submit-validate', [a, this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
		return this;
	}

	var q = $.param(a, traditional);
	if (qx) {
		q = ( q ? (q + '&' + qx) : qx );
	}	
	if (options.type.toUpperCase() == 'GET') {
		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
		options.data = null;  // data is null for 'get'
	}
	else {
		options.data = q; // data is the query string for 'post'
	}

	var callbacks = [];
	if (options.resetForm) {
		callbacks.push(function() { $form.resetForm(); });
	}
	if (options.clearForm) {
		callbacks.push(function() { $form.clearForm(options.includeHidden); });
	}

	// perform a load on the target only if dataType is not provided
	if (!options.dataType && options.target) {
		var oldSuccess = options.success || function(){};
		callbacks.push(function(data) {
			var fn = options.replaceTarget ? 'replaceWith' : 'html';
			$(options.target)[fn](data).each(oldSuccess, arguments);
		});
	}
	else if (options.success) {
		callbacks.push(options.success);
	}

	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
		var context = options.context || options;	// jQuery 1.4+ supports scope context 
		for (var i=0, max=callbacks.length; i < max; i++) {
			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
		}
	};

	// are there files to upload?
	var fileInputs = $('input:file:enabled[value]', this); // [value] (issue #113)
	var hasFileInputs = fileInputs.length > 0;
	var mp = 'multipart/form-data';
	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

	var fileAPI = !!(hasFileInputs && fileInputs.get(0).files && window.FormData);
	log("fileAPI :" + fileAPI);
	var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;

	// options.iframe allows user to force iframe mode
	// 06-NOV-09: now defaulting to iframe mode if file input is detected
	if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
		// hack to fix Safari hang (thanks to Tim Molendijk for this)
		// see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
		if (options.closeKeepAlive) {
			$.get(options.closeKeepAlive, function() {
				fileUploadIframe(a);
			});
		}
  		else {
			fileUploadIframe(a);
  		}
	}
	else if ((hasFileInputs || multipart) && fileAPI) {
		options.progress = options.progress || $.noop;
		fileUploadXhr(a);
	}
	else {
		$.ajax(options);
	}

	 // fire 'notify' event
	 this.trigger('form-submit-notify', [this, options]);
	 return this;

	 // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
	function fileUploadXhr(a) {
		var formdata = new FormData();

		for (var i=0; i < a.length; i++) {
			if (a[i].type == 'file')
				continue;
			formdata.append(a[i].name, a[i].value);
		}

		$form.find('input:file:enabled').each(function(){
			var name = $(this).attr('name'), files = this.files;
			if (name) {
				for (var i=0; i < files.length; i++)
					formdata.append(name, files[i]);
			}
		});

		if (options.extraData) {
			for (var k in options.extraData)
				formdata.append(k, options.extraData[k])
		}

		options.data = null;

		var s = $.extend(true, {}, $.ajaxSettings, options, {
			contentType: false,
			processData: false,
			cache: false,
			type: 'POST'
		});

      //s.context = s.context || s;

      s.data = null;
      var beforeSend = s.beforeSend;
      s.beforeSend = function(xhr, o) {
          o.data = formdata;
          if(xhr.upload) { // unfortunately, jQuery doesn't expose this prop (http://bugs.jquery.com/ticket/10190)
              xhr.upload.onprogress = function(event) {
                  o.progress(event.position, event.total);
              };
          }
          if(beforeSend)
              beforeSend.call(o, xhr, options);
      };
      $.ajax(s);
   }

	// private function for handling file uploads (hat tip to YAHOO!)
	function fileUploadIframe(a) {
		var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
		var useProp = !!$.fn.prop;

		if (a) {
			if ( useProp ) {
				// ensure that every serialized input is still enabled
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.prop('disabled', false);
				}
			} else {
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.removeAttr('disabled');
				}
			};
		}

		if ($(':input[name=submit],:input[id=submit]', form).length) {
			// if there is an input with a name or id of 'submit' then we won't be
			// able to invoke the submit fn on the form (at least not x-browser)
			alert('Error: Form elements must not have name or id of "submit".');
			return;
		}
		
		s = $.extend(true, {}, $.ajaxSettings, options);
		s.context = s.context || s;
		id = 'jqFormIO' + (new Date().getTime());
		if (s.iframeTarget) {
			$io = $(s.iframeTarget);
			n = $io.attr('name');
			if (n == null)
			 	$io.attr('name', id);
			else
				id = n;
		}
		else {
			$io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
			$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
		}
		io = $io[0];


		xhr = { // mock object
			aborted: 0,
			responseText: null,
			responseXML: null,
			status: 0,
			statusText: 'n/a',
			getAllResponseHeaders: function() {},
			getResponseHeader: function() {},
			setRequestHeader: function() {},
			abort: function(status) {
				var e = (status === 'timeout' ? 'timeout' : 'aborted');
				log('aborting upload... ' + e);
				this.aborted = 1;
				$io.attr('src', s.iframeSrc); // abort op in progress
				xhr.error = e;
				s.error && s.error.call(s.context, xhr, e, status);
				g && $.event.trigger("ajaxError", [xhr, s, e]);
				s.complete && s.complete.call(s.context, xhr, e);
			}
		};

		g = s.global;
		// trigger ajax global events so that activity/block indicators work like normal
		if (g && ! $.active++) {
			$.event.trigger("ajaxStart");
		}
		if (g) {
			$.event.trigger("ajaxSend", [xhr, s]);
		}

		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
			if (s.global) {
				$.active--;
			}
			return;
		}
		if (xhr.aborted) {
			return;
		}

		// add submitting element to data if we know it
		sub = form.clk;
		if (sub) {
			n = sub.name;
			if (n && !sub.disabled) {
				s.extraData = s.extraData || {};
				s.extraData[n] = sub.value;
				if (sub.type == "image") {
					s.extraData[n+'.x'] = form.clk_x;
					s.extraData[n+'.y'] = form.clk_y;
				}
			}
		}
		
		var CLIENT_TIMEOUT_ABORT = 1;
		var SERVER_ABORT = 2;

		function getDoc(frame) {
			var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
			return doc;
		}
		
		// Rails CSRF hack (thanks to Yvan Barthelemy)
		var csrf_token = $('meta[name=csrf-token]').attr('content');
		var csrf_param = $('meta[name=csrf-param]').attr('content');
		if (csrf_param && csrf_token) {
			s.extraData = s.extraData || {};
			s.extraData[csrf_param] = csrf_token;
		}

		// take a breath so that pending repaints get some cpu time before the upload starts
		function doSubmit() {
			// make sure form attrs are set
			var t = $form.attr('target'), a = $form.attr('action');

			// update form attrs in IE friendly way
			form.setAttribute('target',id);
			if (!method) {
				form.setAttribute('method', 'POST');
			}
			if (a != s.url) {
				form.setAttribute('action', s.url);
			}

			// ie borks in some cases when setting encoding
			if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
				$form.attr({
					encoding: 'multipart/form-data',
					enctype:  'multipart/form-data'
				});
			}

			// support timout
			if (s.timeout) {
				timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
			}
			
			// look for server aborts
			function checkState() {
				try {
					var state = getDoc(io).readyState;
					log('state = ' + state);
					if (state.toLowerCase() == 'uninitialized')
						setTimeout(checkState,50);
				}
				catch(e) {
					log('Server abort: ' , e, ' (', e.name, ')');
					cb(SERVER_ABORT);
					timeoutHandle && clearTimeout(timeoutHandle);
					timeoutHandle = undefined;
				}
			}

			// add "extra" data to form if provided in options
			var extraInputs = [];
			try {
				if (s.extraData) {
					for (var n in s.extraData) {
						extraInputs.push(
							$('<input type="hidden" name="'+n+'">').attr('value',s.extraData[n])
								.appendTo(form)[0]);
					}
				}

				if (!s.iframeTarget) {
					// add iframe to doc and submit the form
					$io.appendTo('body');
					io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
				}
				setTimeout(checkState,15);
				form.submit();
			}
			finally {
				// reset attrs and remove "extra" input elements
				form.setAttribute('action',a);
				if(t) {
					form.setAttribute('target', t);
				} else {
					$form.removeAttr('target');
				}
				$(extraInputs).remove();
			}
		}

		if (s.forceSync) {
			doSubmit();
		}
		else {
			setTimeout(doSubmit, 10); // this lets dom updates render
		}

		var data, doc, domCheckCount = 50, callbackProcessed;

		function cb(e) {
			if (xhr.aborted || callbackProcessed) {
				return;
			}
			try {
				doc = getDoc(io);
			}
			catch(ex) {
				log('cannot access response document: ', ex);
				e = SERVER_ABORT;
			}
			if (e === CLIENT_TIMEOUT_ABORT && xhr) {
				xhr.abort('timeout');
				return;
			}
			else if (e == SERVER_ABORT && xhr) {
				xhr.abort('server abort');
				return;
			}

			if (!doc || doc.location.href == s.iframeSrc) {
				// response not received yet
				if (!timedOut)
					return;
			}
			io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

			var status = 'success', errMsg;
			try {
				if (timedOut) {
					throw 'timeout';
				}

				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
				log('isXml='+isXml);
				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
					if (--domCheckCount) {
						// in some browsers (Opera) the iframe DOM is not always traversable when
						// the onload callback fires, so we loop a bit to accommodate
						log('requeing onLoad callback, DOM not available');
						setTimeout(cb, 250);
						return;
					}
					// let this fall through because server response could be an empty document
					//log('Could not access iframe DOM after mutiple tries.');
					//throw 'DOMException: not available';
				}

				//log('response detected');
				var docRoot = doc.body ? doc.body : doc.documentElement;
				xhr.responseText = docRoot ? docRoot.innerHTML : null;
				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
				if (isXml)
					s.dataType = 'xml';
				xhr.getResponseHeader = function(header){
					var headers = {'content-type': s.dataType};
					return headers[header];
				};
				// support for XHR 'status' & 'statusText' emulation :
				if (docRoot) {
					xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
					xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
				}

				var dt = (s.dataType || '').toLowerCase();
				var scr = /(json|script|text)/.test(dt);
				if (scr || s.textarea) {
					// see if user embedded response in textarea
					var ta = doc.getElementsByTagName('textarea')[0];
					if (ta) {
						xhr.responseText = ta.value;
						// support for XHR 'status' & 'statusText' emulation :
						xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
						xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
					}
					else if (scr) {
						// account for browsers injecting pre around json response
						var pre = doc.getElementsByTagName('pre')[0];
						var b = doc.getElementsByTagName('body')[0];
						if (pre) {
							xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
						}
						else if (b) {
							xhr.responseText = b.textContent ? b.textContent : b.innerText;
						}
					}
				}
				else if (dt == 'xml' && !xhr.responseXML && xhr.responseText != null) {
					xhr.responseXML = toXml(xhr.responseText);
				}

				try {
					data = httpData(xhr, dt, s);
				}
				catch (e) {
					status = 'parsererror';
					xhr.error = errMsg = (e || status);
				}
			}
			catch (e) {
				log('error caught: ',e);
				status = 'error';
				xhr.error = errMsg = (e || status);
			}

			if (xhr.aborted) {
				log('upload aborted');
				status = null;
			}

			if (xhr.status) { // we've set xhr.status
				status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
			}

			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
			if (status === 'success') {
				s.success && s.success.call(s.context, data, 'success', xhr);
				g && $.event.trigger("ajaxSuccess", [xhr, s]);
			}
			else if (status) {
				if (errMsg == undefined)
					errMsg = xhr.statusText;
				s.error && s.error.call(s.context, xhr, status, errMsg);
				g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
			}

			g && $.event.trigger("ajaxComplete", [xhr, s]);

			if (g && ! --$.active) {
				$.event.trigger("ajaxStop");
			}

			s.complete && s.complete.call(s.context, xhr, status);

			callbackProcessed = true;
			if (s.timeout)
				clearTimeout(timeoutHandle);

			// clean up
			setTimeout(function() {
				if (!s.iframeTarget)
					$io.remove();
				xhr.responseXML = null;
			}, 100);
		}

		var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
			if (window.ActiveXObject) {
				doc = new ActiveXObject('Microsoft.XMLDOM');
				doc.async = 'false';
				doc.loadXML(s);
			}
			else {
				doc = (new DOMParser()).parseFromString(s, 'text/xml');
			}
			return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
		};
		var parseJSON = $.parseJSON || function(s) {
			return window['eval']('(' + s + ')');
		};

		var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

			var ct = xhr.getResponseHeader('content-type') || '',
				xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
				data = xml ? xhr.responseXML : xhr.responseText;

			if (xml && data.documentElement.nodeName === 'parsererror') {
				$.error && $.error('parsererror');
			}
			if (s && s.dataFilter) {
				data = s.dataFilter(data, type);
			}
			if (typeof data === 'string') {
				if (type === 'json' || !type && ct.indexOf('json') >= 0) {
					data = parseJSON(data);
				} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
					$.globalEval(data);
				}
			}
			return data;
		};
	}
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *	is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *	used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
	options = options || {};
	options.delegation = options.delegation && $.isFunction($.fn.on);
	
	// in jQuery 1.3+ we can fix mistakes with the ready state
	if (!options.delegation && this.length === 0) {
		var o = { s: this.selector, c: this.context };
		if (!$.isReady && o.s) {
			log('DOM not ready, queuing ajaxForm');
			$(function() {
				$(o.s,o.c).ajaxForm(options);
			});
			return this;
		}
		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
		return this;
	}

	if ( options.delegation ) {
		$(document)
			.off('submit.form-plugin', this.selector, doAjaxSubmit)
			.off('click.form-plugin', this.selector, captureSubmittingElement)
			.on('submit.form-plugin', this.selector, options, doAjaxSubmit)
			.on('click.form-plugin', this.selector, options, captureSubmittingElement);
		return this;
	}

	return this.ajaxFormUnbind()
		.bind('submit.form-plugin', options, doAjaxSubmit)
		.bind('click.form-plugin', options, captureSubmittingElement);
};

// private event handlers	
function doAjaxSubmit(e) {
	var options = e.data;
	if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
		e.preventDefault();
		$(this).ajaxSubmit(options);
	}
}
	
function captureSubmittingElement(e) {
	var target = e.target;
	var $el = $(target);
	if (!($el.is(":submit,input:image"))) {
		// is this a child element of the submit el?  (ex: a span within a button)
		var t = $el.closest(':submit');
		if (t.length == 0) {
			return;
		}
		target = t[0];
	}
	var form = this;
	form.clk = target;
	if (target.type == 'image') {
		if (e.offsetX != undefined) {
			form.clk_x = e.offsetX;
			form.clk_y = e.offsetY;
		} else if (typeof $.fn.offset == 'function') {
			var offset = $el.offset();
			form.clk_x = e.pageX - offset.left;
			form.clk_y = e.pageY - offset.top;
		} else {
			form.clk_x = e.pageX - target.offsetLeft;
			form.clk_y = e.pageY - target.offsetTop;
		}
	}
	// clear form vars
	setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
};


// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
	return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
	var a = [];
	if (this.length === 0) {
		return a;
	}

	var form = this[0];
	var els = semantic ? form.getElementsByTagName('*') : form.elements;
	if (!els) {
		return a;
	}

	var i,j,n,v,el,max,jmax;
	for(i=0, max=els.length; i < max; i++) {
		el = els[i];
		n = el.name;
		if (!n) {
			continue;
		}

		if (semantic && form.clk && el.type == "image") {
			// handle image inputs on the fly when semantic == true
			if(!el.disabled && form.clk == el) {
				a.push({name: n, value: $(el).val(), type: el.type });
				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
			}
			continue;
		}

		v = $.fieldValue(el, true);
		if (v && v.constructor == Array) {
			for(j=0, jmax=v.length; j < jmax; j++) {
				a.push({name: n, value: v[j]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: n, value: v, type: el.type});
		}
	}

	if (!semantic && form.clk) {
		// input type=='image' are not found in elements array! handle it here
		var $input = $(form.clk), input = $input[0];
		n = input.name;
		if (n && !input.disabled && input.type == 'image') {
			a.push({name: n, value: $input.val()});
			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
		}
	}
	return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
	//hand off to jQuery.param for proper encoding
	return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
	var a = [];
	this.each(function() {
		var n = this.name;
		if (!n) {
			return;
		}
		var v = $.fieldValue(this, successful);
		if (v && v.constructor == Array) {
			for (var i=0,max=v.length; i < max; i++) {
				a.push({name: n, value: v[i]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: this.name, value: v});
		}
	});
	//hand off to jQuery.param for proper encoding
	return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *	  <input name="A" type="text" />
 *	  <input name="A" type="text" />
 *	  <input name="B" type="checkbox" value="B1" />
 *	  <input name="B" type="checkbox" value="B2"/>
 *	  <input name="C" type="radio" value="C1" />
 *	  <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *	array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
	for (var val=[], i=0, max=this.length; i < max; i++) {
		var el = this[i];
		var v = $.fieldValue(el, successful);
		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
			continue;
		}
		v.constructor == Array ? $.merge(val, v) : val.push(v);
	}
	return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
	if (successful === undefined) {
		successful = true;
	}

	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
		(t == 'checkbox' || t == 'radio') && !el.checked ||
		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
		tag == 'select' && el.selectedIndex == -1)) {
			return null;
	}

	if (tag == 'select') {
		var index = el.selectedIndex;
		if (index < 0) {
			return null;
		}
		var a = [], ops = el.options;
		var one = (t == 'select-one');
		var max = (one ? index+1 : ops.length);
		for(var i=(one ? index : 0); i < max; i++) {
			var op = ops[i];
			if (op.selected) {
				var v = op.value;
				if (!v) { // extra pain for IE...
					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
				}
				if (one) {
					return v;
				}
				a.push(v);
			}
		}
		return a;
	}
	return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function(includeHidden) {
	return this.each(function() {
		$('input,select,textarea', this).clearFields(includeHidden);
	});
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
	var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
	return this.each(function() {
		var t = this.type, tag = this.tagName.toLowerCase();
		if (re.test(t) || tag == 'textarea' || (includeHidden && /hidden/.test(t)) ) {
			this.value = '';
		}
		else if (t == 'checkbox' || t == 'radio') {
			this.checked = false;
		}
		else if (tag == 'select') {
			this.selectedIndex = -1;
		}
	});
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
	return this.each(function() {
		// guard against an input with the name of 'reset'
		// note that IE reports the reset function as an 'object'
		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
			this.reset();
		}
	});
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
	if (b === undefined) {
		b = true;
	}
	return this.each(function() {
		this.disabled = !b;
	});
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
	if (select === undefined) {
		select = true;
	}
	return this.each(function() {
		var t = this.type;
		if (t == 'checkbox' || t == 'radio') {
			this.checked = select;
		}
		else if (this.tagName.toLowerCase() == 'option') {
			var $sel = $(this).parent('select');
			if (select && $sel[0] && $sel[0].type == 'select-one') {
				// deselect all other options
				$sel.find('option').selected(false);
			}
			this.selected = select;
		}
	});
};

// expose debug var
$.fn.ajaxSubmit.debug = false;

// helper fn for console logging
function log() {
	if (!$.fn.ajaxSubmit.debug) 
		return;
	var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
	else if (window.opera && window.opera.postError) {
		window.opera.postError(msg);
	}
};

})(jQuery);
},{}],22:[function(require,module,exports){
/**
 * On-demand JavaScript handler
 *
 * Based on http://plugins.jquery.com/files/issues/jquery.ondemand.js_.txt
 * and heavily modified to integrate with SilverStripe and prototype.js.
 * Adds capabilities for custom X-Include-CSS and X-Include-JS HTTP headers
 * to request loading of externals alongside an ajax response.
 *
 * Requires jQuery 1.5 ($.Deferred support)
 *
 * CAUTION: Relies on customization of the 'beforeSend' callback in jQuery.ajaxSetup()
 *
 * @author Ingo Schommer (ingo at silverstripe dot com)
 * @author Sam Minnee (sam at silverstripe dot com)
 */
(function($){

	var decodePath = function(str) {
		return str.replace(/%2C/g,',').replace(/\&amp;/g, '&').replace(/^\s+|\s+$/g, '');
	};

	$.extend({

		// loaded files list - to protect against loading existed file again  (by PGA)
		_ondemand_loaded_list : null,

		/**
		 * Returns true if the given CSS or JS script has already been loaded
		 */
		isItemLoaded : function(scriptUrl) {
			var self = this, src;
			if(this._ondemand_loaded_list === null) {
				this._ondemand_loaded_list = {};
				$('script').each(function() {
					src = $(this).attr('src');
					if(src) self._ondemand_loaded_list[src] = 1;
				});
				$('link[rel="stylesheet"]').each(function() {
					src = $(this).attr('href');
					if(src) self._ondemand_loaded_list[src] = 1;
				});
			}
			return (this._ondemand_loaded_list[decodePath(scriptUrl)] !== undefined);
		},

		requireCss : function(styleUrl, media){
			if(!media) media = 'all';

			// Don't double up on loading scripts
			if($.isItemLoaded(styleUrl)) return;

			if(document.createStyleSheet){
				var ss = document.createStyleSheet(styleUrl);
				ss.media = media;

			} else {
				var styleTag = document.createElement('link');
				$(styleTag).attr({
					href	: styleUrl,
					type	: 'text/css',
					media 	: media,
					rel		: 'stylesheet'
				}).appendTo($('head').get(0));
			}

			this._ondemand_loaded_list[styleUrl] = 1;

		},

		/**
		 * Process the X-Include-CSS and X-Include-JS headers provided by the Requirements class
		 */
		processOnDemandHeaders: function(xml, status, xhr) {
			var self = this, processDfd = new $.Deferred();

			// CSS
			if(xhr.getResponseHeader && xhr.getResponseHeader('X-Include-CSS')) {
				var cssIncludes = xhr.getResponseHeader('X-Include-CSS').split(',');
				for(var i=0;i<cssIncludes.length;i++) {
					// Syntax: "URL:##:media"
					if(cssIncludes[i].match(/^(.*):##:(.*)$/)) {
						$.requireCss(decodePath(RegExp.$1), RegExp.$2);
					// Syntax: "URL"
					} else {
						$.requireCss(decodePath(cssIncludes[i]));
					}
				}
			}

			// JavaScript
			var newJsIncludes = [];
			if(xhr.getResponseHeader && xhr.getResponseHeader('X-Include-JS')) {
				var jsIncludes = xhr.getResponseHeader('X-Include-JS').split(',');
				for(var i=0;i<jsIncludes.length;i++) {
					var jsIncludePath = decodePath(jsIncludes[i]);
					if(!$.isItemLoaded(jsIncludePath)) {
						newJsIncludes.push(jsIncludePath);
					}
				}
			}

			// We make an array of the includes that are actually new, and attach the callback to the last one
			// They are placed in a queue and will be included in order.  This means that the callback will
			// be able to execute script in the new includes (such as a livequery update)
			var getScriptQueue = function() {
				if(newJsIncludes.length) {
					var newJsInclude = newJsIncludes.shift();
					// emulates getScript() with addtl. setting
					$.ajax({
						dataType: 'script',
						url: newJsInclude,
						success: function() {
							self._ondemand_loaded_list[newJsInclude] = 1;
							getScriptQueue();
						},
						cache: false,
						// jQuery seems to override the XHR objects if used in async mode
						async: false
					});
				} else {
					processDfd.resolve(xml, status, xhr);
				}
			}

			if(newJsIncludes.length) {
				getScriptQueue();
			} else {
				// If there aren't any new includes, then we can just call the callbacks ourselves
				processDfd.resolve(xml, status, xhr);
			}

			return processDfd.promise();
		}

	});

	$.ajaxSetup({
		// beforeSend is the only place to access the XHR object before success handlers are added
		beforeSend: function(jqXHR, s) {
			// Avoid recursion in ajax callbacks caused by getScript(), by not parsing
			// ondemand headers for 'script' datatypes
			if(s.dataType == 'script') return;

			var dfd = new $.Deferred();

			// Register our own success handler (assumes no handlers are already registered)
			// 'success' is an alias for 'done', which is executed by the built-in deferred instance in $.ajax()
			jqXHR.success(function(success, statusText, jXHR) {
				$.processOnDemandHeaders(success, statusText, jXHR).done(function() {
					dfd.resolveWith(s.context || this, [success, statusText, jXHR]);
				});
			});

			// Reroute all external success hanlders through our own deferred.
			// Not overloading fail() as no event can cause the original request to fail.
			jqXHR.success = function(callback) {
				dfd.done(callback);
			}
		}
	});


})(jQuery);

},{}],23:[function(require,module,exports){
/**
 * jQuery.query - Query String Modification and Creation for jQuery
 * Written by Blair Mitchelmore (blair DOT mitchelmore AT gmail DOT com)
 * Licensed under the WTFPL (http://sam.zoy.org/wtfpl/).
 * Date: 2009/8/13
 *
 * @author Blair Mitchelmore
 * @version 2.1.7
 *
 **/
new function(settings) { 
  // Various Settings
  var $separator = settings.separator || '&';
  var $spaces = settings.spaces === false ? false : true;
  var $suffix = settings.suffix === false ? '' : '[]';
  var $prefix = settings.prefix === false ? false : true;
  var $hash = $prefix ? settings.hash === true ? "#" : "?" : "";
  var $numbers = settings.numbers === false ? false : true;
  
  jQuery.query = new function() {
    var is = function(o, t) {
      return o != undefined && o !== null && (!!t ? o.constructor == t : true);
    };
    var parse = function(path) {
      var m, rx = /\[([^[]*)\]/g, match = /^([^[]+)(\[.*\])?$/.exec(path), base = match[1], tokens = [];
      while (m = rx.exec(match[2])) tokens.push(m[1]);
      return [base, tokens];
    };
    var set = function(target, tokens, value) {
      var o, token = tokens.shift();
      if (typeof target != 'object') target = null;
      if (token === "") {
        if (!target) target = [];
        if (is(target, Array)) {
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        } else if (is(target, Object)) {
          var i = 0;
          while (target[i++] != null);
          target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value);
        } else {
          target = [];
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        }
      } else if (token && token.match(/^\s*[0-9]+\s*$/)) {
        var index = parseInt(token, 10);
        if (!target) target = [];
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else if (token) {
        var index = token.replace(/^\s*|\s*$/g, "");
        if (!target) target = {};
        if (is(target, Array)) {
          var temp = {};
          for (var i = 0; i < target.length; ++i) {
            temp[i] = target[i];
          }
          target = temp;
        }
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else {
        return value;
      }
      return target;
    };
    
    var queryObject = function(a) {
      var self = this;
      self.keys = {};
      
      if (a.queryObject) {
        jQuery.each(a.get(), function(key, val) {
          self.SET(key, val);
        });
      } else {
        jQuery.each(arguments, function() {
          var q = "" + this;
          q = q.replace(/^[?#]/,''); // remove any leading ? || #
          q = q.replace(/[;&]$/,''); // remove any trailing & || ;
          if ($spaces) q = q.replace(/[+]/g,' '); // replace +'s with spaces
          
          jQuery.each(q.split(/[&;]/), function(){
            var key = decodeURIComponent(this.split('=')[0] || "");
            var val = decodeURIComponent(this.split('=')[1] || "");
            
            if (!key) return;
            
            if ($numbers) {
              if (/^[+-]?[0-9]+\.[0-9]*$/.test(val)) // simple float regex
                val = parseFloat(val);
              else if (/^[+-]?[0-9]+$/.test(val)) // simple int regex
                val = parseInt(val, 10);
            }
            
            val = (!val && val !== 0) ? true : val;
            
            if (val !== false && val !== true && typeof val != 'number')
              val = val;
            
            self.SET(key, val);
          });
        });
      }
      return self;
    };
    
    queryObject.prototype = {
      queryObject: true,
      has: function(key, type) {
        var value = this.get(key);
        return is(value, type);
      },
      GET: function(key) {
        if (!is(key)) return this.keys;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        while (target != null && tokens.length != 0) {
          target = target[tokens.shift()];
        }
        return typeof target == 'number' ? target : target || "";
      },
      get: function(key) {
        var target = this.GET(key);
        if (is(target, Object))
          return jQuery.extend(true, {}, target);
        else if (is(target, Array))
          return target.slice(0);
        return target;
      },
      SET: function(key, val) {
        var value = !is(val) ? null : val;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        this.keys[base] = set(target, tokens.slice(0), value);
        return this;
      },
      set: function(key, val) {
        return this.copy().SET(key, val);
      },
      REMOVE: function(key) {
        return this.SET(key, null).COMPACT();
      },
      remove: function(key) {
        return this.copy().REMOVE(key);
      },
      EMPTY: function() {
        var self = this;
        jQuery.each(self.keys, function(key, value) {
          delete self.keys[key];
        });
        return self;
      },
      load: function(url) {
        var hash = url.replace(/^.*?[#](.+?)(?:\?.+)?$/, "$1");
        var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, "$1");
        return new queryObject(url.length == search.length ? '' : search, url.length == hash.length ? '' : hash);
      },
      empty: function() {
        return this.copy().EMPTY();
      },
      copy: function() {
        return new queryObject(this);
      },
      COMPACT: function() {
        function build(orig) {
          var obj = typeof orig == "object" ? is(orig, Array) ? [] : {} : orig;
          if (typeof orig == 'object') {
            function add(o, key, value) {
              if (is(o, Array))
                o.push(value);
              else
                o[key] = value;
            }
            jQuery.each(orig, function(key, value) {
              if (!is(value)) return true;
              add(obj, key, build(value));
            });
          }
          return obj;
        }
        this.keys = build(this.keys);
        return this;
      },
      compact: function() {
        return this.copy().COMPACT();
      },
      toString: function() {
        var i = 0, queryString = [], chunks = [], self = this;
        var encode = function(str) {
          str = str + "";
          if ($spaces) str = str.replace(/ /g, "+");
          return encodeURIComponent(str);
        };
        var addFields = function(arr, key, value) {
          if (!is(value) || value === false) return;
          var o = [encode(key)];
          if (value !== true) {
            o.push("=");
            o.push(encode(value));
          }
          arr.push(o.join(""));
        };
        var build = function(obj, base) {
          var newKey = function(key) {
            return !base || base == "" ? [key].join("") : [base, "[", key, "]"].join("");
          };
          jQuery.each(obj, function(key, value) {
            if (typeof value == 'object') 
              build(value, newKey(key));
            else
              addFields(chunks, newKey(key), value);
          });
        };
        
        build(this.keys);
        
        if (chunks.length > 0) queryString.push($hash);
        queryString.push(chunks.join($separator));
        
        return queryString.join("");
      }
    };
    
    return new queryObject(location.search, location.hash);
  };
}(jQuery.query || {}); // Pass in jQuery.query as settings object
},{}],24:[function(require,module,exports){
/*! jQuery UI - v1.9.2 - 2012-11-23
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.progressbar.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.slider.js, jquery.ui.sortable.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.9.2",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().andSelf().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the element to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated

(function() {
	var uaMatch = /msie ([\w.]+)/.exec( navigator.userAgent.toLowerCase() ) || [];
	$.ui.ie = uaMatch.length ? true : false;
	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;
})();

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		// TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			// 1.9 BC for #7810
			// TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.9.2",
	options: {
		cancel: 'input,textarea,button,select,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
					$.removeData(event.target, that.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}
function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: 0, left: 0 };
	} else if ( $.isWindow( targetElem ) ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		targetOffset = target.offset();
	}
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// offset option
	(function( $ ) {
		var _position = $.fn.position;
		$.fn.position = function( options ) {
			if ( !options || !options.offset ) {
				return _position.call( this, options );
			}
			var offset = options.offset.split( " " ),
				at = options.at.split( " " );
			if ( offset.length === 1 ) {
				offset[ 1 ] = offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 0 ] ) ) {
				offset[ 0 ] = "+" + offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 1 ] ) ) {
				offset[ 1 ] = "+" + offset[ 1 ];
			}
			if ( at.length === 1 ) {
				if ( /left|center|right/.test( at[ 0 ] ) ) {
					at[ 1 ] = "center";
				} else {
					at[ 1 ] = at[ 0 ];
					at[ 0 ] = "center";
				}
			}
			return _position.call( this, $.extend( options, {
				at: at[ 0 ] + offset[ 0 ] + " " + at[ 1 ] + offset[ 1 ],
				offset: undefined
			} ) );
		};
	}( jQuery ) );
}

}( jQuery ) );
(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = "show";

$.widget( "ui.accordion", {
	version: "1.9.2",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var accordionId = this.accordionId = "ui-accordion-" +
				(this.element.attr( "id" ) || ++uid),
			options = this.options;

		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" );

		this.headers = this.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
		this._hoverable( this.headers );
		this._focusable( this.headers );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.hide();

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active" )
			.toggleClass( "ui-corner-all ui-corner-top" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this._createIcons();
		this.refresh();

		// ARIA
		this.element.attr( "role", "tablist" );

		this.headers
			.attr( "role", "tab" )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( "id" ),
					panel = header.next(),
					panelId = panel.attr( "id" );
				if ( !headerId ) {
					headerId = accordionId + "-header-" + i;
					header.attr( "id", headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + "-panel-" + i;
					panel.attr( "id", panelId );
				}
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}

		this._on( this.headers, { keydown: "_keydown" });
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._setupEvents( options.event );
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var maxHeight, overflow,
			heightStyle = this.options.heightStyle,
			parent = this.element.parent();


		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( !event ) {
			return;
		}
		$.each( event.split(" "), function( index, eventName ) {
			events[ eventName ] = "_eventHandler";
		});
		this._on( this.headers, events );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			})
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( "activate", null, data );
	}
});



// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// navigation options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			navigation: false,
			navigationFilter: function() {
				return this.href.toLowerCase() === location.href.toLowerCase();
			}
		});

		var _create = prototype._create;
		prototype._create = function() {
			if ( this.options.navigation ) {
				var that = this,
					headers = this.element.find( this.options.header ),
					content = headers.next(),
					current = headers.add( content )
						.find( "a" )
						.filter( this.options.navigationFilter )
						[ 0 ];
				if ( current ) {
					headers.add( content ).each( function( index ) {
						if ( $.contains( this, current ) ) {
							that.options.active = Math.floor( index / 2 );
							return false;
						}
					});
				}
			}
			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// height options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			heightStyle: null, // remove default so we fall back to old values
			autoHeight: true, // use heightStyle: "auto"
			clearStyle: false, // use heightStyle: "content"
			fillSpace: false // use heightStyle: "fill"
		});

		var _create = prototype._create,
			_setOption = prototype._setOption;

		$.extend( prototype, {
			_create: function() {
				this.options.heightStyle = this.options.heightStyle ||
					this._mergeHeightStyle();

				_create.call( this );
			},

			_setOption: function( key ) {
				if ( key === "autoHeight" || key === "clearStyle" || key === "fillSpace" ) {
					this.options.heightStyle = this._mergeHeightStyle();
				}
				_setOption.apply( this, arguments );
			},

			_mergeHeightStyle: function() {
				var options = this.options;

				if ( options.fillSpace ) {
					return "fill";
				}

				if ( options.clearStyle ) {
					return "content";
				}

				if ( options.autoHeight ) {
					return "auto";
				}
			}
		});
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// icon options
	(function( $, prototype ) {
		$.extend( prototype.options.icons, {
			activeHeader: null, // remove default so we fall back to old values
			headerSelected: "ui-icon-triangle-1-s"
		});

		var _createIcons = prototype._createIcons;
		prototype._createIcons = function() {
			if ( this.options.icons ) {
				this.options.icons.activeHeader = this.options.icons.activeHeader ||
					this.options.icons.headerSelected;
			}
			_createIcons.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// expanded active option, activate method
	(function( $, prototype ) {
		prototype.activate = prototype._activate;

		var _findActive = prototype._findActive;
		prototype._findActive = function( index ) {
			if ( index === -1 ) {
				index = false;
			}
			if ( index && typeof index !== "number" ) {
				index = this.headers.index( this.headers.filter( index ) );
				if ( index === -1 ) {
					index = false;
				}
			}
			return _findActive.call( this, index );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// resize method
	jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh;

	// change events
	(function( $, prototype ) {
		$.extend( prototype.options, {
			change: null,
			changestart: null
		});

		var _trigger = prototype._trigger;
		prototype._trigger = function( type, event, data ) {
			var ret = _trigger.apply( this, arguments );
			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				ret = _trigger.call( this, "changestart", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			} else if ( type === "activate" ) {
				ret = _trigger.call( this, "change", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			}
			return ret;
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// animated option
	// NOTE: this only provides support for "slide", "bounceslide", and easings
	// not the full $.ui.accordion.animations API
	(function( $, prototype ) {
		$.extend( prototype.options, {
			animate: null,
			animated: "slide"
		});

		var _create = prototype._create;
		prototype._create = function() {
			var options = this.options;
			if ( options.animate === null ) {
				if ( !options.animated ) {
					options.animate = false;
				} else if ( options.animated === "slide" ) {
					options.animate = 300;
				} else if ( options.animated === "bounceslide" ) {
					options.animate = {
						duration: 200,
						down: {
							easing: "easeOutBounce",
							duration: 1000
						}
					};
				} else {
					options.animate = options.animated;
				}
			}

			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );
}

})( jQuery );
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	version: "1.9.2",
	defaultElement: "<input>",
	options: {
		appendTo: "body",
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

		this.isMultiLine = this._isMultiLine();
		this.valueMethod = this.element[ this.element.is( "input,textarea" ) ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( this.document.find( this.options.appendTo || "body" )[ 0 ] )
			.menu({
				// custom key handling for now
				input: $(),
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.zIndex( this.element.zIndex() + 1 )
			.hide()
			.data( "menu" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// #7024 - Prevent accidental activation of menu items in Firefox
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item's value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn't
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "polite"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.insertAfter( this.element );

		if ( $.fn.bgiframe ) {
			this.menu.element.bgiframe();
		}

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this.document.find( value || "body" )[0] );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isMultiLine: function() {
		// Textareas are always multi-line
		if ( this.element.is( "textarea" ) ) {
			return true;
		}
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		if ( this.element.is( "input" ) ) {
			return false;
		}
		// All other element types are determined by whether or not they're contentEditable
		return this.element.prop( "isContentEditable" );
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( "ui-autocomplete-loading" );
			}
		};
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});


}( jQuery ));
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.9.2",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "",
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", that.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.9.2",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.9.2" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' +
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   If false returned from beforeShow event handler do not show.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			//false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
		while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
		}
		var position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			var extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, 'stepMonths');
		var id = '#' + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find('[data-handler]').map(function () {
			var handler = {
				prev: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, -stepMonths, 'M');
				},
				next: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, +stepMonths, 'M');
				},
				hide: function () {
					window['DP_jQuery_' + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window['DP_jQuery_' + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
					return false;
				},
				selectMonth: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'M');
					return false;
				},
				selectYear: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'Y');
					return false;
				}
			};
			$(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' +
			this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' data-handler="selectDay" data-event="click" data-month="' + printDate.getMonth() + '" data-year="' + printDate.getFullYear() + '"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' +
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.ui.ie6 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.delegate(selector, 'mouseout', function() {
			$(this).removeClass('ui-state-hover');
			if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).removeClass('ui-datepicker-prev-hover');
			if (this.className.indexOf('ui-datepicker-next') != -1) $(this).removeClass('ui-datepicker-next-hover');
		})
		.delegate(selector, 'mouseover', function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
				$(this).addClass('ui-state-hover');
				if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).addClass('ui-datepicker-prev-hover');
				if (this.className.indexOf('ui-datepicker-next') != -1) $(this).addClass('ui-datepicker-next-hover');
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
	                Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(document.body).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.9.2";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
(function( $, undefined ) {

var uiDialogClasses = "ui-dialog ui-widget ui-widget-content ui-corner-all ",
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget("ui.dialog", {
	version: "1.9.2",
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: "close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// ensure that the titlebar is never outside the document
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: "",
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr( "title" );
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}
		this.oldPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.options.title = this.options.title || this.originalTitle;
		var that = this,
			options = this.options,

			title = options.title || "&#160;",
			uiDialog,
			uiDialogTitlebar,
			uiDialogTitlebarClose,
			uiDialogTitle,
			uiDialogButtonPane;

			uiDialog = ( this.uiDialog = $( "<div>" ) )
				.addClass( uiDialogClasses + options.dialogClass )
				.css({
					display: "none",
					outline: 0, // TODO: move to stylesheet
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				.attr( "tabIndex", -1)
				.keydown(function( event ) {
					if ( options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						that.close( event );
						event.preventDefault();
					}
				})
				.mousedown(function( event ) {
					that.moveToTop( false, event );
				})
				.appendTo( "body" );

			this.element
				.show()
				.removeAttr( "title" )
				.addClass( "ui-dialog-content ui-widget-content" )
				.appendTo( uiDialog );

			uiDialogTitlebar = ( this.uiDialogTitlebar = $( "<div>" ) )
				.addClass( "ui-dialog-titlebar  ui-widget-header  " +
					"ui-corner-all  ui-helper-clearfix" )
				.bind( "mousedown", function() {
					// Dialog isn't getting focus when dragging (#8063)
					uiDialog.focus();
				})
				.prependTo( uiDialog );

			uiDialogTitlebarClose = $( "<a href='#'></a>" )
				.addClass( "ui-dialog-titlebar-close  ui-corner-all" )
				.attr( "role", "button" )
				.click(function( event ) {
					event.preventDefault();
					that.close( event );
				})
				.appendTo( uiDialogTitlebar );

			( this.uiDialogTitlebarCloseText = $( "<span>" ) )
				.addClass( "ui-icon ui-icon-closethick" )
				.text( options.closeText )
				.appendTo( uiDialogTitlebarClose );

			uiDialogTitle = $( "<span>" )
				.uniqueId()
				.addClass( "ui-dialog-title" )
				.html( title )
				.prependTo( uiDialogTitlebar );

			uiDialogButtonPane = ( this.uiDialogButtonPane = $( "<div>" ) )
				.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );

			( this.uiButtonSet = $( "<div>" ) )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		uiDialog.attr({
			role: "dialog",
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});

		uiDialogTitlebar.find( "*" ).add( uiDialogTitlebar ).disableSelection();
		this._hoverable( uiDialogTitlebarClose );
		this._focusable( uiDialogTitlebarClose );

		if ( options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._createButtons( options.buttons );
		this._isOpen = false;

		if ( $.fn.bgiframe ) {
			uiDialog.bgiframe();
		}

		// prevent tabbing out of modal dialogs
		this._on( uiDialog, { keydown: function( event ) {
			if ( !options.modal || event.keyCode !== $.ui.keyCode.TAB ) {
				return;
			}

			var tabbables = $( ":tabbable", uiDialog ),
				first = tabbables.filter( ":first" ),
				last  = tabbables.filter( ":last" );

			if ( event.target === last[0] && !event.shiftKey ) {
				first.focus( 1 );
				return false;
			} else if ( event.target === first[0] && event.shiftKey ) {
				last.focus( 1 );
				return false;
			}
		}});
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_destroy: function() {
		var next,
			oldPosition = this.oldPosition;

		if ( this.overlay ) {
			this.overlay.destroy();
		}
		this.uiDialog.hide();
		this.element
			.removeClass( "ui-dialog-content ui-widget-content" )
			.hide()
			.appendTo( "body" );
		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = oldPosition.parent.children().eq( oldPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			oldPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function( event ) {
		var that = this,
			maxZ, thisZ;

		if ( !this._isOpen ) {
			return;
		}

		if ( false === this._trigger( "beforeClose", event ) ) {
			return;
		}

		this._isOpen = false;

		if ( this.overlay ) {
			this.overlay.destroy();
		}

		if ( this.options.hide ) {
			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( "close", event );
			});
		} else {
			this.uiDialog.hide();
			this._trigger( "close", event );
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if ( this.options.modal ) {
			maxZ = 0;
			$( ".ui-dialog" ).each(function() {
				if ( this !== that.uiDialog[0] ) {
					thisZ = $( this ).css( "z-index" );
					if ( !isNaN( thisZ ) ) {
						maxZ = Math.max( maxZ, thisZ );
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return this;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function( force, event ) {
		var options = this.options,
			saveScroll;

		if ( ( options.modal && !force ) ||
				( !options.stack && !options.modal ) ) {
			return this._trigger( "focus", event );
		}

		if ( options.zIndex > $.ui.dialog.maxZ ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if ( this.overlay ) {
			$.ui.dialog.maxZ += 1;
			$.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ;
			this.overlay.$el.css( "z-index", $.ui.dialog.overlay.maxZ );
		}

		// Save and then restore scroll
		// Opera 9.5+ resets when parent z-index is changed.
		// http://bugs.jqueryui.com/ticket/3193
		saveScroll = {
			scrollTop: this.element.scrollTop(),
			scrollLeft: this.element.scrollLeft()
		};
		$.ui.dialog.maxZ += 1;
		this.uiDialog.css( "z-index", $.ui.dialog.maxZ );
		this.element.attr( saveScroll );
		this._trigger( "focus", event );

		return this;
	},

	open: function() {
		if ( this._isOpen ) {
			return;
		}

		var hasFocus,
			options = this.options,
			uiDialog = this.uiDialog;

		this._size();
		this._position( options.position );
		uiDialog.show( options.show );
		this.overlay = options.modal ? new $.ui.dialog.overlay( this ) : null;
		this.moveToTop( true );

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		hasFocus = this.element.find( ":tabbable" );
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
			if ( !hasFocus.length ) {
				hasFocus = uiDialog;
			}
		}
		hasFocus.eq( 0 ).focus();

		this._isOpen = true;
		this._trigger( "open" );

		return this;
	},

	_createButtons: function( buttons ) {
		var that = this,
			hasButtons = false;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( typeof buttons === "object" && buttons !== null ) {
			$.each( buttons, function() {
				return !(hasButtons = true);
			});
		}
		if ( hasButtons ) {
			$.each( buttons, function( name, props ) {
				var button, click;
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				// Default to a non-submitting button
				props = $.extend( { type: "button" }, props );
				// Change the context for the click callback to be the main element
				click = props.click;
				props.click = function() {
					click.apply( that.element[0], arguments );
				};
				button = $( "<button></button>", props )
					.appendTo( that.uiButtonSet );
				if ( $.fn.button ) {
					button.button();
				}
			});
			this.uiDialog.addClass( "ui-dialog-buttons" );
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		} else {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
		}
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this )
					.addClass( "ui-dialog-dragging" );
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this )
					.removeClass( "ui-dialog-dragging" );
				that._trigger( "dragStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function( handles ) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var that = this,
			options = this.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === 'string' ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				$( this ).removeClass( "ui-dialog-resizing" );
				options.height = $( this ).height();
				options.width = $( this ).width();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		})
		.css( "position", position )
		.find( ".ui-resizable-se" )
			.addClass( "ui-icon ui-icon-grip-diagonal-se" );
	},

	_minHeight: function() {
		var options = this.options;

		if ( options.height === "auto" ) {
			return options.minHeight;
		} else {
			return Math.min( options.minHeight, options.height );
		}
	},

	_position: function( position ) {
		var myAt = [],
			offset = [ 0, 0 ],
			isVisible;

		if ( position ) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
				myAt = position.split ? position.split( " " ) : [ position[ 0 ], position[ 1 ] ];
				if ( myAt.length === 1 ) {
					myAt[ 1 ] = myAt[ 0 ];
				}

				$.each( [ "left", "top" ], function( i, offsetPosition ) {
					if ( +myAt[ i ] === myAt[ i ] ) {
						offset[ i ] = myAt[ i ];
						myAt[ i ] = offsetPosition;
					}
				});

				position = {
					my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
						myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
					at: myAt.join( " " )
				};
			}

			position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		switch ( key ) {
			case "buttons":
				this._createButtons( value );
				break;
			case "closeText":
				// ensure that we always pass a string
				this.uiDialogTitlebarCloseText.text( "" + value );
				break;
			case "dialogClass":
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( uiDialogClasses + value );
				break;
			case "disabled":
				if ( value ) {
					uiDialog.addClass( "ui-dialog-disabled" );
				} else {
					uiDialog.removeClass( "ui-dialog-disabled" );
				}
				break;
			case "draggable":
				isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}

				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
				break;
			case "position":
				this._position( value );
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is( ":data(resizable)" );
				if ( isResizable && !value ) {
					uiDialog.resizable( "destroy" );
				}

				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}

				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable( value );
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$( ".ui-dialog-title", this.uiDialogTitlebar )
					.html( "" + ( value || "&#160;" ) );
				break;
		}

		this._super( key, value );
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var nonContentHeight, minContentHeight, autoHeight,
			options = this.options,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );

		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	}
});

$.extend($.ui.dialog, {
	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr( "id" );
		if ( !id ) {
			this.uuid += 1;
			id = this.uuid;
		}
		return "ui-dialog-title-" + id;
	},

	overlay: function( dialog ) {
		this.$el = $.ui.dialog.overlay.create( dialog );
	}
});

$.extend( $.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(
		"focus,mousedown,mouseup,keydown,keypress,click".split( "," ),
		function( event ) {
			return event + ".dialog-overlay";
		}
	).join( " " ),
	create: function( dialog ) {
		if ( this.instances.length === 0 ) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ( $.ui.dialog.overlay.instances.length ) {
					$( document ).bind( $.ui.dialog.overlay.events, function( event ) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ( $( event.target ).zIndex() < $.ui.dialog.overlay.maxZ ) {
							return false;
						}
					});
				}
			}, 1 );

			// handle window resize
			$( window ).bind( "resize.dialog-overlay", $.ui.dialog.overlay.resize );
		}

		var $el = ( this.oldInstances.pop() || $( "<div>" ).addClass( "ui-widget-overlay" ) );

		// allow closing by pressing the escape key
		$( document ).bind( "keydown.dialog-overlay", function( event ) {
			var instances = $.ui.dialog.overlay.instances;
			// only react to the event if we're the top overlay
			if ( instances.length !== 0 && instances[ instances.length - 1 ] === $el &&
				dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
				event.keyCode === $.ui.keyCode.ESCAPE ) {

				dialog.close( event );
				event.preventDefault();
			}
		});

		$el.appendTo( document.body ).css({
			width: this.width(),
			height: this.height()
		});

		if ( $.fn.bgiframe ) {
			$el.bgiframe();
		}

		this.instances.push( $el );
		return $el;
	},

	destroy: function( $el ) {
		var indexOf = $.inArray( $el, this.instances ),
			maxZ = 0;

		if ( indexOf !== -1 ) {
			this.oldInstances.push( this.instances.splice( indexOf, 1 )[ 0 ] );
		}

		if ( this.instances.length === 0 ) {
			$( [ document, window ] ).unbind( ".dialog-overlay" );
		}

		$el.height( 0 ).width( 0 ).remove();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		$.each( this.instances, function() {
			maxZ = Math.max( maxZ, this.css( "z-index" ) );
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE
		if ( $.ui.ie ) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if ( scrollHeight < offsetHeight ) {
				return $( window ).height() + "px";
			} else {
				return scrollHeight + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).height() + "px";
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.ui.ie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if ( scrollWidth < offsetWidth ) {
				return $( window ).width() + "px";
			} else {
				return scrollWidth + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).width() + "px";
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $( [] );
		$.each( $.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add( this );
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend( $.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy( this.$el );
	}
});

}( jQuery ) );
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			var innermostIntersecting = false;
			var thisSortable = this;
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if  (this != thisSortable
						&& this.instance._intersectsWith(this.instance.containerCache)
						&& $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]))
						innermostIntersecting = false;
						return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);
(function( $, undefined ) {

$.widget("ui.droppable", {
	version: "1.9.2",
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				// find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(':data(droppable)').filter(function () {
					return $.data(this, 'droppable').options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && $.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = "";

			if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
					curElem = hook === "backgroundColor" ? elem.parentNode : elem;
					while (
						(backgroundColor === "" || backgroundColor === "transparent") &&
						curElem && curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, "backgroundColor" );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
						backgroundColor :
						"_default" );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	// webkit enumerates style porperties
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, '' );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.9.2",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat && $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod && backCompat && $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));
(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( '<div class="ui-effects-transfer"></div>' )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);
(function( $, undefined ) {

var mouseHandled = false;

$.widget( "ui.menu", {
	version: "1.9.2",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-state-disabled > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item:has(a)": function( event ) {
				var target = $( event.target ).closest( ".ui-menu-item" );
				if ( !mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					mouseHandled = true;

					this.select( event );
					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) ) {
						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( ".ui-menu" ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).andSelf()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.children( "a" )
				.removeUniqueId()
				.removeClass( "ui-corner-all ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
				return regex.test( $( this ).children( "a" ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.prev( "a" ),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );

		// Don't refresh list items that are already adapted
		menus.children( ":not(.ui-menu-item):has(a)" )
			.addClass( "ui-menu-item" )
			.attr( "role", "presentation" )
			.children( "a" )
				.uniqueId()
				.addClass( "ui-corner-all" )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( ":not(.ui-menu-item)" ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-\s]/.test( item.text() ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( "a" ).addClass( "ui-state-focus" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.children( "a:first" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( "a" ).removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( "a.ui-state-active" )
				.removeClass( "ui-state-active" );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.children( ".ui-menu-item" )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});

}( jQuery ));
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	version: "1.9.2",
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( "complete" );
			}
		}

		this._super( key, value );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value(),
			percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}

		this.valueDiv
			.toggle( value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

})( jQuery );
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var that = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css('position'),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css('top'),
				left: wrapper.css('left')
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		var cursor = $('.ui-resizable-' + this.axis).css('cursor');
		$('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			that = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, that = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) },
				left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
			if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
			if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
			if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6offset = ($.ui.ie6 ? 1 : 0),
			pxyoffset = ( $.ui.ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options, os = that.originalSize, op = that.originalPosition;

		var delta = {
			height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
			top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {},
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var pr = that._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
						soffsetw = ista ? 0 : that.sizeDiff.width;

		var style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
					left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
						top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css('width'), 10),
						height: parseInt(that.element.css('height'), 10),
						top: parseInt(that.element.css('top'), 10),
						left: parseInt(that.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, el = that.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = that.containerOffset, ch = that.containerSize.height,	cw = that.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options,
				ps = that.containerSize, co = that.containerOffset, cs = that.size, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		var woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width ),
					hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		var isParent = that.containerElement.get(0) == that.element.parent().get(0),
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= that.parentData.left;

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
		}
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options, cp = that.position,
				co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement;

		var helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (that._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var that = $(this).data("resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		that.ghost.appendTo(that.helper);

	},

	resize: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost) that.ghost.css({ position: 'relative', height: that.size.height, width: that.size.width });
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost && that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.left = op.left - ox;
		}
		else {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	version: "1.9.2",
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var that = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == that.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var i, handleCount,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		handleCount = ( o.values && o.values.length ) || 1;

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});

		this._on( this.handles, {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		});

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.prop( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.prop( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

}(jQuery));
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true

	},

	_destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData(this.widgetName + "-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget().toggleClass( "ui-sortable-disabled", !!value );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + '-item') == that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + '-item') == that) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, this._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) continue;

			if (itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var that = this;
			var cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] == item.item[0])
					return false;
			};
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var o = that.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop')||0, 10) - parseInt(that.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft')||0, 10) - parseInt(that.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {

		// get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) return;

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null;
			var posProperty = this.containers[innermostIndex].floating ? 'left' : 'top';
			var sizeProperty = this.containers[innermostIndex].floating ? 'width' : 'height';
			var base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (var j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				if(this.items[j].item[0] == this.currentItem[0]) continue;
				var cur = this.items[j].item.offset()[posProperty];
				var nearBottom = false;
				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? "up": "down";
				}
			}

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);
(function( $ ) {

function modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.9.2",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// format the value, but don't constrain
		this._value( this.element.val(), true );

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
				this.buttons.button( "disable" );
			} else {
				this.element.prop( "disabled", false );
				this.buttons.button( "enable" );
			}
		}
	},

	_setOptions: modifier(function( options ) {
		this._super( options );
		this._value( this.element.val() );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		this._spin( (steps || 1) * this.options.step );
	},

	stepDown: modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		this._spin( (steps || 1) * -this.options.step );
	},

	pageUp: modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}( jQuery ) );
(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length > 1 &&
		anchor.href.replace( rhash, "" ) ===
			location.href.replace( rhash, "" )
				// support: Safari 5.1
				// Safari 5.1 doesn't encode spaces in window.location
				// but it does encode spaces from anchors (#8777)
				.replace( /\s/g, "%20" );
}

$.widget( "ui.tabs", {
	version: "1.9.2",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options,
			active = options.active,
			locationHash = location.hash.substring( 1 );

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = options.collapsible ? false : 0;
			}
		}
		options.active = active;

		// don't allow collapsible: false and active: false
		if ( !options.collapsible && options.active === false && this.anchors.length ) {
			options.active = 0;
		}

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( this.options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight, overflow,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeData( "href.tabs" )
			.removeData( "load.tabs" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li.attr( "aria-controls", prev );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	// TODO: Remove this function in 1.10 when ajaxOptions is removed
	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// helper method for a lot of the back compat extensions
	$.ui.tabs.prototype._ui = function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	};

	// url method
	$.widget( "ui.tabs", $.ui.tabs, {
		url: function( index, url ) {
			this.anchors.eq( index ).attr( "href", url );
		}
	});

	// TODO: Remove _ajaxSettings() method when removing this extension
	// ajaxOptions and cache options
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			ajaxOptions: null,
			cache: false
		},

		_create: function() {
			this._super();

			var that = this;

			this._on({ tabsbeforeload: function( event, ui ) {
				// tab is already cached
				if ( $.data( ui.tab[ 0 ], "cache.tabs" ) ) {
					event.preventDefault();
					return;
				}

				ui.jqXHR.success(function() {
					if ( that.options.cache ) {
						$.data( ui.tab[ 0 ], "cache.tabs", true );
					}
				});
			}});
		},

		_ajaxSettings: function( anchor, event, ui ) {
			var ajaxOptions = this.options.ajaxOptions;
			return $.extend( {}, ajaxOptions, {
				error: function( xhr, status ) {
					try {
						// Passing index avoid a race condition when this method is
						// called after the user has selected another tab.
						// Pass the anchor that initiated this request allows
						// loadError to manipulate the tab content panel via $(a.hash)
						ajaxOptions.error(
							xhr, status, ui.tab.closest( "li" ).index(), ui.tab[ 0 ] );
					}
					catch ( error ) {}
				}
			}, this._superApply( arguments ) );
		},

		_setOption: function( key, value ) {
			// reset cache if switching from cached to not cached
			if ( key === "cache" && value === false ) {
				this.anchors.removeData( "cache.tabs" );
			}
			this._super( key, value );
		},

		_destroy: function() {
			this.anchors.removeData( "cache.tabs" );
			this._super();
		},

		url: function( index ){
			this.anchors.eq( index ).removeData( "cache.tabs" );
			this._superApply( arguments );
		}
	});

	// abort method
	$.widget( "ui.tabs", $.ui.tabs, {
		abort: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
		}
	});

	// spinner
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			spinner: "<em>Loading&#8230;</em>"
		},
		_create: function() {
			this._super();
			this._on({
				tabsbeforeload: function( event, ui ) {
					// Don't react to nested tabs or tabs that don't use a spinner
					if ( event.target !== this.element[ 0 ] ||
							!this.options.spinner ) {
						return;
					}

					var span = ui.tab.find( "span" ),
						html = span.html();
					span.html( this.options.spinner );
					ui.jqXHR.complete(function() {
						span.html( html );
					});
				}
			});
		}
	});

	// enable/disable events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			enable: null,
			disable: null
		},

		enable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === true ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) !== -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		},

		disable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === false ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) === -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		}
	});

	// add/remove methods and events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			add: null,
			remove: null,
			tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
		},

		add: function( url, label, index ) {
			if ( index === undefined ) {
				index = this.anchors.length;
			}

			var doInsertAfter, panel,
				options = this.options,
				li = $( options.tabTemplate
					.replace( /#\{href\}/g, url )
					.replace( /#\{label\}/g, label ) ),
				id = !url.indexOf( "#" ) ?
					url.replace( "#", "" ) :
					this._tabId( li );

			li.addClass( "ui-state-default ui-corner-top" ).data( "ui-tabs-destroy", true );
			li.attr( "aria-controls", id );

			doInsertAfter = index >= this.tabs.length;

			// try to find an existing element before creating a new one
			panel = this.element.find( "#" + id );
			if ( !panel.length ) {
				panel = this._createPanel( id );
				if ( doInsertAfter ) {
					if ( index > 0 ) {
						panel.insertAfter( this.panels.eq( -1 ) );
					} else {
						panel.appendTo( this.element );
					}
				} else {
					panel.insertBefore( this.panels[ index ] );
				}
			}
			panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" ).hide();

			if ( doInsertAfter ) {
				li.appendTo( this.tablist );
			} else {
				li.insertBefore( this.tabs[ index ] );
			}

			options.disabled = $.map( options.disabled, function( n ) {
				return n >= index ? ++n : n;
			});

			this.refresh();
			if ( this.tabs.length === 1 && options.active === false ) {
				this.option( "active", 0 );
			}

			this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			return this;
		},

		remove: function( index ) {
			index = this._getIndex( index );
			var options = this.options,
				tab = this.tabs.eq( index ).remove(),
				panel = this._getPanelForTab( tab ).remove();

			// If selected tab was removed focus tab to the right or
			// in case the last tab was removed the tab to the left.
			// We check for more than 2 tabs, because if there are only 2,
			// then when we remove this tab, there will only be one tab left
			// so we don't need to detect which tab to activate.
			if ( tab.hasClass( "ui-tabs-active" ) && this.anchors.length > 2 ) {
				this._activate( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
			}

			options.disabled = $.map(
				$.grep( options.disabled, function( n ) {
					return n !== index;
				}),
				function( n ) {
					return n >= index ? --n : n;
				});

			this.refresh();

			this._trigger( "remove", null, this._ui( tab.find( "a" )[ 0 ], panel[ 0 ] ) );
			return this;
		}
	});

	// length method
	$.widget( "ui.tabs", $.ui.tabs, {
		length: function() {
			return this.anchors.length;
		}
	});

	// panel ids (idPrefix option + title attribute)
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			idPrefix: "ui-tabs-"
		},

		_tabId: function( tab ) {
			var a = tab.is( "li" ) ? tab.find( "a[href]" ) : tab;
			a = a[0];
			return $( a ).closest( "li" ).attr( "aria-controls" ) ||
				a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF\-]/g, "" ) ||
				this.options.idPrefix + getNextTabId();
		}
	});

	// _createPanel method
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			panelTemplate: "<div></div>"
		},

		_createPanel: function( id ) {
			return $( this.options.panelTemplate )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		}
	});

	// selected option
	$.widget( "ui.tabs", $.ui.tabs, {
		_create: function() {
			var options = this.options;
			if ( options.active === null && options.selected !== undefined ) {
				options.active = options.selected === -1 ? false : options.selected;
			}
			this._super();
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_setOption: function( key, value ) {
			if ( key !== "selected" ) {
				return this._super( key, value );
			}

			var options = this.options;
			this._super( "active", value === -1 ? false : value );
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_eventHandler: function() {
			this._superApply( arguments );
			this.options.selected = this.options.active;
			if ( this.options.selected === false ) {
				this.options.selected = -1;
			}
		}
	});

	// show and select event
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			show: null,
			select: null
		},
		_create: function() {
			this._super();
			if ( this.options.active !== false ) {
				this._trigger( "show", null, this._ui(
					this.active.find( ".ui-tabs-anchor" )[ 0 ],
					this._getPanelForTab( this.active )[ 0 ] ) );
			}
		},
		_trigger: function( type, event, data ) {
			var tab, panel,
				ret = this._superApply( arguments );

			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				tab = data.newTab.length ? data.newTab : data.oldTab;
				panel = data.newPanel.length ? data.newPanel : data.oldPanel;
				ret = this._super( "select", event, {
					tab: tab.find( ".ui-tabs-anchor" )[ 0],
					panel: panel[ 0 ],
					index: tab.closest( "li" ).index()
				});
			} else if ( type === "activate" && data.newTab.length ) {
				ret = this._super( "show", event, {
					tab: data.newTab.find( ".ui-tabs-anchor" )[ 0 ],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( "li" ).index()
				});
			}
			return ret;
		}
	});

	// select method
	$.widget( "ui.tabs", $.ui.tabs, {
		select: function( index ) {
			index = this._getIndex( index );
			if ( index === -1 ) {
				if ( this.options.collapsible && this.options.selected !== -1 ) {
					index = this.options.selected;
				} else {
					return;
				}
			}
			this.anchors.eq( index ).trigger( this.options.event + this.eventNamespace );
		}
	});

	// cookie option
	(function() {

	var listId = 0;

	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			cookie: null // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		},
		_create: function() {
			var options = this.options,
				active;
			if ( options.active == null && options.cookie ) {
				active = parseInt( this._cookie(), 10 );
				if ( active === -1 ) {
					active = false;
				}
				options.active = active;
			}
			this._super();
		},
		_cookie: function( active ) {
			var cookie = [ this.cookie ||
				( this.cookie = this.options.cookie.name || "ui-tabs-" + (++listId) ) ];
			if ( arguments.length ) {
				cookie.push( active === false ? -1 : active );
				cookie.push( this.options.cookie );
			}
			return $.cookie.apply( null, cookie );
		},
		_refresh: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_eventHandler: function() {
			this._superApply( arguments );
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_destroy: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( null, this.options.cookie );
			}
		}
	});

	})();

	// load event
	$.widget( "ui.tabs", $.ui.tabs, {
		_trigger: function( type, event, data ) {
			var _data = $.extend( {}, data );
			if ( type === "load" ) {
				_data.panel = _data.panel[ 0 ];
				_data.tab = _data.tab.find( ".ui-tabs-anchor" )[ 0 ];
			}
			return this._super( type, event, _data );
		}
	});

	// fx option
	// The new animation options (show, hide) conflict with the old show callback.
	// The old fx option wins over show/hide anyway (always favor back-compat).
	// If a user wants to use the new animation API, they must give up the old API.
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			fx: null // e.g. { height: "toggle", opacity: "toggle", duration: 200 }
		},

		_getFx: function() {
			var hide, show,
				fx = this.options.fx;

			if ( fx ) {
				if ( $.isArray( fx ) ) {
					hide = fx[ 0 ];
					show = fx[ 1 ];
				} else {
					hide = show = fx;
				}
			}

			return fx ? { show: show, hide: hide } : null;
		},

		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel,
				fx = this._getFx();

			if ( !fx ) {
				return this._super( event, eventData );
			}

			that.running = true;

			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}

			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

				if ( toShow.length && fx.show ) {
					toShow
						.animate( fx.show, fx.show.duration, function() {
							complete();
						});
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length && fx.hide ) {
				toHide.animate( fx.hide, fx.hide.duration, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
		}
	});
}

})( jQuery );
(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
	var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
	describedby.push( id );
	elem
		.data( "ui-tooltip-id", id )
		.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
}

function removeDescribedBy( elem ) {
	var id = elem.data( "ui-tooltip-id" ),
		describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
		index = $.inArray( id, describedby );
	if ( index !== -1 ) {
		describedby.splice( index, 1 );
	}

	elem.removeData( "ui-tooltip-id" );
	describedby = $.trim( describedby.join( " " ) );
	if ( describedby ) {
		elem.attr( "aria-describedby", describedby );
	} else {
		elem.removeAttr( "aria-describedby" );
	}
}

$.widget( "ui.tooltip", {
	version: "1.9.2",
	options: {
		content: function() {
			return $( this ).attr( "title" );
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.attr( "title", "" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( "ui-tooltip-open" ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, events, delayedShow,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltip = this._tooltip( target );
		addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );

		events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			},
			remove: function() {
				this._removeTooltip( tooltip );
			}
		};
		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// only set title if we had one before (see comment in _open())
		if ( target.data( "ui-tooltip-title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );
		// Remove 'remove' binding only on delegated targets
		if ( target[0] !== this.element[0] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		this.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var id = "ui-tooltip-" + increments++,
			tooltip = $( "<div>" )
				.attr({
					id: id,
					role: "tooltip"
				})
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) );
		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );
		tooltip.appendTo( this.document[0].body );
		if ( $.fn.bgiframe ) {
			tooltip.bgiframe();
		}
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? $( "#" + id ) : $();
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
				element.removeData( "ui-tooltip-title" );
			}
		});
	}
});

}( jQuery ) );

},{}],25:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};

	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}

		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}

		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}

		body.removeChild( container );
		marginDiv = div = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process events on disabled elements (#6911, #8165)
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},
		
		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}


			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );

	// Clear flags for bubbling special change/submit events, they must
	// be reattached when the newly cloned events are first activated
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Clear elements from DocumentFragment (safeFragment or otherwise)
					// to avoid hoarding elements. Fixes #11356
					if ( div ) {
						div.parentNode.removeChild( div );

						// Guard against -1 index exceptions in FF3.6
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];

							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },

	// order is important!
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],

	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( rnumnonpx.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test(val) ) {
		return val;
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}

	return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},

		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {

	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};
});




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			// first pass over propertys to expand / normalize
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];

					// not quite $.extend, this wont overwrite keys already present.
					// also - reusing 'p' from above because we have the correct "name"
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}

			for ( name in prop ) {
				val = prop[ name ];
				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var elem = this[0],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return null;
	}

	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}

	return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;

			if ( jQuery.isWindow( elem ) ) {
				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}

			// Get document width or height
			if ( elem.nodeType === 9 ) {
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				doc = elem.documentElement;

				// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
				// instead we use the correct client[Width/Height]
				// support:IE6
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}

				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}

			// Get width or height on the element
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}

			// Set the width or height on the element
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );
},{}],26:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2009-06-29

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the object holding the key.

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON = JSON || {};

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

},{}],27:[function(require,module,exports){
/*
 * jsTree (custom version for SilverStripe: 1.0-rc3 + minor bugfixes)
 * http://jstree.com/
 *
 * Copyright (c) 2010 Ivan Bozhanov (vakata.com)
 *
 * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Date: 2011-02-09 01:17:14 +0200 (, 09  2011) $
 * $Revision: 236 $
 */

/*jslint browser: true, onevar: true, undef: true, bitwise: true, strict: true */
/*global window : false, clearInterval: false, clearTimeout: false, document: false, setInterval: false, setTimeout: false, jQuery: false, navigator: false, XSLTProcessor: false, DOMParser: false, XMLSerializer: false*/

"use strict";

// top wrapper to prevent multiple inclusion (is this OK?)
(function () { if(jQuery && jQuery.jstree) { return; }
	var is_ie6 = false, is_ie7 = false, is_ff2 = false;

/* 
 * jsTree core
 */
(function ($) {
	// Common functions not related to jsTree 
	// decided to move them to a `vakata` "namespace"
	$.vakata = {};
	// CSS related functions
	$.vakata.css = {
		get_css : function(rule_name, delete_flag, sheet) {
			rule_name = rule_name.toLowerCase();
			var css_rules = sheet.cssRules || sheet.rules,
				j = 0;
			do {
				if(css_rules.length && j > css_rules.length + 5) { return false; }
				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
					if(delete_flag === true) {
						if(sheet.removeRule) { sheet.removeRule(j); }
						if(sheet.deleteRule) { sheet.deleteRule(j); }
						return true;
					}
					else { return css_rules[j]; }
				}
			}
			while (css_rules[++j]);
			return false;
		},
		add_css : function(rule_name, sheet) {
			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
			return $.vakata.css.get_css(rule_name);
		},
		remove_css : function(rule_name, sheet) { 
			return $.vakata.css.get_css(rule_name, true, sheet); 
		},
		add_sheet : function(opts) {
		  // MODIFIED ischommer/SilverStripe: add_sheet significantly slows down rendering,
		  // we're loading all required CSS directly rather than adding it inline
		  
      // var tmp = false, is_new = true;
      // if(opts.str) {
      //  if(opts.title) { tmp = $("style[id='" + opts.title + "-stylesheet']")[0]; }
      //  if(tmp) { is_new = false; }
      //  else {
      //    tmp = document.createElement("style");
      //    tmp.setAttribute('type',"text/css");
      //    if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }
      //  }
      //  if(tmp.styleSheet) {
      //    if(is_new) { 
      //      document.getElementsByTagName("head")[0].appendChild(tmp); 
      //      tmp.styleSheet.cssText = opts.str; 
      //    }
      //    else {
      //      tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; 
      //    }
      //  }
      //  else {
      //    tmp.appendChild(document.createTextNode(opts.str));
      //    document.getElementsByTagName("head")[0].appendChild(tmp);
      //  }
      //  return tmp.sheet || tmp.styleSheet;
      // }
      // if(opts.url) {
      //  if(document.createStyleSheet) {
      //    try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
      //  }
      //  else {
      //    tmp     = document.createElement('link');
      //    tmp.rel   = 'stylesheet';
      //    tmp.type  = 'text/css';
      //    tmp.media = "all";
      //    tmp.href  = opts.url;
      //    document.getElementsByTagName("head")[0].appendChild(tmp);
      //    return tmp.styleSheet;
      //  }
      // }
		}
	};

	// private variables 
	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
		focused_instance = -1,	// the index in the instance array of the currently focused instance
		plugins = {},			// list of included plugins
		prepared_move = {};		// for the move_node function

	// jQuery plugin wrapper (thanks to jquery UI widget function)
	$.fn.jstree = function (settings) {
		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
			args = Array.prototype.slice.call(arguments, 1), 
			returnValue = this;

		// if a method call execute the method on all selected instances
		if(isMethodCall) {
			if(settings.substring(0, 1) == '_') { return returnValue; }
			this.each(function() {
				var instance = instances[$.data(this, "jstree_instance_id")],
					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
					if(typeof methodValue !== "undefined" && (settings.indexOf("is_") === 0 || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
			});
		}
		else {
			this.each(function() {
				// extend settings and allow for multiple hashes and $.data
				var instance_id = $.data(this, "jstree_instance_id"),
					a = [],
					b = settings ? $.extend({}, true, settings) : {},
					c = $(this), 
					s = false, 
					t = [];
				a = a.concat(args);
				if(c.data("jstree")) { a.push(c.data("jstree")); }
				b = a.length ? $.extend.apply(null, [true, b].concat(a)) : b;

				// if an instance already exists, destroy it first
				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
				// push a new empty object to the instances array
				instance_id = parseInt(instances.push({}),10) - 1;
				// store the jstree instance id to the container element
				$.data(this, "jstree_instance_id", instance_id);
				// clean up all plugins
				b.plugins = $.isArray(b.plugins) ? b.plugins : $.jstree.defaults.plugins.slice();
				b.plugins.unshift("core");
				// only unique plugins
				b.plugins = b.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");

				// extend defaults with passed data
				s = $.extend(true, {}, $.jstree.defaults, b);
				s.plugins = b.plugins;
				$.each(plugins, function (i, val) { 
					if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } 
					else { t.push(i); }
				});
				s.plugins = t;

				// push the new object to the instances array (at the same time set the default classes to the container) and init
				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
				// init all activated plugins for this instance
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
				// initialize the instance
				setTimeout(function() { if(instances[instance_id]) { instances[instance_id].init(); } }, 0);
			});
		}
		// return the jquery selection (or if it was a method call that returned a value - the returned value)
		return returnValue;
	};
	// object to store exposed functions and objects
	$.jstree = {
		defaults : {
			plugins : []
		},
		_focused : function () { return instances[focused_instance] || null; },
		_reference : function (needle) { 
			// get by instance id
			if(instances[needle]) { return instances[needle]; }
			// get by DOM (if still no luck - return null
			var o = $(needle); 
			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
			if(!o.length) { return null; }
			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; 
		},
		_instance : function (index, container, settings) { 
			// for plugins to store data in
			this.data = { core : {} };
			this.get_settings	= function () { return $.extend(true, {}, settings); };
			this._get_settings	= function () { return settings; };
			this.get_index		= function () { return index; };
			this.get_container	= function () { return container; };
			this.get_container_ul = function () { return container.children("ul:eq(0)"); };
			this._set_settings	= function (s) { 
				settings = $.extend(true, {}, settings, s);
			};
		},
		_fn : { },
		plugin : function (pname, pdata) {
			pdata = $.extend({}, {
				__init		: $.noop, 
				__destroy	: $.noop,
				_fn			: {},
				defaults	: false
			}, pdata);
			plugins[pname] = pdata;

			$.jstree.defaults[pname] = pdata.defaults;
			$.each(pdata._fn, function (i, val) {
				val.plugin		= pname;
				val.old			= $.jstree._fn[i];
				$.jstree._fn[i] = function () {
					var rslt,
						func = val,
						args = Array.prototype.slice.call(arguments),
						evnt = new $.Event("before.jstree"),
						rlbk = false;

					if(this.data.core.locked === true && i !== "unlock" && i !== "is_locked") { return; }

					// Check if function belongs to the included plugins of this instance
					do {
						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
						func = func.old;
					} while(func);
					if(!func) { return; }

					// context and function to trigger events, then finally call the function
					if(i.indexOf("_") === 0) {
						rslt = func.apply(this, args);
					}
					else {
						rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args, "plugin" : func.plugin });
						if(rslt === false) { return; }
						if(typeof rslt !== "undefined") { args = rslt; }

						rslt = func.apply(
							$.extend({}, this, { 
								__callback : function (data) { 
									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
								},
								__rollback : function () { 
									rlbk = this.get_rollback();
									return rlbk;
								},
								__call_old : function (replace_arguments) {
									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
								}
							}), args);
					}

					// return the result
					return rslt;
				};
				$.jstree._fn[i].old = val.old;
				$.jstree._fn[i].plugin = pname;
			});
		},
		rollback : function (rb) {
			if(rb) {
				if(!$.isArray(rb)) { rb = [ rb ]; }
				$.each(rb, function (i, val) {
					instances[val.i].set_rollback(val.h, val.d);
				});
			}
		}
	};
	// set the prototype for all instances
	$.jstree._fn = $.jstree._instance.prototype = {};

	// load the css when DOM is ready
	$(function() {
		// code is copied from jQuery ($.browser is deprecated + there is a bug in IE)
		var u = navigator.userAgent.toLowerCase(),
			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
			css_string = '' + 
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
				'.jstree > ul > li { margin-left:0px; } ' + 
				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
				'.jstree a:focus { outline: none; } ' + 
				'.jstree a > ins { height:16px; width:16px; } ' + 
				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
				'li.jstree-open > ul { display:block; } ' + 
				'li.jstree-closed > ul { display:none; } ';
		// Correct IE 6 (does not support the > CSS selector)
		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
			is_ie6 = true;

			// fix image flicker and lack of caching
			try {
				document.execCommand("BackgroundImageCache", false, true);
			} catch (err) { }

			css_string += '' + 
				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
				'.jstree li li { margin-left:18px; } ' + 
				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
				'li.jstree-open ul { display:block; } ' + 
				'li.jstree-closed ul { display:none !important; } ' + 
				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
		}
		// Correct IE 7 (shifts anchor nodes onhover)
		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
			is_ie7 = true;
			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
		}
		// correct ff2 lack of display:inline-block
		if(!/compatible/.test(u) && /mozilla/.test(u) && parseFloat(v, 10) < 1.9) {
			is_ff2 = true;
			css_string += '' + 
				'.jstree ins { display:-moz-inline-box; } ' + 
				'.jstree li { line-height:12px; } ' + // WHY??
				'.jstree a { display:-moz-inline-box; } ' + 
				'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } ';
				/* this shouldn't be here as it is theme specific */
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});

	// core functions (open, close, create, update, delete)
	$.jstree.plugin("core", {
		__init : function () {
			this.data.core.locked = false;
			this.data.core.to_open = this.get_settings().core.initially_open;
			this.data.core.to_load = this.get_settings().core.initially_load;
		},
		defaults : { 
			html_titles	: false,
			animation	: 500,
			initially_open : [],
			initially_load : [],
			open_parents : true,
			notify_plugins : true,
			rtl			: false,
			load_open	: false,
			strings		: {
				loading		: "Loading ...",
				new_node	: "New node",
				multiple_selection : "Multiple selection"
			}
		},
		_fn : { 
			init	: function () { 
				this.set_focus(); 
				if(this._get_settings().core.rtl) {
					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
				}
				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_string("loading") + "</a></li></ul>");
				this.data.core.li_height = this.get_container_ul().find("li.jstree-closed, li.jstree-leaf").eq(0).height() || 18;

				this.get_container()
					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
							var trgt = $(event.target);
							// if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
							this.toggle_node(trgt);
						}, this))
					.bind("mousedown.jstree", $.proxy(function () { 
							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
						}, this))
					.bind("dblclick.jstree", function (event) { 
						var sel;
						if(document.selection && document.selection.empty) { document.selection.empty(); }
						else {
							if(window.getSelection) {
								sel = window.getSelection();
								try { 
									sel.removeAllRanges();
									sel.collapse();
								} catch (err) { }
							}
						}
					});
				if(this._get_settings().core.notify_plugins) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li").each(function () {
									var th = $(this);
									if(th.data("jstree")) {
										$.each(th.data("jstree"), function (plugin, values) {
											if(t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"])) {
												t["_" + plugin + "_notify"].call(t, th, values);
											}
										});
									}
								});
							}, this));
				}
				if(this._get_settings().core.load_open) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li.jstree-open:not(:has(ul))").each(function () {
									t.load_node(this, $.noop, $.noop);
								});
							}, this));
				}
				this.__callback();
				this.load_node(-1, function () { this.loaded(); this.reload_nodes(); });
			},
			destroy	: function () { 
				var i,
					n = this.get_index(),
					s = this._get_settings(),
					_this = this;

				$.each(s.plugins, function (i, val) {
					try { plugins[val].__destroy.apply(_this); } catch(err) { }
				});
				this.__callback();
				// set focus to another instance if this one is focused
				if(this.is_focused()) { 
					for(i in instances) { 
						if(instances.hasOwnProperty(i) && i != n) { 
							instances[i].set_focus(); 
							break; 
						} 
					}
				}
				// if no other instance found
				if(n === focused_instance) { focused_instance = -1; }
				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
				this.get_container()
					.unbind(".jstree")
					.undelegate(".jstree")
					.removeData("jstree_instance_id")
					.find("[class^='jstree']")
						.andSelf()
						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
				$(document)
					.unbind(".jstree-" + n)
					.undelegate(".jstree-" + n);
				// remove the actual data
				instances[n] = null;
				delete instances[n];
			},

			_core_notify : function (n, data) {
				if(data.opened) {
					this.open_node(n, false, true);
				}
			},

			lock : function () {
				this.data.core.locked = true;
				this.get_container().children("ul").addClass("jstree-locked").css("opacity","0.7");
				this.__callback({});
			},
			unlock : function () {
				this.data.core.locked = false;
				this.get_container().children("ul").removeClass("jstree-locked").css("opacity","1");
				this.__callback({});
			},
			is_locked : function () { return this.data.core.locked; },
			save_opened : function () {
				var _this = this;
				this.data.core.to_open = [];
				this.get_container_ul().find("li.jstree-open").each(function () { 
					if(this.id) { _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); }
				});
				this.__callback(_this.data.core.to_open);
			},
			save_loaded : function () { },
			reload_nodes : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(!is_callback) { 
					this.data.core.reopen = false; 
					this.data.core.refreshing = true; 
					this.data.core.to_open = $.map($.makeArray(this.data.core.to_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.data.core.to_load = $.map($.makeArray(this.data.core.to_load), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					if(this.data.core.to_open.length) {
						this.data.core.to_load = this.data.core.to_load.concat(this.data.core.to_open);
					}
				}
				if(this.data.core.to_load.length) {
					$.each(this.data.core.to_load, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.core.to_load = remaining;
						$.each(current, function (i, val) { 
							if(!_this._is_loaded(val)) {
								_this.load_node(val, function () { _this.reload_nodes(true); }, function () { _this.reload_nodes(true); });
								done = false;
							}
						});
					}
				}
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				if(done) { 
					// TODO: find a more elegant approach to syncronizing returning requests
					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
					this.data.core.refreshing = false;
					this.reopen();
				}
			},
			reopen : function () {
				var _this = this;
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				this.__callback({});
			},
			refresh : function (obj, s_call, e_call) {
				var _this = this;
				this.save_opened();
				if(!obj) { obj = -1; }
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				if(obj !== -1) { obj.children("UL").remove(); }
				else { this.get_container_ul().empty(); }
				this.load_node(
					obj, 
					function () { 
						_this.__callback({ "obj" : obj}); 
						_this.reload_nodes(); 
						if(s_call) s_call.call(this); 
					},
					e_call
				);
			},
			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
			loaded	: function () { 
				this.__callback(); 
			},
			// deal with focus
			set_focus	: function () { 
				if(this.is_focused()) { return; }
				var f = $.jstree._focused();
				if(f) { f.unset_focus(); }

				this.get_container().addClass("jstree-focused"); 
				focused_instance = this.get_index(); 
				this.__callback();
			},
			is_focused	: function () { 
				return focused_instance == this.get_index(); 
			},
			unset_focus	: function () {
				if(this.is_focused()) {
					this.get_container().removeClass("jstree-focused"); 
					focused_instance = -1; 
				}
				this.__callback();
			},

			// traverse
			_get_node		: function (obj) { 
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_get_next		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }

				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
			},
			_get_prev		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }

				if(obj.prev("li").length) {
					obj = obj.prev("li").eq(0);
					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
					return obj;
				}
				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
			},
			_get_parent		: function (obj) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj.length) { return false; }
				var o = obj.parentsUntil(".jstree", "li:eq(0)");
				return o.length ? o : -1;
			},
			_get_children	: function (obj) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
				if(!obj.length) { return false; }
				return obj.children("ul:eq(0)").children("li");
			},
			get_path		: function (obj, id_mode) {
				var p = [],
					_this = this;
				obj = this._get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				obj.parentsUntil(".jstree", "li").each(function () {
					p.push( id_mode ? this.id : _this.get_text(this) );
				});
				p.reverse();
				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
				return p;
			},

			// string functions
			_get_string : function (key) {
				return this._get_settings().core.strings[key] || key;
			},

			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
			correct_state	: function (obj) {
				obj = this._get_node(obj);
				if(!obj || obj === -1) { return false; }
				obj.removeClass("jstree-closed jstree-open").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// open/close
			open_node	: function (obj, callback, skip_animation) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!this._is_loaded(obj)) {
					obj.children("a").addClass("jstree-loading");
					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
				}
				else {
					if(this._get_settings().core.open_parents) {
						obj.parentsUntil(".jstree",".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
					if(s) { obj.children("ul").css("display","none"); }
					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
					if(s) { obj.children("ul").stop(true, true).slideDown(s, function () { this.style.display = ""; t.after_open(obj); }); }
					else { t.after_open(obj); }
					this.__callback({ "obj" : obj });
					if(callback) { callback.call(); }
				}
			},
			after_open	: function (obj) { this.__callback({ "obj" : obj }); },
			close_node	: function (obj, skip_animation) {
				obj = this._get_node(obj);
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
				if(s) { obj.children("ul").attr("style","display:block !important"); }
				obj.removeClass("jstree-open").addClass("jstree-closed");
				if(s) { obj.children("ul").stop(true, true).slideUp(s, function () { this.style.display = ""; t.after_close(obj); }); }
				else { t.after_close(obj); }
				this.__callback({ "obj" : obj });
			},
			after_close	: function (obj) { this.__callback({ "obj" : obj }); },
			toggle_node	: function (obj) {
				obj = this._get_node(obj);
				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
			},
			open_all	: function (obj, do_animation, original_obj) {
				obj = obj ? this._get_node(obj) : -1;
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				if(original_obj) { 
					obj = obj.find("li.jstree-closed");
				}
				else {
					original_obj = obj;
					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
					else { obj = obj.find("li.jstree-closed"); }
				}
				var _this = this;
				obj.each(function () { 
					var __this = this; 
					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, do_animation, original_obj); }, !do_animation); }
					else { _this.open_node(this, false, !do_animation); }
				});
				// so that callback is fired AFTER all nodes are open
				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
			},
			close_all	: function (obj, do_animation) {
				var _this = this;
				obj = obj ? this._get_node(obj) : this.get_container();
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this, !do_animation); });
				this.__callback({ "obj" : obj });
			},
			clean_node	: function (obj) {
				obj = obj && obj != -1 ? $(obj) : this.get_container_ul();
				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
				obj.removeClass("jstree-last")
					.filter("li:last-child").addClass("jstree-last").end()
					.filter(":has(li)")
						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// rollback
			get_rollback : function () { 
				this.__callback();
				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
			},
			set_rollback : function (html, data) {
				this.get_container().empty().append(html);
				this.data = data;
				this.__callback();
			},
			// Dummy functions to be overwritten by any datastore plugin included
			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
			_is_loaded	: function (obj) { return true; },

			// Basic operations: create
			create_node	: function (obj, position, js, callback, is_loaded) {
				obj = this._get_node(obj);
				position = typeof position === "undefined" ? "last" : position;
				var d = $("<li />"),
					s = this._get_settings().core,
					tmp;

				if(obj !== -1 && !obj.length) { return false; }
				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }

				this.__rollback();

				if(typeof js === "string") { js = { "data" : js }; }
				if(!js) { js = {}; }
				if(js.attr) { d.attr(js.attr); }
				if(js.metadata) { d.data(js.metadata); }
				if(js.state) { d.addClass("jstree-" + js.state); }
				if(!js.data) { js.data = this._get_string("new_node"); }
				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
				$.each(js.data, function (i, m) {
					tmp = $("<a />");
					if($.isFunction(m)) { m = m.call(this, js); }
					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
					else {
						if(!m.attr) { m.attr = {}; }
						if(!m.attr.href) { m.attr.href = '#'; }
						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
						if(m.language) { tmp.addClass(m.language); }
					}
					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(!m.icon && js.icon) { m.icon = js.icon; }
					if(m.icon) { 
						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
					}
					d.append(tmp);
				});
				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
				if(obj === -1) {
					obj = this.get_container();
					if(position === "before") { position = "first"; }
					if(position === "after") { position = "last"; }
				}
				switch(position) {
					case "before": obj.before(d); tmp = this._get_parent(obj); break;
					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
					case "inside":
					case "first" :
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").prepend(d);
						tmp = obj;
						break;
					case "last":
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").append(d);
						tmp = obj;
						break;
					default:
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						if(!position) { position = 0; }
						tmp = obj.children("ul").children("li").eq(position);
						if(tmp.length) { tmp.before(d); }
						else { obj.children("ul").append(d); }
						tmp = obj;
						break;
				}
				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
				this.clean_node(tmp);
				this.__callback({ "obj" : d, "parent" : tmp });
				if(callback) { callback.call(this, d); }
				return d;
			},
			// Basic operations: rename (deal with text)
			get_text	: function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				var s = this._get_settings().core.html_titles;
				obj = obj.children("a:eq(0)");
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj ? obj.nodeValue : '';
				}
			},
			set_text	: function (obj, val) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				obj = obj.children("a:eq(0)");
				if(this._get_settings().core.html_titles) {
					var tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val });
					return (obj.nodeValue = val);
				}
			},
			rename_node : function (obj, val) {
				obj = this._get_node(obj);
				this.__rollback();
				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
			},
			// Basic operations: deleting nodes
			delete_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				this.__rollback();
				var p = this._get_parent(obj), prev = $([]), t = this;
				obj.each(function () {
					prev = prev.add(t._get_prev(this));
				});
				obj = obj.detach();
				if(p !== -1 && p.find("> ul > li").length === 0) {
					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
				}
				this.clean_node(p);
				this.__callback({ "obj" : obj, "prev" : prev, "parent" : p });
				return obj;
			},
			prepare_move : function (o, r, pos, cb, is_cb) {
				var p = {};

				p.ot = $.jstree._reference(o) || this;
				p.o = p.ot._get_node(o);
				p.r = r === - 1 ? -1 : this._get_node(r);
				p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting
				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
					this.__callback(prepared_move);
					if(cb) { cb.call(this, prepared_move); }
					return;
				}
				p.ot = $.jstree._reference(p.o) || this;
				p.rt = $.jstree._reference(p.r) || this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
				if(p.r === -1 || !p.r) {
					p.cr = -1;
					switch(p.p) {
						case "first":
						case "before":
						case "inside":
							p.cp = 0; 
							break;
						case "after":
						case "last":
							p.cp = p.rt.get_container().find(" > ul > li").length; 
							break;
						default:
							p.cp = p.p;
							break;
					}
				}
				else {
					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
					}
					switch(p.p) {
						case "before":
							p.cp = p.r.index();
							p.cr = p.rt._get_parent(p.r);
							break;
						case "after":
							p.cp = p.r.index() + 1;
							p.cr = p.rt._get_parent(p.r);
							break;
						case "inside":
						case "first":
							p.cp = 0;
							p.cr = p.r;
							break;
						case "last":
							p.cp = p.r.find(" > ul > li").length; 
							p.cr = p.r;
							break;
						default: 
							p.cp = p.p;
							p.cr = p.r;
							break;
					}
				}
				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
				p.op = p.ot._get_parent(p.o);
				p.cop = p.o.index();
				if(p.op === -1) { p.op = p.ot ? p.ot.get_container() : this.get_container(); }
				if(!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp++; }
				//if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
				prepared_move = p;
				this.__callback(prepared_move);
				if(cb) { cb.call(this, prepared_move); }
			},
			check_move : function () {
				var obj = prepared_move, ret = true, r = obj.r === -1 ? this.get_container() : obj.r;
				if(!obj || !obj.o || obj.or[0] === obj.o[0]) { return false; }
				if(!obj.cy) {
					if(obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index()) { return false; }
					obj.o.each(function () { 
						if(r.parentsUntil(".jstree", "li").andSelf().index(this) !== -1) { ret = false; return false; }
					});
				}
				return ret;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				if(!is_prepared) { 
					return this.prepare_move(obj, ref, position, function (p) {
						this.move_node(p, false, false, is_copy, true, skip_check);
					});
				}
				if(is_copy) { 
					prepared_move.cy = true;
				}
				if(!skip_check && !this.check_move()) { return false; }

				this.__rollback();
				var o = false;
				if(is_copy) {
					o = obj.o.clone(true);
					o.find("*[id]").andSelf().each(function () {
						if(this.id) { this.id = "copy_" + this.id; }
					});
				}
				else { o = obj.o; }

				if(obj.or.length) { obj.or.before(o); }
				else { 
					if(!obj.np.children("ul").length) { $("<ul />").appendTo(obj.np); }
					obj.np.children("ul:eq(0)").append(o); 
				}

				try { 
					obj.ot.clean_node(obj.op);
					obj.rt.clean_node(obj.np);
					if(!obj.op.find("> ul > li").length) {
						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
					}
				} catch (e) { }

				if(is_copy) { 
					prepared_move.cy = true;
					prepared_move.oc = o; 
				}
				this.__callback(prepared_move);
				return prepared_move;
			},
			_get_move : function () { return prepared_move; }
		}
	});
})(jQuery);
//*/

/* 
 * jsTree ui plugin
 * This plugins handles selecting/deselecting/hovering/dehovering nodes
 */
(function ($) {
	var scrollbar_width, e1, e2;
	$(function() {
		if (/msie/.test(navigator.userAgent.toLowerCase())) {
			e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			scrollbar_width = e1.width() - e2.width();
			e1.add(e2).remove();
		} 
		else {
			e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
					.prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
			scrollbar_width = 100 - e1.width();
			e1.parent().remove();
		}
	});
	$.jstree.plugin("ui", {
		__init : function () { 
			this.data.ui.selected = $(); 
			this.data.ui.last_selected = false; 
			this.data.ui.hovered = null;
			this.data.ui.to_select = this.get_settings().ui.initially_select;

			this.get_container()
				.delegate("a", "click.jstree", $.proxy(function (event) {
						event.preventDefault();
						event.currentTarget.blur();
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.select_node(event.currentTarget, true, event);
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.hover_node(event.target);
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.dehover_node(event.target);
						}
					}, this))
				.bind("reopen.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("get_rollback.jstree", $.proxy(function () { 
						this.dehover_node();
						this.save_selected();
					}, this))
				.bind("set_rollback.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("close_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.children("ul").find("a.jstree-clicked") : $(),
							_this = this;
						if(s.selected_parent_close === false || !clk.length) { return; }
						clk.each(function () { 
							_this.deselect_node(this);
							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
						});
					}, this))
				.bind("delete_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui.select_prev_on_delete,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.find("a.jstree-clicked") : [],
							_this = this;
						clk.each(function () { _this.deselect_node(this); });
						if(s && clk.length) { 
							data.rslt.prev.each(function () { 
								if(this.parentNode) { _this.select_node(this); return false; /* if return false is removed all prev nodes will be selected */}
							});
						}
					}, this))
				.bind("move_node.jstree", $.proxy(function (event, data) { 
						if(data.rslt.cy) { 
							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");
						}
					}, this));
		},
		defaults : {
			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
			select_range_modifier : "shift",
			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
			selected_parent_open : true,
			select_prev_on_delete : true,
			disable_selecting_children : false,
			initially_select : []
		},
		_fn : { 
			_get_node : function (obj, allow_multiple) {
				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_ui_notify : function (n, data) {
				if(data.selected) {
					this.select_node(n, false);
				}
			},
			save_selected : function () {
				var _this = this;
				this.data.ui.to_select = [];
				this.data.ui.selected.each(function () { if(this.id) { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); } });
				this.__callback(this.data.ui.to_select);
			},
			reselect : function () {
				var _this = this,
					s = this.data.ui.to_select;
				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
				// this.deselect_all(); WHY deselect, breaks plugin state notifier?
				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
				this.data.ui.selected = this.data.ui.selected.filter(function () { return this.parentNode; });
				this.__callback();
			},
			refresh : function (obj) {
				this.save_selected();
				return this.__call_old();
			},
			hover_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
				this._fix_scroll(obj);
				this.__callback({ "obj" : obj });
			},
			dehover_node : function () {
				var obj = this.data.ui.hovered, p;
				if(!obj || !obj.length) { return false; }
				p = obj.children("a").removeClass("jstree-hovered").parent();
				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
				this.__callback({ "obj" : obj });
			},
			select_node : function (obj, check, e) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj || !obj.length) { return false; }
				var s = this._get_settings().ui,
					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
					is_range = (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]),
					is_selected = this.is_selected(obj),
					proceed = true,
					t = this;
				if(check) {
					if(s.disable_selecting_children && is_multiple && 
						(
							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked").length) ||
							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)
						)
					) {
						return false;
					}
					proceed = false;
					switch(!0) {
						case (is_range):
							this.data.ui.last_selected.addClass("jstree-last-selected");
							obj = obj[ obj.index() < this.data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".jstree-last-selected").andSelf();
							if(s.select_limit == -1 || obj.length < s.select_limit) {
								this.data.ui.last_selected.removeClass("jstree-last-selected");
								this.data.ui.selected.each(function () {
									if(this !== t.data.ui.last_selected[0]) { t.deselect_node(this); }
								});
								is_selected = false;
								proceed = true;
							}
							else {
								proceed = false;
							}
							break;
						case (is_selected && !is_multiple): 
							this.deselect_all();
							is_selected = false;
							proceed = true;
							break;
						case (!is_selected && !is_multiple): 
							if(s.select_limit == -1 || s.select_limit > 0) {
								this.deselect_all();
								proceed = true;
							}
							break;
						case (is_selected && is_multiple): 
							this.deselect_node(obj);
							break;
						case (!is_selected && is_multiple): 
							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
								proceed = true;
							}
							break;
					}
				}
				if(proceed && !is_selected) {
					if(!is_range) { this.data.ui.last_selected = obj; }
					obj.children("a").addClass("jstree-clicked");
					if(s.selected_parent_open) {
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.data.ui.selected = this.data.ui.selected.add(obj);
					this._fix_scroll(obj.eq(0));
					this.__callback({ "obj" : obj, "e" : e });
				}
			},
			_fix_scroll : function (obj) {
				var c = this.get_container()[0], t;
				if(c.scrollHeight > c.offsetHeight) {
					obj = this._get_node(obj);
					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }
					t = obj.offset().top - this.get_container().offset().top;
					if(t < 0) { 
						c.scrollTop = c.scrollTop + t - 1; 
					}
					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight) { 
						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
					}
				}
			},
			deselect_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) {
					obj.children("a").removeClass("jstree-clicked");
					this.data.ui.selected = this.data.ui.selected.not(obj);
					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
					this.__callback({ "obj" : obj });
				}
			},
			toggle_select : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) { this.deselect_node(obj); }
				else { this.select_node(obj); }
			},
			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
			get_selected : function (context) { 
				return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; 
			},
			deselect_all : function (context) {
				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();
				ret.children("a.jstree-clicked").removeClass("jstree-clicked");
				this.data.ui.selected = $([]);
				this.data.ui.last_selected = false;
				this.__callback({ "obj" : ret });
			}
		}
	});
	// include the selection plugin by default
	$.jstree.defaults.plugins.push("ui");
})(jQuery);
//*/

/* 
 * jsTree CRRM plugin
 * Handles creating/renaming/removing/moving nodes by user interaction.
 */
(function ($) {
	$.jstree.plugin("crrm", { 
		__init : function () {
			this.get_container()
				.bind("move_node.jstree", $.proxy(function (e, data) {
					if(this._get_settings().crrm.move.open_onmove) {
						var t = this;
						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
				}, this));
		},
		defaults : {
			input_width_limit : 200,
			move : {
				always_copy			: false, // false, true or "multitree"
				open_onmove			: true,
				default_position	: "last",
				check_move			: function (m) { return true; }
			}
		},
		_fn : {
			_show_input : function (obj, callback) {
				obj = this._get_node(obj);
				var rtl = this._get_settings().core.rtl,
					w = this._get_settings().crrm.input_width_limit,
					w1 = obj.children("ins").width(),
					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
					t = this.get_text(obj),
					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
					h2 = obj.css("position","relative").append(
					$("<input />", { 
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"position" : "absolute",
							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
							"top" : "0px",
							"height" : (this.data.core.li_height - 2) + "px",
							"lineHeight" : (this.data.core.li_height - 2) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = obj.children(".jstree-rename-input"),
								v = i.val();
							if(v === "") { v = t; }
							h1.remove();
							i.remove(); // rollback purposes
							this.set_text(obj,t); // rollback purposes
							this.rename_node(obj, v);
							callback.call(this, obj, v, t);
							obj.css("position","");
						}, this),
						"keyup" : function (event) {
							var key = event.keyCode || event.which;
							if(key == 27) { this.value = t; this.blur(); return; }
							else if(key == 13) { this.blur(); return; }
							else {
								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
							}
						},
						"keypress" : function(event) {
							var key = event.keyCode || event.which;
							if(key == 13) { return false; }
						}
					})
				).children(".jstree-rename-input"); 
				this.set_text(obj, "");
				h1.css({
						fontFamily		: h2.css('fontFamily')		|| '',
						fontSize		: h2.css('fontSize')		|| '',
						fontWeight		: h2.css('fontWeight')		|| '',
						fontStyle		: h2.css('fontStyle')		|| '',
						fontStretch		: h2.css('fontStretch')		|| '',
						fontVariant		: h2.css('fontVariant')		|| '',
						letterSpacing	: h2.css('letterSpacing')	|| '',
						wordSpacing		: h2.css('wordSpacing')		|| ''
				});
				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			},
			rename : function (obj) {
				obj = this._get_node(obj);
				this.__rollback();
				var f = this.__callback;
				this._show_input(obj, function (obj, new_name, old_name) { 
					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
				});
			},
			create : function (obj, position, js, callback, skip_rename) {
				var t, _this = this;
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				this.__rollback();
				t = this.create_node(obj, position, js, function (t) {
					var p = this._get_parent(t),
						pos = $(t).index();
					if(callback) { callback.call(this, t); }
					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
					if(!skip_rename) { 
						this._show_input(t, function (obj, new_name, old_name) { 
							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
						});
					}
					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
				});
				return t;
			},
			remove : function (obj) {
				obj = this._get_node(obj, true);
				var p = this._get_parent(obj), prev = this._get_prev(obj);
				this.__rollback();
				obj = this.delete_node(obj);
				if(obj !== false) { this.__callback({ "obj" : obj, "prev" : prev, "parent" : p }); }
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var s = this._get_settings().crrm.move;
				if(!s.check_move.call(this, this._get_move())) { return false; }
				return true;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				var s = this._get_settings().crrm.move;
				if(!is_prepared) { 
					if(typeof position === "undefined") { position = s.default_position; }
					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
				}
				// if the move is already prepared
				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
					is_copy = true;
				}
				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
			},

			cut : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.cp_nodes = false;
				this.data.crrm.ct_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			copy : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.ct_nodes = false;
				this.data.crrm.cp_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			paste : function (obj) { 
				obj = this._get_node(obj);
				if(!obj || !obj.length) { return false; }
				var nodes = this.data.crrm.ct_nodes ? this.data.crrm.ct_nodes : this.data.crrm.cp_nodes;
				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); this.data.crrm.ct_nodes = false; }
				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
				this.__callback({ "obj" : obj, "nodes" : nodes });
			}
		}
	});
	// include the crr plugin by default
	// $.jstree.defaults.plugins.push("crrm");
})(jQuery);
//*/

/* 
 * jsTree themes plugin
 * Handles loading and setting themes, as well as detecting path to themes, etc.
 */
(function ($) {
	var themes_loaded = [];
	// this variable stores the path to the themes folder - if left as false - it will be autodetected
	$.jstree._themes = false;
	$.jstree.plugin("themes", {
		__init : function () { 
			this.get_container()
				.bind("init.jstree", $.proxy(function () {
						var s = this._get_settings().themes;
						this.data.themes.dots = s.dots; 
						this.data.themes.icons = s.icons; 
						this.set_theme(s.theme, s.url);
					}, this))
				.bind("loaded.jstree", $.proxy(function () {
						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
						if(!this.data.themes.dots) { this.hide_dots(); }
						else { this.show_dots(); }
						if(!this.data.themes.icons) { this.hide_icons(); }
						else { this.show_icons(); }
					}, this));
		},
		defaults : { 
			theme : "default", 
			url : false,
			dots : true,
			icons : true
		},
		_fn : {
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
				if($.inArray(theme_url, themes_loaded) == -1) {
					$.vakata.css.add_sheet({ "url" : theme_url });
					themes_loaded.push(theme_url);
				}
				if(this.data.themes.theme != theme_name) {
					this.get_container().removeClass('jstree-' + this.data.themes.theme);
					this.data.themes.theme = theme_name;
				}
				this.get_container().addClass('jstree-' + theme_name);
				if(!this.data.themes.dots) { this.hide_dots(); }
				else { this.show_dots(); }
				if(!this.data.themes.icons) { this.hide_icons(); }
				else { this.show_icons(); }
				this.__callback();
			},
			get_theme	: function () { return this.data.themes.theme; },

			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },

			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
		}
	});
	// autodetect themes path
	$(function () {
		if($.jstree._themes === false) {
			$("script").each(function () { 
				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
					return false; 
				}
			});
		}
		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
	});
	// include the themes plugin by default
	$.jstree.defaults.plugins.push("themes");
})(jQuery);
//*/

/*
 * jsTree hotkeys plugin
 * Enables keyboard navigation for all tree instances
 * Depends on the jstree ui & jquery hotkeys plugins
 */
(function ($) {
	var bound = [];
	function exec(i, event) {
		var f = $.jstree._focused(), tmp;
		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
			tmp = f._get_settings().hotkeys[i];
			if(tmp) { return tmp.call(f, event); }
		}
	}
	$.jstree.plugin("hotkeys", {
		__init : function () {
			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
			$.each(this._get_settings().hotkeys, function (i, v) {
				if(v !== false && $.inArray(i, bound) == -1) {
					$(document).bind("keydown", i, function (event) { return exec(i, event); });
					bound.push(i);
				}
			});
			this.get_container()
				.bind("lock.jstree", $.proxy(function () {
						if(this.data.hotkeys.enabled) { this.data.hotkeys.enabled = false; this.data.hotkeys.revert = true; }
					}, this))
				.bind("unlock.jstree", $.proxy(function () {
						if(this.data.hotkeys.revert) { this.data.hotkeys.enabled = true; }
					}, this));
			this.enable_hotkeys();
		},
		defaults : {
			"up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"ctrl+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"shift+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"ctrl+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"shift+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"ctrl+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"shift+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"ctrl+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"shift+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"space" : function () { 
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
				return false; 
			},
			"ctrl+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"shift+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
		},
		_fn : {
			enable_hotkeys : function () {
				this.data.hotkeys.enabled = true;
			},
			disable_hotkeys : function () {
				this.data.hotkeys.enabled = false;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree JSON plugin
 * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("json_data", {
		__init : function() {
			var s = this._get_settings().json_data;
			if(s.progressive_unload) {
				this.get_container().bind("after_close.jstree", function (e, data) {
					data.rslt.obj.children("ul").remove();
				});
			}
		},
		defaults : { 
			// `data` can be a function:
			//  * accepts two arguments - node being loaded and a callback to pass the result to
			//  * will be executed in the current tree's scope & ajax won't be supported
			data : false, 
			ajax : false,
			correct_state : true,
			progressive_render : false,
			progressive_unload : false
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().json_data;
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!s.ajax && !s.progressive_render && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;
			},
			refresh : function (obj) {
				obj = this._get_node(obj);
				var s = this._get_settings().json_data;
				if(obj && obj !== -1 && s.progressive_unload && ($.isFunction(s.data) || !!s.ajax)) {
					obj.removeData("jstree_children");
				}
				return this.__call_old();
			},
			load_node_json : function (obj, s_call, e_call) {
				var s = this.get_settings().json_data, d,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);

				if(obj && obj !== -1 && (s.progressive_render || s.progressive_unload) && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree_children")) {
					d = this._parse_json(obj.data("jstree_children"), obj);
					if(d) {
						obj.append(d);
						if(!s.progressive_unload) { obj.removeData("jstree_children"); }
					}
					this.clean_node(obj);
					if(s_call) { s_call.call(this); }
					return;
				}

				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					// function option added here for easier model integration (also supporting async - see callback)
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							d = this._parse_json(d, obj);
							if(!d) { 
								if(obj === -1 || !obj) {
									if(s.correct_state) { this.get_container().children("ul").empty(); }
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { this.correct_state(obj); }
								}
								if(e_call) { e_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = this._parse_json(s.data, obj);
							if(d) {
								this.get_container().children("ul").empty().append(d.children());
								this.clean_node();
							}
							else { 
								if(s.correct_state) { this.get_container().children("ul").empty(); }
							}
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().json_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().json_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d))) {
								return error_func.call(this, x, t, "");
							}
							d = this._parse_json(d, obj);
							if(d) {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) {
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			_parse_json : function (js, obj, is_callback) {
				var d = false, 
					p = this._get_settings(),
					s = p.json_data,
					t = p.core.html_titles,
					tmp, i, j, ul1, ul2;

				if(!js) { return d; }
				if(s.progressive_unload && obj && obj !== -1) { 
					obj.data("jstree_children", d);
				}
				if($.isArray(js)) {
					d = $();
					if(!js.length) { return false; }
					for(i = 0, j = js.length; i < j; i++) {
						tmp = this._parse_json(js[i], obj, true);
						if(tmp.length) { d = d.add(tmp); }
					}
				}
				else {
					if(typeof js == "string") { js = { data : js }; }
					if(!js.data && js.data !== "") { return d; }
					d = $("<li />");
					if(js.attr) { d.attr(js.attr); }
					if(js.metadata) { d.data(js.metadata); }
					if(js.state) { d.addClass("jstree-" + js.state); }
					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
					$.each(js.data, function (i, m) {
						tmp = $("<a />");
						if($.isFunction(m)) { m = m.call(this, js); }
						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
						else {
							if(!m.attr) { m.attr = {}; }
							if(!m.attr.href) { m.attr.href = '#'; }
							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
							if(m.language) { tmp.addClass(m.language); }
						}
						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
						if(!m.icon && js.icon) { m.icon = js.icon; }
						if(m.icon) { 
							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
						}
						d.append(tmp);
					});
					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(js.children) { 
						if(s.progressive_render && js.state !== "open") {
							d.addClass("jstree-closed").data("jstree_children", js.children);
						}
						else {
							if(s.progressive_unload) { d.data("jstree_children", js.children); }
							if($.isArray(js.children) && js.children.length) {
								tmp = this._parse_json(js.children, obj, true);
								if(tmp.length) {
									ul2 = $("<ul />");
									ul2.append(tmp);
									d.append(ul2);
								}
							}
						}
					}
				}
				if(!is_callback) {
					ul1 = $("<ul />");
					ul1.append(d);
					d = ul1;
				}
				return d;
			},
			get_json : function (obj, li_attr, a_attr, is_callback) {
				var result = [], 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, t, lang;
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				obj.each(function () {
					li = $(this);
					tmp1 = { data : [] };
					if(li_attr.length) { tmp1.attr = { }; }
					$.each(li_attr, function (i, v) { 
						tmp2 = li.attr(v); 
						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*/ig,'').length) {
							tmp1.attr[v] = (" " + tmp2).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,""); 
						}
					});
					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
					if(li.data()) { tmp1.metadata = li.data(); }
					a = li.children("a");
					a.each(function () {
						t = $(this);
						if(
							a_attr.length || 
							$.inArray("languages", s.plugins) !== -1 || 
							t.children("ins").get(0).style.backgroundImage.length || 
							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
						) { 
							lang = false;
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (l, lv) {
									if(t.hasClass(lv)) {
										lang = lv;
										return false;
									}
								});
							}
							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
							$.each(a_attr, function (k, z) {
								tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							});
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (k, z) {
									if(t.hasClass(z)) { tmp2.language = z; return true; }
								});
							}
							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							}
							if(t.children("ins").get(0).style.backgroundImage.length) {
								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
							}
						}
						else {
							tmp2 = _this.get_text(t);
						}
						if(a.length > 1) { tmp1.data.push(tmp2); }
						else { tmp1.data = tmp2; }
					});
					li = li.find("> ul > li");
					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
					result.push(tmp1);
				});
				return result;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree languages plugin
 * Adds support for multiple language versions in one tree
 * This basically allows for many titles coexisting in one node, but only one of them being visible at any given time
 * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
 */
(function ($) {
	var sh = false;
	$.jstree.plugin("languages", {
		__init : function () { this._load_css();  },
		defaults : [],
		_fn : {
			set_lang : function (i) { 
				var langs = this._get_settings().languages,
					st = false,
					selector = ".jstree-" + this.get_index() + ' a';
				if(!$.isArray(langs) || langs.length === 0) { return false; }
				if($.inArray(i,langs) == -1) {
					if(!!langs[i]) { i = langs[i]; }
					else { return false; }
				}
				if(i == this.data.languages.current_language) { return true; }
				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, sh);
				if(st !== false) { st.style.display = "none"; }
				st = $.vakata.css.get_css(selector + "." + i, false, sh);
				if(st !== false) { st.style.display = ""; }
				this.data.languages.current_language = i;
				this.__callback(i);
				return true;
			},
			get_lang : function () {
				return this.data.languages.current_language;
			},
			_get_string : function (key, lang) {
				var langs = this._get_settings().languages,
					s = this._get_settings().core.strings;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
				}
				if(s[lang] && s[lang][key]) { return s[lang][key]; }
				if(s[key]) { return s[key]; }
				return key;
			},
			get_text : function (obj, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text : function (obj, val, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles,
					tmp;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return (obj.nodeValue = val);
				}
			},
			_load_css : function () {
				var langs = this._get_settings().languages,
					str = "/* languages css */",
					selector = ".jstree-" + this.get_index() + ' a',
					ln;
				if($.isArray(langs) && langs.length) {
					this.data.languages.current_language = langs[0];
					for(ln = 0; ln < langs.length; ln++) {
						str += selector + "." + langs[ln] + " {";
						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
						str += " } ";
					}
					sh = $.vakata.css.add_sheet({ 'str' : str, 'title' : "jstree-languages" });
				}
			},
			create_node : function (obj, position, js, callback) {
				var t = this.__call_old(true, obj, position, js, function (t) {
					var langs = this._get_settings().languages,
						a = t.children("a"),
						ln;
					if($.isArray(langs) && langs.length) {
						for(ln = 0; ln < langs.length; ln++) {
							if(!a.is("." + langs[ln])) {
								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
							}
						}
						a.not("." + langs.join(", .")).remove();
					}
					if(callback) { callback.call(this, t); }
				});
				return t;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree cookies plugin
 * Stores the currently opened/selected nodes in a cookie and then restores them
 * Depends on the jquery.cookie plugin
 */
(function ($) {
	$.jstree.plugin("cookies", {
		__init : function () {
			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }

			var s = this._get_settings().cookies,
				tmp;
			if(!!s.save_loaded) {
				tmp = $.cookie(s.save_loaded);
				if(tmp && tmp.length) { this.data.core.to_load = tmp.split(","); }
			}
			if(!!s.save_opened) {
				tmp = $.cookie(s.save_opened);
				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
			}
			if(!!s.save_selected) {
				tmp = $.cookie(s.save_selected);
				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
			}
			this.get_container()
				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
					this.get_container()
						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
							}, this));
				}, this));
		},
		defaults : {
			save_loaded		: "jstree_load",
			save_opened		: "jstree_open",
			save_selected	: "jstree_select",
			auto_save		: true,
			cookie_options	: {}
		},
		_fn : {
			save_cookie : function (c) {
				if(this.data.core.refreshing) { return; }
				var s = this._get_settings().cookies;
				if(!c) { // if called manually and not by event
					if(s.save_loaded) {
						this.save_loaded();
						$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options);
					}
					if(s.save_opened) {
						this.save_opened();
						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
					}
					if(s.save_selected && this.data.ui) {
						this.save_selected();
						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
					}
					return;
				}
				switch(c) {
					case "open_node":
					case "close_node":
						if(!!s.save_opened) { 
							this.save_opened(); 
							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
						}
						if(!!s.save_loaded) { 
							this.save_loaded(); 
							$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options); 
						}
						break;
					case "select_node":
					case "deselect_node":
						if(!!s.save_selected && this.data.ui) { 
							this.save_selected(); 
							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
						}
						break;
				}
			}
		}
	});
	// include cookies by default
	// $.jstree.defaults.plugins.push("cookies");
})(jQuery);
//*/

/*
 * jsTree sort plugin
 * Sorts items alphabetically (or using any other function)
 */
(function ($) {
	$.jstree.plugin("sort", {
		__init : function () {
			this.get_container()
				.bind("load_node.jstree", $.proxy(function (e, data) {
						var obj = this._get_node(data.rslt.obj);
						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
						this.sort(obj);
					}, this))
				.bind("rename_node.jstree create_node.jstree create.jstree", $.proxy(function (e, data) {
						this.sort(data.rslt.obj.parent());
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
						this.sort(m.children("ul"));
					}, this));
		},
		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
		_fn : {
			sort : function (obj) {
				var s = this._get_settings().sort,
					t = this;
				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
				obj.find("> li > ul").each(function() { t.sort($(this)); });
				this.clean_node(obj);
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree DND plugin
 * Drag and drop plugin for moving/copying nodes
 */
(function ($) {
	var o = false,
		r = false,
		m = false,
		ml = false,
		sli = false,
		sti = false,
		dir1 = false,
		dir2 = false,
		last_pos = false;
	$.vakata.dnd = {
		is_down : false,
		is_drag : false,
		helper : false,
		scroll_spd : 10,
		init_x : 0,
		init_y : 0,
		threshold : 5,
		helper_left : 5,
		helper_top : 10,
		user_data : {},

		drag_start : function (e, data, html) { 
			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
			try {
				e.currentTarget.unselectable = "on";
				e.currentTarget.onselectstart = function() { return false; };
				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
			} catch(err) { }
			$.vakata.dnd.init_x = e.pageX;
			$.vakata.dnd.init_y = e.pageY;
			$.vakata.dnd.user_data = data;
			$.vakata.dnd.is_down = true;
			$.vakata.dnd.helper = $("<div id='vakata-dragged' />").html(html); //.fadeTo(10,0.25);
			$(document).bind("mousemove", $.vakata.dnd.drag);
			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
			return false;
		},
		drag : function (e) { 
			if(!$.vakata.dnd.is_down) { return; }
			if(!$.vakata.dnd.is_drag) {
				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
					$.vakata.dnd.helper.appendTo("body");
					$.vakata.dnd.is_drag = true;
					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
				}
				else { return; }
			}

			// maybe use a scrolling parent element instead of document?
			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
				if(e.pageY - t < 20) { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
				}
				if($(window).height() - (e.pageY - t) < 20) {
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
				}

				if(e.pageX - l < 20) {
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
				}
				if($(window).width() - (e.pageX - l) < 20) {
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
				}
			}

			$.vakata.dnd.helper.css({ left : (e.pageX + $.vakata.dnd.helper_left) + "px", top : (e.pageY + $.vakata.dnd.helper_top) + "px" });
			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
		},
		drag_stop : function (e) {
			if(sli) { clearInterval(sli); }
			if(sti) { clearInterval(sti); }
			$(document).unbind("mousemove", $.vakata.dnd.drag);
			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
			$.vakata.dnd.helper.remove();
			$.vakata.dnd.init_x = 0;
			$.vakata.dnd.init_y = 0;
			$.vakata.dnd.user_data = {};
			$.vakata.dnd.is_down = false;
			$.vakata.dnd.is_drag = false;
		}
	};
	$(function() {
		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
	});

	$.jstree.plugin("dnd", {
		__init : function () {
			this.data.dnd = {
				active : false,
				after : false,
				inside : false,
				before : false,
				off : false,
				prepared : false,
				w : 0,
				to1 : false,
				to2 : false,
				cof : false,
				cw : false,
				ch : false,
				i1 : false,
				i2 : false,
				mto : false
			};
			this.get_container()
				.bind("mouseenter.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.themes) {
								m.attr("class", "jstree-" + this.data.themes.theme); 
								if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
								$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
							}
							//if($(e.currentTarget).find("> ul > li").length === 0) {
							if(e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
								var tr = $.jstree._reference(e.target), dc;
								if(tr.data.dnd.foreign) {
									dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
									if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
								else {
									tr.prepare_move(o, tr.get_container(), "last");
									if(tr.check_move()) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
							}
						}
					}, this))
				.bind("mouseup.jstree", $.proxy(function (e) {
						//if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && $(e.currentTarget).find("> ul > li").length === 0) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
							var tr = $.jstree._reference(e.currentTarget), dc;
							if(tr.data.dnd.foreign) {
								dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
									tr._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								}
							}
							else {
								tr.move_node(o, tr.get_container(), "last", e[tr._get_settings().dnd.copy_modifier + "Key"]);
							}
						}
					}, this))
				.bind("mouseleave.jstree", $.proxy(function (e) {
						if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
							return false; 
						}
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
							if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
							if($.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}
					}, this))
				.bind("mousemove.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							var cnt = this.get_container()[0];

							// Horizontal scroll
							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageX - 24 < this.data.dnd.cof.left) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							}

							// Vertical scroll
							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageY - 24 < this.data.dnd.cof.top) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							}

						}
					}, this))
				.bind("scroll.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && m && ml) {
							m.hide();
							ml.hide();
						}
					}, this))
				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
						if(e.which === 1) {
							this.start_drag(e.currentTarget, e);
							return false;
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_enter(e.currentTarget);
						}
					}, this))
				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(!r || !r.length || r.children("a")[0] !== e.currentTarget) {
								this.dnd_enter(e.currentTarget);
							}
							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
							this.dnd_show();
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
								return false; 
							}
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							/*
							var ec = $(e.currentTarget).closest("li"), 
								er = $(e.relatedTarget).closest("li");
							if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							}
							*/
							this.data.dnd.mto = setTimeout( 
								(function (t) { return function () { t.dnd_leave(e); }; })(this),
							0);
						}
					}, this))
				.delegate("a, #jstree-marker-line", "mouseup.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_finish(e);
						}
					}, this));

			$(document)
				.bind("drag_stop.vakata", $.proxy(function () {
						if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
						if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
						if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
						if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
						this.data.dnd.after		= false;
						this.data.dnd.before	= false;
						this.data.dnd.inside	= false;
						this.data.dnd.off		= false;
						this.data.dnd.prepared	= false;
						this.data.dnd.w			= false;
						this.data.dnd.to1		= false;
						this.data.dnd.to2		= false;
						this.data.dnd.i1		= false;
						this.data.dnd.i2		= false;
						this.data.dnd.active	= false;
						this.data.dnd.foreign	= false;
						if(m) { m.css({ "top" : "-2000px" }); }
						if(ml) { ml.css({ "top" : "-2000px" }); }
					}, this))
				.bind("drag_start.vakata", $.proxy(function (e, data) {
						if(data.data.jstree) { 
							var et = $(data.event.target);
							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
								this.dnd_enter(et);
							}
						}
					}, this));
				/*
				.bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
							var h = $.vakata.dnd.helper.children("ins");
							if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
							} 
							else {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
							}
						}
					}, this)); */



			var s = this._get_settings().dnd;
			if(s.drag_target) {
				$(document)
					.delegate(s.drag_target, "mousedown.jstree-" + this.get_index(), $.proxy(function (e) {
						o = e.target;
						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
						if(this.data.themes) { 
							if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
							if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
						}
						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
						var cnt = this.get_container();
						this.data.dnd.cof = cnt.offset();
						this.data.dnd.cw = parseInt(cnt.width(),10);
						this.data.dnd.ch = parseInt(cnt.height(),10);
						this.data.dnd.foreign = true;
						e.preventDefault();
					}, this));
			}
			if(s.drop_target) {
				$(document)
					.delegate(s.drop_target, "mouseenter.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target), "e" : e })) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
							}
						}, this))
					.delegate(s.drop_target, "mouseleave.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}, this))
					.delegate(s.drop_target + ", #jstree-marker-line", "mouseup.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target), "e" : e });
							}
						}, this));
			}
		},
		defaults : {
			copy_modifier	: "ctrl",
			check_timeout	: 100,
			open_timeout	: 500,
			drop_target		: ".jstree-drop",
			drop_check		: function (data) { return true; },
			drop_finish		: $.noop,
			drag_target		: ".jstree-draggable",
			drag_finish		: $.noop,
			drag_check		: function (data) { return { after : false, before : false, inside : true }; }
		},
		__destroy : function () {
			// unbind global event handlers when last instance is removed
			// (no access to private 'instances' variable from here)
			if($('.jstree').length <= 1) {
				$(document)
					.unbind("drag_start.vakata")
					.unbind("drag_stop.vakata");	
			}
			o = false;
		},
		_fn : {
			dnd_prepare : function () {
				if(!r || !r.length) { return; }
				this.data.dnd.off = r.offset();
				if(this._get_settings().core.rtl) {
					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
				}
				if(this.data.dnd.foreign) {
					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
					this.data.dnd.after = a.after;
					this.data.dnd.before = a.before;
					this.data.dnd.inside = a.inside;
					this.data.dnd.prepared = true;
					return this.dnd_show();
				}
				this.prepare_move(o, r, "before");
				this.data.dnd.before = this.check_move();
				this.prepare_move(o, r, "after");
				this.data.dnd.after = this.check_move();
				if(this._is_loaded(r)) {
					this.prepare_move(o, r, "inside");
					this.data.dnd.inside = this.check_move();
				}
				else {
					this.data.dnd.inside = false;
				}
				this.data.dnd.prepared = true;
				return this.dnd_show();
			},
			dnd_show : function () {
				if(!this.data.dnd.prepared) { return; }
				var o = ["before","inside","after"],
					r = false,
					rtl = this._get_settings().core.rtl,
					pos;
				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
				}
				else { o = ["after","inside","before"]; }
				$.each(o, $.proxy(function (i, val) { 
					if(this.data.dnd[val]) {
						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
						r = val;
						return false;
					}
				}, this));
				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
				
				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
				switch(r) {
					case "before":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top - 1) + "px" }).show(); }
						break;
					case "after":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 1) + "px" }).show(); }
						break;
					case "inside":
						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
						if(ml) { ml.hide(); }
						break;
					default:
						m.hide();
						if(ml) { ml.hide(); }
						break;
				}
				last_pos = r;
				return r;
			},
			dnd_open : function () {
				this.data.dnd.to2 = false;
				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
			},
			dnd_finish : function (e) {
				if(this.data.dnd.foreign) {
					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r, "p" : last_pos });
					}
				}
				else {
					this.dnd_prepare();
					this.move_node(o, r, last_pos, e[this._get_settings().dnd.copy_modifier + "Key"]);
				}
				o = false;
				r = false;
				m.hide();
				if(ml) { ml.hide(); }
			},
			dnd_enter : function (obj) {
				if(this.data.dnd.mto) { 
					clearTimeout(this.data.dnd.mto);
					this.data.dnd.mto = false;
				}
				var s = this._get_settings().dnd;
				this.data.dnd.prepared = false;
				r = this._get_node(obj);
				if(s.check_timeout) { 
					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
				}
				else { 
					this.dnd_prepare(); 
				}
				if(s.open_timeout) { 
					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
					if(r && r.length && r.hasClass("jstree-closed")) { 
						// if the node is closed - open it, then recalculate
						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
					}
				}
				else {
					if(r && r.length && r.hasClass("jstree-closed")) { 
						this.dnd_open();
					}
				}
			},
			dnd_leave : function (e) {
				this.data.dnd.after		= false;
				this.data.dnd.before	= false;
				this.data.dnd.inside	= false;
				$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
				m.hide();
				if(ml) { ml.hide(); }
				if(r && r[0] === e.target.parentNode) {
					if(this.data.dnd.to1) {
						clearTimeout(this.data.dnd.to1);
						this.data.dnd.to1 = false;
					}
					if(this.data.dnd.to2) {
						clearTimeout(this.data.dnd.to2);
						this.data.dnd.to2 = false;
					}
				}
			},
			start_drag : function (obj, e) {
				o = this._get_node(obj);
				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
				var dt = o.length > 1 ? this._get_string("multiple_selection") : this.get_text(o),
					cnt = this.get_container();
				if(!this._get_settings().core.html_titles) { dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;"); }
				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + dt );
				if(this.data.themes) { 
					if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
					if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
				}
				this.data.dnd.cof = cnt.offset();
				this.data.dnd.cw = parseInt(cnt.width(),10);
				this.data.dnd.ch = parseInt(cnt.height(),10);
				this.data.dnd.active = true;
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; ' + 
			' -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; ' +
			'} ' + 
			'#vakata-dragged .jstree-ok { background:green; } ' + 
			'#vakata-dragged .jstree-invalid { background:red; } ' + 
			'#jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } ' + 
			'#jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43; ' + 
			' cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666; ' + 
			' -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; ' +
			'}' + 
			'';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
		m = $("<div />").attr({ id : "jstree-marker" }).hide().html("&raquo;")
			.bind("mouseleave mouseenter", function (e) { 
				m.hide();
				ml.hide();
				e.preventDefault(); 
				e.stopImmediatePropagation(); 
				return false; 
			})
			.appendTo("body");
		ml = $("<div />").attr({ id : "jstree-marker-line" }).hide()
			.bind("mouseup", function (e) { 
				if(r && r.length) { 
					r.children("a").trigger(e); 
					e.preventDefault(); 
					e.stopImmediatePropagation(); 
					return false; 
				} 
			})
			.bind("mouseleave", function (e) { 
				var rt = $(e.relatedTarget);
				if(rt.is(".jstree") || rt.closest(".jstree").length === 0) {
					if(r && r.length) { 
						r.children("a").trigger(e); 
						m.hide();
						ml.hide();
						e.preventDefault(); 
						e.stopImmediatePropagation(); 
						return false; 
					}
				}
			})
			.appendTo("body");
		$(document).bind("drag_start.vakata", function (e, data) {
			if(data.data.jstree) { m.show(); if(ml) { ml.show(); } }
		});
		$(document).bind("drag_stop.vakata", function (e, data) {
			if(data.data.jstree) { m.hide(); if(ml) { ml.hide(); } }
		});
	});
})(jQuery);
//*/

/*
 * jsTree checkbox plugin
 * Inserts checkboxes in front of every node
 * Depends on the ui plugin
 * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
 */
(function ($) {
	$.jstree.plugin("checkbox", {
		__init : function () {
			this.data.checkbox.noui = this._get_settings().checkbox.override_ui;
			if(this.data.ui && this.data.checkbox.noui) {
				this.select_node = this.deselect_node = this.deselect_all = $.noop;
				this.get_selected = this.get_checked;
			}

			this.get_container()
				.bind("open_node.jstree create_node.jstree clean_node.jstree refresh.jstree", $.proxy(function (e, data) { 
						this._prepare_checkboxes(data.rslt.obj);
					}, this))
				.bind("loaded.jstree", $.proxy(function (e) {
						this._prepare_checkboxes();
					}, this))
				.delegate( (this.data.ui && this.data.checkbox.noui ? "a" : "ins.jstree-checkbox") , "click.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
						else { this.check_node(e.target); }
						if(this.data.ui && this.data.checkbox.noui) {
							this.save_selected();
							if(this.data.cookies) { this.save_cookie("select_node"); }
						}
						else {
							e.stopImmediatePropagation();
							return false;
						}
					}, this));
		},
		defaults : {
			override_ui : false,
			two_state : false,
			real_checkboxes : false,
			checked_parent_open : true,
			real_checkboxes_names : function (n) { return [ ("check_" + (n[0].id || Math.ceil(Math.random() * 10000))) , 1]; }
		},
		__destroy : function () {
			this.get_container()
				.find("input.jstree-real-checkbox").removeClass("jstree-real-checkbox").end()
				.find("ins.jstree-checkbox").remove();
		},
		_fn : {
			_checkbox_notify : function (n, data) {
				if(data.checked) {
					this.check_node(n, false);
				}
			},
			_prepare_checkboxes : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				var c, _this = this, t, ts = this._get_settings().checkbox.two_state, rc = this._get_settings().checkbox.real_checkboxes, rcn = this._get_settings().checkbox.real_checkboxes_names;
				obj.each(function () {
					t = $(this);
					c = t.is("li") && (t.hasClass("jstree-checked") || (rc && t.children(":checked").length)) ? "jstree-checked" : "jstree-unchecked";
					t.find("li").andSelf().each(function () {
						var $t = $(this), nm;
						$t.children("a" + (_this.data.languages ? "" : ":eq(0)") ).not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass( ts ? "jstree-unchecked" : c );
						if(rc) {
							if(!$t.children(":checkbox").length) {
								nm = rcn.call(_this, $t);
								$t.prepend("<input type='checkbox' class='jstree-real-checkbox' id='" + nm[0] + "' name='" + nm[0] + "' value='" + nm[1] + "' />");
							}
							else {
								$t.children(":checkbox").addClass("jstree-real-checkbox");
							}
						}
						if(!ts) {
							if(c === "jstree-checked" || $t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.find("li").andSelf().addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
						else {
							if($t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
					});
				});
				if(!ts) {
					obj.find(".jstree-checked").parent().parent().each(function () { _this._repair_state(this); }); 
				}
			},
			change_state : function (obj, state) {
				obj = this._get_node(obj);
				var coll = false, rc = this._get_settings().checkbox.real_checkboxes;
				if(!obj || obj === -1) { return false; }
				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
				if(this._get_settings().checkbox.two_state) {
					if(state) { 
						obj.removeClass("jstree-checked").addClass("jstree-unchecked"); 
						if(rc) { obj.children(":checkbox").prop("checked", false); }
					}
					else { 
						obj.removeClass("jstree-unchecked").addClass("jstree-checked"); 
						if(rc) { obj.children(":checkbox").prop("checked", true); }
					}
				}
				else {
					if(state) { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-checked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); 
						if(rc) { coll.children(":checkbox").prop("checked", false); }
					}
					else { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-unchecked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
						if(rc) { coll.children(":checkbox").prop("checked", true); }
						if(this.data.ui) { this.data.ui.last_selected = obj; }
						this.data.checkbox.last_selected = obj;
					}
					obj.parentsUntil(".jstree", "li").each(function () {
						var $this = $(this);
						if(state) {
							if($this.children("ul").children("li.jstree-checked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
								if(rc) { $this.children(":checkbox").prop("checked", false); }
							}
						}
						else {
							if($this.children("ul").children("li.jstree-unchecked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
								if(rc) { $this.children(":checkbox").prop("checked", true); }
							}
						}
					});
				}
				if(this.data.ui && this.data.checkbox.noui) { this.data.ui.selected = this.get_checked(); }
				this.__callback(obj);
				return true;
			},
			check_node : function (obj) {
				if(this.change_state(obj, false)) { 
					obj = this._get_node(obj);
					if(this._get_settings().checkbox.checked_parent_open) {
						var t = this;
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.__callback({ "obj" : obj }); 
				}
			},
			uncheck_node : function (obj) {
				if(this.change_state(obj, true)) { this.__callback({ "obj" : this._get_node(obj) }); }
			},
			check_all : function () {
				var _this = this, 
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, false);
				});
				this.__callback();
			},
			uncheck_all : function () {
				var _this = this,
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, true);
				});
				this.__callback();
			},

			is_checked : function(obj) {
				obj = this._get_node(obj);
				return obj.length ? obj.is(".jstree-checked") : false;
			},
			get_checked : function (obj, get_all) {
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-checked") : obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
			},
			get_unchecked : function (obj, get_all) { 
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-unchecked") : obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
			},

			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },

			_repair_state : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return; }
				if(this._get_settings().checkbox.two_state) {
					obj.find('li').andSelf().not('.jstree-checked').removeClass('jstree-undetermined').addClass('jstree-unchecked').children(':checkbox').prop('checked', true);
					return;
				}
				var rc = this._get_settings().checkbox.real_checkboxes,
					a = obj.find("> ul > .jstree-checked").length,
					b = obj.find("> ul > .jstree-undetermined").length,
					c = obj.find("> ul > li").length;
				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.change_state(obj, false); } }
				else if(a === 0 && b === 0) { this.change_state(obj, true); }
				else if(a === c) { this.change_state(obj, false); }
				else { 
					obj.parentsUntil(".jstree","li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
					if(rc) { obj.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
				}
			},
			reselect : function () {
				if(this.data.ui && this.data.checkbox.noui) { 
					var _this = this,
						s = this.data.ui.to_select;
					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.deselect_all();
					$.each(s, function (i, val) { _this.check_node(val); });
					this.__callback();
				}
				else { 
					this.__call_old(); 
				}
			},
			save_loaded : function () {
				var _this = this;
				this.data.core.to_load = [];
				this.get_container_ul().find("li.jstree-closed.jstree-undetermined").each(function () {
					if(this.id) { _this.data.core.to_load.push("#" + this.id); }
				});
			}
		}
	});
	$(function() {
		var css_string = '.jstree .jstree-real-checkbox { display:none; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree XML plugin
 * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.vakata.xslt = function (xml, xsl, callback) {
		var rs = "", xm, xs, processor, support;
		// TODO: IE9 no XSLTProcessor, no document.recalc
		if(document.recalc) {
			xm = document.createElement('xml');
			xs = document.createElement('xml');
			xm.innerHTML = xml;
			xs.innerHTML = xsl;
			$("body").append(xm).append(xs);
			setTimeout( (function (xm, xs, callback) {
				return function () {
					callback.call(null, xm.transformNode(xs.XMLDocument));
					setTimeout( (function (xm, xs) { return function () { $(xm).remove(); $(xs).remove(); }; })(xm, xs), 200);
				};
			})(xm, xs, callback), 100);
			return true;
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor === "undefined") {
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			// alert(xml.transformNode());
			// callback.call(null, new XMLSerializer().serializeToString(rs));
			
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
			processor = new XSLTProcessor();
			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
			if(!support) { return false; }
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			if($.isFunction(processor.transformDocument)) {
				rs = document.implementation.createDocument("", "", null);
				processor.transformDocument(xml, xsl, rs, null);
				callback.call(null, new XMLSerializer().serializeToString(rs));
				return true;
			}
			else {
				processor.importStylesheet(xsl);
				rs = processor.transformToFragment(xml, document);
				callback.call(null, $("<div />").append(rs).html());
				return true;
			}
		}
		return false;
	};
	var xsl = {
		'nest' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
			'<xsl:template match="/">' + 
			'	<xsl:call-template name="nodes">' + 
			'		<xsl:with-param name="node" select="/root" />' + 
			'	</xsl:call-template>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<ul>' + 
			'	<xsl:for-each select="$node/item">' + 
			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
			'		<li>' + 
			'			<xsl:attribute name="class">' + 
			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
			'				<xsl:choose>' + 
			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'				</xsl:choose>' + 
			'				<xsl:value-of select="@class" />' + 
			'			</xsl:attribute>' + 
			'			<xsl:for-each select="@*">' + 
			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'				</xsl:if>' + 
			'			</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'			<xsl:for-each select="content/name">' + 
			'				<a>' + 
			'				<xsl:attribute name="href">' + 
			'					<xsl:choose>' + 
			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'					<xsl:otherwise>#</xsl:otherwise>' + 
			'					</xsl:choose>' + 
			'				</xsl:attribute>' + 
			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'				<xsl:for-each select="@*">' + 
			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'					</xsl:if>' + 
			'				</xsl:for-each>' + 
			'					<ins>' + 
			'						<xsl:attribute name="class">jstree-icon ' + 
			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'						</xsl:attribute>' + 
			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'						<xsl:text>&#xa0;</xsl:text>' + 
			'					</ins>' + 
			'					<xsl:copy-of select="./child::node()" />' + 
			'				</a>' + 
			'			</xsl:for-each>' + 
			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
			'		</li>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>',

		'flat' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
			'<xsl:template match="/">' + 
			'	<ul>' + 
			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
			'		<xsl:call-template name="nodes">' + 
			'			<xsl:with-param name="node" select="." />' + 
			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'		</xsl:call-template>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<xsl:param name="is_last" />' + 
			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
			'	<li>' + 
			'	<xsl:attribute name="class">' + 
			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
			'		<xsl:choose>' + 
			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'		</xsl:choose>' + 
			'		<xsl:value-of select="@class" />' + 
			'	</xsl:attribute>' + 
			'	<xsl:for-each select="@*">' + 
			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'		</xsl:if>' + 
			'	</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'	<xsl:for-each select="content/name">' + 
			'		<a>' + 
			'		<xsl:attribute name="href">' + 
			'			<xsl:choose>' + 
			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'			<xsl:otherwise>#</xsl:otherwise>' + 
			'			</xsl:choose>' + 
			'		</xsl:attribute>' + 
			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'		<xsl:for-each select="@*">' + 
			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'			</xsl:if>' + 
			'		</xsl:for-each>' + 
			'			<ins>' + 
			'				<xsl:attribute name="class">jstree-icon ' + 
			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'				</xsl:attribute>' + 
			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'				<xsl:text>&#xa0;</xsl:text>' + 
			'			</ins>' + 
			'			<xsl:copy-of select="./child::node()" />' + 
			'		</a>' + 
			'	</xsl:for-each>' + 
			'	<xsl:if test="$children">' + 
			'		<ul>' + 
			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
			'			<xsl:call-template name="nodes">' + 
			'				<xsl:with-param name="node" select="." />' + 
			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'			</xsl:call-template>' + 
			'		</xsl:for-each>' + 
			'		</ul>' + 
			'	</xsl:if>' + 
			'	</li>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>'
	},
	escape_xml = function(string) {
		return string
			.toString()
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;');
	};
	$.jstree.plugin("xml_data", {
		defaults : { 
			data : false,
			ajax : false,
			xsl : "flat",
			clean_node : false,
			correct_state : true,
			get_skip_empty : false,
			get_include_preamble : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().xml_data;
				obj = this._get_node(obj);
				return obj == -1 || !obj || (!s.ajax && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_xml : function (obj, s_call, e_call) {
				var s = this.get_settings().xml_data,
					error_func = function () {},
					success_func = function () {};

				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							this.parse_xml(s.data, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										this.get_container().children("ul").empty().append(d.children());
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
								}
								else { 
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
							}, this));
						}
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().xml_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj !== -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							d = x.responseText;
							var sf = this.get_settings().xml_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			parse_xml : function (xml, callback) {
				var s = this._get_settings().xml_data;
				$.vakata.xslt(xml, xsl[s.xsl], callback);
			},
			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
				var result = "", 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, lang;
				if(!tp) { tp = "flat"; }
				if(!is_callback) { is_callback = 0; }
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }

				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				if(!is_callback) { 
					if(s.xml_data.get_include_preamble) { 
						result += '<' + '?xml version="1.0" encoding="UTF-8"?' + '>'; 
					}
					result += "<root>"; 
				}
				obj.each(function () {
					result += "<item";
					li = $(this);
					$.each(li_attr, function (i, v) { 
						var t = li.attr(v);
						if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
							result += " " + v + "=\"" + escape_xml((" " + (t || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\""; 
						}
					});
					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
					if(tp === "flat") { result += " parent_id=\"" + escape_xml(is_callback) + "\""; }
					result += ">";
					result += "<content>";
					a = li.children("a");
					a.each(function () {
						tmp1 = $(this);
						lang = false;
						result += "<name";
						if($.inArray("languages", s.plugins) !== -1) {
							$.each(s.languages, function (k, z) {
								if(tmp1.hasClass(z)) { result += " lang=\"" + escape_xml(z) + "\""; lang = z; return false; }
							});
						}
						if(a_attr.length) { 
							$.each(a_attr, function (k, z) {
								var t = tmp1.attr(z);
								if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
									result += " " + z + "=\"" + escape_xml((" " + t || "").replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\"";
								}
							});
						}
						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + '"';
						}
						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","").replace(/'/ig,"").replace(/"/ig,"")) + '"';
						}
						result += ">";
						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
						result += "</name>";
					});
					result += "</content>";
					tmp2 = li[0].id || true;
					li = li.find("> ul > li");
					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
					else { tmp2 = ""; }
					if(tp == "nest") { result += tmp2; }
					result += "</item>";
					if(tp == "flat") { result += tmp2; }
				});
				if(!is_callback) { result += "</root>"; }
				return result;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree search plugin
 * Enables both sync and async search on the tree
 * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
 */
(function ($) {
	$.expr[':'].jstree_contains = function(a,i,m){
		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.expr[':'].jstree_title_contains = function(a,i,m) {
		return (a.getAttribute("title") || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.jstree.plugin("search", {
		__init : function () {
			this.data.search.str = "";
			this.data.search.result = $();
			if(this._get_settings().search.show_only_matches) {
				this.get_container()
					.bind("search.jstree", function (e, data) {
						$(this).children("ul").find("li").hide().removeClass("jstree-last");
						data.rslt.nodes.parentsUntil(".jstree").andSelf().show()
							.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });
					})
					.bind("clear_search.jstree", function () {
						$(this).children("ul").find("li").css("display","").end().end().jstree("clean_node", -1);
					});
			}
		},
		defaults : {
			ajax : false,
			search_method : "jstree_contains", // for case insensitive - jstree_contains
			show_only_matches : false
		},
		_fn : {
			search : function (str, skip_async) {
				if($.trim(str) === "") { this.clear_search(); return; }
				var s = this.get_settings().search, 
					t = this,
					error_func = function () { },
					success_func = function () { };
				this.data.search.str = str;

				if(!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {
					this.search.supress_callback = true;
					error_func = function () { };
					success_func = function (d, t, x) {
						var sf = this.get_settings().search.ajax.success; 
						if(sf) { d = sf.call(this,d,t,x) || d; }
						this.data.search.to_open = d;
						this._search_open();
					};
					s.ajax.context = this;
					s.ajax.error = error_func;
					s.ajax.success = success_func;
					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
					$.ajax(s.ajax);
					return;
				}
				if(this.data.search.result.length) { this.clear_search(); }
				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.search_method) + "(" + this.data.search.str + ")");
				this.data.search.result.addClass("jstree-search").parent().parents(".jstree-closed").each(function () {
					t.open_node(this, false, true);
				});
				this.__callback({ nodes : this.data.search.result, str : str });
			},
			clear_search : function (str) {
				this.data.search.result.removeClass("jstree-search");
				this.__callback(this.data.search.result);
				this.data.search.result = $();
			},
			_search_open : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(this.data.search.to_open.length) {
					$.each(this.data.search.to_open, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.search.to_open = remaining;
						$.each(current, function (i, val) { 
							_this.open_node(val, function () { _this._search_open(true); }); 
						});
						done = false;
					}
				}
				if(done) { this.search(this.data.search.str, true); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree contextmenu plugin
 */
(function ($) {
	$.vakata.context = {
		hide_on_mouseleave : false,

		cnt		: $("<div id='vakata-contextmenu' />"),
		vis		: false,
		tgt		: false,
		par		: false,
		func	: false,
		data	: false,
		rtl		: false,
		show	: function (s, t, x, y, d, p, rtl) {
			$.vakata.context.rtl = !!rtl;
			var html = $.vakata.context.parse(s), h, w;
			if(!html) { return; }
			$.vakata.context.vis = true;
			$.vakata.context.tgt = t;
			$.vakata.context.par = p || t || null;
			$.vakata.context.data = d || null;
			$.vakata.context.cnt
				.html(html)
				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });

			if($.vakata.context.hide_on_mouseleave) {
				$.vakata.context.cnt
					.one("mouseleave", function(e) { $.vakata.context.hide(); });
			}

			h = $.vakata.context.cnt.height();
			w = $.vakata.context.cnt.width();
			if(x + w > $(document).width()) { 
				x = $(document).width() - (w + 5); 
				$.vakata.context.cnt.find("li > ul").addClass("right"); 
			}
			if(y + h > $(document).height()) { 
				y = y - (h + t[0].offsetHeight); 
				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
			}

			$.vakata.context.cnt
				.css({ "left" : x, "top" : y })
				.find("li:has(ul)")
					.bind("mouseenter", function (e) { 
						var w = $(document).width(),
							h = $(document).height(),
							ul = $(this).children("ul").show(); 
						if(w !== $(document).width()) { ul.toggleClass("right"); }
						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
					})
					.bind("mouseleave", function (e) { 
						$(this).children("ul").hide(); 
					})
					.end()
				.css({ "visibility" : "visible" })
				.show();
			$(document).triggerHandler("context_show.vakata");
		},
		hide	: function () {
			$.vakata.context.vis = false;
			$.vakata.context.cnt.attr("class","").css({ "visibility" : "hidden" });
			$(document).triggerHandler("context_hide.vakata");
		},
		parse	: function (s, is_callback) {
			if(!s) { return false; }
			var str = "",
				tmp = false,
				was_sep = true;
			if(!is_callback) { $.vakata.context.func = {}; }
			str += "<ul>";
			$.each(s, function (i, val) {
				if(!val) { return true; }
				$.vakata.context.func[i] = val.action;
				if(!was_sep && val.separator_before) {
					str += "<li class='vakata-separator vakata-separator-before'></li>";
				}
				was_sep = false;
				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
				if(val.submenu) {
					str += "<span style='float:" + ($.vakata.context.rtl ? "left" : "right") + ";'>&raquo;</span>";
				}
				str += val.label + "</a>";
				if(val.submenu) {
					tmp = $.vakata.context.parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "</li>";
				if(val.separator_after) {
					str += "<li class='vakata-separator vakata-separator-after'></li>";
					was_sep = true;
				}
			});
			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
			str += "</ul>";
			$(document).triggerHandler("context_parse.vakata");
			return str.length > 10 ? str : false;
		},
		exec	: function (i) {
			if($.isFunction($.vakata.context.func[i])) {
				// if is string - eval and call it!
				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
				return true;
			}
			else { return false; }
		}
	};
	$(function () {
		var css_string = '' + 
			'#vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
		$.vakata.context.cnt
			.delegate("a","click", function (e) { e.preventDefault(); })
			.delegate("a","mouseup", function (e) {
				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
					$.vakata.context.hide();
				}
				else { $(this).blur(); }
			})
			.delegate("a","mouseover", function () {
				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
			})
			.appendTo("body");
		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
		if(typeof $.hotkeys !== "undefined") {
			$(document)
				.bind("keydown", "up", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "down", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "right", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "left", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "esc", function (e) { 
					$.vakata.context.hide(); 
					e.preventDefault();
				})
				.bind("keydown", "space", function (e) { 
					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
					e.preventDefault();
				});
		}
	});

	$.jstree.plugin("contextmenu", {
		__init : function () {
			this.get_container()
				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(!$(e.currentTarget).hasClass("jstree-loading")) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
						}
					}, this))
				.delegate("a", "click.jstree", $.proxy(function (e) {
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this))
				.bind("destroy.jstree", $.proxy(function () {
						// TODO: move this to descruct method
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this));
			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
		},
		__destroy: function() {
			// unbind global event handlers when last instance is removed
			// (no access to private 'instances' variable from here)
			if($('.jstree').length <= 1) {
				$(document).unbind("context_hide.vakata");	
			}
		},
		defaults : { 
			select_node : false, // requires UI plugin
			show_at_node : true,
			items : { // Could be a function that should return an object like this one
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"label"				: "Create",
					"action"			: function (obj) { this.create(obj); }
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"label"				: "Rename",
					"action"			: function (obj) { this.rename(obj); }
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Delete",
					"action"			: function (obj) { if(this.is_selected(obj)) { this.remove(); } else { this.remove(obj); } }
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : { 
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (obj) { this.cut(obj); }
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (obj) { this.copy(obj); }
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (obj) { this.paste(obj); }
						}
					}
				}
			}
		},
		_fn : {
			show_contextmenu : function (obj, x, y) {
				obj = this._get_node(obj);
				var s = this.get_settings().contextmenu,
					a = obj.children("a:visible:eq(0)"),
					o = false,
					i = false;
				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
					this.deselect_all();
					this.select_node(obj, true);
				}
				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
					o = a.offset();
					x = o.left;
					y = o.top + this.data.core.li_height;
				}
				i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;
				if($.isFunction(i)) { i = i.call(this, obj); }
				this.data.contextmenu = true;
				$.vakata.context.show(i, a, x, y, this, obj, this._get_settings().core.rtl);
				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree types plugin
 * Adds support types of nodes
 * You can set an attribute on each li node, that represents its type.
 * According to the type setting the node may get custom icon/validation rules
 */
(function ($) {
	$.jstree.plugin("types", {
		__init : function () {
			var s = this._get_settings().types;
			this.data.types.attach_to = [];
			this.get_container()
				.bind("init.jstree", $.proxy(function () { 
						var types = s.types, 
							attr  = s.type_attr, 
							icons_css = "", 
							_this = this;

						$.each(types, function (i, tp) {
							$.each(tp, function (k, v) { 
								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
							});
							if(!tp.icon) { return true; }
							if( tp.icon.image || tp.icon.position) {
								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '="' + i + '"] > a > .jstree-icon { '; }
								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
								else				{ icons_css += ' background-position:0 0; '; }
								icons_css += '} ';
							}
						});
						if(icons_css !== "") { $.vakata.css.add_sheet({ 'str' : icons_css, title : "jstree-types" }); }
					}, this))
				.bind("before.jstree", $.proxy(function (e, data) { 
						var s, t, 
							o = this._get_settings().types.use_data ? this._get_node(data.args[0]) : false, 
							d = o && o !== -1 && o.length ? o.data("jstree") : false;
						if(d && d.types && d.types[data.func] === false) { e.stopImmediatePropagation(); return false; }
						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
							if(!data.args[0] || (!data.args[0].tagName && !data.args[0].jquery)) { return; }
							s = this._get_settings().types.types;
							t = this._get_type(data.args[0]);
							if(
								( 
									(s[t] && typeof s[t][data.func] !== "undefined") || 
									(s["default"] && typeof s["default"][data.func] !== "undefined") 
								) && this._check(data.func, data.args[0]) === false
							) {
								e.stopImmediatePropagation();
								return false;
							}
						}
					}, this));
			if(is_ie6) {
				this.get_container()
					.bind("load_node.jstree set_type.jstree", $.proxy(function (e, data) {
							var r = data && data.rslt && data.rslt.obj && data.rslt.obj !== -1 ? this._get_node(data.rslt.obj).parent() : this.get_container_ul(),
								c = false,
								s = this._get_settings().types;
							$.each(s.types, function (i, tp) {
								if(tp.icon && (tp.icon.image || tp.icon.position)) {
									c = i === "default" ? r.find("li > a > .jstree-icon") : r.find("li[" + s.type_attr + "='" + i + "'] > a > .jstree-icon");
									if(tp.icon.image) { c.css("backgroundImage","url(" + tp.icon.image + ")"); }
									c.css("backgroundPosition", tp.icon.position || "0 0");
								}
							});
						}, this));
			}
		},
		defaults : {
			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
			max_children		: -1,
			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
			max_depth			: -1,
			// defines valid node types for the root nodes
			valid_children		: "all",

			// whether to use $.data
			use_data : false, 
			// where is the type stores (the rel attribute of the LI element)
			type_attr : "rel",
			// a list of types
			types : {
				// the default type
				"default" : {
					"max_children"	: -1,
					"max_depth"		: -1,
					"valid_children": "all"

					// Bound functions - you can bind any other function here (using boolean or function)
					//"select_node"	: true
				}
			}
		},
		_fn : {
			_types_notify : function (n, data) {
				if(data.type && this._get_settings().types.use_data) {
					this.set_type(data.type, n);
				}
			},
			_get_type : function (obj) {
				obj = this._get_node(obj);
				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
			},
			set_type : function (str, obj) {
				obj = this._get_node(obj);
				var ret = (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
				if(ret) { this.__callback({ obj : obj, type : str}); }
				return ret;
			},
			_check : function (rule, obj, opts) {
				obj = this._get_node(obj);
				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types, data = false;
				if(obj === -1) { 
					if(!!s[rule]) { v = s[rule]; }
					else { return; }
				}
				else {
					if(t === false) { return; }
					data = s.use_data ? obj.data("jstree") : false;
					if(data && data.types && typeof data.types[rule] !== "undefined") { v = data.types[rule]; }
					else if(!!s.types[t] && typeof s.types[t][rule] !== "undefined") { v = s.types[t][rule]; }
					else if(!!s.types["default"] && typeof s.types["default"][rule] !== "undefined") { v = s.types["default"][rule]; }
				}
				if($.isFunction(v)) { v = v.call(this, obj); }
				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
					// also include the node itself - otherwise if root node it is not checked
					obj.children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
						// check if current depth already exceeds global tree depth
						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
						d = (i === 0) ? v : _this._check(rule, this, false);
						// check if current node max depth is already matched or exceeded
						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
						// otherwise - set the max depth to the current value minus current depth
						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
					});
				}
				return v;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var m  = this._get_move(),
					s  = m.rt._get_settings().types,
					mc = m.rt._check("max_children", m.cr),
					md = m.rt._check("max_depth", m.cr),
					vc = m.rt._check("valid_children", m.cr),
					ch = 0, d = 1, t;

				if(vc === "none") { return false; } 
				if($.isArray(vc) && m.ot && m.ot._get_type) {
					m.o.each(function () {
						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
					});
					if(d === false) { return false; }
				}
				if(s.max_children !== -2 && mc !== -1) {
					ch = m.cr === -1 ? this.get_container().find("> ul > li").not(m.o).length : m.cr.find("> ul > li").not(m.o).length;
					if(ch + m.o.length > mc) { return false; }
				}
				if(s.max_depth !== -2 && md !== -1) {
					d = 0;
					if(md === 0) { return false; }
					if(typeof m.o.d === "undefined") {
						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
						t = m.o;
						while(t.length > 0) {
							t = t.find("> ul > li");
							d ++;
						}
						m.o.d = d;
					}
					if(md - m.o.d < 0) { return false; }
				}
				return true;
			},
			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
					var p  = (typeof position == "string" && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
						s  = this._get_settings().types,
						mc = this._check("max_children", p),
						md = this._check("max_depth", p),
						vc = this._check("valid_children", p),
						ch;
					if(typeof js === "string") { js = { data : js }; }
					if(!js) { js = {}; }
					if(vc === "none") { return false; } 
					if($.isArray(vc)) {
						if(!js.attr || !js.attr[s.type_attr]) { 
							if(!js.attr) { js.attr = {}; }
							js.attr[s.type_attr] = vc[0]; 
						}
						else {
							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
						}
					}
					if(s.max_children !== -2 && mc !== -1) {
						ch = p === -1 ? this.get_container().find("> ul > li").length : p.find("> ul > li").length;
						if(ch + 1 > mc) { return false; }
					}
					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
				}
				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree HTML plugin
 * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("html_data", {
		__init : function () { 
			// this used to use html() and clean the whitespace, but this way any attached data was lost
			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
			// remove white space from LI node - otherwise nodes appear a bit to the right
			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
		},
		defaults : { 
			data : false,
			ajax : false,
			correct_state : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!this._get_settings().html_data.ajax && !$.isFunction(this._get_settings().html_data.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_html : function (obj, s_call, e_call) {
				var d,
					s = this.get_settings().html_data,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							if(d && d !== "" && d.toString && d.toString().replace(/^[\s\n]+$/,"") !== "") {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						}, this));
						break;
					case (!s.data && !s.ajax):
						if(!obj || obj == -1) {
							this.get_container()
								.children("ul").empty()
								.append(this.data.html_data.original_container_html)
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = $(s.data);
							if(!d.is("ul")) { d = $("<ul />").append(d); }
							this.get_container()
								.children("ul").empty().append(d.children())
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						obj = this._get_node(obj);
						error_func = function (x, t, e) {
							var ef = this.get_settings().html_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().html_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							if(d) {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			}
		}
	});
	// include the HTML data plugin by default
	$.jstree.defaults.plugins.push("html_data");
})(jQuery);
//*/

/* 
 * jsTree themeroller plugin
 * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
 */
(function ($) {
	$.jstree.plugin("themeroller", {
		__init : function () {
			var s = this._get_settings().themeroller;
			this.get_container()
				.addClass("ui-widget-content")
				.addClass("jstree-themeroller")
				.delegate("a","mouseenter.jstree", function (e) {
					if(!$(e.currentTarget).hasClass("jstree-loading")) {
						$(this).addClass(s.item_h);
					}
				})
				.delegate("a","mouseleave.jstree", function () {
					$(this).removeClass(s.item_h);
				})
				.bind("init.jstree", $.proxy(function (e, data) { 
						data.inst.get_container().find("> ul > li > .jstree-loading > ins").addClass("ui-icon-refresh");
						this._themeroller(data.inst.get_container().find("> ul > li"));
					}, this))
				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
						this._themeroller();
					}, this))
				.bind("close_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("delete_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.parent);
					}, this))
				.bind("correct_state.jstree", $.proxy(function (e, data) {
						data.rslt.obj
							.children("ins.jstree-icon").removeClass(s.opened + " " + s.closed + " ui-icon").end()
							.find("> a > ins.ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_open + " " + s.item_clsd).addClass(s.item_leaf || "jstree-no-icon");
					}, this))
				.bind("select_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").addClass(s.item_a);
					}, this))
				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_a).removeClass(s.item_a).end()
							.find("a.jstree-clicked").addClass(s.item_a);
					}, this))
				.bind("dehover_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").removeClass(s.item_h);
					}, this))
				.bind("hover_node.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_h).not(data.rslt.obj).removeClass(s.item_h);
						data.rslt.obj.children("a").addClass(s.item_h);
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.o);
						this._themeroller(data.rslt.op);
					}, this));
		},
		__destroy : function () {
			var s = this._get_settings().themeroller,
				c = [ "ui-icon" ];
			$.each(s, function (i, v) {
				v = v.split(" ");
				if(v.length) { c = c.concat(v); }
			});
			this.get_container()
				.removeClass("ui-widget-content")
				.find("." + c.join(", .")).removeClass(c.join(" "));
		},
		_fn : {
			_themeroller : function (obj) {
				var s = this._get_settings().themeroller;
				obj = (!obj || obj == -1) ? this.get_container_ul() : this._get_node(obj);
				obj = (!obj || obj == -1) ? this.get_container_ul() : obj.parent();
				obj
					.find("li.jstree-closed")
						.children("ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_open).addClass(s.item_clsd || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-open")
						.children("ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_clsd).addClass(s.item_open || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-leaf")
						.children("ins.jstree-icon").removeClass(s.closed + " ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_clsd + " " + s.item_open).addClass(s.item_leaf || "jstree-no-icon");
			}
		},
		defaults : {
			"opened"	: "ui-icon-triangle-1-se",
			"closed"	: "ui-icon-triangle-1-e",
			"item"		: "ui-state-default",
			"item_h"	: "ui-state-hover",
			"item_a"	: "ui-state-active",
			"item_open"	: "ui-icon-folder-open",
			"item_clsd"	: "ui-icon-folder-collapsed",
			"item_leaf"	: "ui-icon-document"
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree-themeroller .ui-icon { overflow:visible; } ' + 
			'.jstree-themeroller a { padding:0 2px; } ' + 
			'.jstree-themeroller .jstree-no-icon { display:none; }';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree unique plugin
 * Forces different names amongst siblings (still a bit experimental)
 * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
 */
(function ($) {
	$.jstree.plugin("unique", {
		__init : function () {
			this.get_container()
				.bind("before.jstree", $.proxy(function (e, data) { 
						var nms = [], res = true, p, t;
						if(data.func == "move_node") {
							// obj, ref, position, is_copy, is_prepared, skip_check
							if(data.args[4] === true) {
								if(data.args[0].o && data.args[0].o.length) {
									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o), "move_node");
								}
							}
						}
						if(data.func == "create_node") {
							// obj, position, js, callback, is_loaded
							if(data.args[4] || this._is_loaded(data.args[0])) {
								p = this._get_node(data.args[0]);
								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
									p = this._get_parent(data.args[0]);
									if(!p || p === -1) { p = this.get_container(); }
								}
								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_string("new_node")); }
								else { nms.push(data.args[2].data); }
								res = this._check_unique(nms, p.find("> ul > li"), "create_node");
							}
						}
						if(data.func == "rename_node") {
							// obj, val
							nms.push(data.args[1]);
							t = this._get_node(data.args[0]);
							p = this._get_parent(t);
							if(!p || p === -1) { p = this.get_container(); }
							res = this._check_unique(nms, p.find("> ul > li").not(t), "rename_node");
						}
						if(!res) {
							e.stopPropagation();
							return false;
						}
					}, this));
		},
		defaults : { 
			error_callback : $.noop
		},
		_fn : { 
			_check_unique : function (nms, p, func) {
				var cnms = [], ok = true;
				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
				if(!cnms.length || !nms.length) { return true; }
				$.each(nms, function (i, v) {
					if($.inArray(v, cnms) !== -1) {
						ok = false;
						return false;
					}
				});
				if(!ok) {
					this._get_settings().unique.error_callback.call(null, nms, p, func);
				}
				return ok;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var p = this._get_move(), nms = [];
				if(p.o && p.o.length) {
					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
					return this._check_unique(nms, p.np.find("> ul > li").not(p.o), "check_move");
				}
				return true;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree wholerow plugin
 * Makes select and hover work on the entire width of the node
 * MAY BE HEAVY IN LARGE DOM
 */
(function ($) {
	$.jstree.plugin("wholerow", {
		__init : function () {
			if(!this.data.ui) { throw "jsTree wholerow: jsTree UI plugin not included."; }
			this.data.wholerow.html = false;
			this.data.wholerow.to = false;
			this.get_container()
				.bind("init.jstree", $.proxy(function (e, data) { 
						this._get_settings().core.animation = 0;
					}, this))
				.bind("open_node.jstree create_node.jstree clean_node.jstree loaded.jstree", $.proxy(function (e, data) { 
						this._prepare_wholerow_span( data && data.rslt && data.rslt.obj ? data.rslt.obj : -1 );
					}, this))
				.bind("search.jstree clear_search.jstree reopen.jstree after_open.jstree after_close.jstree create_node.jstree delete_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
						if(this.data.to) { clearTimeout(this.data.to); }
						this.data.to = setTimeout( (function (t, o) { return function() { t._prepare_wholerow_ul(o); }; })(this,  data && data.rslt && data.rslt.obj ? data.rslt.obj : -1), 0);
					}, this))
				.bind("deselect_all.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-clicked").removeClass("jstree-clicked " + (this.data.themeroller ? this._get_settings().themeroller.item_a : "" ));
					}, this))
				.bind("select_node.jstree deselect_node.jstree ", $.proxy(function (e, data) { 
						data.rslt.obj.each(function () { 
							var ref = data.inst.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt((($(this).offset().top - data.inst.get_container().offset().top + data.inst.get_container()[0].scrollTop) / data.inst.data.core.li_height),10)) + ")");
							// ref.children("a")[e.type === "select_node" ? "addClass" : "removeClass"]("jstree-clicked");
							ref.children("a").attr("class",data.rslt.obj.children("a").attr("class"));
						});
					}, this))
				.bind("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-hovered").removeClass("jstree-hovered " + (this.data.themeroller ? this._get_settings().themeroller.item_h : "" ));
						if(e.type === "hover_node") {
							var ref = this.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt(((data.rslt.obj.offset().top - this.get_container().offset().top + this.get_container()[0].scrollTop) / this.data.core.li_height),10)) + ")");
							// ref.children("a").addClass("jstree-hovered");
							ref.children("a").attr("class",data.rslt.obj.children(".jstree-hovered").attr("class"));
						}
					}, this))
				.delegate(".jstree-wholerow-span, ins.jstree-icon, li", "click.jstree", function (e) {
						var n = $(e.currentTarget);
						if(e.target.tagName === "A" || (e.target.tagName === "INS" && n.closest("li").is(".jstree-open, .jstree-closed"))) { return; }
						n.closest("li").children("a:visible:eq(0)").click();
						e.stopImmediatePropagation();
					})
				.delegate("li", "mouseover.jstree", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if($(e.currentTarget).children(".jstree-hovered, .jstree-clicked").length) { return false; }
						this.hover_node(e.currentTarget);
						return false;
					}, this))
				.delegate("li", "mouseleave.jstree", $.proxy(function (e) {
						if($(e.currentTarget).children("a").hasClass("jstree-hovered").length) { return; }
						this.dehover_node(e.currentTarget);
					}, this));
			if(is_ie7 || is_ie6) {
				$.vakata.css.add_sheet({ str : ".jstree-" + this.get_index() + " { position:relative; } ", title : "jstree" });
			}
		},
		defaults : {
		},
		__destroy : function () {
			this.get_container().children(".jstree-wholerow").remove();
			this.get_container().find(".jstree-wholerow-span").remove();
		},
		_fn : {
			_prepare_wholerow_span : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				obj.each(function () {
					$(this).find("li").andSelf().each(function () {
						var $t = $(this);
						if($t.children(".jstree-wholerow-span").length) { return true; }
						$t.prepend("<span class='jstree-wholerow-span' style='width:" + ($t.parentsUntil(".jstree","li").length * 18) + "px;'>&#160;</span>");
					});
				});
			},
			_prepare_wholerow_ul : function () {
				var o = this.get_container().children("ul").eq(0), h = o.html();
				o.addClass("jstree-wholerow-real");
				if(this.data.wholerow.last_html !== h) {
					this.data.wholerow.last_html = h;
					this.get_container().children(".jstree-wholerow").remove();
					this.get_container().append(
						o.clone().removeClass("jstree-wholerow-real")
							.wrapAll("<div class='jstree-wholerow' />").parent()
							.width(o.parent()[0].scrollWidth)
							.css("top", (o.height() + ( is_ie7 ? 5 : 0)) * -1 )
							.find("li[id]").each(function () { this.removeAttribute("id"); }).end()
					);
				}
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree .jstree-wholerow-real { position:relative; z-index:1; } ' + 
			'.jstree .jstree-wholerow-real li { cursor:pointer; } ' + 
			'.jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } ' + 
			'.jstree .jstree-wholerow { position:relative; z-index:0; height:0; } ' + 
			'.jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }' + 
			'.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }' + 
			'.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } ' + 
			'.jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }';
		if(is_ff2) {
			css_string += '' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; margin:0; padding:0; border:0; } ' + 
				'.jstree .jstree-wholerow-real a { border-color:transparent !important; } ';
		}
		if(is_ie7 || is_ie6) {
			css_string += '' + 
				'.jstree .jstree-wholerow, .jstree .jstree-wholerow li, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow a { margin:0; padding:0; line-height:18px; } ' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; line-height:18px; overflow:hidden; } ';
		}
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/*
* jsTree model plugin
* This plugin gets jstree to use a class model to retrieve data, creating great dynamism
*/
(function ($) {
	var nodeInterface = ["getChildren","getChildrenCount","getAttr","getName","getProps"],
		validateInterface = function(obj, inter) {
			var valid = true;
			obj = obj || {};
			inter = [].concat(inter);
			$.each(inter, function (i, v) {
				if(!$.isFunction(obj[v])) { valid = false; return false; }
			});
			return valid;
		};
	$.jstree.plugin("model", {
		__init : function () {
			if(!this.data.json_data) { throw "jsTree model: jsTree json_data plugin not included."; }
			this._get_settings().json_data.data = function (n, b) {
				var obj = (n == -1) ? this._get_settings().model.object : n.data("jstree_model");
				if(!validateInterface(obj, nodeInterface)) { return b.call(null, false); }
				if(this._get_settings().model.async) {
					obj.getChildren($.proxy(function (data) {
						this.model_done(data, b);
					}, this));
				}
				else {
					this.model_done(obj.getChildren(), b);
				}
			};
		},
		defaults : {
			object : false,
			id_prefix : false,
			async : false
		},
		_fn : {
			model_done : function (data, callback) {
				var ret = [], 
					s = this._get_settings(),
					_this = this;

				if(!$.isArray(data)) { data = [data]; }
				$.each(data, function (i, nd) {
					var r = nd.getProps() || {};
					r.attr = nd.getAttr() || {};
					if(nd.getChildrenCount()) { r.state = "closed"; }
					r.data = nd.getName();
					if(!$.isArray(r.data)) { r.data = [r.data]; }
					if(_this.data.types && $.isFunction(nd.getType)) {
						r.attr[s.types.type_attr] = nd.getType();
					}
					if(r.attr.id && s.model.id_prefix) { r.attr.id = s.model.id_prefix + r.attr.id; }
					if(!r.metadata) { r.metadata = { }; }
					r.metadata.jstree_model = nd;
					ret.push(r);
				});
				callback.call(null, ret);
			}
		}
	});
})(jQuery);
//*/

})();
},{}],"i18n":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var i18n = function () {
	function i18n() {
		_classCallCheck(this, i18n);

		this.currentLocale = null;
		this.defaultLocale = 'en_US';
		this.lang = {};
	}

	_createClass(i18n, [{
		key: 'setLocale',
		value: function setLocale(locale) {
			this.currentLocale = locale;
		}
	}, {
		key: 'getLocale',
		value: function getLocale() {
			return this.currentLocale !== null ? this.currentLocale : this.defaultLocale;
		}
	}, {
		key: '_t',
		value: function _t(entity, fallbackString, priority, context) {
			var langName = this.getLocale().replace(/_[\w]+/i, '');
			var defaultlangName = this.defaultLocale.replace(/_[\w]+/i, '');

			if (this.lang && this.lang[this.getLocale()] && this.lang[this.getLocale()][entity]) {
				return this.lang[this.getLocale()][entity];
			} else if (this.lang && this.lang[langName] && this.lang[langName][entity]) {
				return this.lang[langName][entity];
			} else if (this.lang && this.lang[this.defaultLocale] && this.lang[this.defaultLocale][entity]) {
				return this.lang[this.defaultLocale][entity];
			} else if (this.lang && this.lang[defaultlangName] && this.lang[defaultlangName][entity]) {
				return this.lang[defaultlangName][entity];
			} else if (fallbackString) {
				return fallbackString;
			} else {
				return '';
			}
		}
	}, {
		key: 'addDictionary',
		value: function addDictionary(locale, dict) {
			if (typeof this.lang[locale] === 'undefined') {
				this.lang[locale] = {};
			}

			for (var entity in dict) {
				this.lang[locale][entity] = dict[entity];
			}
		}
	}, {
		key: 'getDictionary',
		value: function getDictionary(locale) {
			return this.lang[locale];
		}
	}, {
		key: 'stripStr',
		value: function stripStr(str) {
			return str.replace(/^\s*/, '').replace(/\s*$/, '');
		}
	}, {
		key: 'stripStrML',
		value: function stripStrML(str) {
			var parts = str.split('\n');

			for (var i = 0; i < parts.length; i += 1) {
				parts[i] = stripStr(parts[i]);
			}

			return stripStr(parts.join(' '));
		}
	}, {
		key: 'sprintf',
		value: function sprintf(s) {
			for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				params[_key - 1] = arguments[_key];
			}

			if (params.length === 0) {
				return s;
			}

			var regx = new RegExp('(.?)(%s)', 'g');

			var i = 0;

			return s.replace(regx, function (match, subMatch1, subMatch2, offset, string) {
				if (subMatch1 === '%') {
					return match;
				}

				return subMatch1 + params[i += 1];
			});
		}
	}, {
		key: 'inject',
		value: function inject(s, map) {
			var regx = new RegExp('\{([A-Za-z0-9_]*)\}', 'g');

			return s.replace(regx, function (match, key, offset, string) {
				return map[key] ? map[key] : match;
			});
		}
	}, {
		key: 'detectLocale',
		value: function detectLocale() {
			var rawLocale;
			var detectedLocale;

			rawLocale = jQuery('body').attr('lang');

			if (!rawLocale) {
				var metas = document.getElementsByTagName('meta');

				for (var i = 0; i < metas.length; i++) {
					if (metas[i].attributes['http-equiv'] && metas[i].attributes['http-equiv'].nodeValue.toLowerCase() == 'content-language') {
						rawLocale = metas[i].attributes['content'].nodeValue;
					}
				}
			}

			if (!rawLocale) {
				rawLocale = this.defaultLocale;
			}

			var rawLocaleParts = rawLocale.match(/([^-|_]*)[-|_](.*)/);

			if (rawLocale.length == 2) {
				for (var compareLocale in i18n.lang) {
					if (compareLocale.substr(0, 2).toLowerCase() == rawLocale.toLowerCase()) {
						detectedLocale = compareLocale;
						break;
					}
				}
			} else if (rawLocaleParts) {
				detectedLocale = rawLocaleParts[1].toLowerCase() + '_' + rawLocaleParts[2].toUpperCase();
			}

			return detectedLocale;
		}
	}, {
		key: 'addEvent',
		value: function addEvent(obj, evType, fn, useCapture) {
			if (obj.addEventListener) {
				obj.addEventListener(evType, fn, useCapture);
				return true;
			} else if (obj.attachEvent) {
				return obj.attachEvent('on' + evType, fn);
			} else {
				console.log('Handler could not be attached');
			}
		}
	}]);

	return i18n;
}();

var _i18n = new i18n();

window.ss = typeof window.ss !== 'undefined' ? window.ss : {};
window.ss.i18n = window.i18n = _i18n;

exports.default = _i18n;

},{}],"jQuery":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jQuery = typeof window.jQuery !== 'undefined' ? window.jQuery : null;

exports.default = jQuery;

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhZG1pbi9qYXZhc2NyaXB0L3NyYy9idW5kbGVzL2xpYi5qcyIsImFkbWluL2phdmFzY3JpcHQvc3JjL3NzcGF0aC5qcyIsImFkbWluL2phdmFzY3JpcHQvc3JjL3NzdWkuY29yZS5qcyIsImFkbWluL3RoaXJkcGFydHkvY2hvc2VuL2Nob3Nlbi9jaG9zZW4uanF1ZXJ5LmpzIiwiYWRtaW4vdGhpcmRwYXJ0eS9oaXN0b3J5LWpzL3NjcmlwdHMvdW5jb21wcmVzc2VkL2hpc3RvcnkuYWRhcHRlci5qcXVlcnkuanMiLCJhZG1pbi90aGlyZHBhcnR5L2hpc3RvcnktanMvc2NyaXB0cy91bmNvbXByZXNzZWQvaGlzdG9yeS5odG1sNC5qcyIsImFkbWluL3RoaXJkcGFydHkvaGlzdG9yeS1qcy9zY3JpcHRzL3VuY29tcHJlc3NlZC9oaXN0b3J5LmpzIiwiYWRtaW4vdGhpcmRwYXJ0eS9qbGF5b3V0L2xpYi9qbGF5b3V0LmJvcmRlci5qcyIsImFkbWluL3RoaXJkcGFydHkvamxheW91dC9saWIvanF1ZXJ5LmpsYXlvdXQuanMiLCJhZG1pbi90aGlyZHBhcnR5L2pxdWVyeS1ob3ZlckludGVudC9qcXVlcnkuaG92ZXJJbnRlbnQuanMiLCJhZG1pbi90aGlyZHBhcnR5L2pxdWVyeS1ub3RpY2UvanF1ZXJ5Lm5vdGljZS5qcyIsImFkbWluL3RoaXJkcGFydHkvanNpemVzL2xpYi9qcXVlcnkuc2l6ZXMuanMiLCJqYXZhc2NyaXB0L3NyYy9EYXRlRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9HcmlkRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9IdG1sRWRpdG9yRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9UYWJTZXQuanMiLCJqYXZhc2NyaXB0L3NyYy9UcmVlRHJvcGRvd25GaWVsZC5qcyIsInRoaXJkcGFydHkvanF1ZXJ5LWNoYW5nZXRyYWNrZXIvbGliL2pxdWVyeS5jaGFuZ2V0cmFja2VyLmpzIiwidGhpcmRwYXJ0eS9qcXVlcnktY29va2llL2pxdWVyeS5jb29raWUuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1lbnR3aW5lL2Rpc3QvanF1ZXJ5LmVudHdpbmUtZGlzdC5qcyIsInRoaXJkcGFydHkvanF1ZXJ5LWZvcm0vanF1ZXJ5LmZvcm0uanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1vbmRlbWFuZC9qcXVlcnkub25kZW1hbmQuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1xdWVyeS9qcXVlcnkucXVlcnkuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS11aS9qcXVlcnktdWkuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS9qcXVlcnkuanMiLCJ0aGlyZHBhcnR5L2pzb24tanMvanNvbjIuanMiLCJ0aGlyZHBhcnR5L2pzdHJlZS9qcXVlcnkuanN0cmVlLmpzIiwiamF2YXNjcmlwdC9zcmMvaTE4bi5qcyIsImphdmFzY3JpcHQvc3JjL2pRdWVyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsUUFBUSx5Q0FBUjtBQUNBLFFBQVEsMkRBQVI7QUFDQSxRQUFRLHFCQUFSO0FBQ0EsUUFBUSwrQ0FBUjtBQUNBLFFBQVEseUNBQVI7QUFDQSxRQUFRLG1FQUFSO0FBQ0EsUUFBUSx1REFBUjtBQUNBLFFBQVEscURBQVI7QUFDQSxRQUFRLG1EQUFSO0FBQ0EsUUFBUSxvREFBUjtBQUNBLFFBQVEsZ0RBQVI7QUFDQSxRQUFRLG1EQUFSO0FBQ0EsUUFBUSxtREFBUjtBQUNBLFFBQVEsZ0VBQVI7QUFDQSxRQUFRLCtFQUFSO0FBQ0EsUUFBUSxzRUFBUjtBQUNBLFFBQVEsZ0RBQVI7QUFDQSxRQUFRLG9EQUFSO0FBQ0EsUUFBUSw4REFBUjtBQUNBLFFBQVEseUVBQVI7QUFDQSxRQUFRLGlEQUFSO0FBQ0EsUUFBUSx5Q0FBUjtBQUNBLFFBQVEsK0NBQVI7QUFDQSxRQUFRLHNDQUFSO0FBQ0EsUUFBUSx3QkFBUjtBQUNBLFFBQVEseUNBQVI7Ozs7Ozs7Ozs7O0FDREEsSUFBSSxVQUFVLHNCQUFHLE1BQUgsQ0FBVjtJQUNILFFBQVEsc0JBQUcsTUFBSCxDQUFSO0lBQ0EsUUFBUSxzQkFBRyxNQUFILENBQVI7SUFHQSxPQUFPO0FBMkJOLGFBQVksa0xBQVo7O0FBSUEsV0FBVSxrQkFBVSxHQUFWLEVBQWdCO0FBR3pCLE1BQUssaUJBQUUsSUFBRixDQUFRLEdBQVIsTUFBa0IsUUFBbEIsRUFBNkI7QUFDakMsVUFBTyxHQUFQLENBRGlDO0dBQWxDOztBQUlBLE1BQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBc0IsT0FBTyxFQUFQLENBQXRCLElBQXFDLEVBQXJDLENBUFc7O0FBYXhCLFNBQU87QUFDTixTQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGVBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsaUJBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsV0FBYyxRQUFVLENBQVYsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGdCQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGNBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsYUFBYyxRQUFVLENBQVYsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLFNBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsYUFBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7QUFDZCxTQUFjLFFBQVMsRUFBVCxLQUFpQixFQUFqQjtBQUNkLGFBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsY0FBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVMsRUFBVCxLQUFpQixFQUFqQjtBQUNkLFdBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsU0FBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7R0FqQmYsQ0Fid0I7RUFBaEI7O0FBcUNWLG1CQUFrQiwwQkFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTZCO0FBQzlDLE1BQUssV0FBVyxRQUFRLE1BQVIsQ0FBZ0IsQ0FBaEIsTUFBd0IsR0FBeEIsRUFBOEI7QUFDN0MsVUFBTyxPQUFQLENBRDZDO0dBQTlDOztBQUlBLFlBQVUsV0FBVyxFQUFYLENBTG9DO0FBTTlDLFlBQVUsVUFBVSxRQUFRLE9BQVIsQ0FBaUIseUJBQWpCLEVBQTRDLEVBQTVDLENBQVYsR0FBNkQsRUFBN0QsQ0FOb0M7O0FBUTlDLE1BQUksV0FBVyxVQUFVLFFBQVEsS0FBUixDQUFlLEdBQWYsQ0FBVixHQUFpQyxFQUFqQztNQUNkLFdBQVcsUUFBUSxLQUFSLENBQWUsR0FBZixDQUFYLENBVDZDO0FBVTlDLE9BQU0sSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLFNBQVMsTUFBVCxFQUFpQixHQUF0QyxFQUE0QztBQUMzQyxPQUFJLElBQUksU0FBVSxDQUFWLENBQUosQ0FEdUM7QUFFM0MsV0FBUyxDQUFUO0FBQ0MsU0FBSyxHQUFMO0FBQ0MsV0FERDtBQURELFNBR00sSUFBTDtBQUNDLFNBQUssU0FBUyxNQUFULEVBQWtCO0FBQ3RCLGVBQVMsR0FBVCxHQURzQjtNQUF2QjtBQUdBLFdBSkQ7QUFIRDtBQVNFLGNBQVMsSUFBVCxDQUFlLENBQWYsRUFERDtBQUVDLFdBRkQ7QUFSRCxJQUYyQztHQUE1QztBQWVBLFNBQU8sTUFBTSxTQUFTLElBQVQsQ0FBZSxHQUFmLENBQU4sQ0F6QnVDO0VBQTdCOztBQTZCbEIsZUFBYyxzQkFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTZCO0FBQzFDLFNBQU8sS0FBSyxRQUFMLENBQWUsT0FBZixFQUF5QixNQUF6QixLQUFvQyxLQUFLLFFBQUwsQ0FBZSxPQUFmLEVBQXlCLE1BQXpCLENBREQ7RUFBN0I7O0FBS2QsZ0JBQWUsdUJBQVUsR0FBVixFQUFnQjtBQUU5QixTQUFPLEtBQUssUUFBTCxDQUFlLEdBQWYsRUFBcUIsUUFBckIsS0FBa0MsRUFBbEMsQ0FGdUI7RUFBaEI7O0FBTWYsZ0JBQWUsdUJBQVUsR0FBVixFQUFnQjtBQUM5QixTQUFPLEtBQUssUUFBTCxDQUFlLEdBQWYsRUFBcUIsUUFBckIsS0FBa0MsRUFBbEMsQ0FEdUI7RUFBaEI7O0FBTWYsa0JBQWlCLHlCQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMkI7QUFDM0MsTUFBSyxDQUFDLEtBQUssYUFBTCxDQUFvQixNQUFwQixDQUFELEVBQWdDO0FBQ3BDLFVBQU8sTUFBUCxDQURvQztHQUFyQzs7QUFJQSxNQUFJLFNBQVMsS0FBSyxRQUFMLENBQWUsTUFBZixDQUFUO01BQ0gsU0FBUyxLQUFLLFFBQUwsQ0FBZSxNQUFmLENBQVQ7TUFDQSxXQUFXLE9BQU8sUUFBUCxJQUFtQixPQUFPLFFBQVA7TUFDOUIsY0FBYyxPQUFPLFFBQVAsR0FBa0IsT0FBTyxXQUFQLEdBQXVCLE9BQU8sV0FBUCxJQUFzQixPQUFPLFdBQVA7TUFDN0UsWUFBWSxPQUFPLFNBQVAsSUFBb0IsT0FBTyxTQUFQO01BQ2hDLFVBQVUsT0FBTyxRQUFQLEtBQW9CLEVBQXBCO01BQ1YsV0FBVyxLQUFLLGdCQUFMLENBQXVCLE9BQU8sUUFBUCxJQUFtQixPQUFPLFFBQVAsRUFBaUIsT0FBTyxRQUFQLENBQXRFO01BQ0EsU0FBUyxPQUFPLE1BQVAsSUFBbUIsQ0FBQyxPQUFELElBQVksT0FBTyxNQUFQLElBQW1CLEVBQWxEO01BQ1QsT0FBTyxPQUFPLElBQVAsQ0FibUM7O0FBZTNDLFNBQU8sV0FBVyxXQUFYLEdBQXlCLFNBQXpCLEdBQXFDLFFBQXJDLEdBQWdELE1BQWhELEdBQXlELElBQXpELENBZm9DO0VBQTNCOztBQW9CakIsa0JBQWlCLHlCQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXdCO0FBQ3hDLE1BQUksSUFBSSxLQUFLLFFBQUwsQ0FBZSxHQUFmLENBQUo7TUFDSCxTQUFTLE9BQVMsTUFBUCxLQUFrQixRQUFsQixHQUErQixLQUFLLG9CQUFMLENBQTJCLE1BQTNCLENBQWpDLEdBQXVFLE1BQXZFO01BQ1QsWUFBWSxpQkFBRSxNQUFGLENBQVUsS0FBSyxvQkFBTCxDQUEyQixFQUFFLE1BQUYsQ0FBckMsRUFBaUQsTUFBakQsQ0FBWixDQUh1QztBQUl4QyxTQUFPLEVBQUUsWUFBRixHQUFpQixHQUFqQixHQUF1QixpQkFBRSxLQUFGLENBQVMsU0FBVCxDQUF2QixJQUFnRCxFQUFFLElBQUYsSUFBVSxFQUFWLENBQWhELENBSmlDO0VBQXhCOztBQVFqQixrQkFBaUIseUJBQVMsR0FBVCxFQUFjO0FBQzlCLE1BQUksSUFBSSxLQUFLLFFBQUwsQ0FBZSxHQUFmLENBQUosQ0FEMEI7QUFFOUIsU0FBTyxLQUFLLG9CQUFMLENBQTJCLEVBQUUsTUFBRixDQUFsQyxDQUY4QjtFQUFkOztBQVFqQix1QkFBc0IsOEJBQVMsTUFBVCxFQUFpQjtBQUN0QyxNQUFJLFNBQVMsRUFBVDtNQUNILFNBQVMsT0FBTyxPQUFQLENBQWdCLEtBQWhCLEVBQXVCLEVBQXZCLENBQVQ7TUFDQSxRQUFRLFNBQVMsT0FBTyxLQUFQLENBQWMsR0FBZCxDQUFULEdBQStCLEVBQS9CO01BQW1DLENBRjVDO01BRStDLEdBRi9DLENBRHNDO0FBSXRDLE9BQUksSUFBRSxDQUFGLEVBQUssSUFBSSxNQUFNLE1BQU4sRUFBYyxHQUEzQixFQUFnQztBQUMvQixTQUFNLE1BQU0sQ0FBTixFQUFTLEtBQVQsQ0FBZ0IsR0FBaEIsQ0FBTixDQUQrQjtBQUUvQixVQUFPLElBQUksQ0FBSixDQUFQLElBQWlCLElBQUksQ0FBSixDQUFqQixDQUYrQjtHQUFoQztBQUlBLFNBQU8sTUFBUCxDQVJzQztFQUFqQjs7QUFXdEIsc0JBQXFCLDZCQUFVLE1BQVYsRUFBbUI7QUFDdkMsTUFBSSxJQUFJLEtBQUssUUFBTCxDQUFlLE1BQWYsQ0FBSixDQURtQztBQUV2QyxNQUFLLEtBQUssY0FBTCxDQUFxQixDQUFyQixDQUFMLEVBQWdDO0FBRy9CLFVBQU8sRUFBRSxJQUFGLENBQU8sS0FBUCxDQUFjLGFBQWQsRUFBOEIsQ0FBOUIsRUFBaUMsT0FBakMsQ0FBMEMsSUFBMUMsRUFBZ0QsRUFBaEQsQ0FBUCxDQUgrQjtHQUFoQyxNQUlPLElBQUssS0FBSyxZQUFMLENBQW1CLENBQW5CLEVBQXNCLFFBQXRCLENBQUwsRUFBd0M7QUFDOUMsVUFBTyxFQUFFLFVBQUYsQ0FBYSxPQUFiLENBQXNCLFNBQVMsTUFBVCxFQUFpQixFQUF2QyxDQUFQLENBRDhDO0dBQXhDO0FBR1AsU0FBTyxNQUFQLENBVHVDO0VBQW5COztBQWFyQixNQUFLLGFBQVUsT0FBVixFQUFvQjtBQUN4QixNQUFJLFlBQVksU0FBWixFQUF3QjtBQUMzQixhQUFVLFNBQVMsSUFBVCxDQURpQjtHQUE1QjtBQUdBLFNBQU8sS0FBSyxTQUFMLENBQWdCLE9BQWhCLEVBQTBCLE9BQTFCLENBQW1DLGtCQUFuQyxFQUF1RCxFQUF2RCxDQUFQLENBSndCO0VBQXBCOztBQVFMLGNBQWEscUJBQVUsSUFBVixFQUFpQjtBQUM3QixNQUFJLFdBQVcsTUFBTSxpQkFBRSxNQUFGLENBQVMsYUFBVCxDQURRO0FBRTdCLFNBQU8sUUFBUSxLQUFLLEtBQUwsQ0FBWSxRQUFaLEVBQXVCLENBQXZCLEVBQTBCLEtBQTFCLENBQWlDLGFBQWpDLEVBQWlELENBQWpELENBQVIsQ0FGc0I7RUFBakI7O0FBTWIsTUFBSyxhQUFVLElBQVYsRUFBaUI7QUFDckIsV0FBUyxJQUFULEdBQWdCLElBQWhCLENBRHFCO0VBQWpCOztBQU1MLFNBQVEsZ0JBQVUsR0FBVixFQUFnQjtBQUN2QixTQUFPLE1BQVMsSUFBVCxDQUFlLEdBQWYsQ0FBUDtJQUR1QjtFQUFoQjs7QUFLUixRQUFPLGVBQVUsR0FBVixFQUFnQjtBQUN0QixTQUFPLElBQUksT0FBSixDQUFhLFNBQVMsTUFBVCxFQUFpQixFQUE5QixDQUFQLENBRHNCO0VBQWhCOztBQUtQLFlBQVcsbUJBQVUsR0FBVixFQUFnQjtBQUMxQixTQUFPLElBQUksT0FBSixDQUFhLElBQWIsRUFBbUIsRUFBbkIsQ0FBUCxDQUQwQjtFQUFoQjs7QUFLWCxZQUFXLG1CQUFVLElBQVYsRUFBaUI7QUFDM0IsU0FBTyxLQUFLLFNBQUwsQ0FBZ0IsS0FBSyxPQUFMLENBQWMsT0FBZCxFQUF1QixFQUF2QixFQUE0QixPQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxFQUFwRCxDQUFoQixDQUFQLENBRDJCO0VBQWpCOztBQU1YLGFBQVksb0JBQVUsR0FBVixFQUFnQjtBQUMzQixNQUFJLElBQUksS0FBSyxRQUFMLENBQWUsR0FBZixDQUFKLENBRHVCO0FBRTNCLFNBQU8sRUFBRSxRQUFGLElBQWMsRUFBRSxNQUFGLEtBQWEsU0FBUyxNQUFULEdBQWtCLElBQTdDLEdBQW9ELEtBQXBELENBRm9CO0VBQWhCOztBQUtaLGNBQWEscUJBQVUsR0FBVixFQUFnQjtBQUM1QixTQUFPLGFBQWdCLElBQWhCLENBQXNCLEdBQXRCLENBQVA7SUFENEI7RUFBaEI7Q0E1TmQ7O0FBaU9ELGlCQUFFLElBQUYsR0FBUyxJQUFUOzs7Ozs7Ozs7OztBQ3BQQSxpQkFBRSxNQUFGLENBQVMsYUFBVCxFQUF3QixpQkFBRSxFQUFGLENBQUssTUFBTCxFQUFhO0FBQ3BDLFVBQVM7QUFDUixhQUFXO0FBQ1YsU0FBTSxJQUFOO0FBQ0EsU0FBTSxJQUFOO0dBRkQ7QUFJQSxvQkFBa0IsS0FBbEI7RUFMRDs7QUFXQSxrQkFBaUIsMkJBQVc7QUFDM0IsTUFBSSxLQUFLLFFBQUwsQ0FBYyxtQkFBZCxNQUFxQyxLQUFyQyxFQUE0QyxPQUFoRDs7QUFHQSxNQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixJQUErQixDQUFDLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsRUFBNkIsT0FBbEU7O0FBRUEsT0FBSyxPQUFMLENBQWEsZ0JBQWIsR0FBZ0MsQ0FBQyxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQU5OO0FBTzNCLE9BQUssT0FBTCxHQVAyQjtFQUFYOztBQWFqQixvQkFBbUIsNkJBQVc7QUFDN0IsT0FBSyxRQUFMLENBQWMsd0JBQWQsRUFENkI7O0FBSTdCLE1BQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLElBQStCLENBQUMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixFQUE2QixPQUFsRTs7QUFFQSxNQUFJLEtBQUssT0FBTCxDQUFhLGdCQUFiLEVBQStCO0FBQ2xDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IseUJBQWxCLEVBQTZDLElBQTdDLEdBRGtDO0FBRWxDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsaUJBQWxCLEVBQXFDLElBQXJDLEdBRmtDO0FBR2xDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSGtDO0FBSWxDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSmtDO0dBQW5DLE1BTUs7QUFDSixRQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLHlCQUFsQixFQUE2QyxJQUE3QyxHQURJO0FBRUosUUFBSyxPQUFMLENBQWEsSUFBYixDQUFrQixpQkFBbEIsRUFBcUMsSUFBckMsR0FGSTtBQUdKLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSEk7QUFJSixRQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxJQUEvQyxHQUpJO0dBTkw7O0FBYUEsT0FBSyxRQUFMLENBQWMsdUJBQWQsRUFuQjZCO0VBQVg7O0FBMEJuQixlQUFjLHdCQUFXO0FBQ3hCLE1BQUksY0FBYyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLGNBQWxCLENBQWQ7TUFDSCxnQkFBZ0IsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixnQkFBbEIsQ0FBaEIsQ0FGdUI7O0FBSXhCLE1BQUksQ0FBQyxXQUFELEVBQWMsY0FBYyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLE1BQWxCLENBQWQsQ0FBbEI7O0FBR0EsTUFBRyxXQUFILEVBQWdCLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsT0FBbkIsR0FBNkIsY0FBYyxXQUFkLENBQTdDO0FBQ0EsTUFBRyxhQUFILEVBQWtCLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsU0FBbkIsR0FBK0IsY0FBYyxhQUFkLENBQWpEOztBQUVBLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixZQUF0QixDQUFtQyxJQUFuQyxDQUF3QyxJQUF4QyxFQVZ3Qjs7QUFheEIsTUFBSSxDQUFDLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDakMsUUFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixHQUE4QixLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLGdCQUFsQixDQUE5QixDQURpQztHQUFsQztBQUdBLE1BQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLEVBQTZCO0FBQ2pDLFFBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsR0FBOEIsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixnQkFBbEIsQ0FBOUIsQ0FEaUM7R0FBbEM7QUFHQSxNQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsZ0JBQWIsRUFBK0I7QUFDbkMsUUFBSyxPQUFMLENBQWEsZ0JBQWIsR0FBZ0MsS0FBSyxPQUFMLENBQWEsUUFBYixDQUFzQixpQkFBdEIsQ0FBaEMsQ0FEbUM7R0FBcEM7O0FBS0EsTUFBSSxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLEVBQTZCO0FBQ2hDLFFBQUssYUFBTCxDQUFtQixNQUFuQixDQUNDLG1GQUNFLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsR0FBOEIsV0FEaEMsQ0FERCxDQURnQztHQUFqQztBQU1BLE1BQUksS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixFQUE2QjtBQUNoQyxRQUFLLGFBQUwsQ0FBbUIsTUFBbkIsQ0FDQywyREFBMkQsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixHQUE4QixTQUF6RixDQURELENBRGdDO0dBQWpDOztBQU1BLE9BQUssaUJBQUwsR0FwQ3dCO0VBQVg7O0FBdUNkLFVBQVMsbUJBQVc7QUFDbkIsbUJBQUUsRUFBRixDQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLE9BQXRCLENBQThCLElBQTlCLENBQW1DLElBQW5DLEVBRG1COztBQUduQixPQUFLLGlCQUFMLEdBSG1CO0VBQVg7O0FBTVQsVUFBUyxtQkFBVztBQUNuQixPQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxNQUEvQyxHQURtQjtBQUVuQixPQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxNQUEvQyxHQUZtQjs7QUFJbkIsbUJBQUUsRUFBRixDQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLE9BQXRCLENBQThCLElBQTlCLENBQW9DLElBQXBDLEVBSm1CO0VBQVg7Q0FoR1Y7O0FBbUhBLGlCQUFFLE1BQUYsQ0FBUyxlQUFULEVBQTBCLGlCQUFFLEVBQUYsQ0FBSyxNQUFMLEVBQWE7QUFDdEMsVUFBUztBQUVSLGFBQVcsRUFBWDtBQUNBLGdCQUFjLElBQWQ7QUFDQSxvQkFBa0IsRUFBbEI7O0FBR0EsU0FBTyxJQUFQO0FBQ0EsWUFBVSxJQUFWO0FBQ0EsWUFBVSxLQUFWO0FBQ0EsZ0JBQWMsSUFBZDtBQUNBLFlBQVUsR0FBVjtBQUNBLFlBQVUsR0FBVjtBQUNBLGFBQVcsR0FBWDtBQUNBLGFBQVcsR0FBWDtBQUNBLGNBQVksR0FBWjtBQUNBLGVBQWEsR0FBYjtBQUNBLGFBQVcsS0FBWDtFQWpCRDtBQW1CQSxVQUFTLG1CQUFXO0FBQ25CLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixPQUF0QixDQUE4QixJQUE5QixDQUFtQyxJQUFuQyxFQURtQjs7QUFHbkIsTUFBSSxPQUFPLElBQVAsQ0FIZTs7QUFNbkIsTUFBSSxTQUFTLHNCQUFFLHFGQUFGLENBQVQsQ0FOZTtBQU9uQixTQUFPLElBQVAsQ0FBWSxNQUFaLEVBQW9CLFVBQVMsQ0FBVCxFQUFZO0FBQy9CLE9BQUcsc0JBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxLQUFiLEtBQXVCLGFBQXZCLEVBQXNDLE9BQXpDOztBQUVBLFVBQU8sUUFBUCxDQUFnQixRQUFoQixFQUEwQixJQUExQixHQUgrQjtBQUkvQixRQUFLLGFBQUwsR0FKK0I7QUFLL0IsUUFBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixTQUExQixFQUwrQjtHQUFaLENBQXBCLENBTUcsSUFOSCxHQVBtQjs7QUFlbkIsTUFBRyxLQUFLLE9BQUwsQ0FBYSxnQkFBYixFQUErQixLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQXVCLEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQXZCLENBQWxDO0FBQ0EsT0FBSyxPQUFMLENBQWEsTUFBYixDQUFvQixNQUFwQixFQWhCbUI7O0FBbUJuQixNQUFHLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0IsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixVQUFqQixFQUE2QixRQUE3QixFQUEzQjtFQW5CUTtBQXFCVCxPQUFNLGdCQUFXO0FBQ2hCLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixJQUF0QixDQUEyQixJQUEzQixDQUFnQyxJQUFoQyxFQURnQjs7QUFHaEIsTUFBSSxPQUFPLElBQVA7TUFBYSxTQUFTLEtBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsUUFBdEIsQ0FBVCxDQUhEOztBQU1oQixNQUFHLEtBQUssT0FBTCxDQUFhLFNBQWIsS0FBMkIsQ0FBQyxPQUFPLFFBQVAsQ0FBZ0IsUUFBaEIsQ0FBRCxJQUE4QixLQUFLLE9BQUwsQ0FBYSxZQUFiLENBQXpELEVBQXFGO0FBQ3ZGLFVBQU8sSUFBUCxHQUR1RjtBQUV2RixVQUFPLElBQVAsQ0FBWSxLQUFaLEVBQW1CLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBbkIsQ0FGdUY7QUFHdkYsUUFBSyxRQUFMLENBQWMsUUFBZCxDQUF1QixTQUF2QixFQUh1RjtHQUF4Rjs7QUFPQSx3QkFBRSxNQUFGLEVBQVUsSUFBVixDQUFlLGlCQUFmLEVBQWtDLFlBQVc7QUFBQyxRQUFLLGFBQUwsR0FBRDtHQUFYLENBQWxDLENBYmdCO0VBQVg7QUFlTixRQUFPLGlCQUFXO0FBQ2pCLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUF0QixDQUE0QixJQUE1QixDQUFpQyxJQUFqQyxFQURpQjs7QUFHakIsT0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixpQkFBckIsRUFIaUI7QUFJakIsd0JBQUUsTUFBRixFQUFVLE1BQVYsQ0FBaUIsaUJBQWpCLEVBSmlCO0VBQVg7QUFNUCxnQkFBZSx5QkFBVztBQUN6QixNQUFJLE9BQU8sRUFBUDtNQUFXLFFBQWY7TUFBeUIsU0FBekI7TUFBb0MsU0FBUyxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLFFBQXRCLENBQVQsQ0FEWDtBQUV6QixNQUFHLEtBQUssT0FBTCxDQUFhLFVBQWIsRUFBeUI7QUFDM0IsY0FBVyxzQkFBRSxNQUFGLEVBQVUsS0FBVixLQUFvQixLQUFLLE9BQUwsQ0FBYSxVQUFiLENBREo7QUFFM0IsT0FBRyxLQUFLLE9BQUwsQ0FBYSxRQUFiLElBQXlCLFdBQVcsS0FBSyxPQUFMLENBQWEsUUFBYixFQUF1QjtBQUM3RCxTQUFLLEtBQUwsR0FBYSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBRGdEO0lBQTlELE1BRU8sSUFBRyxLQUFLLE9BQUwsQ0FBYSxRQUFiLElBQXlCLFdBQVcsS0FBSyxPQUFMLENBQWEsUUFBYixFQUF1QjtBQUNwRSxTQUFLLEtBQUwsR0FBYSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBRHVEO0lBQTlELE1BRUE7QUFDTixTQUFLLEtBQUwsR0FBYSxRQUFiLENBRE07SUFGQTtHQUpSO0FBVUEsTUFBRyxLQUFLLE9BQUwsQ0FBYSxXQUFiLEVBQTBCO0FBQzVCLGVBQVksc0JBQUUsTUFBRixFQUFVLE1BQVYsS0FBcUIsS0FBSyxPQUFMLENBQWEsV0FBYixDQURMO0FBRTVCLE9BQUcsS0FBSyxPQUFMLENBQWEsU0FBYixJQUEwQixZQUFZLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0I7QUFDaEUsU0FBSyxNQUFMLEdBQWMsS0FBSyxPQUFMLENBQWEsU0FBYixDQURrRDtJQUFqRSxNQUVPLElBQUcsS0FBSyxPQUFMLENBQWEsU0FBYixJQUEwQixZQUFZLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0I7QUFDdkUsU0FBSyxNQUFMLEdBQWMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUR5RDtJQUFqRSxNQUVBO0FBQ04sU0FBSyxNQUFMLEdBQWMsU0FBZCxDQURNO0lBRkE7R0FKUjs7QUFXQSxNQUFHLENBQUMsT0FBTyxhQUFQLENBQXFCLElBQXJCLENBQUQsRUFBNkI7QUFDL0IsUUFBSyxXQUFMLENBQWlCLElBQWpCLEVBRCtCOztBQUkvQixVQUFPLElBQVAsQ0FBWSxPQUFaLEVBQ0MsS0FBSyxLQUFMLEdBQ0UsV0FBVyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLGFBQWpCLENBQVgsQ0FERixHQUVFLFdBQVcsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixjQUFqQixDQUFYLENBRkYsQ0FERCxDQUorQjtBQVMvQixVQUFPLElBQVAsQ0FBWSxRQUFaLEVBQ0MsS0FBSyxNQUFMLEdBQ0UsV0FBVyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLFlBQWpCLENBQVgsQ0FERixHQUVFLFdBQVcsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixlQUFqQixDQUFYLENBRkYsQ0FERCxDQVQrQjs7QUFnQi9CLE9BQUcsS0FBSyxPQUFMLENBQWEsWUFBYixFQUEyQjtBQUM3QixTQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsRUFBNEIsS0FBSyxPQUFMLENBQWEsUUFBYixDQUE1QixDQUQ2QjtJQUE5QjtHQWhCRDtFQXZCYztDQTlEaEI7O0FBNEdBLGlCQUFFLE1BQUYsQ0FBUyxlQUFULEVBQTBCO0FBQ3pCLFVBQVMsbUJBQVc7QUFDbkIsT0FBSyxhQUFMLEdBQXFCLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsT0FBbEIsQ0FBckIsQ0FEbUI7O0FBR25CLE1BQUksT0FBTyxJQUFQLENBSGU7QUFJbkIsTUFBSSxVQUFVLEtBQUssT0FBTCxDQUpLOztBQU1uQixNQUFJLFFBQVEsUUFBUSxLQUFSLElBQWlCLEtBQUssYUFBTCxJQUFzQixRQUF2QyxDQU5PO0FBT25CLE1BQUksVUFBVSxpQkFBRSxFQUFGLENBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsS0FBSyxPQUFMLENBQWpDLENBUGU7O0FBU25CLE9BQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsUUFBdEIsQ0FBK0IsV0FBL0IsRUFUbUI7O0FBV25CLE1BQUksbUJBQW1CLEtBQUssT0FBTCxDQUN0QixRQURzQixDQUVyQix3QkFDQSxtQkFEQSxHQUVBLGdCQUZBLEdBR0Esb0JBSEEsQ0FGRSxDQVhlOztBQXFCbEIsTUFBRyxRQUFRLFdBQVIsRUFBcUI7QUFDdkIsT0FBSSx3QkFBd0Isc0JBQUUsZUFBRixFQUMxQixRQUQwQixDQUUxQiw4QkFDQSxlQURBLENBRjBCLENBSzFCLElBTDBCLENBS3JCLE1BTHFCLEVBS2IsUUFMYSxFQU0xQixLQU4wQixDQU8xQixZQUFXO0FBQ1YsMEJBQXNCLFFBQXRCLENBQStCLGdCQUEvQixFQURVO0lBQVgsRUFHQSxZQUFXO0FBQ1YsMEJBQXNCLFdBQXRCLENBQWtDLGdCQUFsQyxFQURVO0lBQVgsQ0FWMEIsQ0FjMUIsS0FkMEIsQ0FjcEIsWUFBVztBQUNqQiwwQkFBc0IsUUFBdEIsQ0FBK0IsZ0JBQS9CLEVBRGlCO0lBQVgsQ0Fkb0IsQ0FpQjFCLElBakIwQixDQWlCckIsWUFBVztBQUNoQiwwQkFBc0IsV0FBdEIsQ0FBa0MsZ0JBQWxDLEVBRGdCO0lBQVgsQ0FqQnFCLENBb0IxQixTQXBCMEIsQ0FvQmhCLFVBQVMsRUFBVCxFQUFhO0FBQ3ZCLE9BQUcsZUFBSCxHQUR1QjtJQUFiLENBcEJnQixDQXVCMUIsUUF2QjBCLENBdUJqQixnQkF2QmlCLENBQXhCLENBRG1COztBQTBCdkIsT0FBSSw0QkFBNEIsQ0FBQyxLQUFLLHlCQUFMLEdBQWlDLHNCQUFFLFNBQUYsQ0FBakMsQ0FBRCxDQUM5QixRQUQ4QixDQUU5QixhQUNBLG9CQURBLENBRjhCLENBSzlCLElBTDhCLENBS3pCLFFBQVEsU0FBUixDQUx5QixDQU05QixRQU44QixDQU1yQixxQkFOcUIsQ0FBNUIsQ0ExQm1CO0dBQXhCOztBQW1DQSxNQUFJLGdCQUFnQixzQkFBRSxTQUFGLEVBQ2xCLFFBRGtCLENBQ1QsaUJBRFMsRUFFbEIsSUFGa0IsQ0FFYixJQUZhLEVBRVAsT0FGTyxFQUdsQixJQUhrQixDQUdiLEtBSGEsRUFJbEIsU0FKa0IsQ0FJUixnQkFKUSxDQUFoQixDQXhEYzs7QUE4RGxCLG1CQUFpQixJQUFqQixDQUFzQixHQUF0QixFQUEyQixHQUEzQixDQUErQixnQkFBL0IsRUFBaUQsZ0JBQWpELEdBOURrQjtFQUFYOztBQWlFVCxVQUFTLG1CQUFXO0FBQ25CLE9BQUssT0FBTCxDQUNFLE1BREYsQ0FDUyxTQURULEVBRUUsVUFGRixDQUVhLFFBRmIsRUFHRSxXQUhGLENBR2MscUNBSGQsRUFJRSxJQUpGLEdBSVMsUUFKVCxDQUlrQixNQUpsQixFQURtQjs7QUFPbkIsTUFBQyxDQUFLLGFBQUwsSUFBc0IsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixPQUFsQixFQUEyQixLQUFLLGFBQUwsQ0FBakQsQ0FQa0I7RUFBWDtDQWxFVjs7QUE2RUEsaUJBQUUsTUFBRixDQUFTLGlCQUFFLElBQUYsQ0FBTyxRQUFQLEVBQWlCO0FBQ3pCLFVBQVMsT0FBVDtBQUNBLFVBQVM7QUFDUixTQUFPLEVBQVA7QUFDQSxlQUFhLEtBQWI7QUFDQSxhQUFXLE9BQVg7RUFIRDs7QUFNQSxPQUFNLENBQU47O0FBRUEsYUFBWSxvQkFBUyxHQUFULEVBQWM7QUFDekIsU0FBTyxzQkFBc0IsSUFBSSxJQUFKLENBQVMsSUFBVCxLQUFrQixFQUFFLEtBQUssSUFBTCxDQUExQyxDQURrQjtFQUFkO0NBVmI7OztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3FCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4L0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDMUVBLGlCQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVk7QUFDWCxlQUFjLHNCQUFTLElBQVQsRUFBZTtBQUM1QixTQUFPLHNCQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsWUFBVztBQUM5QixPQUFHLHNCQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsWUFBYixDQUFILEVBQStCLE9BQS9COztBQUVBLHlCQUFFLElBQUYsRUFBUSxRQUFSLENBQWlCLFFBQWpCLEVBQTJCLFFBQTNCLENBQW9DLDBCQUFwQyxFQUg4Qjs7QUFLOUIsT0FBSSxTQUFTLHNCQUFFLElBQUYsRUFBUSxPQUFSLENBQWdCLG1CQUFoQixDQUFUO09BQ0gsU0FBUyxpQkFBRSxNQUFGLENBQVMsUUFBUSxFQUFSLEVBQVksc0JBQUUsSUFBRixFQUFRLElBQVIsRUFBckIsRUFBcUMsc0JBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxnQkFBYixDQUFyQyxFQUFxRSxFQUFyRSxDQUFULENBTjZCO0FBTzlCLE9BQUcsQ0FBQyxPQUFPLFlBQVAsRUFBcUIsT0FBekI7O0FBRUEsT0FBRyxPQUFPLE1BQVAsSUFBaUIsaUJBQUUsVUFBRixDQUFhLFFBQWIsQ0FBc0IsT0FBTyxNQUFQLENBQXZDLEVBQXVEO0FBQ3pELGFBQVMsaUJBQUUsTUFBRixDQUFTLE1BQVQsRUFBaUIsaUJBQUUsVUFBRixDQUFhLFFBQWIsQ0FBc0IsT0FBTyxNQUFQLENBQXZDLEVBQXVELEVBQXZELENBQVQsQ0FEeUQ7SUFBMUQ7O0FBSUEsT0FBRyxPQUFPLEdBQVAsRUFBWSxPQUFPLE9BQVAsR0FBaUIsaUJBQUUsVUFBRixDQUFhLFNBQWIsQ0FBdUIsVUFBdkIsRUFBbUMsT0FBTyxHQUFQLENBQXBELENBQWY7QUFDQSxPQUFHLE9BQU8sR0FBUCxFQUFZLE9BQU8sT0FBUCxHQUFpQixpQkFBRSxVQUFGLENBQWEsU0FBYixDQUF1QixVQUF2QixFQUFtQyxPQUFPLEdBQVAsQ0FBcEQsQ0FBZjs7QUFJQSxVQUFPLFVBQVAsR0FBb0IsT0FBTyxnQkFBUCxDQWxCVTtBQW1COUIseUJBQUUsSUFBRixFQUFRLFVBQVIsQ0FBbUIsTUFBbkIsRUFuQjhCO0dBQVgsQ0FBcEIsQ0FENEI7RUFBZjtDQURmOztBQTBCQSxzQkFBRSxRQUFGLEVBQVksRUFBWixDQUFlLE9BQWYsRUFBd0Isd0NBQXhCLEVBQWtFLFlBQVc7QUFDNUUsdUJBQUUsSUFBRixFQUFRLFlBQVIsR0FENEU7O0FBRzVFLEtBQUcsc0JBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxZQUFiLENBQUgsRUFBK0I7QUFDOUIsd0JBQUUsSUFBRixFQUFRLFVBQVIsQ0FBbUIsTUFBbkIsRUFEOEI7RUFBL0I7Q0FIaUUsQ0FBbEU7Ozs7Ozs7Ozs7Ozs7OztBQ3pCQSxpQkFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixVQUFTLENBQVQsRUFBWTtBQUMzQixHQUFFLGVBQUYsRUFBbUIsT0FBbkIsQ0FBMkI7O0FBTTFCLFVBQVEsZ0JBQVMsUUFBVCxFQUFtQixlQUFuQixFQUFvQztBQUMzQyxPQUFJLE9BQU8sSUFBUDtPQUFhLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQO09BQ2hCLGdCQUFnQixLQUFLLElBQUwsQ0FBVSxjQUFWLEVBQTBCLElBQTFCLENBQStCLE1BQS9CLENBQWhCO09BQ0EsT0FBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLGNBQXBCLEVBQVAsQ0FIMEM7O0FBSzNDLE9BQUcsQ0FBQyxRQUFELEVBQVcsV0FBVyxFQUFYLENBQWQ7QUFDQSxPQUFHLENBQUMsU0FBUyxJQUFULEVBQWUsU0FBUyxJQUFULEdBQWdCLEVBQWhCLENBQW5CO0FBQ0EsWUFBUyxJQUFULEdBQWdCLFNBQVMsSUFBVCxDQUFjLE1BQWQsQ0FBcUIsSUFBckIsQ0FBaEIsQ0FQMkM7O0FBWTNDLE9BQUcsT0FBTyxRQUFQLENBQWdCLE1BQWhCLEVBQXdCO0FBQzFCLGFBQVMsSUFBVCxHQUFnQixPQUFPLFFBQVAsQ0FBZ0IsTUFBaEIsQ0FBdUIsT0FBdkIsQ0FBK0IsS0FBL0IsRUFBc0MsRUFBdEMsSUFBNEMsR0FBNUMsR0FBa0QsRUFBRSxLQUFGLENBQVEsU0FBUyxJQUFULENBQTFELENBRFU7SUFBM0I7O0FBTUEsT0FBRyxDQUFDLE9BQU8sT0FBUCxJQUFrQixDQUFDLE9BQU8sT0FBUCxDQUFlLFNBQWYsRUFBeUI7QUFDL0MsUUFBRyxPQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsSUFBd0IsT0FBTyxRQUFQLENBQWdCLElBQWhCLENBQXFCLE9BQXJCLENBQTZCLEdBQTdCLEtBQXFDLENBQUMsQ0FBRCxFQUFHO0FBQ2xFLGNBQVMsSUFBVCxHQUFnQixPQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsQ0FBcUIsU0FBckIsQ0FBK0IsT0FBTyxRQUFQLENBQWdCLElBQWhCLENBQXFCLE9BQXJCLENBQTZCLEdBQTdCLElBQW9DLENBQXBDLENBQS9CLEdBQXdFLEdBQXhFLEdBQThFLEVBQUUsS0FBRixDQUFRLFNBQVMsSUFBVCxDQUF0RixDQURrRDtLQUFuRTtJQUREOztBQU1BLFFBQUssUUFBTCxDQUFjLFNBQWQsRUF4QjJDOztBQTBCM0MsS0FBRSxJQUFGLENBQU8sRUFBRSxNQUFGLENBQVMsRUFBVCxFQUFhO0FBQ25CLGFBQVMsRUFBQyxVQUFXLGNBQVgsRUFBVjtBQUNBLFVBQU0sTUFBTjtBQUNBLFNBQUssS0FBSyxJQUFMLENBQVUsS0FBVixDQUFMO0FBQ0EsY0FBVSxNQUFWO0FBQ0EsYUFBUyxpQkFBUyxJQUFULEVBQWU7QUFJdkIsVUFBSyxLQUFMLEdBQWEsTUFBYixDQUFvQixFQUFFLElBQUYsRUFBUSxRQUFSLEVBQXBCLEVBSnVCOztBQVF2QixTQUFHLGFBQUgsRUFBa0IsS0FBSyxJQUFMLENBQVUsa0JBQWtCLGFBQWxCLEdBQWtDLElBQWxDLENBQVYsQ0FBa0QsS0FBbEQsR0FBbEI7O0FBR0EsU0FBRyxLQUFLLElBQUwsQ0FBVSxnQkFBVixFQUE0QixNQUE1QixFQUFvQztBQUN0QyxVQUFJLE9BQUosQ0FEc0M7QUFFdEMsVUFBRyxTQUFTLElBQVQsQ0FBYyxDQUFkLEVBQWlCLE1BQWpCLElBQXlCLE1BQXpCLEVBQWlDO0FBQ25DLGlCQUFVLG9DQUFWLENBRG1DO0FBRW5DLFlBQUssUUFBTCxDQUFjLGFBQWQsRUFBNkIsSUFBN0IsQ0FBa0MsZ0JBQWxDLEVBQW9ELElBQXBELEdBRm1DO09BQXBDLE1BR087QUFDTixpQkFBVSw4RkFBVixDQURNO0FBRU4sWUFBSyxXQUFMLENBQWlCLGFBQWpCLEVBQWdDLElBQWhDLENBQXFDLGdCQUFyQyxFQUF1RCxJQUF2RCxHQUZNO09BSFA7O0FBUUEsV0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsSUFBdEMsQ0FBMkMsT0FBM0MsRUFWc0M7TUFBdkM7O0FBYUEsVUFBSyxXQUFMLENBQWlCLFNBQWpCLEVBeEJ1QjtBQXlCdkIsU0FBRyxlQUFILEVBQW9CLGdCQUFnQixLQUFoQixDQUFzQixJQUF0QixFQUE0QixTQUE1QixFQUFwQjtBQUNBLFVBQUssT0FBTCxDQUFhLFFBQWIsRUFBdUIsSUFBdkIsRUExQnVCO0tBQWY7QUE0QlQsV0FBTyxlQUFTLENBQVQsRUFBWTtBQUNsQixXQUFNLGVBQUssRUFBTCxDQUFRLDhCQUFSLENBQU4sRUFEa0I7QUFFbEIsVUFBSyxXQUFMLENBQWlCLFNBQWpCLEVBRmtCO0tBQVo7SUFqQ0QsRUFxQ0osUUFyQ0ksQ0FBUCxFQTFCMkM7R0FBcEM7QUFpRVIsa0JBQWdCLHdCQUFTLEdBQVQsRUFBYztBQUM3QixVQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsR0FBdUIsR0FBdkIsQ0FENkI7R0FBZDtBQUdoQixZQUFVLG9CQUFXO0FBQ3BCLFVBQU8sS0FBSyxJQUFMLENBQVUsb0JBQVYsQ0FBUCxDQURvQjtHQUFYOztBQU9WLFlBQVUsa0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN4QixPQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVIsQ0FEb0I7QUFFeEIsU0FBTSxDQUFOLElBQVcsQ0FBWCxDQUZ3QjtBQUd4QixRQUFLLElBQUwsQ0FBVSxrQkFBa0IsS0FBSyxJQUFMLENBQVUsTUFBVixDQUFsQixHQUFzQyxlQUF0QyxDQUFWLENBQWlFLEdBQWpFLENBQXFFLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBckUsRUFId0I7R0FBZjs7QUFRVixZQUFVLG9CQUFXO0FBQ3BCLFVBQU8sS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVUsa0JBQWtCLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBbEIsR0FBc0MsZUFBdEMsQ0FBVixDQUFpRSxHQUFqRSxFQUFYLENBQVAsQ0FEb0I7R0FBWDtFQXpGWCxFQUQyQjs7QUErRjNCLEdBQUUsaUJBQUYsRUFBcUIsT0FBckIsQ0FBNkI7QUFDNUIsZ0JBQWMsd0JBQVc7QUFDeEIsVUFBTyxLQUFLLE9BQUwsQ0FBYSxlQUFiLENBQVAsQ0FEd0I7R0FBWDtFQURmLEVBL0YyQjs7QUF1RzNCLEdBQUUsd0NBQUYsRUFBNEMsT0FBNUMsQ0FBb0Q7QUFDbkQsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsS0FBRSxnQkFBRixFQUNFLElBREYsQ0FDTyxNQURQLEVBRUUsSUFGRixDQUVPLGNBRlAsRUFFdUIsS0FGdkIsR0FEb0I7QUFJcEIsUUFBSyxPQUFMLENBQWEsZUFBYixFQUE4QixRQUE5QixDQUF1QyxhQUF2QyxFQUpvQjtBQUtwQixRQUFLLE1BQUwsR0FBYyxJQUFkLENBQW1CLG9DQUFuQixFQUxvQjtBQU1wQixLQUFFLGNBQUYsR0FOb0I7R0FBWjtFQURWLEVBdkcyQjs7QUFtSDNCLEdBQUUsa0NBQUYsRUFBc0MsT0FBdEMsQ0FBOEM7QUFDN0MsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsT0FBRyxFQUFFLEVBQUUsTUFBRixDQUFGLENBQVksT0FBWixDQUFvQixTQUFwQixFQUErQixNQUEvQixFQUF1QztBQUN6QyxTQUFLLE1BQUwsQ0FBWSxDQUFaLEVBRHlDO0FBRXpDLFdBQU8sS0FBUCxDQUZ5QztJQUExQzs7QUFLQSxPQUFJLFdBQVcsS0FBSyxJQUFMLENBQVUsWUFBVixDQUFYLENBTmdCO0FBT3BCLE9BQUcsU0FBUyxNQUFULEVBQWlCLEtBQUssWUFBTCxHQUFvQixjQUFwQixDQUFtQyxTQUFTLElBQVQsQ0FBYyxNQUFkLENBQW5DLEVBQXBCO0dBUFE7QUFTVCxlQUFhLHVCQUFXO0FBQ3ZCLE9BQUcsS0FBSyxJQUFMLENBQVUsWUFBVixFQUF3QixNQUF4QixFQUFnQyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLFNBQW5CLEVBQW5DO0dBRFk7QUFHYixjQUFZLHNCQUFXO0FBQ3RCLFFBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFEc0I7R0FBWDtFQWJiLEVBbkgyQjs7QUFxSTNCLEdBQUUsdUJBQUYsRUFBMkIsT0FBM0IsQ0FBbUM7QUFDbEMsV0FBUyxpQkFBUyxDQUFULEVBQVc7QUFDbkIsT0FBSSxjQUFZLE1BQVosQ0FEZTtBQUluQixPQUFJLEtBQUssTUFBTCxDQUFZLFFBQVosRUFBc0IsVUFBdEIsQ0FBSixFQUF1QztBQUN0QyxNQUFFLGNBQUYsR0FEc0M7QUFFdEMsV0FGc0M7SUFBdkM7O0FBS0EsT0FBRyxLQUFLLFFBQUwsQ0FBYywyQkFBZCxLQUE4QyxDQUFFLEtBQUssT0FBTCxDQUFhLGVBQWIsRUFBOEIsUUFBOUIsQ0FBdUMsYUFBdkMsQ0FBRixFQUF5RDtBQUN6RyxrQkFBWSxRQUFaLENBRHlHO0lBQTFHOztBQUlBLFFBQUssWUFBTCxHQUFvQixNQUFwQixDQUEyQixFQUFDLE1BQU0sQ0FBQyxFQUFDLE1BQU0sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFOLEVBQXlCLE9BQU8sS0FBSyxHQUFMLEVBQVAsRUFBbUIsUUFBUSxXQUFSLEVBQTlDLENBQU4sRUFBNUIsRUFibUI7QUFjbkIsS0FBRSxjQUFGLEdBZG1CO0dBQVg7RUFEVixFQXJJMkI7O0FBMkozQixHQUFFLDJDQUFGLEVBQStDLE9BQS9DLENBQXVEO0FBQ3RELGtCQUFnQiwwQkFBWTtBQUMzQixPQUFJLE9BQU8sSUFBUCxDQUR1Qjs7QUFHM0IsUUFBSyxjQUFMLEdBSDJCOztBQUszQixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxFQUFoQyxDQUFtQyxPQUFuQyxFQUE0QyxZQUFZO0FBQ3ZELFNBQUssY0FBTCxHQUR1RDtJQUFaLENBQTVDLENBTDJCO0dBQVo7QUFTaEIsYUFBVyxxQkFBWTtBQUN0QixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxDQUFvQyxPQUFwQyxFQURzQjtHQUFaO0FBR1gsa0JBQWdCLDBCQUFZO0FBQzNCLE9BQUksVUFBVSxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQVY7T0FDSCxTQUFTLEtBQUssSUFBTCxDQUFVLG9CQUFWLENBQVQ7T0FDQSxnQkFBZ0IsT0FBTyxHQUFQLE9BQWlCLEVBQWpCO09BQ2hCLGlCQUFpQixRQUFRLEVBQVIsQ0FBVyxXQUFYLENBQWpCLENBSjBCOztBQU0zQixPQUFJLGFBQUMsSUFBaUIsY0FBakIsSUFBcUMsQ0FBQyxhQUFELElBQWtCLENBQUMsY0FBRCxFQUFrQjtBQUM3RSxZQUFRLE1BQVIsQ0FBZSxRQUFmLEVBQXlCLFVBQXpCLEVBQXFDLENBQUMsY0FBRCxDQUFyQyxDQUQ2RTtJQUE5RTtHQU5lO0VBYmpCLEVBM0oyQjs7QUFxTDNCLEdBQUUsaUhBQUYsRUFBcUgsT0FBckgsQ0FBNkg7QUFDNUgsV0FBUyxpQkFBUyxDQUFULEVBQVc7QUFDbkIsT0FBRyxDQUFDLFFBQVEsZUFBSyxFQUFMLENBQVEsaUNBQVIsQ0FBUixDQUFELEVBQXNEO0FBQ3hELE1BQUUsY0FBRixHQUR3RDtBQUV4RCxXQUFPLEtBQVAsQ0FGd0Q7SUFBekQsTUFHTztBQUNOLFNBQUssTUFBTCxDQUFZLENBQVosRUFETTtJQUhQO0dBRFE7RUFEVixFQXJMMkI7O0FBZ00zQixHQUFFLDhDQUFGLEVBQWtELE9BQWxELENBQTBEO0FBQ3pELFFBQU0sSUFBTjtBQUNBLFdBQVMsbUJBQVc7QUFDbkIsUUFBSyxNQUFMLEdBRG1CO0FBRW5CLFFBQUssT0FBTCxDQUFhLElBQUksSUFBSixHQUFXLE9BQVgsRUFBYixFQUZtQjtHQUFYO0FBSVQsYUFBVyxxQkFBVztBQUNyQixRQUFLLE1BQUwsR0FEcUI7R0FBWDtBQUdYLFdBQVMsaUJBQVMsQ0FBVCxFQUFXO0FBQ25CLE9BQUksTUFBTSxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQU47T0FBK0IsT0FBTyxLQUFLLFlBQUwsRUFBUDtPQUNsQyxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUDtPQUE2QixPQUFPLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLFNBQTlCLEVBQVAsQ0FGWDs7QUFLbkIsV0FBUSxNQUFNLG1CQUFtQixJQUFJLElBQUosQ0FBUyxNQUFULENBQW5CLENBQU4sR0FBNkMsR0FBN0MsR0FBbUQsbUJBQW1CLElBQUksR0FBSixFQUFuQixDQUFuRCxDQUxXOztBQVduQixPQUFHLE9BQU8sUUFBUCxDQUFnQixNQUFoQixFQUF3QjtBQUMxQixXQUFPLE9BQU8sUUFBUCxDQUFnQixNQUFoQixDQUF1QixPQUF2QixDQUErQixLQUEvQixFQUFzQyxFQUF0QyxJQUE0QyxHQUE1QyxHQUFrRCxJQUFsRCxDQURtQjtJQUEzQjs7QUFLQSxPQUFJLFlBQVksS0FBSyxJQUFMLENBQVUsS0FBVixFQUFpQixPQUFqQixDQUF5QixHQUF6QixLQUFpQyxDQUFDLENBQUQsR0FBSyxHQUF0QyxHQUE0QyxHQUE1QyxDQWhCRzs7QUFrQm5CLE9BQUksTUFBTSxFQUFFLElBQUYsQ0FBTyxlQUFQLENBQ1QsS0FBSyxJQUFMLENBQVUsS0FBVixJQUFtQixTQUFuQixHQUErQixJQUEvQixFQUNBLEVBQUUsTUFBRixFQUFVLElBQVYsQ0FBZSxNQUFmLENBRlMsQ0FBTixDQWxCZTs7QUF1Qm5CLE9BQUksWUFBWSxPQUFPLElBQVAsQ0FBWSxHQUFaLENBQVosQ0F2QmU7O0FBeUJuQixVQUFPLEtBQVAsQ0F6Qm1CO0dBQVg7RUFUVixFQWhNMkI7O0FBc08zQixHQUFFLDRCQUFGLEVBQWdDLE9BQWhDLENBQXdDO0FBQ3ZDLFdBQVMsbUJBQVU7QUFDbEIsUUFBSyxNQUFMLEdBRGtCOztBQUdsQixRQUFLLElBQUwsR0FBWSxJQUFaLENBQWlCLE1BQWpCLEVBQXlCLFlBQVc7QUFDbkMsU0FBSyxLQUFMLEdBRG1DO0FBRW5DLFFBQUksUUFBUSxLQUFLLGFBQUwsSUFBc0IsSUFBdEIsQ0FGdUI7QUFHbkMsVUFBTSxLQUFOLEdBSG1DO0lBQVgsQ0FBekIsQ0FIa0I7R0FBVjtBQVNULGFBQVcscUJBQVc7QUFDckIsUUFBSyxNQUFMLEdBRHFCO0dBQVg7RUFWWixFQXRPMkI7O0FBMlAzQixHQUFFLCtCQUFGLEVBQW1DLE9BQW5DLENBQTJDO0FBQzFDLFdBQVMsaUJBQVMsQ0FBVCxFQUFXO0FBQ25CLE9BQUksT0FBTyxJQUFQO09BQWEsTUFBTSxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQU47T0FBK0IsT0FBTyxLQUFLLFlBQUwsRUFBUDtPQUMvQyxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUDtPQUE2QixPQUFPLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLFNBQTlCLEVBQVAsQ0FGWDs7QUFLbkIsV0FBUSxNQUFNLG1CQUFtQixJQUFJLElBQUosQ0FBUyxNQUFULENBQW5CLENBQU4sR0FBNkMsR0FBN0MsR0FBbUQsbUJBQW1CLElBQUksR0FBSixFQUFuQixDQUFuRCxDQUxXOztBQVVuQixPQUFHLE9BQU8sUUFBUCxDQUFnQixNQUFoQixFQUF3QjtBQUMxQixXQUFPLE9BQU8sUUFBUCxDQUFnQixNQUFoQixDQUF1QixPQUF2QixDQUErQixLQUEvQixFQUFzQyxFQUF0QyxJQUE0QyxHQUE1QyxHQUFrRCxJQUFsRCxDQURtQjtJQUEzQjs7QUFLQSxPQUFJLFlBQVksS0FBSyxJQUFMLENBQVUsS0FBVixFQUFpQixPQUFqQixDQUF5QixHQUF6QixLQUFpQyxDQUFDLENBQUQsR0FBSyxHQUF0QyxHQUE0QyxHQUE1QyxDQWZHOztBQWlCbkIsVUFBTyxRQUFQLENBQWdCLElBQWhCLEdBQXVCLEVBQUUsSUFBRixDQUFPLGVBQVAsQ0FDdEIsS0FBSyxJQUFMLENBQVUsS0FBVixJQUFtQixTQUFuQixHQUErQixJQUEvQixFQUNBLEVBQUUsTUFBRixFQUFVLElBQVYsQ0FBZSxNQUFmLENBRnNCLENBQXZCLENBakJtQjs7QUFzQm5CLFVBQU8sS0FBUCxDQXRCbUI7R0FBWDtFQURWLEVBM1AyQjs7QUFzUjNCLEdBQUUsOEJBQUYsRUFBa0MsT0FBbEMsQ0FBMEM7QUFDekMsV0FBUyxtQkFBVztBQUNuQixRQUFLLFlBQUwsR0FBb0IsY0FBcEIsQ0FBbUMsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLE1BQWIsQ0FBbkMsRUFEbUI7QUFFbkIsVUFBTyxLQUFQLENBRm1CO0dBQVg7RUFEVixFQXRSMkI7O0FBaVMzQixHQUFFLGdDQUFGLEVBQW9DLE9BQXBDLENBQTRDO0FBSTNDLG9CQUFrQiw0QkFBVztBQUM1QixVQUFPLEtBQUssSUFBTCxDQUFVLGdDQUFWLENBQVAsQ0FENEI7R0FBWDs7QUFNbEIsa0JBQWdCLDBCQUFXO0FBQzFCLFVBQU8sRUFBRSxHQUFGLENBQU0sS0FBSyxnQkFBTCxFQUFOLEVBQStCLFVBQVMsRUFBVCxFQUFhO0FBQUMsV0FBTyxFQUFFLEVBQUYsRUFBTSxJQUFOLENBQVcsSUFBWCxDQUFQLENBQUQ7SUFBYixDQUF0QyxDQUQwQjtHQUFYO0VBVmpCLEVBalMyQjtBQStTM0IsR0FBRSxvREFBRixFQUF3RCxPQUF4RCxDQUFnRTtBQUMvRCxTQUFPLGlCQUFXO0FBQ2pCLFFBQUssTUFBTCxHQURpQjs7QUFJakIsUUFBSyxVQUFMLEdBSmlCO0dBQVg7QUFNUCxZQUFVLG9CQUFXO0FBQ3BCLFFBQUssTUFBTCxHQURvQjtBQUVwQixPQUFJLEtBQUssSUFBTCxDQUFVLFlBQVYsQ0FBSixFQUE2QixLQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsRUFBN0I7R0FGUztFQVBYLEVBL1MyQjs7QUFnVTNCLEdBQUUscUNBQUYsRUFBeUMsT0FBekMsQ0FBaUQ7QUFDaEQsV0FBUyxtQkFBVztBQUNuQixPQUFJLFlBQVksS0FBSyxPQUFMLENBQWEsYUFBYixFQUE0QixJQUE1QixDQUFpQyw2QkFBakMsQ0FBWjtPQUNILFdBQVcsS0FBSyxPQUFMLENBQWEsYUFBYixFQUE0QixJQUE1QixDQUFpQyw0QkFBakMsQ0FBWCxDQUZrQjs7QUFJbkIsT0FBRyxLQUFLLEdBQUwsRUFBSCxFQUFlO0FBQ2QsY0FBVSxRQUFWLENBQW1CLFVBQW5CLEVBRGM7QUFFZCxhQUFTLFFBQVQsQ0FBa0IsVUFBbEIsRUFGYztJQUFmO0FBSUEsUUFBSyxNQUFMLEdBUm1CO0dBQVg7QUFVVCxhQUFXLHFCQUFXO0FBQ3JCLFFBQUssTUFBTCxHQURxQjtHQUFYO0FBR1gsYUFBVyxtQkFBUyxDQUFULEVBQVk7QUFFdEIsT0FBRyxLQUFLLE9BQUwsQ0FBYSw0QkFBYixFQUEyQyxNQUEzQyxFQUFtRCxPQUF0RDs7QUFFQSxPQUFJLFlBQVksS0FBSyxPQUFMLENBQWEsYUFBYixFQUE0QixJQUE1QixDQUFpQyw2QkFBakMsQ0FBWjtPQUNILFdBQVcsS0FBSyxPQUFMLENBQWEsYUFBYixFQUE0QixJQUE1QixDQUFpQyw0QkFBakMsQ0FBWCxDQUxxQjs7QUFPdEIsT0FBRyxFQUFFLE9BQUYsSUFBYSxJQUFiLEVBQW1CO0FBQ3JCLFFBQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxnQkFBYixFQUErQixJQUEvQixDQUFvQyw2QkFBcEMsQ0FBUCxDQURpQjtBQUVyQixRQUFJLGNBQVksTUFBWixDQUZpQjtBQUdyQixRQUFHLEtBQUssUUFBTCxDQUFjLDJCQUFkLEtBQTRDLENBQUUsS0FBSyxPQUFMLENBQWEsZUFBYixFQUE4QixRQUE5QixDQUF1QyxhQUF2QyxDQUFGLEVBQXlEO0FBQ3ZHLG1CQUFZLFFBQVosQ0FEdUc7S0FBeEc7O0FBSUEsU0FBSyxZQUFMLEdBQW9CLE1BQXBCLENBQTJCLEVBQUMsTUFBTSxDQUFDLEVBQUMsTUFBTSxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQU4sRUFBeUIsT0FBTyxLQUFLLEdBQUwsRUFBUCxFQUFtQixRQUFRLFdBQVIsRUFBOUMsQ0FBTixFQUE1QixFQVBxQjtBQVFyQixXQUFPLEtBQVAsQ0FScUI7SUFBdEIsTUFTSztBQUNKLGNBQVUsUUFBVixDQUFtQixhQUFuQixFQURJO0FBRUosYUFBUyxRQUFULENBQWtCLGFBQWxCLEVBRkk7SUFUTDtHQVBVO0VBZFosRUFoVTJCOztBQXFXM0IsR0FBRSxnQ0FBRixFQUFvQyxPQUFwQyxDQUE0QztBQUMzQyxhQUFXLG1CQUFVLEtBQVYsRUFBaUI7QUFDM0IsUUFBSyxZQUFMLENBQWtCO0FBQ2pCLFlBQVEsZ0JBQVMsT0FBVCxFQUFrQixRQUFsQixFQUEyQjtBQUNsQyxTQUFJLGNBQWMsRUFBRSxLQUFLLE9BQUwsQ0FBaEIsQ0FEOEI7QUFFbEMsU0FBSSxPQUFPLEVBQUUsS0FBSyxPQUFMLENBQUYsQ0FBZ0IsT0FBaEIsQ0FBd0IsTUFBeEIsQ0FBUCxDQUY4QjtBQUdsQyxPQUFFLElBQUYsQ0FBTztBQUNOLGVBQVM7QUFDUixpQkFBVyxTQUFYO09BREQ7QUFHQSxZQUFNLEtBQU47QUFDQSxXQUFLLEVBQUUsV0FBRixFQUFlLElBQWYsQ0FBb0IsV0FBcEIsQ0FBTDtBQUNBLFlBQU0sbUJBQW1CLFlBQVksSUFBWixDQUFpQixNQUFqQixDQUFuQixJQUE2QyxHQUE3QyxHQUFpRCxtQkFBbUIsWUFBWSxHQUFaLEVBQW5CLENBQWpEO0FBQ04sZUFBUyxpQkFBUyxJQUFULEVBQWU7QUFDdkIsZ0JBQVMsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFULEVBRHVCO09BQWY7QUFHVCxhQUFPLGVBQVMsQ0FBVCxFQUFZO0FBQ2xCLGFBQU0sZUFBSyxFQUFMLENBQVEsOEJBQVIsRUFBd0MsZ0ZBQXhDLENBQU4sRUFEa0I7T0FBWjtNQVZSLEVBSGtDO0tBQTNCO0FBa0JSLFlBQVEsZ0JBQVMsS0FBVCxFQUFnQixFQUFoQixFQUFvQjtBQUMzQixPQUFFLElBQUYsRUFBUSxPQUFSLENBQWdCLGVBQWhCLEVBQWlDLElBQWpDLENBQXNDLGdDQUF0QyxFQUF3RSxXQUF4RSxDQUNDLG1EQUFpRCxHQUFHLElBQUgsQ0FBUSxFQUFSLEdBQVcscUJBQTVELENBREQsQ0FEMkI7QUFJM0IsU0FBSSxZQUFZLEVBQUUsSUFBRixFQUFRLE9BQVIsQ0FBZ0IsZUFBaEIsRUFBaUMsSUFBakMsQ0FBc0MsK0JBQXRDLENBQVosQ0FKdUI7QUFLM0IsU0FBRyxVQUFVLElBQVYsQ0FBZSxRQUFmLENBQUgsRUFBNEI7QUFDM0IsZ0JBQVUsTUFBVixDQUFpQixRQUFqQixFQUQyQjtNQUE1QixNQUVLO0FBQ0osZ0JBQVUsVUFBVixDQUFxQixVQUFyQixFQURJO01BRkw7S0FMTztJQW5CVCxFQUQyQjtHQUFqQjtFQURaLEVBclcyQjs7QUF5WTNCLEdBQUUsNkNBQUYsRUFBaUQsT0FBakQsQ0FBeUQ7QUFDeEQsYUFBVyxtQkFBUyxLQUFULEVBQWdCO0FBQzFCLE9BQUcsTUFBTSxPQUFOLElBQWlCLEVBQWpCLEVBQXFCO0FBQ3ZCLFFBQUksVUFBVSxTQUFTLEVBQUUsSUFBRixFQUFRLEdBQVIsRUFBVCxFQUF3QixFQUF4QixDQUFWLENBRG1COztBQUd2QixRQUFJLFlBQVksRUFBRSxJQUFGLEVBQVEsWUFBUixFQUFaLENBSG1CO0FBSXZCLGNBQVUsUUFBVixDQUFtQixvQkFBbkIsRUFBeUMsRUFBQyxhQUFhLE9BQWIsRUFBMUMsRUFKdUI7QUFLdkIsY0FBVSxNQUFWLEdBTHVCOztBQU92QixXQUFPLEtBQVAsQ0FQdUI7SUFBeEI7R0FEVTtFQURaLEVBelkyQjtDQUFaLENBQWhCOzs7Ozs7Ozs7Ozs7Ozs7QUNRQSxJQUFJLEtBQUssT0FBTyxPQUFPLEVBQVAsS0FBYyxXQUFyQixHQUFtQyxPQUFPLEVBQVAsR0FBWSxFQUEvQzs7QUFPVCxHQUFHLGNBQUgsR0FBb0IsRUFBcEI7QUFDQSxHQUFHLGNBQUgsQ0FBa0IsT0FBbEIsR0FBNkIsWUFBVztBQUd2QyxLQUFJLFFBQUosQ0FIdUM7O0FBS3ZDLFFBQU87QUFNTixRQUFNLGNBQVMsRUFBVCxFQUFhO0FBQ2xCLGNBQVcsRUFBWCxDQURrQjs7QUFHbEIsUUFBSyxNQUFMLEdBSGtCO0dBQWI7O0FBU04sV0FBUyxtQkFBVztBQUNuQixXQUFRLGFBQVIsQ0FBc0IsV0FBdEIsQ0FBa0MsaUJBQWxDLEVBQXFELEtBQXJELEVBQTRELFFBQTVELEVBRG1CO0dBQVg7O0FBU1QsZUFBYSx1QkFBVztBQUN2QixVQUFPLFFBQVEsYUFBUixDQUFzQixHQUF0QixDQUEwQixRQUExQixDQUFQLENBRHVCO0dBQVg7O0FBT2IsVUFBUSxrQkFBVyxFQUFYOztBQU9SLFdBQVMsbUJBQVcsRUFBWDs7QUFTVCxhQUFXLHFCQUFXO0FBQ3JCLE9BQUksV0FBVyxNQUFNLFFBQU47T0FDZCxTQUFTLHNCQUFFLFFBQUYsRUFBWSxJQUFaLENBQWlCLFFBQWpCLENBQVQ7T0FDQSxPQUFPLElBQVAsQ0FIb0I7O0FBTXJCLFVBQU8sUUFBUCxHQUFrQixRQUFsQixDQU5xQjs7QUFTckIsVUFBTyxLQUFQLEdBQWUsVUFBUyxFQUFULEVBQWE7QUFDM0IsT0FBRyxFQUFILENBQU0sUUFBTixFQUFnQixZQUFXO0FBQzFCLFVBQUssSUFBTCxHQUQwQjtLQUFYLENBQWhCLENBRDJCO0lBQWIsQ0FUTTtBQWNyQixVQUFPLE1BQVAsQ0FkcUI7R0FBWDs7QUFvQlgsUUFBTSxnQkFBVztBQUNoQixPQUFJLFdBQVcsS0FBSyxXQUFMLEVBQVgsQ0FEWTtBQUVoQixZQUFTLElBQVQsR0FGZ0I7O0FBS2hCLHlCQUFFLFNBQVMsVUFBVCxFQUFGLEVBQXlCLE9BQXpCLENBQWlDLFFBQWpDLEVBTGdCO0dBQVg7O0FBV04sVUFBUSxrQkFBVztBQUNsQixPQUFJLFNBQVMsS0FBSyxTQUFMLEVBQVQsQ0FEYzs7QUFHbEIsT0FBRyxPQUFPLE9BQU8sT0FBUCxLQUFtQixXQUExQixFQUF1QztBQUN6QyxZQUFRLGFBQVIsQ0FBc0IsT0FBdEIsR0FBZ0MsT0FBTyxPQUFQLENBRFM7SUFBMUM7QUFHQSxXQUFRLElBQVIsQ0FBYSxNQUFiLEVBTmtCO0dBQVg7O0FBWVIsV0FBUyxtQkFBVyxFQUFYOztBQU9ULFdBQVMsbUJBQVc7QUFDbkIsVUFBTyxLQUFLLFdBQUwsR0FBbUIsT0FBbkIsRUFBUCxDQURtQjtHQUFYOztBQVNULGNBQVksc0JBQVc7QUFDdEIsVUFBTyxLQUFLLFdBQUwsR0FBbUIsVUFBbkIsRUFBUCxDQURzQjtHQUFYOztBQVNaLFVBQVEsa0JBQVc7QUFDbEIsVUFBTyxLQUFLLFdBQUwsR0FBbUIsVUFBbkIsRUFBUCxDQURrQjtHQUFYOztBQU9SLGdCQUFjLHdCQUFXO0FBQ3hCLFVBQU8sS0FBSyxXQUFMLEdBQW1CLFlBQW5CLEVBQVAsQ0FEd0I7R0FBWDs7QUFTZCxtQkFBaUIsMkJBQVc7QUFDM0IsVUFBTyxLQUFLLFdBQUwsR0FBbUIsU0FBbkIsQ0FBNkIsT0FBN0IsRUFBUCxDQUQyQjtHQUFYOztBQVNqQixjQUFZLG9CQUFTLElBQVQsRUFBZTtBQUMxQixRQUFLLFdBQUwsR0FBbUIsU0FBbkIsQ0FBNkIsTUFBN0IsQ0FBb0MsSUFBcEMsRUFEMEI7R0FBZjs7QUFVWixjQUFZLG9CQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCO0FBQ2hDLFFBQUssV0FBTCxHQUFtQixVQUFuQixDQUE4QixJQUE5QixFQUFvQyxJQUFwQyxFQURnQztHQUFyQjs7QUFVWixpQkFBZSx1QkFBUyxJQUFULEVBQWUsSUFBZixFQUFxQjtBQUNuQyxRQUFLLFdBQUwsR0FBbUIsYUFBbkIsQ0FBaUMsSUFBakMsRUFBdUMsSUFBdkMsRUFEbUM7R0FBckI7O0FBUWYsa0JBQWdCLHdCQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCO0FBQ3BDLFFBQUssV0FBTCxHQUFtQixXQUFuQixDQUErQixtQkFBL0IsRUFBb0QsS0FBcEQsRUFBMkQsSUFBM0QsRUFBaUUsSUFBakUsRUFEb0M7R0FBckI7O0FBUWhCLGNBQVksb0JBQVMsS0FBVCxFQUFnQixJQUFoQixFQUFzQjtBQUNqQyxRQUFLLFdBQUwsR0FBbUIsV0FBbkIsQ0FBK0IsZUFBL0IsRUFBZ0QsS0FBaEQsRUFBdUQsS0FBdkQsRUFBOEQsSUFBOUQsRUFEaUM7R0FBdEI7O0FBTVosY0FBWSxzQkFBVztBQUN0QixRQUFLLFdBQUwsR0FBbUIsV0FBbkIsQ0FBK0IsUUFBL0IsRUFBeUMsS0FBekMsRUFEc0I7R0FBWDs7QUFVWixhQUFXLG1CQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCO0FBQy9CLE9BQUksV0FBVyxLQUFLLFNBQUw7T0FDZCxLQUFLLFNBQVMsdUJBQVQsQ0FBTCxDQUY4QjtBQUcvQixPQUFHLEVBQUgsRUFBTyxPQUFPLEtBQUssS0FBSyxxQkFBTCxDQUFaLENBQVA7O0FBR0EsT0FBRyxLQUFLLEtBQUwsQ0FBVyxJQUFJLE1BQUosQ0FBVyxNQUFNLFFBQVEsUUFBUixDQUFpQixtQkFBakIsQ0FBTixHQUE4QyxPQUE5QyxDQUF0QixDQUFILEVBQWtGO0FBQ2pGLFdBQU8sT0FBTyxFQUFQLENBRDBFO0lBQWxGOztBQUtBLE9BQUcsS0FBSyxLQUFMLENBQVcsc0JBQVgsQ0FBSCxFQUF1QyxPQUFPLEVBQVAsQ0FBdkM7O0FBRUEsVUFBTyxJQUFQLENBYitCO0dBQXJCOztBQW9CWCxrQkFBZ0IsMEJBQVc7QUFDMUIsVUFBTyxLQUFLLFdBQUwsR0FBbUIsU0FBbkIsQ0FBNkIsV0FBN0IsRUFBUCxDQUQwQjtHQUFYOztBQU9oQixrQkFBZ0Isd0JBQVMsUUFBVCxFQUFtQjtBQUNsQyxRQUFLLFdBQUwsR0FBbUIsU0FBbkIsQ0FBNkIsY0FBN0IsQ0FBNEMsUUFBNUMsRUFEa0M7QUFFbEMsUUFBSyxXQUFMLEdBQW1CLEtBQW5CLEdBRmtDO0dBQW5COztBQU9oQixRQUFNLGdCQUFXO0FBQ2hCLFFBQUssV0FBTCxHQUFtQixTQUFuQixDQUE2QixRQUE3QixHQURnQjtHQUFYOztBQU1OLFdBQVMsbUJBQVc7QUFDbkIsUUFBSyxXQUFMLEdBQW1CLFdBQW5CLENBQStCLEdBQS9CLEdBRG1CO0dBQVg7RUF4T1YsQ0FMdUM7Q0FBWDs7QUFtUDdCLEdBQUcsY0FBSCxDQUFrQixTQUFsQixJQUErQixHQUFHLGNBQUgsQ0FBa0IsT0FBbEI7O0FBRS9CLGlCQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFVBQVMsQ0FBVCxFQUFZO0FBUzNCLEdBQUUscUJBQUYsRUFBeUIsT0FBekIsQ0FBaUM7O0FBRWhDLFVBQVEsSUFBUjs7QUFLQSxTQUFPLGlCQUFXO0FBQ2pCLE9BQUksVUFBVSxLQUFLLElBQUwsQ0FBVSxRQUFWLEtBQXVCLFNBQXZCO09BQ2IsS0FBSyxHQUFHLGNBQUgsQ0FBa0IsT0FBbEIsR0FBTCxDQUZnQjtBQUdqQixRQUFLLFNBQUwsQ0FBZSxFQUFmLEVBSGlCOztBQUtqQixNQUFHLElBQUgsQ0FBUSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQVIsRUFMaUI7O0FBT2pCLFFBQUssTUFBTCxHQVBpQjtHQUFYOztBQWFQLFlBQVUsb0JBQVc7QUFDcEIsUUFBSyxTQUFMLEdBQWlCLE9BQWpCLEdBRG9CO0FBRXBCLFFBQUssTUFBTCxHQUZvQjtHQUFYOztBQVFWLHlCQUF1QjtBQUN0Qix1QkFBb0IsOEJBQVc7QUFDOUIsU0FBSyxTQUFMLEdBQWlCLElBQWpCLEdBRDhCO0FBRTlCLFNBQUssTUFBTCxHQUY4QjtJQUFYO0dBRHJCOztBQVdBLGtCQUFnQiwwQkFBVztBQUMxQixRQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsRUFEMEI7R0FBWDs7QUFRaEIsbUJBQWlCLDJCQUFXO0FBQzNCLFFBQUssVUFBTCxDQUFnQixPQUFoQixFQUQyQjtHQUFYOztBQUlqQixjQUFZLG9CQUFTLElBQVQsRUFBZTtBQUMxQixPQUFJLGFBQWEsU0FBYixVQUFhLENBQVMsSUFBVCxFQUFlO0FBQy9CLFdBQU8sS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLFdBQWYsS0FBK0IsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLFdBQWQsRUFBL0IsQ0FEd0I7SUFBZixDQURTOztBQUsxQixPQUFJLE9BQU8sSUFBUDtPQUNILE1BQU0sRUFBRSxxQkFBRixFQUF5QixJQUF6QixDQUE4QixRQUFRLFdBQVcsSUFBWCxDQUFSLEdBQTJCLE1BQTNCLENBQXBDO09BQ0EsU0FBUyxFQUFFLHNCQUFzQixJQUF0QixHQUE2QixRQUE3QixDQUFYLENBUHlCOztBQVMxQixPQUFHLE9BQU8sTUFBUCxFQUFlO0FBRWpCLFdBQU8sT0FBUCxHQUFpQixVQUFqQixDQUE0QixJQUE1QixFQUZpQjtBQUdqQixXQUFPLElBQVAsQ0FBWSxFQUFaLEVBSGlCO0FBSWpCLFdBQU8sUUFBUCxDQUFnQixTQUFoQixFQUppQjtBQUtqQixXQUFPLElBQVAsR0FMaUI7SUFBbEIsTUFNTztBQUdOLGFBQVMsRUFBRSx3REFBd0QsSUFBeEQsR0FBK0Qsa0JBQS9ELENBQVgsQ0FITTtBQUlOLE1BQUUsTUFBRixFQUFVLE1BQVYsQ0FBaUIsTUFBakIsRUFKTTtJQU5QOztBQWFBLEtBQUUsSUFBRixDQUFPO0FBQ04sU0FBSyxHQUFMO0FBQ0EsY0FBVSxvQkFBVztBQUNwQixZQUFPLFdBQVAsQ0FBbUIsU0FBbkIsRUFEb0I7S0FBWDtBQUdWLGFBQVMsaUJBQVMsSUFBVCxFQUFlO0FBQ3ZCLFlBQU8sSUFBUCxDQUFZLElBQVosRUFEdUI7QUFFdkIsWUFBTyxPQUFQLEdBQWlCLFVBQWpCLENBQTRCLElBQTVCLEVBRnVCO0FBR3ZCLFlBQU8sT0FBUCxDQUFlLGNBQWYsRUFIdUI7S0FBZjtJQUxWLEVBdEIwQjtHQUFmO0VBbkRiLEVBVDJCOztBQWdHM0IsR0FBRSx5QkFBRixFQUE2QixPQUE3QixDQUFxQztBQUNwQyxTQUFPLGlCQUFXO0FBR2pCLE9BQUksQ0FBQyxLQUFLLEVBQUwsQ0FBUSxvQkFBUixDQUFELEVBQWdDO0FBQ25DLFNBQUssUUFBTCxDQUFjO0FBQ2IsZUFBVSxJQUFWO0FBQ0EsY0FBUztBQUNSLGdCQUFVO0FBQ1QsYUFBTSxlQUFLLEVBQUwsQ0FDTCx3QkFESyxFQUVMLFFBRkssQ0FBTjtBQUlBLG9CQUFhLFFBQWI7QUFDQSxjQUFPLHdDQUFQO0FBQ0EsY0FBTyxpQkFBVztBQUNqQixVQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsTUFBYixFQUFxQixNQUFyQixHQURpQjtRQUFYO09BUFI7TUFERDtLQUZELEVBRG1DO0lBQXBDOztBQW1CQSxRQUFLLE1BQUwsR0F0QmlCO0dBQVg7O0FBeUJQLFdBQVMsbUJBQVc7QUFDbkIsVUFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQVAsQ0FEbUI7R0FBWDtBQUdULFFBQU0sZ0JBQVc7QUFDaEIsUUFBSyxRQUFMLENBQWMsTUFBZCxFQURnQjtHQUFYO0FBR04sU0FBTyxpQkFBVztBQUNqQixRQUFLLFFBQUwsQ0FBYyxPQUFkLEVBRGlCO0dBQVg7QUFHUCxVQUFRLGdCQUFTLElBQVQsRUFBZTtBQUN0QixPQUFHLEtBQUssRUFBTCxDQUFRLFVBQVIsQ0FBSCxFQUF3QixLQUFLLEtBQUwsR0FBeEIsS0FDSyxLQUFLLElBQUwsR0FETDtHQURPO0FBSVIsWUFBVSxvQkFBWTtBQUNyQixRQUFLLE9BQUwsQ0FBYTtBQUNaLGVBQVcsS0FBSyxJQUFMLENBQVUsTUFBVixFQUFrQixNQUFsQixFQUFYO0lBREQsRUFFRyxHQUZILEVBRHFCO0dBQVo7RUF2Q1gsRUFoRzJCOztBQWtKM0IsR0FBRSwyQkFBRixFQUErQixPQUEvQixDQUF1QztBQUN0QyxhQUFXLElBQVg7O0FBR0EsWUFBVSxJQUFWOztBQUdBLFdBQVMsSUFBVDs7QUFFQSxnQkFBYyxzQkFBUyxJQUFULEVBQWU7QUFDNUIsVUFBTyxLQUFLLE1BQUwsQ0FBWSxFQUFFLElBQUYsQ0FBWixDQUFQLENBRDRCO0dBQWY7O0FBSWQsU0FBTyxpQkFBVztBQUVqQixPQUFJLFVBQVUsS0FBSyxJQUFMLENBQVUsZUFBVixDQUFWLENBRmE7QUFHakIsUUFBSyxTQUFMLEdBQWlCLElBQWpCLENBQXNCLE9BQXRCLEVBQStCLFFBQVEsSUFBUixFQUEvQixFQUhpQjs7QUFLakIsUUFBSyxNQUFMLEdBTGlCO0dBQVg7QUFPUCxZQUFVLG9CQUFXO0FBQ3BCLFFBQUssWUFBTCxDQUFrQixJQUFsQixFQURvQjtBQUVwQixRQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFGb0I7QUFHcEIsUUFBSyxVQUFMLENBQWdCLElBQWhCLEVBSG9COztBQUtwQixRQUFLLE1BQUwsR0FMb0I7R0FBWDs7QUFRVixhQUFXLHFCQUFXO0FBRXJCLFVBQU8sS0FBSyxPQUFMLENBQWEseUJBQWIsQ0FBUCxDQUZxQjtHQUFYOztBQUtYLGNBQVk7QUFDWCxtQkFBZ0IsMEJBQVU7QUFDekIsUUFBSSxLQUFLLEtBQUssU0FBTCxFQUFMLENBRHFCOztBQUd6QixTQUFLLFlBQUwsQ0FBa0IsR0FBRyxlQUFILEVBQWxCLEVBSHlCO0FBSXpCLFNBQUssV0FBTCxDQUFpQixHQUFHLGNBQUgsRUFBakIsRUFKeUI7O0FBTXpCLE9BQUcsSUFBSCxHQU55Qjs7QUFRekIsU0FBSyxJQUFMLENBQVUsa0RBQVYsRUFDRSxNQURGLENBQ1Msa0JBRFQsRUFFRSxFQUZGLENBRUssQ0FGTCxFQUdFLEtBSEYsR0FSeUI7O0FBYXpCLFNBQUssTUFBTCxHQWJ5QjtBQWN6QixTQUFLLGdCQUFMLEdBZHlCO0lBQVY7O0FBaUJoQixvQkFBaUIsMkJBQVU7QUFDMUIsUUFBSSxLQUFLLEtBQUssU0FBTCxFQUFMLENBRHNCOztBQUcxQixPQUFHLGNBQUgsQ0FBa0IsS0FBSyxXQUFMLEVBQWxCLEVBSDBCOztBQUsxQixTQUFLLFlBQUwsQ0FBa0IsSUFBbEIsRUFMMEI7QUFNMUIsU0FBSyxXQUFMLENBQWlCLElBQWpCLEVBTjBCOztBQVExQixTQUFLLFdBQUwsR0FSMEI7SUFBVjtHQWxCbEI7O0FBaUNBLGFBQVcscUJBQVU7QUFDcEIsVUFBTyxLQUFLLFVBQUwsR0FBa0IsU0FBbEIsRUFBUCxDQURvQjtHQUFWOztBQUlYLG1CQUFpQix5QkFBUyxRQUFULEVBQW1CO0FBQ25DLE9BQUksS0FBSyxLQUFLLFNBQUwsRUFBTCxDQUQrQjs7QUFHbkMsTUFBRyxjQUFILENBQWtCLEtBQUssV0FBTCxFQUFsQixFQUhtQztBQUluQyxZQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLEVBQXBCLEVBSm1DOztBQU1uQyxRQUFLLFlBQUwsQ0FBa0IsR0FBRyxlQUFILEVBQWxCLEVBTm1DO0FBT25DLFFBQUssV0FBTCxDQUFpQixHQUFHLGNBQUgsRUFBakIsRUFQbUM7O0FBU25DLE1BQUcsSUFBSCxHQVRtQztHQUFuQjs7QUFZakIsb0JBQWtCLDRCQUFXLEVBQVg7QUFHbEIsVUFBUSxrQkFBVyxFQUFYO0FBR1IsZUFBYSx1QkFBVztBQUV2QixRQUFLLElBQUwsQ0FBVSxjQUFWLEVBQTBCLEtBQTFCLEdBRnVCO0dBQVg7RUF4RmQsRUFsSjJCOztBQXNQM0IsR0FBRSwrQkFBRixFQUFtQyxPQUFuQyxDQUEyQztBQUcxQyxZQUFVLGtCQUFTLENBQVQsRUFBWTtBQUNyQixRQUFLLFVBQUwsR0FEcUI7QUFFckIsUUFBSyxTQUFMLEdBQWlCLEtBQWpCLEdBRnFCO0FBR3JCLFVBQU8sS0FBUCxDQUhxQjtHQUFaO0FBS1YsZUFBYSx1QkFBVztBQUN2QixRQUFLLE1BQUwsR0FEdUI7O0FBSXZCLFFBQUssQ0FBTCxFQUFRLEtBQVIsR0FKdUI7R0FBWDtBQU1iLFVBQVEsa0JBQVc7QUFDbEIsUUFBSyxNQUFMLEdBRGtCOztBQUdsQixPQUFJLFdBQVcsS0FBSyxJQUFMLENBQVUsK0JBQVYsRUFBMkMsR0FBM0MsRUFBWCxDQUhjOztBQUtsQixRQUFLLGlCQUFMLEdBTGtCOztBQU9sQixRQUFLLGNBQUwsR0FQa0I7O0FBVWxCLFFBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLElBQWhDLEdBVmtCO0FBV2xCLFFBQUssSUFBTCxDQUFVLHdCQUFWLEVBQW9DLElBQXBDLEdBWGtCO0FBWWxCLFFBQUssSUFBTCxDQUFVLGlCQUFpQixRQUFqQixHQUEyQixXQUEzQixDQUFWLENBQWtELElBQWxELEdBWmtCOztBQWNsQixPQUFHLFlBQVksVUFBWixJQUEwQixZQUFZLFFBQVosRUFBc0I7QUFDbEQsU0FBSyxJQUFMLENBQVUsNkJBQVYsRUFBeUMsSUFBekMsR0FEa0Q7SUFBbkQ7O0FBSUEsT0FBRyxZQUFZLE9BQVosRUFBcUI7QUFDdkIsU0FBSyxJQUFMLENBQVUsOEJBQVYsRUFBMEMsSUFBMUMsR0FEdUI7SUFBeEIsTUFFTztBQUNOLFNBQUssSUFBTCxDQUFVLGtDQUFWLEVBQThDLElBQTlDLEdBRE07SUFGUDs7QUFNQSxPQUFHLFlBQVksUUFBWixFQUFzQjtBQUN4QixTQUFLLElBQUwsQ0FBVSxxQ0FBVixFQUFpRCxJQUFqRCxHQUR3QjtJQUF6QjtBQUdBLFFBQUssSUFBTCxDQUFVLGtDQUFWLEVBQThDLElBQTlDLEdBM0JrQjtHQUFYOztBQWdDUixxQkFBbUIsNkJBQVc7QUFDN0IsT0FBSSxJQUFKO09BQ0MsU0FBUyxJQUFUO09BQ0EsVUFBVSxLQUFLLElBQUwsQ0FBVSxzQkFBVixFQUFrQyxHQUFsQyxFQUFWO09BQ0EsU0FBUyxLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFULENBSjRCOztBQU83QixPQUFHLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEVBQXRDLENBQXlDLFVBQXpDLENBQUgsRUFBeUQ7QUFDeEQsYUFBUyxRQUFULENBRHdEO0lBQXpEOztBQUtBLFdBQU8sS0FBSyxJQUFMLENBQVUsK0JBQVYsRUFBMkMsR0FBM0MsRUFBUDtBQUNDLFNBQUssVUFBTDtBQUNDLFlBQU8sdUJBQXVCLEtBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLEVBQXZCLEdBQWtFLEdBQWxFLENBRFI7O0FBR0MsU0FBRyxNQUFILEVBQVc7QUFDVixjQUFRLE1BQU0sTUFBTixDQURFO01BQVg7O0FBSUEsV0FQRDs7QUFERCxTQVVNLFFBQUw7QUFDQyxZQUFPLE1BQU0sTUFBTixDQURSO0FBRUMsV0FGRDs7QUFWRCxTQWNNLE1BQUw7QUFDQyxZQUFPLG1CQUFtQixLQUFLLElBQUwsQ0FBVSxzQ0FBVixFQUFrRCxJQUFsRCxDQUF1RCxhQUF2RCxDQUFuQixHQUEyRixHQUEzRixDQURSO0FBRUMsV0FGRDs7QUFkRCxTQWtCTSxPQUFMO0FBQ0MsWUFBTyxZQUFZLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLEVBQVosQ0FEUjtBQUVDLFNBQUcsT0FBSCxFQUFZO0FBQ1gsY0FBUSxjQUFjLG1CQUFtQixPQUFuQixDQUFkLENBREc7TUFBWjtBQUdBLGNBQVMsSUFBVCxDQUxEO0FBTUMsV0FORDs7QUFsQkQ7QUE0QkUsWUFBTyxLQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxFQUFQLENBREQ7O0FBR0MsU0FBRyxLQUFLLE9BQUwsQ0FBYSxLQUFiLEtBQXVCLENBQUMsQ0FBRCxFQUFJLE9BQU8sWUFBWSxJQUFaLENBQXJDO0FBQ0EsV0FKRDtBQTNCRCxJQVo2Qjs7QUE4QzdCLFVBQU87QUFDTixVQUFPLElBQVA7QUFDQSxZQUFTLE1BQVQ7QUFDQSxXQUFRLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEdBQXRDLEVBQVI7SUFIRCxDQTlDNkI7R0FBWDtBQW9EbkIsY0FBWSxzQkFBVztBQUN0QixRQUFLLGVBQUwsQ0FBcUIsVUFBUyxFQUFULEVBQVk7QUFDaEMsT0FBRyxVQUFILENBQWMsS0FBSyxpQkFBTCxFQUFkLEVBRGdDO0lBQVosQ0FBckIsQ0FEc0I7R0FBWDtBQUtaLGNBQVksc0JBQVc7QUFDdEIsUUFBSyxlQUFMLENBQXFCLFVBQVMsRUFBVCxFQUFZO0FBQ2hDLE9BQUcsVUFBSCxHQURnQztJQUFaLENBQXJCLENBRHNCOztBQUt0QixRQUFLLGNBQUwsR0FMc0I7QUFNdEIsUUFBSyxLQUFMLEdBTnNCO0dBQVg7O0FBU1osa0JBQWdCLDBCQUFXO0FBRTFCLE9BQUksWUFBWSxLQUFLLElBQUwsQ0FBVSxvQ0FBVixDQUFaO09BQ0gsYUFBYSxVQUFVLElBQVYsQ0FBZSxZQUFmLENBQWI7T0FDQSxjQUFjLFVBQVUsSUFBVixDQUFlLG1DQUFmLENBQWQsQ0FKeUI7O0FBTTFCLE9BQUcsWUFBWSxNQUFaLEVBQW9CO0FBQ3RCLGVBQVcsUUFBWCxDQUFvQixTQUFwQixFQUErQixJQUEvQixFQUFxQyxFQUFDLFNBQVMsV0FBVCxFQUF0QyxFQURzQjtBQUV0QixjQUFVLElBQVYsQ0FBZSx5QkFBZixFQUEwQyxXQUExQyxDQUFzRCxXQUF0RCxFQUZzQjtJQUF2QjtHQU5lOztBQWVoQixxQkFBbUIsNkJBQVc7QUFFN0IsT0FBRyxLQUFLLElBQUwsQ0FBVSw2QkFBVixFQUF5QyxNQUF6QyxFQUFpRCxPQUFwRDs7QUFFQSxPQUFJLE9BQU8sSUFBUCxDQUp5QjtBQUs3QixPQUFJLGlCQUFpQixFQUNwQix3RkFEb0IsQ0FBakIsQ0FMeUI7QUFRN0IsUUFBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsTUFBakMsR0FBMEMsTUFBMUMsQ0FBaUQsY0FBakQsRUFSNkI7O0FBVzdCLFFBQUssb0JBQUwsR0FYNkI7O0FBYzdCLGtCQUFlLE1BQWYsQ0FBc0IsVUFBUyxDQUFULEVBQVk7QUFDakMsU0FBSyxJQUFMLENBQVUsdUJBQVYsRUFBbUMsR0FBbkMsQ0FBdUMsRUFBRSxJQUFGLEVBQVEsR0FBUixFQUF2QyxFQURpQztJQUFaLENBQXRCLENBZDZCO0dBQVg7O0FBd0JuQixjQUFZLHNCQUFXO0FBQ3RCLE9BQUksV0FBVyxLQUFLLElBQUwsQ0FBVSwrQkFBVixFQUEyQyxHQUEzQyxFQUFYLENBRGtCO0FBRXRCLE9BQUksYUFBYSxFQUFFLFFBQUYsRUFBYixDQUZrQjs7QUFJdEIsV0FBUSxRQUFSO0FBQ0MsU0FBSyxRQUFMO0FBRUMsU0FBSSxtQkFBbUIsRUFBbkIsQ0FGTDtBQUdDLFNBQUksS0FBSyxLQUFLLFNBQUwsRUFBTCxDQUhMOzs7QUFPQyxTQUFHLEVBQUgsRUFBTztBQUNOLFVBQUksTUFBTSxHQUFHLFVBQUgsR0FDUixLQURRLENBQ0YsK0VBREUsQ0FBTixDQURFO0FBR04sVUFBSSxPQUFPLElBQUksTUFBSixFQUFZO0FBQ3RCLFlBQUksSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLElBQUksTUFBSixFQUFZLEdBQS9CLEVBQW9DO0FBQ25DLFlBQUksYUFBYSxHQUFDLENBQUksQ0FBSixFQUFPLE9BQVAsQ0FBZSxLQUFmLEtBQXlCLENBQUMsQ0FBRCxHQUFNLENBQWhDLEdBQW9DLENBQXBDLENBRGtCO0FBRW5DLHlCQUFpQixJQUFqQixDQUFzQixJQUFJLENBQUosRUFBTyxNQUFQLENBQWMsVUFBZCxFQUEwQixPQUExQixDQUFrQyxJQUFsQyxFQUF3QyxFQUF4QyxDQUF0QixFQUZtQztRQUFwQztPQUREO01BSEQ7O0FBV0EsZ0JBQVcsT0FBWCxDQUFtQixnQkFBbkIsRUFsQkQ7QUFtQkMsV0FuQkQ7O0FBREQsU0FzQk0sVUFBTDtBQUVDLFNBQUksU0FBUyxLQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxFQUFULENBRkw7O0FBSUMsU0FBSSxNQUFKLEVBQVk7QUFDWCxRQUFFLElBQUYsQ0FBTztBQUNOLFlBQUssRUFBRSxJQUFGLENBQU8sZUFBUCxDQUNKLEtBQUssSUFBTCxDQUFVLFFBQVYsRUFBb0IsT0FBcEIsQ0FBNEIsVUFBNUIsRUFBd0MsWUFBeEMsQ0FESSxFQUVKLEVBQUMsVUFBVSxTQUFTLE1BQVQsQ0FBVixFQUZHLENBQUw7QUFJQSxnQkFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QixHQUF2QixFQUE0QjtBQUNwQyxtQkFBVyxPQUFYLENBQW1CLEVBQUUsU0FBRixDQUFZLElBQVosQ0FBbkIsRUFEb0M7UUFBNUI7QUFHVCxjQUFPLGVBQVMsR0FBVCxFQUFjLE1BQWQsRUFBc0I7QUFDNUIsbUJBQVcsTUFBWCxDQUFrQixJQUFJLFlBQUosQ0FBbEIsQ0FENEI7UUFBdEI7T0FSUixFQURXO01BQVosTUFhTztBQUNOLGlCQUFXLE9BQVgsQ0FBbUIsRUFBbkIsRUFETTtNQWJQO0FBZ0JBLFdBcEJEOztBQXRCRDtBQThDRSxnQkFBVyxNQUFYLENBQWtCLGVBQUssRUFBTCxDQUNqQixxQ0FEaUIsRUFFakIsK0NBRmlCLENBQWxCLEVBRkQ7QUFNQyxXQU5EO0FBNUNELElBSnNCOztBQXlEdEIsVUFBTyxXQUFXLE9BQVgsRUFBUCxDQXpEc0I7R0FBWDs7QUErRFosd0JBQXNCLGdDQUFXO0FBQ2hDLE9BQUksT0FBTyxJQUFQLENBRDRCO0FBRWhDLE9BQUksV0FBVyxLQUFLLElBQUwsQ0FBVSw2QkFBVixDQUFYLENBRjRCO0FBR2hDLE9BQUksYUFBYSxLQUFLLFVBQUwsRUFBYixDQUg0Qjs7QUFNaEMsWUFBUyxLQUFULEdBTmdDO0FBT2hDLFlBQVMsTUFBVCxDQUFnQixFQUNmLG1DQUNBLGVBQUssRUFBTCxDQUFRLG1DQUFSLEVBQTZDLHdCQUE3QyxDQURBLEdBRUEsV0FGQSxDQURELEVBUGdDOztBQWFoQyxjQUFXLElBQVgsQ0FBZ0IsVUFBUyxPQUFULEVBQWtCO0FBQ2pDLGFBQVMsS0FBVCxHQURpQztBQUVqQyxhQUFTLE1BQVQsQ0FBZ0IsRUFDZixtQ0FDQSxlQUFLLEVBQUwsQ0FBUSw4QkFBUixDQURBLEdBRUEsV0FGQSxDQURELEVBRmlDOztBQVFqQyxRQUFJLE9BQUosRUFBYTtBQUNaLFVBQUssSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLFFBQVEsTUFBUixFQUFnQixHQUFwQyxFQUF5QztBQUN4QyxlQUFTLE1BQVQsQ0FBZ0IsRUFBRSxvQkFBa0IsUUFBUSxDQUFSLENBQWxCLEdBQTZCLElBQTdCLEdBQWtDLFFBQVEsQ0FBUixDQUFsQyxHQUE2QyxXQUE3QyxDQUFsQixFQUR3QztNQUF6QztLQUREO0lBUmUsQ0FBaEIsQ0FjRyxJQWRILENBY1EsVUFBUyxPQUFULEVBQWtCO0FBQ3pCLGFBQVMsS0FBVCxHQUR5QjtBQUV6QixhQUFTLE1BQVQsQ0FBZ0IsRUFDZixtQ0FDQSxPQURBLEdBRUEsV0FGQSxDQURELEVBRnlCO0lBQWxCLENBZFIsQ0FiZ0M7O0FBcUNoQyxPQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsU0FBUyxJQUFULEdBQWdCLElBQWhCLEdBQXBCO0dBckNxQjs7QUE0Q3RCLG9CQUFrQiw0QkFBVztBQUM1QixPQUFJLGlCQUFpQixhQUFqQjtPQUFnQyxTQUFwQztPQUErQyxPQUFPLEtBQUssY0FBTCxFQUFQLENBRG5COztBQUc1QixPQUFHLElBQUgsRUFBUztBQUNSLFNBQUksU0FBSixJQUFpQixJQUFqQixFQUF1QjtBQUN0QixTQUFJLEtBQUssS0FBSyxJQUFMLENBQVUsaUJBQWlCLFNBQWpCLEdBQTZCLEdBQTdCLENBQWY7U0FBa0QsV0FBVyxLQUFLLFNBQUwsQ0FBWCxDQURoQzs7QUFHdEIsU0FBRyxPQUFPLFFBQVAsSUFBb0IsUUFBcEIsRUFBOEIsV0FBVyxTQUFTLE9BQVQsQ0FBaUIsY0FBakIsRUFBaUMsRUFBakMsQ0FBWCxDQUFqQzs7QUFHQSxTQUFHLEdBQUcsRUFBSCxDQUFNLFdBQU4sQ0FBSCxFQUF1QjtBQUN0QixTQUFHLElBQUgsQ0FBUSxTQUFSLEVBQW1CLFFBQW5CLEVBQTZCLE1BQTdCLEdBRHNCO01BQXZCLE1BRU8sSUFBRyxHQUFHLEVBQUgsQ0FBTSxRQUFOLENBQUgsRUFBb0I7QUFDMUIsU0FBRyxHQUFILENBQU8sQ0FBQyxRQUFELENBQVAsRUFBbUIsTUFBbkIsR0FEMEI7TUFBcEIsTUFFQSxJQUFHLGFBQWEsTUFBYixFQUFxQjtBQUU5QixXQUFLLEtBQUssSUFBTCxDQUFVLGtCQUFrQixTQUFsQixHQUE4QixlQUE5QixDQUFmLENBRjhCOztBQUk5QixXQUFLLEdBQUcsT0FBSCxDQUFXLGlCQUFYLENBQUwsQ0FKOEI7O0FBTzlCLE9BQUMsU0FBUyxNQUFULENBQWdCLEVBQWhCLEVBQW9CLFFBQXBCLEVBQThCO0FBQzlCLFdBQUksQ0FBRSxHQUFHLFNBQUgsRUFBRixFQUFrQjtBQUNyQixtQkFBVyxZQUFVO0FBQUUsZ0JBQU8sRUFBUCxFQUFXLFFBQVgsRUFBRjtTQUFWLEVBQXFDLEVBQWhELEVBRHFCO1FBQXRCLE1BRU87QUFDTixXQUFHLFdBQUgsQ0FBZSxDQUFDLFFBQUQsQ0FBZixFQURNO1FBRlA7T0FEQSxDQUFELENBTUcsRUFOSCxFQU1PLFFBTlAsRUFQOEI7TUFBeEIsTUFjQTtBQUNOLFNBQUcsR0FBSCxDQUFPLFFBQVAsRUFBaUIsTUFBakIsR0FETTtNQWRBO0tBVlI7SUFERDtHQUhpQjs7QUF3Q2xCLGtCQUFnQiwwQkFBVztBQUMxQixPQUFJLGFBQWEsS0FBSyxZQUFMLEVBQWI7T0FDSCxPQUFPLEVBQVA7T0FBVyxTQUFTLEVBQVQ7T0FBYSxRQUFRLEVBQVI7T0FBWSxTQUFTLFFBQVQ7T0FBbUIsY0FBYyxFQUFkLENBRjlCOztBQU8xQixPQUFJLGlCQUFpQixJQUFqQixDQVBzQjtBQVExQixPQUFHLFdBQVcsTUFBWCxFQUFtQjtBQUNyQixRQUFHLFdBQVcsRUFBWCxDQUFjLEdBQWQsQ0FBSCxFQUF1QjtBQUV0QixzQkFBaUIsVUFBakIsQ0FGc0I7S0FBdkIsTUFRTztBQUVOLHVCQUFpQixhQUFhLFdBQVcsT0FBWCxDQUFtQixTQUFuQixDQUFiLENBRlg7TUFSUDtJQUREO0FBY0EsT0FBRyxrQkFBa0IsZUFBZSxNQUFmLEVBQXVCLEtBQUssZUFBTCxDQUFxQixVQUFTLEVBQVQsRUFBWTtBQUM1RSxPQUFHLFVBQUgsQ0FBYyxlQUFlLENBQWYsQ0FBZCxFQUQ0RTtJQUFaLENBQXJCLENBQTVDOztBQUtBLE9BQUksQ0FBQyxlQUFlLElBQWYsQ0FBb0IsTUFBcEIsQ0FBRCxFQUE4QixpQkFBaUIsSUFBakIsQ0FBbEM7O0FBRUEsT0FBSSxjQUFKLEVBQW9CO0FBQ25CLFdBQU8sZUFBZSxJQUFmLENBQW9CLE1BQXBCLENBQVAsQ0FEbUI7QUFFbkIsYUFBUyxlQUFlLElBQWYsQ0FBb0IsUUFBcEIsQ0FBVCxDQUZtQjtBQUduQixZQUFRLGVBQWUsSUFBZixDQUFvQixPQUFwQixDQUFSLENBSG1CO0FBSW5CLGtCQUFjLGVBQWUsSUFBZixDQUFvQixPQUFwQixDQUFkLENBSm1CO0FBS25CLFdBQU8sS0FBSyxTQUFMLEdBQWlCLFNBQWpCLENBQTJCLElBQTNCLEVBQWlDLGNBQWpDLENBQVAsQ0FMbUI7QUFNbkIsYUFBUyxRQUFULENBTm1CO0lBQXBCOztBQVNBLE9BQUcsS0FBSyxLQUFMLENBQVcsZUFBWCxDQUFILEVBQWdDO0FBQy9CLFdBQU87QUFDTixlQUFVLE9BQVY7QUFDQSxZQUFPLE9BQU8sRUFBUDtBQUNQLGtCQUFhLEtBQWI7S0FIRCxDQUQrQjtJQUFoQyxNQU1PLElBQUcsS0FBSyxLQUFMLENBQVcsZ0JBQVgsS0FBZ0MsS0FBSyxLQUFMLENBQVcsb0RBQVgsQ0FBaEMsRUFBa0c7QUFDM0csV0FBTztBQUNOLGVBQVUsTUFBVjtBQUNBLFdBQU0sT0FBTyxFQUFQO0FBQ04sa0JBQWEsS0FBYjtBQUNBLGtCQUFhLFNBQVMsSUFBVCxHQUFnQixLQUFoQjtLQUpkLENBRDJHO0lBQXJHLE1BT0EsSUFBRyxLQUFLLEtBQUwsQ0FBVyxTQUFYLENBQUgsRUFBMEI7QUFDaEMsV0FBTztBQUNOLGVBQVUsUUFBVjtBQUNBLGFBQVEsT0FBTyxFQUFQO0FBQ1Isa0JBQWEsS0FBYjtBQUNBLGtCQUFhLFNBQVMsSUFBVCxHQUFnQixLQUFoQjtLQUpkLENBRGdDO0lBQTFCLE1BT0EsSUFBRyxLQUFLLEtBQUwsQ0FBVyxzREFBWCxDQUFILEVBQXVFO0FBQzdFLFdBQU87QUFDTixlQUFVLFVBQVY7QUFDQSxlQUFVLE9BQU8sRUFBUDtBQUNWLGFBQVEsT0FBTyxFQUFQLEdBQVksT0FBTyxFQUFQLENBQVUsTUFBVixDQUFpQixDQUFqQixDQUFaLEdBQWtDLEVBQWxDO0FBQ1Isa0JBQWEsS0FBYjtBQUNBLGtCQUFhLFNBQVMsSUFBVCxHQUFnQixLQUFoQjtLQUxkLENBRDZFO0lBQXZFLE1BUUEsSUFBRyxJQUFILEVBQVM7QUFDZixXQUFPO0FBQ04sZUFBVSxVQUFWO0FBQ0EsZUFBVSxJQUFWO0FBQ0Esa0JBQWEsS0FBYjtBQUNBLGtCQUFhLFNBQVMsSUFBVCxHQUFnQixLQUFoQjtLQUpkLENBRGU7SUFBVCxNQU9BO0FBRU4sV0FBTyxJQUFQLENBRk07SUFQQTtHQWxFUTtFQTFTakIsRUF0UDJCOztBQWduQjNCLEdBQUUsb0RBQUYsRUFBd0QsT0FBeEQsQ0FBZ0U7QUFDL0QsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsUUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQixNQUEzQixHQURvQjtBQUVwQixRQUFLLE1BQUwsR0FGb0I7R0FBWjtBQUlULFlBQVUsb0JBQVc7QUFDcEIsUUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQixNQUEzQixHQURvQjs7QUFJcEIsT0FBSSxXQUFXLEtBQUssTUFBTCxHQUFjLElBQWQsQ0FBbUIsVUFBbkIsRUFBK0IsR0FBL0IsRUFBWCxDQUpnQjtBQUtwQixPQUFJLGFBQVcsUUFBWCxJQUF1QixhQUFXLFVBQVgsRUFBdUI7QUFDakQsU0FBSyxPQUFMLENBQWEsK0JBQWIsRUFBOEMsb0JBQTlDLEdBRGlEO0lBQWxEO0FBR0EsUUFBSyxNQUFMLEdBUm9CO0dBQVg7RUFMWCxFQWhuQjJCOztBQWlvQjNCLEdBQUUsb0RBQUYsRUFBd0QsT0FBeEQsQ0FBZ0U7QUFJL0Qsa0JBQWdCLDBCQUFXO0FBQzFCLFFBQUssT0FBTCxDQUFhLCtCQUFiLEVBQThDLG9CQUE5QyxHQUQwQjtBQUUxQixRQUFLLE1BQUwsR0FGMEI7R0FBWDtFQUpqQixFQWpvQjJCOztBQTJvQjNCLEdBQUUsMkRBQUYsRUFBK0QsT0FBL0QsQ0FBdUU7QUFDdEUsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsUUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQixVQUEzQixHQURvQjtBQUVwQixRQUFLLE1BQUwsR0FGb0I7QUFHcEIsVUFBTyxLQUFQLENBSG9CO0dBQVo7RUFEVixFQTNvQjJCOztBQTZwQjNCLEdBQUUsZ0NBQUYsRUFBb0MsT0FBcEMsQ0FBNEM7QUFDM0MscUJBQW1CLDZCQUFVO0FBQzVCLE9BQUksaUJBQWlCLFFBQVEsS0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsTUFBdEMsQ0FBekIsQ0FEd0I7QUFFNUIsUUFBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsaUJBQWlCLE1BQWpCLEdBQTBCLE1BQTFCLENBQXRDLEdBRjRCO0dBQVY7QUFJbkIsWUFBVSxvQkFBVztBQUNwQixRQUFLLGVBQUwsQ0FBcUIsVUFBUyxFQUFULEVBQVk7QUFDaEMsU0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsSUFBdEMsQ0FBMkMsWUFBVztBQUNyRCxPQUFFLElBQUYsRUFBUSxVQUFSLENBQW1CLEVBQW5CLEVBRHFEO0tBQVgsQ0FBM0MsQ0FEZ0M7SUFBWixDQUFyQixDQURvQjs7QUFPcEIsUUFBSyxTQUFMLEdBQWlCLEtBQWpCLEdBUG9CO0FBUXBCLFVBQU8sS0FBUCxDQVJvQjtHQUFYO0FBVVYsb0JBQWtCLDRCQUFXO0FBQzVCLE9BQUksT0FBTyxJQUFQO09BQWEsT0FBTyxLQUFLLFlBQUwsRUFBUCxDQURXOztBQUk1QixPQUFHLEtBQUssRUFBTCxDQUFRLEtBQVIsQ0FBSCxFQUFtQjtBQUNsQixTQUFLLFlBQUwsQ0FBa0IsS0FBSyxJQUFMLENBQVUsS0FBVixLQUFvQixLQUFLLElBQUwsQ0FBVSxLQUFWLENBQXBCLENBQWxCLENBQXdELElBQXhELENBQTZELFVBQVMsU0FBVCxFQUFvQjtBQUNoRixlQUFVLGNBQVYsQ0FBeUIsSUFBekIsRUFEZ0Y7QUFFaEYsVUFBSyxpQkFBTCxHQUZnRjtBQUdoRixVQUFLLE1BQUwsR0FIZ0Y7S0FBcEIsQ0FBN0QsQ0FEa0I7SUFBbkI7QUFPQSxRQUFLLE1BQUwsR0FYNEI7R0FBWDtBQWFsQixVQUFRLGdCQUFTLGNBQVQsRUFBeUI7QUFDaEMsUUFBSyxNQUFMLEdBRGdDOztBQUdoQyxPQUFJLE9BQU8sS0FBSyxZQUFMLEVBQVA7T0FDSCxXQUFXLFFBQVEsS0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsTUFBdEMsQ0FBbkI7T0FDQSxrQkFBa0IsS0FBSyxFQUFMLENBQVEsS0FBUixDQUFsQjtPQUNBLGVBQWUsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUFmO09BQ0EsU0FBUyxLQUFLLElBQUwsQ0FBVSxjQUFWLENBQVQsQ0FQK0I7O0FBVWhDLFVBQU8sV0FBYSxNQUFiLEdBQXNCLE1BQXRCLENBQVAsR0FWZ0M7O0FBYWhDLFFBQUssT0FBTCxDQUFhLFdBQWIsRUFDRSxJQURGLENBQ08sb0NBRFAsRUFFRSxNQUZGLENBRVMsV0FBVyxRQUFYLEdBQXNCLFNBQXRCLENBRlQsQ0FHRSxXQUhGLENBR2MsbUJBSGQsRUFHbUMsQ0FBQyxRQUFELENBSG5DLENBYmdDOztBQW1CaEMsUUFBSyxJQUFMLENBQVUsZ0NBQVYsRUFBNEMsbUJBQW1CLFlBQW5CLEdBQWtDLE1BQWxDLEdBQTJDLE1BQTNDLENBQTVDLEdBbkJnQztBQW9CaEMsUUFBSyxJQUFMLENBQVUsNEJBQVYsRUFBd0MsbUJBQW1CLENBQUMsWUFBRCxHQUFnQixNQUFuQyxHQUE0QyxNQUE1QyxDQUF4QyxHQXBCZ0M7O0FBc0JoQyxPQUFJLG1CQUFtQixLQUFLLElBQUwsQ0FBVSwyQ0FBVixDQUFuQixDQXRCNEI7O0FBd0JoQyxPQUFJLGVBQUosRUFBcUI7QUFFcEIscUJBQWlCLElBQWpCLEdBRm9CO0lBQXJCLE1BR08sSUFBSSxZQUFKLEVBQWtCO0FBRXhCLHFCQUNFLElBREYsR0FFRSxJQUZGLENBRU8sZUFBSyxFQUFMLENBQVEsMkJBQVIsQ0FGUCxFQUdFLE9BSEYsQ0FHVSxvRUFBb0UsZUFBSyxFQUFMLENBQVEsc0JBQVIsQ0FBcEUsR0FBc0csYUFBdEcsQ0FIVixDQUZ3Qjs7QUFPeEIsU0FBSyxJQUFMLENBQVUsNENBQVYsRUFBd0QsS0FBeEQsR0FQd0I7SUFBbEIsTUFRQTtBQUVOLHFCQUNFLElBREYsR0FFRSxJQUZGLENBRU8sZUFBSyxFQUFMLENBQVEsNEJBQVIsQ0FGUCxFQUdFLElBSEYsQ0FHTyxjQUhQLEVBR3VCLE1BSHZCLEdBRk07SUFSQTs7QUFpQlAsUUFBSyxJQUFMLENBQVUsMkNBQVYsRUFBdUQsa0JBQWtCLE1BQWxCLEdBQTJCLE1BQTNCLENBQXZELEdBNUNnQztBQTZDaEMsUUFBSyxJQUFMLENBQVUsOEJBQVYsRUFBMEMsa0JBQWtCLE1BQWxCLEdBQTJCLE1BQTNCLENBQTFDLEdBN0NnQztBQThDaEMsUUFBSyxJQUFMLENBQVUsMkJBQVYsRUFBdUMsa0JBQWtCLE1BQWxCLEdBQTJCLE1BQTNCLENBQXZDLEdBOUNnQztBQStDaEMsUUFBSyxJQUFMLENBQVUsOEJBQVYsRUFBMEMsa0JBQWtCLE1BQWxCLEdBQTJCLE1BQTNCLENBQTFDLEdBL0NnQztBQWdEaEMsUUFBSyxJQUFMLENBQVUsd0JBQVYsRUFBb0Msa0JBQWtCLE1BQWxCLEdBQTJCLE1BQTNCLENBQXBDLEdBaERnQztBQWlEaEMsUUFBSyxJQUFMLENBQVUsK0JBQVYsRUFBMkMsY0FBM0MsQ0FBMEQsZUFBMUQsRUFqRGdDO0FBa0RoQyxRQUFLLElBQUwsQ0FBVSwrQ0FBVixFQUEyRCxHQUEzRCxDQUErRCxNQUEvRCxFQUF1RSxFQUFFLDRDQUFGLEVBQWdELFVBQWhELEVBQXZFLEVBbERnQztBQW1EaEMsUUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQixRQUEzQixDQUFvQyx5QkFBcEMsRUFuRGdDO0FBb0RoQyxRQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQ0UsSUFERixDQUNPLHFEQURQLEVBRUUsSUFGRixDQUVPLENBQUMsa0JBQWtCLGVBQUssRUFBTCxDQUN6Qix3QkFEeUIsRUFFekIsUUFGeUIsQ0FBbEIsR0FHSixlQUFLLEVBQUwsQ0FDSCx3QkFERyxFQUVILFFBRkcsQ0FISSxDQUZSLEVBcERnQztHQUF6QjtBQThEUixlQUFhLHVCQUFXO0FBQ3ZCLFFBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLE1BQXRDLEdBRHVCO0FBRXZCLFFBQUssSUFBTCxDQUFVLGtDQUFWLEVBQThDLFdBQTlDLENBQTBELGFBQTFELEVBRnVCO0FBR3ZCLFFBQUssSUFBTCxDQUFVLHdCQUFWLEVBQW9DLE1BQXBDLEdBSHVCO0FBSXZCLFFBQUssTUFBTCxHQUp1Qjs7QUFNdkIsUUFBSyxNQUFMLEdBTnVCO0dBQVg7QUFRYixlQUFhLHFCQUFTLE9BQVQsRUFBa0I7QUFDOUIsVUFBTyxLQUFLLElBQUwsQ0FBVSxzQ0FBc0MsT0FBdEMsR0FBZ0QsR0FBaEQsQ0FBakIsQ0FEOEI7R0FBbEI7QUFHYixnQkFBYyxzQkFBUyxPQUFULEVBQWtCO0FBQy9CLE9BQUksT0FBTyxJQUFQO09BQWEsU0FBUyxNQUFDLENBQU8sT0FBUCxLQUFtQixPQUFuQixHQUE4QixFQUFDLElBQUksT0FBSixFQUFoQyxHQUErQyxFQUFDLFNBQVMsT0FBVCxFQUFoRCxDQURLOztBQUcvQixPQUFJLE9BQU8sRUFBRSxpREFBRixDQUFQLENBSDJCO0FBSS9CLFFBQUssSUFBTCxDQUFVLGVBQVYsRUFBMkIsT0FBM0IsQ0FBbUMsSUFBbkMsRUFKK0I7O0FBTS9CLE9BQUksTUFBTSxFQUFFLFFBQUYsRUFBTixDQU4yQjs7QUFRL0IsS0FBRSxJQUFGLENBQU87QUFDTixTQUFLLEVBQUUsSUFBRixDQUFPLGVBQVAsQ0FBdUIsS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixPQUFwQixDQUE0QixXQUE1QixFQUF5QyxVQUF6QyxDQUF2QixFQUE2RSxNQUE3RSxDQUFMO0FBQ0EsYUFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QixHQUF2QixFQUE0QjtBQUNwQyxTQUFJLFVBQVUsRUFBRSxJQUFGLEVBQVEsTUFBUixDQUFlLDBCQUFmLENBQVYsQ0FEZ0M7QUFFcEMsVUFBSyxXQUFMLENBQWlCLE9BQWpCLEVBRm9DO0FBR3BDLFVBQUssTUFBTCxHQUhvQztBQUlwQyxTQUFJLE9BQUosQ0FBWSxPQUFaLEVBSm9DO0tBQTVCO0FBTVQsV0FBTyxpQkFBVztBQUNqQixVQUFLLE1BQUwsR0FEaUI7QUFFakIsU0FBSSxNQUFKLEdBRmlCO0tBQVg7SUFSUixFQVIrQjs7QUFzQi9CLFVBQU8sSUFBSSxPQUFKLEVBQVAsQ0F0QitCO0dBQWxCO0VBckdmLEVBN3BCMkI7O0FBNnhCM0IsR0FBRSwwREFBRixFQUE4RCxPQUE5RCxDQUFzRTtBQUNyRSxXQUFTLG1CQUFZO0FBQ3BCLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVAsQ0FEZ0I7O0FBR3BCLFFBQUssUUFBTCxDQUFjLGNBQWQsRUFIb0I7QUFJcEIsUUFBSyxNQUFMLEdBSm9CO0dBQVo7RUFEVixFQTd4QjJCOztBQXV5QjNCLEdBQUUsZ0ZBQUYsRUFBb0YsT0FBcEYsQ0FBNEY7QUFDM0YsV0FBUyxtQkFBVztBQUNuQixPQUFJLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQLENBRGU7O0FBR25CLFFBQUssV0FBTCxDQUFpQixjQUFqQixFQUhtQjtBQUluQixRQUFLLE1BQUwsR0FKbUI7R0FBWDtFQURWLEVBdnlCMkI7O0FBZ3pCM0IsR0FBRSxvREFBRixFQUF3RCxPQUF4RCxDQUFnRTtBQUMvRCx3QkFBc0IsOEJBQVMsQ0FBVCxFQUFZLEVBQVosRUFBZ0I7QUFDckMsT0FBSSxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUDtPQUE2QixPQUFPLEVBQUUsR0FBRyxRQUFILENBQVQsQ0FESTtBQUVyQyxPQUFHLENBQUMsS0FBSyxFQUFMLENBQVEsb0JBQVIsQ0FBRCxFQUFnQyxPQUFuQztBQUNBLFFBQUssT0FBTCxDQUFhLE1BQWIsRUFBcUIsWUFBckIsQ0FBa0MsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFsQyxFQUhxQztBQUlyQyxRQUFLLE1BQUwsR0FKcUM7O0FBTXJDLFFBQUssTUFBTCxHQUFjLE9BQWQsQ0FBc0IsUUFBdEIsRUFOcUM7R0FBaEI7QUFRdEIsMEJBQXdCLGdDQUFTLENBQVQsRUFBWSxFQUFaLEVBQWdCO0FBQ3ZDLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVA7T0FBNkIsT0FBTyxFQUFFLEdBQUcsVUFBSCxDQUFULENBRE07QUFFdkMsT0FBRyxDQUFDLEtBQUssRUFBTCxDQUFRLG9CQUFSLENBQUQsRUFBZ0MsT0FBbkM7QUFDQSxRQUFLLFdBQUwsQ0FBaUIsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFqQixFQUFrQyxNQUFsQyxHQUh1QztBQUl2QyxRQUFLLE1BQUwsR0FKdUM7R0FBaEI7RUFUekIsRUFoekIyQjs7QUFvMEIzQixHQUFFLDZFQUFGLEVBQWlGLE9BQWpGLENBQXlGO0FBR3hGLG9CQUFrQiwwQkFBUyxDQUFULEVBQVk7QUFDN0IsT0FBSSxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUCxDQUR5Qjs7QUFJN0IsT0FBSSxlQUFlLEVBQWYsQ0FKeUI7QUFLN0IsUUFBSyxJQUFMLENBQVUsa0JBQVYsRUFBOEIsSUFBOUIsQ0FBbUMsNkJBQW5DLEVBQWtFLElBQWxFLENBQXVFLFlBQVU7QUFFaEYsaUJBQWEsSUFBYixDQUFrQixFQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsSUFBYixDQUFsQixFQUZnRjtJQUFWLENBQXZFLENBTDZCOztBQVU3QixPQUFJLGdCQUFnQixFQUFFLHVCQUFGLEVBQTJCLElBQTNCLEVBQWlDLFFBQWpDLENBQTBDLHNCQUExQyxDQUFoQixDQVZ5QjtBQVc3QixpQkFBYyxJQUFkLENBQW1CLFlBQVU7QUFDNUIsUUFBSSxhQUFhLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxRQUFiLENBQWIsQ0FEd0I7QUFFNUIsUUFBSSxjQUFjLEVBQUUsT0FBRixDQUFVLFVBQVYsRUFBc0IsWUFBdEIsS0FBdUMsQ0FBQyxDQUFELEVBQUk7QUFFNUQsT0FBRSxJQUFGLEVBQVEsTUFBUixHQUY0RDtBQUc1RCxVQUFLLFlBQUwsQ0FBa0IsVUFBbEIsRUFINEQ7S0FBN0Q7SUFGa0IsQ0FBbkIsQ0FYNkI7O0FBb0I3QixRQUFLLE1BQUwsR0FBYyxPQUFkLENBQXNCLFFBQXRCLEVBcEI2Qjs7QUFzQjdCLFFBQUssTUFBTCxHQXRCNkI7R0FBWjs7RUFIbkIsRUFwMEIyQjs7QUFrMkIzQixHQUFFLHFFQUFGLEVBQXlFLE9BQXpFLENBQWlGO0FBQ2hGLFNBQU8saUJBQVc7QUFDakIsUUFBSyxNQUFMLEdBRGlCO0FBRWpCLFFBQUssUUFBTCxHQUZpQjtHQUFYOztBQUtQLFdBQVMsbUJBQVc7QUFDbkIsUUFBSyxRQUFMLEdBRG1CO0dBQVg7O0FBSVQsWUFBVSxvQkFBVztBQUNwQixRQUFLLFFBQUwsR0FEb0I7R0FBWDs7QUFJVixnQkFBYyx3QkFBVztBQUN4QixVQUFPLEtBQUssT0FBTCxDQUFhLGlCQUFiLEVBQWdDLElBQWhDLENBQXFDLGdCQUFyQyxDQUFQLENBRHdCO0dBQVg7O0FBSWQsWUFBVSxvQkFBVztBQUNwQixPQUFJLE1BQU0sS0FBSyxHQUFMLEVBQU47T0FBa0IsT0FBTyxHQUFQLENBREY7O0FBR3BCLFNBQU0sRUFBRSxJQUFGLENBQU8sR0FBUCxDQUFOLENBSG9CO0FBSXBCLFNBQU0sSUFBSSxPQUFKLENBQVksZUFBWixFQUE2QixFQUE3QixDQUFOLENBSm9CO0FBS3BCLE9BQUksU0FBUyxHQUFULEVBQWMsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFsQjs7QUFFQSxRQUFLLFlBQUwsR0FBb0IsTUFBcEIsQ0FBMkIsQ0FBQyxDQUFDLEdBQUQsR0FBTyxRQUFSLEdBQW1CLFNBQW5CLENBQTNCLENBUG9CO0FBUXBCLFVBQU8sQ0FBQyxDQUFDLEdBQUQsQ0FSWTtHQUFYO0VBbEJYLEVBbDJCMkI7O0FBbTRCM0IsR0FBRSw4REFBRixFQUFrRSxPQUFsRSxDQUEwRTtBQUN6RSxlQUFhLHVCQUFXO0FBQ3ZCLFVBQU8sS0FBSyxPQUFMLENBQWEsaUJBQWIsRUFBZ0MsSUFBaEMsQ0FBcUMsaUJBQXJDLENBQVAsQ0FEdUI7R0FBWDs7QUFJYixXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixPQUFJLFdBQVcsS0FBSyxXQUFMLEVBQVg7T0FBK0IsWUFBWSxLQUFLLE9BQUwsQ0FBYSxpQkFBYixDQUFaO09BQTZDLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQLENBRDVEOztBQUdwQixPQUFJLFNBQVMsUUFBVCxFQUFKLEVBQXlCO0FBQ3hCLGNBQVUsUUFBVixDQUFtQixTQUFuQixFQUR3QjtBQUV4QixTQUFLLFlBQUwsQ0FBa0IsWUFBWSxTQUFTLEdBQVQsRUFBWixDQUFsQixDQUE4QyxJQUE5QyxDQUFtRCxZQUFXO0FBQzdELGVBQVUsV0FBVixDQUFzQixTQUF0QixFQUQ2RDs7QUFHN0QsVUFBSyxNQUFMLEdBQWMsT0FBZCxDQUFzQixRQUF0QixFQUg2RDtLQUFYLENBQW5ELENBRndCO0FBT3hCLFNBQUssTUFBTCxHQVB3QjtJQUF6Qjs7QUFVQSxVQUFPLEtBQVAsQ0Fib0I7R0FBWjtFQUxWLEVBbjRCMkI7O0FBNjVCM0IsR0FBRSx5REFBRixFQUE2RCxPQUE3RCxDQUFxRTtBQUlwRSxpQkFBZSx5QkFBVyxFQUFYOztBQU1mLGdCQUFjLHdCQUFXLEVBQVg7O0FBS2QsV0FBUyxtQkFBVztBQUVuQixVQUFPLEVBQUUsT0FBRixFQUFXLE1BQVgsQ0FDTixFQUFFLE1BQUYsRUFBVSxJQUFWLENBQWUsRUFBQyxNQUFNLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBTixFQUFoQixFQUF5QyxJQUF6QyxDQUE4QyxLQUFLLElBQUwsQ0FBVSxPQUFWLEVBQW1CLElBQW5CLEVBQTlDLENBRE0sRUFFTCxJQUZLLEVBQVAsQ0FGbUI7R0FBWDs7QUFTVCxjQUFZLG9CQUFTLEVBQVQsRUFBYTtBQUV4QixNQUFHLGNBQUgsQ0FBa0IsS0FBSyxPQUFMLEVBQWxCLEVBRndCO0dBQWI7O0FBU1osa0JBQWdCLHdCQUFTLElBQVQsRUFBZSxFQUFmOztBQVVoQixvQkFBa0IsMEJBQVMsV0FBVCxFQUFzQixJQUF0QixFQUE0QixJQUE1QixFQUFrQztBQUNuRCxPQUFJLFVBQVUsS0FBSyxJQUFMLENBQVUsb0JBQVYsQ0FBVjtPQUNILFdBQVcsS0FBSyxJQUFMLENBQVUscUJBQVYsQ0FBWDtPQUNBLElBQUksUUFBUSxHQUFSLEVBQUo7T0FDQSxJQUFJLFNBQVMsR0FBVCxFQUFKO09BQ0EsTUFKRCxDQURtRDs7QUFRbkQsT0FBRyxLQUFLLENBQUwsRUFBUTtBQUNWLFFBQUcsV0FBSCxFQUFnQjtBQUNmLGNBQVMsU0FBUyxVQUFULEtBQXdCLFFBQVEsVUFBUixFQUF4QixDQURNOztBQUdmLFNBQUcsZUFBZSxPQUFmLEVBQXdCO0FBQzFCLFVBQUcsUUFBUSxJQUFJLElBQUosRUFBVSxJQUFJLElBQUosQ0FBckI7QUFDQSxVQUFJLEtBQUssS0FBTCxDQUFXLElBQUksTUFBSixDQUFmLENBRjBCO01BQTNCLE1BR08sSUFBRyxlQUFlLFFBQWYsRUFBeUI7QUFDbEMsVUFBRyxRQUFRLElBQUksSUFBSixFQUFVLElBQUksSUFBSixDQUFyQjtBQUNBLFVBQUksS0FBSyxJQUFMLENBQVUsSUFBSSxNQUFKLENBQWQsQ0FGa0M7TUFBNUI7S0FOUixNQVVPO0FBQ04sU0FBRyxRQUFRLElBQUksSUFBSixFQUFVLElBQUksSUFBSixDQUFyQjtBQUNBLFNBQUcsUUFBUSxJQUFJLElBQUosRUFBVSxJQUFJLElBQUosQ0FBckI7S0FaRDs7QUFlQSxZQUFRLEdBQVIsQ0FBWSxDQUFaLEVBaEJVO0FBaUJWLGFBQVMsR0FBVCxDQUFhLENBQWIsRUFqQlU7SUFBWDtHQVJpQjtFQTNDbkIsRUE3NUIyQjs7QUFzK0IzQixHQUFFLCtEQUFGLEVBQW1FLE9BQW5FLENBQTJFO0FBQzFFLGlCQUFlLHlCQUFXO0FBQ3pCLE9BQUksUUFBUSxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxFQUFSO09BQ0gsU0FBUyxLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFULENBRndCO0FBR3pCLFVBQU87QUFDTixXQUFRLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLEdBQTlCLEVBQVI7QUFDQSxXQUFRLEtBQUssSUFBTCxDQUFVLHNCQUFWLEVBQWtDLEdBQWxDLEVBQVI7QUFDQSxhQUFVLFFBQVEsU0FBUyxLQUFULEVBQWdCLEVBQWhCLENBQVIsR0FBOEIsSUFBOUI7QUFDVixjQUFXLFNBQVMsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQVQsR0FBZ0MsSUFBaEM7QUFDWCxhQUFVLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLEVBQVY7QUFDQSxhQUFVLEtBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLEVBQVY7QUFDQSxtQkFBZ0IsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBaEI7SUFQRCxDQUh5QjtHQUFYO0FBYWYsZ0JBQWMsd0JBQVc7QUFDeEIsVUFBTztBQUNOLG1CQUFlLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEdBQXRDLEVBQWY7SUFERCxDQUR3QjtHQUFYO0FBS2QsV0FBUyxtQkFBVyxFQUFYOztBQU1ULGNBQVksb0JBQVMsRUFBVCxFQUFhO0FBQ3hCLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVAsQ0FEb0I7QUFFeEIsT0FBSSxPQUFPLEtBQUssWUFBTCxFQUFQLENBRm9CO0FBR3hCLE9BQUksQ0FBQyxFQUFELEVBQUssS0FBSyxLQUFLLFNBQUwsRUFBTCxDQUFUOztBQUdBLE9BQUksUUFBUSxLQUFLLGFBQUwsRUFBUjtPQUE4QixZQUFZLEtBQUssWUFBTCxFQUFaLENBTlY7O0FBU3hCLE9BQUksV0FBVyxJQUFDLElBQVEsS0FBSyxFQUFMLENBQVEsS0FBUixDQUFSLEdBQTBCLElBQTNCLEdBQWtDLElBQWxDLENBVFM7QUFVeEIsT0FBSSxZQUFZLFNBQVMsTUFBVCxHQUFrQixFQUFsQixDQUFxQixlQUFyQixDQUFaLEVBQW1ELFdBQVcsU0FBUyxNQUFULEVBQVgsQ0FBdkQ7O0FBR0EsT0FBSSxNQUFNLElBQUMsSUFBUSxLQUFLLEVBQUwsQ0FBUSxLQUFSLENBQVIsR0FBMEIsSUFBM0IsR0FBa0MsRUFBRSxTQUFGLENBQWxDLENBYmM7QUFjeEIsT0FBSSxJQUFKLENBQVMsS0FBVCxFQWR3Qjs7QUFpQnhCLE9BQUksWUFBWSxJQUFJLE1BQUosQ0FBVyxlQUFYLENBQVo7T0FBeUMsVUFBVSxVQUFVLElBQVYsQ0FBZSxVQUFmLENBQVYsQ0FqQnJCOztBQW9CeEIsT0FBSSxVQUFVLFdBQVYsRUFBdUI7QUFDMUIsUUFBSSxDQUFDLFVBQVUsTUFBVixFQUFrQjtBQUN0QixpQkFBWSxFQUFFLGFBQUYsQ0FBWixDQURzQjtLQUF2Qjs7QUFJQSxjQUFVLElBQVYsQ0FBZSxPQUFmLEVBQXdCLGtCQUFnQixNQUFNLE9BQU4sQ0FBaEIsQ0FBeEIsQ0FBd0QsR0FBeEQsQ0FBNEQsT0FBNUQsRUFBcUUsTUFBTSxLQUFOLENBQXJFLENBTDBCOztBQU8xQixRQUFJLENBQUMsUUFBUSxNQUFSLEVBQWdCO0FBQ3BCLGVBQVUsRUFBRSx5QkFBRixFQUE2QixRQUE3QixDQUFzQyxTQUF0QyxDQUFWLENBRG9CO0tBQXJCOztBQUlBLFlBQVEsSUFBUixDQUFhLE9BQWIsRUFBc0IsYUFBVyxNQUFNLE9BQU4sQ0FBWCxDQUF0QixDQUFpRCxJQUFqRCxDQUFzRCxVQUFVLFdBQVYsQ0FBdEQsQ0FYMEI7SUFBM0IsTUFjSztBQUNKLGlCQUFZLFVBQVUsSUFBVixDQURSO0tBZEw7O0FBbUJBLE9BQUksV0FBVyxZQUFZLFNBQVosR0FBd0IsR0FBeEIsQ0F2Q1M7O0FBMEN4QixPQUFJLFlBQVksU0FBUyxHQUFULENBQWEsUUFBYixFQUF1QixNQUF2QixFQUErQjtBQUM5QyxhQUFTLFdBQVQsQ0FBcUIsUUFBckIsRUFEOEM7SUFBL0M7O0FBTUEsT0FBSSxTQUFKLEVBQWU7QUFDZCxjQUFVLE9BQVYsQ0FBa0IsR0FBbEIsRUFEYztJQUFmOztBQUtBLE9BQUksQ0FBQyxRQUFELEVBQVc7QUFFZCxPQUFHLE9BQUgsR0FGYztBQUdkLE9BQUcsYUFBSCxDQUFpQixFQUFFLFNBQUYsRUFBYSxNQUFiLENBQW9CLFFBQXBCLEVBQThCLElBQTlCLEVBQWpCLEVBQXVELEVBQUMsV0FBWSxDQUFaLEVBQXhELEVBSGM7SUFBZjs7QUFNQSxNQUFHLE9BQUgsR0EzRHdCO0FBNER4QixNQUFHLE9BQUgsR0E1RHdCO0dBQWI7QUE4RFosa0JBQWdCLHdCQUFTLElBQVQsRUFBZTtBQUM5QixRQUFLLElBQUwsQ0FBVSxzQkFBVixFQUFrQyxHQUFsQyxDQUFzQyxLQUFLLElBQUwsQ0FBVSxLQUFWLENBQXRDLEVBRDhCO0FBRTlCLFFBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLENBQW9DLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBcEMsRUFGOEI7QUFHOUIsUUFBSyxJQUFMLENBQVUsdUJBQVYsRUFBbUMsR0FBbkMsQ0FBdUMsS0FBSyxJQUFMLENBQVUsT0FBVixDQUF2QyxFQUg4QjtBQUk5QixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxDQUFvQyxLQUFLLEtBQUwsRUFBcEMsRUFKOEI7QUFLOUIsUUFBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsQ0FBcUMsS0FBSyxNQUFMLEVBQXJDLEVBTDhCO0FBTTlCLFFBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEdBQXRDLENBQTBDLEtBQUssUUFBTCxDQUFjLGdCQUFkLEVBQWdDLElBQWhDLEVBQTFDLEVBTjhCO0FBTzlCLFFBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLENBQXFDLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBckMsRUFQOEI7R0FBZjtFQXZGakIsRUF0K0IyQjs7QUE2a0MzQixHQUFFLCtEQUFGLEVBQW1FLE9BQW5FLENBQTJFO0FBQzFFLGlCQUFlLHlCQUFXO0FBQ3pCLE9BQUksUUFBUSxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxFQUFSO09BQ0gsU0FBUyxLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFULENBRndCO0FBR3pCLFVBQU87QUFDTixXQUFRLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLEdBQTlCLEVBQVI7QUFDQSxhQUFVLFFBQVEsU0FBUyxLQUFULEVBQWdCLEVBQWhCLENBQVIsR0FBOEIsSUFBOUI7QUFDVixjQUFXLFNBQVMsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQVQsR0FBZ0MsSUFBaEM7QUFDWCxtQkFBZ0IsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBaEI7SUFKRCxDQUh5QjtHQUFYO0FBVWYsV0FBUyxtQkFBVztBQUNuQixPQUFJLFFBQVEsS0FBSyxhQUFMLEVBQVIsQ0FEZTs7QUFJbkIsT0FBSSxLQUFLLFFBQVEsWUFBUixDQUFxQixPQUFyQixDQUE2QixLQUE3QixDQUFtQyxTQUFuQyxDQUE2QztBQUNyRCxZQUFRLE9BQVI7QUFDQSxhQUFTLE1BQU0sS0FBTjtBQUNULGNBQVUsTUFBTSxNQUFOO0FBQ1YsY0FBVSxFQUFDLE9BQU8sTUFBTSxHQUFOLEVBQWxCO0FBQ0EsYUFBUyxFQUFDLFdBQVcsRUFBWCxFQUFWO0lBTFEsQ0FBTCxDQUplOztBQVluQixVQUFPLEVBQUUsU0FBRixFQUFhLE1BQWIsQ0FBb0IsRUFBcEIsRUFBd0IsSUFBeEIsRUFBUCxDQVptQjtHQUFYO0FBY1Qsa0JBQWdCLHdCQUFTLElBQVQsRUFBZSxFQUFmO0VBekJqQixFQTdrQzJCOztBQWduQzNCLEdBQUUsK0RBQUYsRUFBbUUsT0FBbkUsQ0FBMkU7QUFDMUUsaUJBQWUseUJBQVc7QUFDekIsT0FBSSxRQUFRLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLEVBQVI7T0FDSCxTQUFTLEtBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLEVBQVQsQ0FGd0I7QUFHekIsVUFBTztBQUNOLFdBQVEsS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsSUFBaEMsQ0FBcUMsS0FBckMsQ0FBUjtBQUNBLGFBQVUsUUFBUSxTQUFTLEtBQVQsRUFBZ0IsRUFBaEIsQ0FBUixHQUE4QixJQUE5QjtBQUNWLGNBQVcsU0FBUyxTQUFTLE1BQVQsRUFBaUIsRUFBakIsQ0FBVCxHQUFnQyxJQUFoQztBQUNYLGFBQVUsS0FBSyxJQUFMLENBQVUsdUJBQVYsRUFBbUMsR0FBbkMsRUFBVjtBQUNBLFdBQVEsS0FBSyxJQUFMLENBQVUsc0JBQVYsRUFBa0MsR0FBbEMsRUFBUjtBQUNBLGFBQVUsS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsRUFBVjtBQUNBLG1CQUFnQixLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFoQjtJQVBELENBSHlCO0dBQVg7QUFhZixnQkFBYyx3QkFBVztBQUN4QixPQUFJLFFBQVEsS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsRUFBUjtPQUNILFNBQVMsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBVCxDQUZ1QjtBQUd4QixVQUFPO0FBQ04sbUJBQWUsS0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsR0FBdEMsRUFBZjtBQUNBLFdBQU8sS0FBSyxJQUFMLENBQVUsa0JBQVYsRUFBOEIsR0FBOUIsRUFBUDtBQUNBLGlCQUFhLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLElBQWhDLENBQXFDLEtBQXJDLENBQWI7QUFDQSxhQUFVLFFBQVEsU0FBUyxLQUFULEVBQWdCLEVBQWhCLENBQVIsR0FBOEIsSUFBOUI7QUFDVixjQUFXLFNBQVMsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQVQsR0FBZ0MsSUFBaEM7QUFDWCxnQkFBWSxLQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxFQUFaO0lBTkQsQ0FId0I7R0FBWDtBQVlkLFdBQVMsbUJBQVc7QUFDbkIsT0FBSSxFQUFKO09BQ0MsUUFBUSxLQUFLLGFBQUwsRUFBUjtPQUNBLFlBQVksS0FBSyxZQUFMLEVBQVo7T0FFQSxRQUFRLEVBQUUsU0FBRixFQUFhLElBQWIsQ0FBa0IsS0FBbEIsRUFBeUIsUUFBekIsQ0FBa0MsK0JBQWxDLENBQVIsQ0FMa0I7O0FBT25CLEtBQUUsSUFBRixDQUFPLFNBQVAsRUFBa0IsVUFBVSxHQUFWLEVBQWUsS0FBZixFQUFzQjtBQUN2QyxVQUFNLElBQU4sQ0FBVyxVQUFVLEdBQVYsRUFBZSxLQUExQixFQUR1QztJQUF0QixDQUFsQixDQVBtQjs7QUFXbkIsT0FBRyxVQUFVLFdBQVYsRUFBdUI7QUFDekIsU0FBSyxFQUFFLHdCQUF3QixNQUFNLE9BQU4sQ0FBeEIsR0FBeUMsMkJBQXpDLEdBQXVFLE1BQU0sT0FBTixDQUF2RSxHQUF3Rix1QkFBeEYsR0FBa0gsVUFBVSxXQUFWLEdBQXdCLFlBQTFJLENBQUYsQ0FBMEosT0FBMUosQ0FBa0ssS0FBbEssQ0FBTCxDQUR5QjtJQUExQixNQUVPO0FBQ04sU0FBSyxLQUFMLENBRE07SUFGUDtBQUtBLFVBQU8sRUFBRSxTQUFGLEVBQWEsTUFBYixDQUFvQixFQUFwQixFQUF3QixJQUF4QixFQUFQLENBaEJtQjtHQUFYO0FBa0JULGtCQUFnQix3QkFBUyxJQUFULEVBQWU7QUFDOUIsUUFBSyxJQUFMLENBQVUsc0JBQVYsRUFBa0MsR0FBbEMsQ0FBc0MsS0FBSyxJQUFMLENBQVUsS0FBVixDQUF0QyxFQUQ4QjtBQUU5QixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxDQUFvQyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQXBDLEVBRjhCO0FBRzlCLFFBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLENBQW9DLEtBQUssS0FBTCxFQUFwQyxFQUg4QjtBQUk5QixRQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxDQUFxQyxLQUFLLE1BQUwsRUFBckMsRUFKOEI7QUFLOUIsUUFBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsQ0FBb0MsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFwQyxFQUw4QjtBQU05QixRQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxDQUF1QyxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXZDLEVBTjhCO0FBTzlCLFFBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLENBQXFDLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBckMsRUFQOEI7R0FBZjtFQTVDakIsRUFobkMyQjs7QUF1cUMzQixHQUFFLDRFQUFGLEVBQWdGLE9BQWhGLENBQXdGO0FBQ3ZGLFdBQVMsSUFBVDtBQUNBLFdBQVMsbUJBQVk7QUFDcEIsUUFBSyxNQUFMLEdBRG9COztBQUdwQixRQUFLLFVBQUwsQ0FBZ0IsU0FBUyxLQUFLLEdBQUwsRUFBVCxFQUFxQixFQUFyQixDQUFoQixFQUhvQjtHQUFaO0FBS1QsYUFBVyxxQkFBVztBQUNyQixRQUFLLE1BQUwsR0FEcUI7R0FBWDtBQUdYLGNBQVksb0JBQVMsQ0FBVCxFQUFZO0FBQ3ZCLFFBQUssT0FBTCxDQUFhLDBCQUFiLEVBQXlDLGdCQUF6QyxDQUEwRCxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQTFELEVBRHVCO0dBQVo7RUFWYixFQXZxQzJCOztBQXlyQzNCLEdBQUUsaUZBQUYsRUFBcUYsT0FBckYsQ0FBNkY7QUFDNUYsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsT0FBSSxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUDtPQUE2QixPQUFPLEtBQUssT0FBTCxDQUFhLHFCQUFiLENBQVAsQ0FEYjtBQUVwQixRQUFLLElBQUwsQ0FBVSxnQ0FBZ0MsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFoQyxHQUFrRCxHQUFsRCxDQUFWLENBQWlFLFdBQWpFLENBQTZFLGFBQTdFLEVBRm9CO0FBR3BCLFFBQUssT0FBTCxDQUFhLHNCQUFiLEVBQXFDLE1BQXJDLEdBSG9CO0FBSXBCLFFBQUssTUFBTCxHQUpvQjtBQUtwQixLQUFFLGNBQUYsR0FMb0I7R0FBWjtFQURWLEVBenJDMkI7O0FBbXNDM0IsR0FBRSxzR0FBRixFQUEwRyxPQUExRyxDQUFrSDtBQUNqSCxlQUFhLHVCQUFXO0FBQ3ZCLFVBQU8sS0FBSyxPQUFMLENBQWEsc0JBQWIsRUFBcUMsSUFBckMsQ0FBMEMsK0JBQTFDLENBQVAsQ0FEdUI7R0FBWDs7QUFJYixnQkFBYztBQUNiLGFBQVUsa0JBQVMsQ0FBVCxFQUFXO0FBQ3BCLFFBQUksT0FBTyxFQUFFLEVBQUUsTUFBRixDQUFULENBRGdCO0FBRXBCLFNBQUssV0FBTCxDQUFpQixRQUFqQixFQUZvQjtBQUdwQixTQUFLLFFBQUwsQ0FBYyxRQUFkLEVBSG9CO0lBQVg7R0FEWDs7QUFRQSxXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixPQUFJLFdBQVcsS0FBSyxXQUFMLEVBQVgsQ0FEZ0I7O0FBS3BCLE9BQUksS0FBSyxPQUFMLENBQWEsc0JBQWIsRUFBcUMsUUFBckMsQ0FBOEMseUJBQTlDLENBQUosRUFBOEU7QUFDN0UsYUFBUyxNQUFULENBQWdCLHFCQUFoQixFQUF1QyxXQUF2QyxDQUFtRCxrQkFBbkQsRUFENkU7O0FBRzdFLGFBQVMsY0FBVCxHQUg2RTs7QUFLN0UsTUFBRSxjQUFGLEdBTDZFOztBQU83RSxXQUFPLEtBQVAsQ0FQNkU7SUFBOUU7O0FBVUEsUUFBSyxNQUFMLENBQVksQ0FBWixFQWZvQjtHQUFaO0VBYlYsRUFuc0MyQjs7QUFtdUMzQixHQUFFLHVEQUFGLEVBQTJELE9BQTNELENBQW1FO0FBQ2xFLGtCQUFnQix3QkFBUyxJQUFULEVBQWU7QUFDOUIsT0FBSSxXQUFXLEtBQUssSUFBTCxDQUFVLDJCQUFWLENBQVg7T0FBbUQsU0FBUyxTQUFTLElBQVQsQ0FBYyw2QkFBZCxDQUFULENBRHpCO0FBRTlCLE9BQUksT0FBSyxFQUFMLENBRjBCOztBQUk5QixPQUFHLFNBQVMsSUFBVCxJQUFrQixTQUFTLEtBQVQsSUFBa0IsS0FBSyxNQUFMLE9BQWtCLENBQWxCLEVBQXNCO0FBQzVELFdBQU8sZUFBSyxFQUFMLENBQVEscUJBQVIsRUFBK0IsYUFBL0IsQ0FBUCxDQUQ0RDtBQUU1RCxTQUFLLE1BQUwsQ0FBWSxNQUFaLEVBRjREO0FBRzVELGFBQVMsSUFBVCxDQUFjLHNCQUFkLEVBQXNDLFFBQXRDLENBQStDLFFBQS9DLEVBSDREO0FBSTVELFdBQU8sV0FBUCxDQUFtQix1QkFBbkIsRUFBNEMsV0FBNUMsQ0FBd0QsdUJBQXhELEVBSjREO0lBQTdELE1BS087QUFDTixTQUFLLE1BQUwsQ0FBWSxDQUFaLEVBRE07QUFFTixhQUFTLElBQVQsQ0FBYyxzQkFBZCxFQUFzQyxXQUF0QyxDQUFrRCxRQUFsRCxFQUZNO0FBR04sUUFBRyxDQUFDLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBRCxFQUF5QjtBQUMzQixZQUFPLGVBQUssRUFBTCxDQUFRLHVCQUFSLEVBQWlDLFlBQWpDLENBQVAsQ0FEMkI7QUFFM0IsWUFBTyxRQUFQLENBQWdCLHVCQUFoQixFQUYyQjtLQUE1QixNQUdLO0FBQ0osWUFBTyxlQUFLLEVBQUwsQ0FBUSwwQkFBUixFQUFvQyxjQUFwQyxDQUFQLENBREk7QUFFSixVQUFLLFdBQUwsQ0FBaUIsUUFBakIsRUFGSTtBQUdKLFlBQU8sUUFBUCxDQUFnQix1QkFBaEIsRUFISTtLQUhMO0lBUkQ7QUFrQkEsVUFBTyxJQUFQLENBQVksT0FBWixFQUFvQixJQUFwQixFQUEwQixJQUExQixDQUErQixJQUEvQixFQXRCOEI7R0FBZjtFQURqQixFQW51QzJCOztBQSt2QzNCLEdBQUUsaUZBQUYsRUFBcUYsT0FBckYsQ0FBNkY7QUFDNUYsU0FBTyxpQkFBVztBQUNqQixRQUFLLE1BQUwsR0FEaUI7O0FBSWpCLE9BQUksT0FBTyxJQUFQLENBSmE7QUFLakIsUUFBSyxJQUFMLENBQVUsUUFBVixFQUFvQixZQUFXO0FBQzlCLFFBQUksV0FBVyxLQUFLLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLElBQXJCLENBQTBCLGVBQTFCLENBQVgsQ0FEMEI7QUFFOUIsYUFBUyxRQUFULENBQWtCLFVBQWxCLEVBQThCLEtBQUssUUFBTCxFQUE5QixFQUY4QjtBQUc5QixhQUFTLE1BQVQsR0FIOEI7SUFBWCxDQUFwQixDQUxpQjtHQUFYO0VBRFIsRUEvdkMyQjtDQUFaLENBQWhCOzs7Ozs7Ozs7OztBQ3RRQSxpQkFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixVQUFTLENBQVQsRUFBVztBQUkxQixHQUFFLFlBQUYsRUFBZ0IsT0FBaEIsQ0FBd0I7QUFDdkIsa0JBQWdCLEtBQWhCOztBQUVBLFNBQU8saUJBQVc7QUFDakIsT0FBSSxPQUFPLE9BQU8sUUFBUCxDQUFnQixJQUFoQixDQURNOztBQUlqQixRQUFLLFVBQUwsR0FKaUI7O0FBTWpCLE9BQUksU0FBUyxFQUFULEVBQWE7QUFDaEIsU0FBSyxjQUFMLENBQW9CLElBQXBCLEVBRGdCO0lBQWpCOztBQUlBLFFBQUssTUFBTCxHQVZpQjtHQUFYOztBQWFQLFlBQVUsb0JBQVc7QUFDcEIsT0FBRyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQUgsRUFBc0IsS0FBSyxJQUFMLENBQVUsU0FBVixFQUF0QjtBQUNBLFFBQUssTUFBTCxHQUZvQjtHQUFYOztBQUtWLGNBQVksc0JBQVc7QUFDdEIsUUFBSyxnQkFBTCxHQURzQjtBQUV0QixRQUFLLElBQUwsR0FGc0I7R0FBWDs7QUFVWixrQkFBZ0Isd0JBQVUsSUFBVixFQUFnQjtBQUMvQixPQUFJLFFBQUosQ0FEK0I7O0FBSS9CLEtBQUUsSUFBRixDQUFPLEtBQUssSUFBTCxDQUFVLGlCQUFWLENBQVAsRUFBcUMsWUFBWTtBQUVoRCxRQUFJLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsSUFBbEIsTUFBNEIsQ0FBQyxDQUFELElBQU0sRUFBRSxJQUFGLEVBQVEsTUFBUixLQUFtQixDQUFuQixFQUFzQjtBQUMzRCxnQkFBVyxFQUFFLElBQUYsQ0FBWCxDQUQyRDtBQUUzRCxZQUFPLEtBQVAsQ0FGMkQ7S0FBNUQ7SUFGb0MsQ0FBckMsQ0FKK0I7O0FBYS9CLE9BQUksYUFBYSxLQUFLLENBQUwsRUFBUTtBQUN4QixXQUR3QjtJQUF6Qjs7QUFLQSxLQUFFLE1BQUYsRUFBVSxHQUFWLENBQWMsY0FBZCxFQUE4QixZQUFZO0FBQ3pDLGFBQVMsS0FBVCxHQUR5QztJQUFaLENBQTlCLENBbEIrQjtHQUFoQjs7QUEyQmhCLG9CQUFrQiw0QkFBVztBQUM1QixLQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsTUFBYixFQUFxQixJQUFyQixDQUEwQixZQUFXO0FBQ3BDLFFBQUksQ0FBQyxFQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsTUFBYixDQUFELEVBQXVCLE9BQTNCOztBQUVBLFFBQUksVUFBVSxFQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsTUFBYixFQUFxQixLQUFyQixDQUEyQixLQUEzQixDQUFWLENBSGdDO0FBSXBDLFFBQUcsQ0FBQyxPQUFELEVBQVUsT0FBYjtBQUNBLE1BQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxNQUFiLEVBQXFCLFNBQVMsUUFBVCxDQUFrQixJQUFsQixDQUF1QixPQUF2QixDQUErQixLQUEvQixFQUFzQyxFQUF0QyxJQUE0QyxRQUFRLENBQVIsQ0FBNUMsQ0FBckIsQ0FMb0M7SUFBWCxDQUExQixDQUQ0QjtHQUFYO0VBMURuQixFQUowQjtDQUFYLENBQWhCOzs7Ozs7Ozs7Ozs7Ozs7QUNDQSxpQkFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixVQUFTLENBQVQsRUFBVztBQUsxQixLQUFJLFdBQUosRUFBaUIsWUFBakIsQ0FMMEI7QUFNMUIsR0FBRSxNQUFGLEVBQVUsSUFBVixDQUFlLDBCQUFmLEVBQTJDLFlBQVc7QUFFckQsTUFBSSxLQUFLLFNBQUwsRUFBSyxHQUFXO0FBQUMsS0FBRSxvQkFBRixFQUF3QixVQUF4QixHQUFEO0dBQVgsQ0FGNEM7O0FBS3JELE1BQUcsRUFBRSxPQUFGLENBQVUsSUFBVixJQUFrQixTQUFTLEVBQUUsT0FBRixDQUFVLE9BQVYsRUFBbUIsRUFBNUIsSUFBa0MsQ0FBbEMsRUFBcUM7QUFDekQsT0FBSSxpQkFBaUIsRUFBRSxNQUFGLEVBQVUsS0FBVixFQUFqQjtPQUFvQyxrQkFBa0IsRUFBRSxNQUFGLEVBQVUsTUFBVixFQUFsQixDQURpQjtBQUV6RCxPQUFHLGtCQUFrQixXQUFsQixJQUFpQyxtQkFBbUIsWUFBbkIsRUFBaUM7QUFDcEUsa0JBQWMsY0FBZCxDQURvRTtBQUVwRSxtQkFBZSxlQUFmLENBRm9FO0FBR3BFLFNBSG9FO0lBQXJFO0dBRkQsTUFPTztBQUNOLFFBRE07R0FQUDtFQUwwQyxDQUEzQyxDQU4wQjs7QUF1QjFCLEtBQUksVUFBVTtBQUNiLGNBQVksZUFBSyxFQUFMLENBQVEsNEJBQVIsQ0FBWjtBQUNBLGdCQUFjLE1BQU0sZUFBSyxFQUFMLENBQVEsOEJBQVIsQ0FBTixHQUFnRCxHQUFoRDtBQUNkLHNCQUFvQixNQUFNLGVBQUssRUFBTCxDQUFRLG9DQUFSLENBQU4sR0FBc0QsR0FBdEQ7RUFIakIsQ0F2QnNCOztBQTZCMUIsS0FBSSxlQUFlLFNBQWYsWUFBZSxDQUFTLENBQVQsRUFBWTtBQUU5QixNQUFHLENBQUMsRUFBRSxFQUFFLE1BQUYsQ0FBRixDQUFZLE9BQVosQ0FBb0Isb0JBQXBCLEVBQTBDLE1BQTFDLEVBQWtELEVBQUUsb0JBQUYsRUFBd0IsVUFBeEIsR0FBdEQ7RUFGa0IsQ0E3Qk87O0FBMkMxQixHQUFFLG9CQUFGLEVBQXdCLE9BQXhCLENBQWdDO0FBRy9CLGNBQVksSUFBWjs7QUFFQSxTQUFPLGlCQUFXO0FBQ2pCLFFBQUssTUFBTCxDQUNDLGtEQUNBLDhHQURBLEdBRUEsNEVBRkEsQ0FERCxDQURpQjs7QUFPakIsT0FBSSxZQUFZLFFBQVEsUUFBUixDQVBDO0FBUWpCLE9BQUcsU0FBSCxFQUFjLEtBQUssSUFBTCxDQUFVLHVDQUFWLEVBQW1ELElBQW5ELENBQXdELE9BQXhELEVBQWlFLFNBQWpFLEVBQWQ7QUFDQSxPQUFHLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBSCxFQUF1QixLQUFLLFFBQUwsQ0FBYyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWQsRUFBdkI7O0FBRUEsUUFBSyxRQUFMLEdBQWdCLElBQWhCLEdBWGlCO0FBWWpCLFFBQUssTUFBTCxHQVppQjtHQUFYO0FBY1AsWUFBVSxvQkFBVztBQUNwQixVQUFPLEtBQUssSUFBTCxDQUFVLDBCQUFWLENBQVAsQ0FEb0I7R0FBWDtBQUdWLGFBQVcscUJBQVc7QUFFckIsS0FBRSxvQkFBRixFQUF3QixVQUF4QixHQUZxQjs7QUFLckIsS0FBRSxNQUFGLEVBQVUsSUFBVixDQUFlLE9BQWYsRUFBd0IsWUFBeEIsRUFMcUI7O0FBT3JCLE9BQUksUUFBUSxLQUFLLFFBQUwsRUFBUjtPQUF5QixPQUFPLEtBQUssSUFBTCxDQUFVLGNBQVYsQ0FBUCxDQVBSOztBQVNyQixTQUFNLEdBQU4sQ0FBVSxPQUFWLEVBQW1CLEtBQUssS0FBTCxFQUFuQixFQVRxQjs7QUFXckIsU0FBTSxJQUFOLEdBWHFCOztBQWNyQixPQUFJLFNBQVMsS0FBSyxJQUFMLENBQVUsc0NBQVYsQ0FBVCxDQWRpQjtBQWVyQixVQUFPLFFBQVAsQ0FBZ0IsNkJBQWhCLEVBZnFCO0FBZ0JyQixRQUFLLFFBQUwsQ0FBYyw2QkFBZCxFQWhCcUI7O0FBa0JyQixVQUFPLElBQVAsQ0FBWSxHQUFaLEVBQ0UsV0FERixDQUNjLHNCQURkLEVBRUUsUUFGRixDQUVXLHNCQUZYLEVBbEJxQjs7QUFzQnJCLE9BQUcsS0FBSyxFQUFMLENBQVEsUUFBUixLQUFxQixDQUFDLE1BQU0sUUFBTixDQUFlLFNBQWYsQ0FBRCxFQUE0QjtBQUNuRCxTQUFLLFFBQUwsQ0FBYyxJQUFkLEVBQW9CLEtBQUssT0FBTCxDQUFwQixDQURtRDtJQUFwRCxNQUVPO0FBQ04sU0FBSyxPQUFMLEdBRE07SUFGUDs7QUFNQSxRQUFLLE9BQUwsQ0FBYSxXQUFiLEVBNUJxQjtHQUFYO0FBOEJYLFdBQVMsbUJBQVc7QUFDbkIsT0FBSSxZQUFZLElBQVo7T0FDSCxXQUFXLEtBQUssUUFBTCxFQUFYO09BQ0EsU0FBUyxLQUFLLElBQUwsQ0FBVSxzQ0FBVixDQUFUO09BQ0EsWUFBWSxPQUFPLFdBQVAsRUFBWjtPQUNBLFFBSkQ7T0FLQyxLQUxEO09BTUMsV0FORCxDQURtQjs7QUFTbkIsT0FBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBaEIsRUFBbUI7QUFDdEIsa0JBQWMsQ0FBQyxDQUFFLE1BQUYsRUFBVSxNQUFWLEtBQXFCLEVBQUUsUUFBRixFQUFZLFNBQVosRUFBckIsR0FBZ0QsT0FBTyxXQUFQLEVBQWpELENBRFE7QUFFdEIsWUFBUSxPQUFPLE1BQVAsR0FBZ0IsR0FBaEIsQ0FGYztBQUd0QixlQUFXLFNBQVMsV0FBVCxFQUFYLENBSHNCOztBQU10QixRQUFJLFFBQVEsUUFBUixHQUFtQixXQUFuQixJQUFrQyxRQUFRLFFBQVIsR0FBbUIsQ0FBbkIsRUFBc0I7QUFDM0QsZUFBVSxRQUFWLENBQW1CLDZCQUFuQixFQUQyRDtBQUUzRCxpQkFBWSxDQUFDLFNBQVMsV0FBVCxFQUFELENBRitDO0tBQTVELE1BR087QUFDTixlQUFVLFdBQVYsQ0FBc0IsNkJBQXRCLEVBRE07S0FIUDtJQU5EO0FBYUEsWUFBUyxHQUFULENBQWEsRUFBQyxPQUFPLFlBQVksSUFBWixFQUFyQixFQXRCbUI7R0FBWDtBQXdCVCxjQUFZLHNCQUFXO0FBQ3RCLFVBQU8sTUFBUCxFQUFlLE1BQWYsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFEc0I7O0FBSXRCLE9BQUksU0FBUyxLQUFLLElBQUwsQ0FBVSxzQ0FBVixDQUFULENBSmtCO0FBS3RCLFVBQU8sV0FBUCxDQUFtQiw2QkFBbkIsRUFMc0I7QUFNdEIsUUFBSyxXQUFMLENBQWlCLHlEQUFqQixFQU5zQjs7QUFRdEIsVUFBTyxJQUFQLENBQVksR0FBWixFQUNFLFdBREYsQ0FDYyxzQkFEZCxFQUVFLFFBRkYsQ0FFVyxzQkFGWCxFQVJzQjs7QUFhdEIsUUFBSyxRQUFMLEdBQWdCLElBQWhCLEdBYnNCO0FBY3RCLFFBQUssT0FBTCxDQUFhLFdBQWIsRUFkc0I7R0FBWDtBQWdCWixlQUFhLHVCQUFXO0FBQ3ZCLFFBQUssS0FBSyxRQUFMLEdBQWdCLEVBQWhCLENBQW1CLFVBQW5CLElBQWlDLFlBQWpDLEdBQWdELFdBQWhELENBQUwsR0FEdUI7R0FBWDtBQUdiLFlBQVUsa0JBQVMsS0FBVCxFQUFnQjtBQUN6QixXQUFRLFNBQVMsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFULElBQStCLFFBQVEsVUFBUixDQURkOztBQUd6QixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxJQUF0QyxDQUEyQyxLQUEzQyxFQUh5QjtBQUl6QixRQUFLLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQW5CLEVBSnlCO0dBQWhCO0FBTVYsWUFBVSxvQkFBVztBQUNwQixVQUFPLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLElBQXRDLEVBQVAsQ0FEb0I7R0FBWDs7QUFNVixlQUFhLHVCQUFXO0FBQ3ZCLE9BQUksT0FBTyxJQUFQO09BQWEsT0FBTyxLQUFLLElBQUwsQ0FBVSxjQUFWLENBQVA7T0FBa0MsTUFBTSxLQUFLLFFBQUwsRUFBTixDQUQ1QjtBQUV2QixPQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVc7QUFDekIsUUFBSSxNQUFNLEtBQUssUUFBTCxFQUFOLENBRHFCO0FBRXpCLFFBQUcsR0FBSCxFQUFROztBQUVQLFNBQUksT0FBTyxLQUFLLElBQUwsQ0FBVSxnQkFBZ0IsR0FBaEIsR0FBc0IsSUFBdEIsQ0FBakI7U0FDSCxRQUFRLEtBQUssUUFBTCxDQUFjLEdBQWQsRUFBbUIsSUFBbkIsQ0FBd0Isc0JBQXhCLElBQWdELEtBQUssUUFBTCxDQUFjLEdBQWQsRUFBbUIsSUFBbkIsQ0FBd0IsV0FBeEIsRUFBcUMsSUFBckMsRUFBaEQsR0FBNEYsSUFBNUYsQ0FIRjtBQUlQLFNBQUcsQ0FBQyxLQUFELEVBQVEsUUFBTSxJQUFDLENBQUssTUFBTCxHQUFjLENBQWQsR0FBbUIsS0FBSyxNQUFMLENBQVksVUFBWixFQUF3QixLQUFLLENBQUwsQ0FBeEIsQ0FBcEIsR0FBdUQsSUFBdkQsQ0FBakI7O0FBRUEsU0FBRyxLQUFILEVBQVU7QUFDVCxXQUFLLFFBQUwsQ0FBYyxLQUFkLEVBRFM7QUFFVCxXQUFLLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQW5CLEVBRlM7TUFBVjtBQUlBLFNBQUcsSUFBSCxFQUFTLEtBQUssTUFBTCxDQUFZLGFBQVosRUFBMkIsSUFBM0IsRUFBVDtLQVZELE1BWUs7QUFDSixVQUFLLFFBQUwsQ0FBYyxLQUFLLElBQUwsQ0FBVSxhQUFWLENBQWQsRUFESTtBQUVKLFVBQUssVUFBTCxDQUFnQixPQUFoQixFQUZJO0tBWkw7SUFGYyxDQUZROztBQXVCdkIsT0FBRyxDQUFDLEtBQUssRUFBTCxDQUFRLFFBQVIsQ0FBRCxJQUFzQixDQUFDLEdBQUQsRUFBTSxXQUEvQixLQUNLLEtBQUssUUFBTCxDQUFjLEVBQUMsWUFBWSxHQUFaLEVBQWYsRUFBaUMsUUFBakMsRUFETDtHQXZCWTtBQTBCYixZQUFVLGtCQUFTLEdBQVQsRUFBYztBQUN2QixRQUFLLElBQUwsQ0FBVSxVQUFWLEVBQXNCLEVBQUUsTUFBRixDQUFTLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBVCxFQUFnQyxFQUFDLElBQUksR0FBSixFQUFqQyxDQUF0QixFQUR1QjtBQUV2QixRQUFLLElBQUwsQ0FBVSxlQUFWLEVBQTJCLEdBQTNCLENBQStCLEdBQS9CLEVBR0UsT0FIRixDQUdVLGNBSFYsRUFJRSxPQUpGLENBSVUsUUFKVixFQUZ1QjtHQUFkO0FBUVYsWUFBVSxvQkFBVztBQUNwQixVQUFPLEtBQUssSUFBTCxDQUFVLGVBQVYsRUFBMkIsR0FBM0IsRUFBUCxDQURvQjtHQUFYO0FBR1YsWUFBVSxrQkFBUyxNQUFULEVBQWlCLFFBQWpCLEVBQTJCO0FBQ3BDLE9BQUksT0FBTyxJQUFQO09BQWEsUUFBUSxLQUFLLFFBQUwsRUFBUjtPQUF5QixhQUFhLEVBQUUsS0FBRixFQUFTLElBQVQsQ0FBYyxjQUFkLENBQWI7T0FDekMsU0FBUyxTQUFXLEVBQUUsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLLGdCQUFMLEVBQWIsRUFBc0MsTUFBdEMsQ0FBWCxHQUEyRCxLQUFLLGdCQUFMLEVBQTNEO09BQW9GLEdBRDlGLENBRG9DOztBQUlwQyxPQUFHLEtBQUssYUFBTCxFQUFILEVBQXlCLEtBQUssYUFBTCxHQUFxQixLQUFyQixHQUF6QjtBQUNBLFNBQU0sUUFBTixDQUFlLFNBQWYsRUFMb0M7QUFNcEMsU0FBTSxFQUFFLElBQUYsQ0FBTztBQUNaLFNBQUssS0FBSyxJQUFMLENBQVUsU0FBVixDQUFMO0FBQ0EsVUFBTSxNQUFOO0FBQ0EsY0FBVSxrQkFBUyxHQUFULEVBQWMsTUFBZCxFQUFzQjtBQUMvQixXQUFNLFdBQU4sQ0FBa0IsU0FBbEIsRUFEK0I7S0FBdEI7QUFHVixhQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3BDLGdCQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFEb0M7QUFFcEMsU0FBSSxZQUFZLElBQVosQ0FGZ0M7QUFHcEMsZ0JBQ0UsTUFERixDQUNTLFNBRFQsRUFFRSxJQUZGLENBRU8sZUFGUCxFQUV3QixVQUFTLENBQVQsRUFBWSxJQUFaLEVBQWtCO0FBQ3hDLFVBQUksTUFBTSxLQUFLLFFBQUwsRUFBTjtVQUF1QixhQUFhLFdBQVcsSUFBWCxDQUFnQixnQkFBZ0IsR0FBaEIsR0FBc0IsSUFBdEIsQ0FBN0I7VUFDMUIsY0FBYyxLQUFLLElBQUwsQ0FBVSxZQUFWLEVBQWQsQ0FGdUM7QUFHeEMsVUFBRyxPQUFPLGNBQWMsV0FBZCxFQUEyQixLQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLFVBQXRCLEVBQXJDO0FBQ0Esa0JBQVksS0FBWixDQUp3QztBQUt4QyxVQUFHLFFBQUgsRUFBYSxTQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQWI7TUFMc0IsQ0FGeEIsQ0FTRSxNQVRGLENBU1MsS0FBSyxhQUFMLEVBVFQsRUFVRSxJQVZGLENBVU8sb0JBVlAsRUFVNkIsVUFBUyxDQUFULEVBQVksSUFBWixFQUFrQjtBQUM3QyxVQUFJLE9BQU8sS0FBSyxJQUFMLENBQVUsR0FBVjtVQUFlLEtBQUssRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLElBQWIsQ0FBTCxDQURtQjtBQUU3QyxVQUFHLENBQUMsU0FBRCxJQUFjLEtBQUssUUFBTCxNQUFtQixFQUFuQixFQUF1QjtBQUV2QyxZQUFLLElBQUwsQ0FBVSxVQUFWLEVBQXNCLElBQXRCLEVBRnVDO0FBR3ZDLFlBQUssUUFBTCxDQUFjLElBQWQsRUFIdUM7QUFJdkMsWUFBSyxRQUFMLENBQWMsSUFBZCxFQUp1QztBQUt2QyxZQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLElBQXhCLEVBTHVDO09BQXhDLE1BTU87QUFDTixZQUFLLElBQUwsQ0FBVSxVQUFWLEVBQXNCLEVBQUUsTUFBRixDQUFTLEVBQUMsSUFBSSxFQUFKLEVBQVYsRUFBbUIsRUFBRSxJQUFGLEVBQVEsV0FBUixFQUFuQixDQUF0QixFQURNO0FBRU4sWUFBSyxRQUFMLENBQWMsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixJQUFuQixDQUFkLEVBRk07QUFHTixZQUFLLFFBQUwsQ0FBYyxFQUFkLEVBSE07T0FOUDs7QUFhQSxVQUFHLENBQUMsU0FBRCxFQUFZLEtBQUssVUFBTCxHQUFmO0FBQ0Esa0JBQVUsS0FBVixDQWhCNkM7TUFBbEIsQ0FWN0IsQ0FIb0M7O0FBZ0NwQyxVQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFoQ29DO0tBQTVCO0lBTkosQ0FBTixDQU5vQztBQStDcEMsUUFBSyxhQUFMLENBQW1CLEdBQW5CLEVBL0NvQztHQUEzQjtBQWlEVixpQkFBZSx5QkFBVztBQUN6QixPQUFJLE9BQU8sSUFBUCxDQURxQjtBQUV6QixVQUFPO0FBQ04sWUFBUTtBQUNQLG9CQUFlLElBQWY7O0FBRUEsa0JBQWEsQ0FBYjtLQUhEO0FBS0EsaUJBQWE7QUFFWixhQUFRLEtBQUssUUFBTCxHQUFnQixJQUFoQixDQUFxQixjQUFyQixFQUFxQyxJQUFyQyxFQUFSO0FBQ0EsYUFBUTtBQUNQLGFBQU8sYUFBUyxJQUFULEVBQWU7QUFDckIsV0FBSSxNQUFNLEVBQUUsSUFBRixDQUFPLFFBQVAsQ0FBZ0IsS0FBSyxJQUFMLENBQVUsU0FBVixDQUFoQixFQUFzQyxZQUF0QyxDQURXO0FBRXJCLGNBQU8sTUFBTSxHQUFOLElBQWEsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLElBQWIsSUFBcUIsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLElBQWIsQ0FBckIsR0FBMEMsQ0FBMUMsQ0FBYixDQUZjO09BQWY7QUFJUCxjQUFRLGNBQVMsSUFBVCxFQUFlO0FBQ3RCLFdBQUksUUFBUSxFQUFFLEtBQUYsQ0FBUSxJQUFSLENBQWEsS0FBSyxJQUFMLENBQVUsU0FBVixDQUFiLEVBQW1DLElBQW5DLENBRFU7QUFFdEIsV0FBSSxTQUFTLEtBQUssZ0JBQUwsRUFBVCxDQUZrQjtBQUd0QixnQkFBUyxFQUFFLE1BQUYsQ0FBUyxFQUFULEVBQWEsS0FBYixFQUFvQixNQUFwQixFQUE0QixFQUFDLE1BQU0sQ0FBTixFQUE3QixDQUFULENBSHNCO0FBSXRCLGNBQU8sTUFBUCxDQUpzQjtPQUFmO01BTFQ7S0FIRDtBQWdCQSxVQUFNO0FBQ0wscUJBQWlCLENBQWpCO0FBQ0EseUJBQW9CLENBQUMsS0FBSyxRQUFMLEdBQWdCLElBQWhCLENBQXFCLFVBQXJCLEVBQWlDLElBQWpDLENBQXNDLElBQXRDLENBQUQsQ0FBcEI7S0FGRDtBQUlBLGNBQVU7QUFDVCxjQUFTLE9BQVQ7S0FERDtBQUdBLGFBQVU7QUFDVCxjQUFVO0FBQ1QsaUJBQVc7QUFDVixxQkFBYyxvQkFBUyxJQUFULEVBQWU7QUFDNUIsZUFBUyxDQUFFLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FBRixDQURtQjtRQUFmO0FBR2QsdUJBQWdCLHNCQUFTLElBQVQsRUFBZTtBQUM5QixlQUFTLENBQUUsS0FBSyxRQUFMLENBQWMsVUFBZCxDQUFGLENBRHFCO1FBQWY7QUFHaEIsc0JBQWUscUJBQVMsSUFBVCxFQUFlO0FBQzdCLGVBQVMsQ0FBRSxLQUFLLFFBQUwsQ0FBYyxVQUFkLENBQUYsQ0FEb0I7UUFBZjtBQUdmLHdCQUFpQix1QkFBUyxJQUFULEVBQWU7QUFDL0IsZUFBUyxDQUFFLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FBRixDQURzQjtRQUFmO09BVmxCO01BREQ7S0FERDtBQWtCQSxlQUFXLENBQUMsV0FBRCxFQUFjLElBQWQsRUFBb0IsUUFBcEIsRUFBOEIsT0FBOUIsQ0FBWDtJQS9DRCxDQUZ5QjtHQUFYOztBQTJEZixvQkFBa0IsNEJBQVc7QUFDNUIsVUFBTyxFQUFQLENBRDRCO0dBQVg7RUE1UG5CLEVBM0MwQjs7QUE0UzFCLEdBQUUsb0NBQUYsRUFBd0MsT0FBeEMsQ0FBZ0Q7QUFPL0MsZUFBYSx1QkFBVztBQUN2QixPQUFJLFVBQVUsS0FBSyxJQUFMLENBQVUsT0FBVixFQUFtQixLQUFuQixDQUF5QixpQkFBekIsQ0FBVixDQURtQjtBQUV2QixPQUFJLFFBQVEsVUFBVSxRQUFRLENBQVIsQ0FBVixHQUF1QixFQUF2QixDQUZXO0FBR3ZCLFVBQU8sRUFBQyxXQUFXLEtBQVgsRUFBUixDQUh1QjtHQUFYO0VBUGQsRUE1UzBCOztBQTBUMUIsR0FBRSxzQkFBRixFQUEwQixPQUExQixDQUFrQztBQUNqQyxZQUFVLG9CQUFXO0FBQ3BCLFVBQU8sS0FBSyxPQUFMLENBQWEsMEJBQWIsQ0FBUCxDQURvQjtHQUFYO0VBRFgsRUExVDBCOztBQWdVMUIsR0FBRSxvQkFBRixFQUF3QixPQUF4QixDQUFnQztBQUMvQixXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixRQUFLLFdBQUwsR0FEb0I7O0FBR3BCLFVBQU8sS0FBUCxDQUhvQjtHQUFaO0VBRFYsRUFoVTBCOztBQXdVMUIsR0FBRSw2Q0FBRixFQUFpRCxPQUFqRCxDQUF5RDtBQUN4RCxXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixVQUFPLEtBQVAsQ0FEb0I7R0FBWjtFQURWLEVBeFUwQjs7QUE4VTFCLEdBQUUsK0JBQUYsRUFBbUMsT0FBbkMsQ0FBMkM7QUFDMUMsU0FBTyxpQkFBVztBQUNqQixRQUFLLE1BQUwsR0FEaUI7QUFFakIsT0FBSSxRQUFRLGVBQUssRUFBTCxDQUFRLGlDQUFSLENBQVIsQ0FGYTtBQUdqQixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxPQUF0QyxDQUNDLEVBQUUsd0dBQXdHLEtBQXhHLEdBQWdILGVBQWhILENBREgsRUFIaUI7R0FBWDtBQU9QLFVBQVEsZ0JBQVMsR0FBVCxFQUFjLFFBQWQsRUFBd0I7QUFDL0IsUUFBSyxTQUFMLEdBRCtCO0FBRS9CLFFBQUssUUFBTCxDQUFjLEVBQUMsUUFBUSxHQUFSLEVBQWYsRUFBNkIsUUFBN0IsRUFGK0I7R0FBeEI7QUFJUixnQkFBYyx3QkFBVztBQUN4QixRQUFLLFVBQUwsR0FEd0I7QUFFeEIsUUFBSyxRQUFMLEdBRndCO0dBQVg7RUFaZixFQTlVMEI7O0FBZ1cxQixHQUFFLDRDQUFGLEVBQWdELE9BQWhELENBQXdEO0FBQ3ZELGFBQVcsbUJBQVMsQ0FBVCxFQUFZO0FBQ3RCLE9BQUksUUFBUSxLQUFLLFFBQUwsRUFBUixDQURrQjtBQUV0QixPQUFHLEVBQUUsT0FBRixJQUFhLEVBQWIsRUFBaUI7QUFFbkIsVUFBTSxNQUFOLENBQWEsS0FBSyxHQUFMLEVBQWIsRUFGbUI7QUFHbkIsV0FBTyxLQUFQLENBSG1CO0lBQXBCLE1BSU8sSUFBRyxFQUFFLE9BQUYsSUFBYSxFQUFiLEVBQWlCO0FBRTFCLFVBQU0sWUFBTixHQUYwQjtJQUFwQjtHQU5HO0VBRFosRUFoVzBCOztBQThXMUIsR0FBRSw2QkFBRixFQUFpQyxPQUFqQyxDQUF5QztBQUN4QyxpQkFBZSx5QkFBVztBQUN6QixPQUFJLE1BQU0sS0FBSyxNQUFMLEVBQU4sQ0FEcUI7QUFFekIsT0FBSSxRQUFKLEdBQWUsRUFBQyxhQUFhLElBQWIsRUFBbUIsV0FBVyxJQUFYLEVBQW5DLENBRnlCO0FBR3pCLE9BQUksT0FBSixDQUFZLElBQVosQ0FBaUIsVUFBakIsRUFIeUI7QUFJekIsT0FBSSxFQUFKLENBQU8sWUFBUCxHQUFzQixDQUFDLENBQUQsQ0FKRztBQUt6QixVQUFPLEdBQVAsQ0FMeUI7R0FBWDtBQU9mLFlBQVUsa0JBQVMsTUFBVCxFQUFpQixRQUFqQixFQUEyQjtBQUNwQyxPQUFJLE9BQU8sSUFBUDtPQUFhLFFBQVEsS0FBSyxRQUFMLEVBQVI7T0FBeUIsYUFBYSxFQUFFLEtBQUYsRUFBUyxJQUFULENBQWMsY0FBZCxDQUFiLENBRE47QUFFcEMsT0FBSSxTQUFTLFNBQVcsRUFBRSxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQUssZ0JBQUwsRUFBYixFQUFzQyxNQUF0QyxDQUFYLEdBQTJELEtBQUssZ0JBQUwsRUFBM0Q7T0FBb0YsR0FBakcsQ0FGb0M7O0FBSXBDLE9BQUcsS0FBSyxhQUFMLEVBQUgsRUFBeUIsS0FBSyxhQUFMLEdBQXFCLEtBQXJCLEdBQXpCO0FBQ0EsU0FBTSxRQUFOLENBQWUsU0FBZixFQUxvQztBQU1wQyxTQUFNLEVBQUUsSUFBRixDQUFPO0FBQ1osU0FBSyxLQUFLLElBQUwsQ0FBVSxTQUFWLENBQUw7QUFDQSxVQUFNLE1BQU47QUFDQSxjQUFVLGtCQUFTLEdBQVQsRUFBYyxNQUFkLEVBQXNCO0FBQy9CLFdBQU0sV0FBTixDQUFrQixTQUFsQixFQUQrQjtLQUF0QjtBQUdWLGFBQVMsaUJBQVMsSUFBVCxFQUFlLE1BQWYsRUFBdUIsR0FBdkIsRUFBNEI7QUFDcEMsZ0JBQVcsSUFBWCxDQUFnQixJQUFoQixFQURvQztBQUVwQyxTQUFJLFlBQVksSUFBWixDQUZnQztBQUdwQyxVQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFIb0M7QUFJcEMsZ0JBQ0UsTUFERixDQUNTLFNBRFQsRUFFRSxJQUZGLENBRU8sZUFGUCxFQUV3QixVQUFTLENBQVQsRUFBWSxJQUFaLEVBQWtCO0FBQ3hDLFFBQUUsSUFBRixDQUFPLEtBQUssUUFBTCxFQUFQLEVBQXdCLFVBQVMsQ0FBVCxFQUFZLEdBQVosRUFBaUI7QUFDeEMsWUFBSyxJQUFMLENBQVUsVUFBVixDQUFxQixXQUFXLElBQVgsQ0FBZ0IsZUFBZSxHQUFmLEdBQXFCLEdBQXJCLENBQXJDLEVBRHdDO09BQWpCLENBQXhCLENBRHdDO0FBSXhDLGtCQUFZLEtBQVosQ0FKd0M7QUFLeEMsVUFBRyxRQUFILEVBQWEsU0FBUyxLQUFULENBQWUsSUFBZixFQUFiO01BTHNCLENBRnhCLENBU0UsTUFURixDQVNTLEtBQUssYUFBTCxFQVRULEVBVUUsSUFWRixDQVVPLHVDQVZQLEVBVWdELFVBQVMsQ0FBVCxFQUFZLElBQVosRUFBa0I7QUFDaEUsVUFBSSxRQUFRLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsSUFBdEIsRUFBNEIsSUFBNUIsQ0FBUixDQUQ0RDtBQUVoRSxXQUFLLFFBQUwsQ0FBYyxFQUFFLEdBQUYsQ0FBTSxLQUFOLEVBQWEsVUFBUyxFQUFULEVBQWEsQ0FBYixFQUFnQjtBQUMxQyxjQUFPLEVBQUUsRUFBRixFQUFNLElBQU4sQ0FBVyxJQUFYLENBQVAsQ0FEMEM7T0FBaEIsQ0FBM0IsRUFGZ0U7QUFLaEUsV0FBSyxRQUFMLENBQWMsRUFBRSxHQUFGLENBQU0sS0FBTixFQUFhLFVBQVMsRUFBVCxFQUFhLENBQWIsRUFBZ0I7QUFDMUMsY0FBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLEVBQW5CLENBQVAsQ0FEMEM7T0FBaEIsQ0FBM0IsRUFMZ0U7QUFRaEUsV0FBSyxJQUFMLENBQVUsVUFBVixFQUFzQixFQUFFLEdBQUYsQ0FBTSxLQUFOLEVBQWEsVUFBUyxFQUFULEVBQWEsQ0FBYixFQUFnQjtBQUNsRCxjQUFPLEVBQUMsSUFBSSxFQUFFLEVBQUYsRUFBTSxJQUFOLENBQVcsSUFBWCxDQUFKLEVBQXNCLFVBQVUsRUFBRSxFQUFGLEVBQU0sV0FBTixFQUFWLEVBQTlCLENBRGtEO09BQWhCLENBQW5DLEVBUmdFO01BQWxCLENBVmhELENBSm9DO0tBQTVCO0lBTkosQ0FBTixDQU5vQztBQXdDcEMsUUFBSyxhQUFMLENBQW1CLEdBQW5CLEVBeENvQztHQUEzQjtBQTBDVixZQUFVLG9CQUFXO0FBQ3BCLE9BQUksTUFBTSxLQUFLLE1BQUwsRUFBTixDQURnQjtBQUVwQixVQUFPLElBQUksS0FBSixDQUFVLE9BQVYsQ0FBUCxDQUZvQjtHQUFYO0FBSVYsWUFBVSxrQkFBUyxHQUFULEVBQWM7QUFDdkIsUUFBSyxNQUFMLENBQVksRUFBRSxPQUFGLENBQVUsR0FBVixJQUFpQixJQUFJLElBQUosQ0FBUyxHQUFULENBQWpCLEdBQWlDLEdBQWpDLENBQVosQ0FEdUI7R0FBZDtBQUdWLFlBQVUsa0JBQVMsS0FBVCxFQUFnQjtBQUN6QixRQUFLLE1BQUwsQ0FBWSxFQUFFLE9BQUYsQ0FBVSxLQUFWLElBQW1CLE1BQU0sSUFBTixDQUFXLElBQVgsQ0FBbkIsR0FBc0MsS0FBdEMsQ0FBWixDQUR5QjtHQUFoQjtBQUdWLGVBQWEsdUJBQVcsRUFBWDtFQTVEZCxFQTlXMEI7O0FBK2ExQixHQUFFLHVDQUFGLEVBQTJDLE9BQTNDLENBQW1EO0FBQ2xELFNBQU8saUJBQVc7QUFDakIsUUFBSyxNQUFMLEdBRGlCO0FBRWpCLFFBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLFlBQVc7QUFDaEQsTUFBRSxJQUFGLEVBQVEsUUFBUixHQUFtQixXQUFuQixHQURnRDtJQUFYLENBQXRDLENBRmlCO0dBQVg7QUFNUCxZQUFVLG9CQUFXO0FBQ3BCLFFBQUssTUFBTCxHQURvQjtBQUVwQixRQUFLLE1BQUwsQ0FBWSxvQkFBWixFQUZvQjtHQUFYO0VBUFgsRUEvYTBCO0NBQVgsQ0FBaEI7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0lDMTlJTTtBQUNMLFVBREssSUFDTCxHQUFjO3dCQURULE1BQ1M7O0FBQ2IsT0FBSyxhQUFMLEdBQXFCLElBQXJCLENBRGE7QUFFYixPQUFLLGFBQUwsR0FBcUIsT0FBckIsQ0FGYTtBQUdiLE9BQUssSUFBTCxHQUFZLEVBQVosQ0FIYTtFQUFkOztjQURLOzs0QkFZSyxRQUFRO0FBQ2pCLFFBQUssYUFBTCxHQUFxQixNQUFyQixDQURpQjs7Ozs4QkFTTjtBQUNYLFVBQU8sS0FBSyxhQUFMLEtBQXVCLElBQXZCLEdBQThCLEtBQUssYUFBTCxHQUFxQixLQUFLLGFBQUwsQ0FEL0M7Ozs7cUJBZVQsUUFBUSxnQkFBZ0IsVUFBVSxTQUFTO0FBQzdDLE9BQU0sV0FBVyxLQUFLLFNBQUwsR0FBaUIsT0FBakIsQ0FBeUIsU0FBekIsRUFBb0MsRUFBcEMsQ0FBWCxDQUR1QztBQUU3QyxPQUFNLGtCQUFrQixLQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsU0FBM0IsRUFBc0MsRUFBdEMsQ0FBbEIsQ0FGdUM7O0FBSTdDLE9BQUksS0FBSyxJQUFMLElBQWEsS0FBSyxJQUFMLENBQVUsS0FBSyxTQUFMLEVBQVYsQ0FBYixJQUE0QyxLQUFLLElBQUwsQ0FBVSxLQUFLLFNBQUwsRUFBVixFQUE0QixNQUE1QixDQUE1QyxFQUFpRjtBQUNwRixXQUFPLEtBQUssSUFBTCxDQUFVLEtBQUssU0FBTCxFQUFWLEVBQTRCLE1BQTVCLENBQVAsQ0FEb0Y7SUFBckYsTUFFTyxJQUFJLEtBQUssSUFBTCxJQUFhLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBYixJQUFvQyxLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLE1BQXBCLENBQXBDLEVBQWlFO0FBQzNFLFdBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixNQUFwQixDQUFQLENBRDJFO0lBQXJFLE1BRUEsSUFBSSxLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxLQUFLLGFBQUwsQ0FBdkIsSUFBOEMsS0FBSyxJQUFMLENBQVUsS0FBSyxhQUFMLENBQVYsQ0FBOEIsTUFBOUIsQ0FBOUMsRUFBcUY7QUFDL0YsV0FBTyxLQUFLLElBQUwsQ0FBVSxLQUFLLGFBQUwsQ0FBVixDQUE4QixNQUE5QixDQUFQLENBRCtGO0lBQXpGLE1BRUEsSUFBSSxLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQWIsSUFBMkMsS0FBSyxJQUFMLENBQVUsZUFBVixFQUEyQixNQUEzQixDQUEzQyxFQUErRTtBQUN6RixXQUFPLEtBQUssSUFBTCxDQUFVLGVBQVYsRUFBMkIsTUFBM0IsQ0FBUCxDQUR5RjtJQUFuRixNQUVBLElBQUcsY0FBSCxFQUFtQjtBQUN6QixXQUFPLGNBQVAsQ0FEeUI7SUFBbkIsTUFFQTtBQUNOLFdBQU8sRUFBUCxDQURNO0lBRkE7Ozs7Z0NBZU0sUUFBUSxNQUFNO0FBQzNCLE9BQUksT0FBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQVAsS0FBNkIsV0FBN0IsRUFBMEM7QUFDN0MsU0FBSyxJQUFMLENBQVUsTUFBVixJQUFvQixFQUFwQixDQUQ2QztJQUE5Qzs7QUFJQSxRQUFLLElBQUksTUFBSixJQUFjLElBQW5CLEVBQXlCO0FBQ3hCLFNBQUssSUFBTCxDQUFVLE1BQVYsRUFBa0IsTUFBbEIsSUFBNEIsS0FBSyxNQUFMLENBQTVCLENBRHdCO0lBQXpCOzs7O2dDQVVhLFFBQVE7QUFDckIsVUFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQVAsQ0FEcUI7Ozs7MkJBU2IsS0FBSztBQUNiLFVBQU8sSUFBSSxPQUFKLENBQVksTUFBWixFQUFvQixFQUFwQixFQUF3QixPQUF4QixDQUFnQyxNQUFoQyxFQUF3QyxFQUF4QyxDQUFQLENBRGE7Ozs7NkJBU0gsS0FBSztBQUdmLE9BQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxJQUFWLENBQVIsQ0FIVzs7QUFLZixRQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxNQUFNLE1BQU4sRUFBYyxLQUFLLENBQUwsRUFBUTtBQUN6QyxVQUFNLENBQU4sSUFBVyxTQUFTLE1BQU0sQ0FBTixDQUFULENBQVgsQ0FEeUM7SUFBMUM7O0FBTUEsVUFBTyxTQUFTLE1BQU0sSUFBTixDQUFXLEdBQVgsQ0FBVCxDQUFQLENBWGU7Ozs7MEJBcUJSLEdBQWM7cUNBQVI7O0lBQVE7O0FBQ3JCLE9BQUksT0FBTyxNQUFQLEtBQWtCLENBQWxCLEVBQXFCO0FBQ3hCLFdBQU8sQ0FBUCxDQUR3QjtJQUF6Qjs7QUFJQSxPQUFNLE9BQU8sSUFBSSxNQUFKLENBQVcsVUFBWCxFQUF1QixHQUF2QixDQUFQLENBTGU7O0FBT3JCLE9BQUksSUFBSSxDQUFKLENBUGlCOztBQVNyQixVQUFPLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsVUFBVSxLQUFWLEVBQWlCLFNBQWpCLEVBQTRCLFNBQTVCLEVBQXVDLE1BQXZDLEVBQStDLE1BQS9DLEVBQXVEO0FBRTdFLFFBQUksY0FBYyxHQUFkLEVBQW1CO0FBQ3RCLFlBQU8sS0FBUCxDQURzQjtLQUF2Qjs7QUFJQSxXQUFPLFlBQVksT0FBTyxLQUFLLENBQUwsQ0FBbkIsQ0FOc0U7SUFBdkQsQ0FBdkIsQ0FUcUI7Ozs7eUJBMEJmLEdBQUcsS0FBSztBQUNkLE9BQU0sT0FBTyxJQUFJLE1BQUosQ0FBVyxxQkFBWCxFQUFrQyxHQUFsQyxDQUFQLENBRFE7O0FBR2QsVUFBTyxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFVBQVUsS0FBVixFQUFpQixHQUFqQixFQUFzQixNQUF0QixFQUE4QixNQUE5QixFQUFzQztBQUM1RCxXQUFPLEdBQUMsQ0FBSSxHQUFKLENBQUQsR0FBYSxJQUFJLEdBQUosQ0FBYixHQUF3QixLQUF4QixDQURxRDtJQUF0QyxDQUF2QixDQUhjOzs7O2lDQWlCQTtBQUNkLE9BQUksU0FBSixDQURjO0FBRWQsT0FBSSxjQUFKLENBRmM7O0FBS2QsZUFBWSxPQUFPLE1BQVAsRUFBZSxJQUFmLENBQW9CLE1BQXBCLENBQVosQ0FMYzs7QUFRZCxPQUFJLENBQUMsU0FBRCxFQUFZO0FBQ2YsUUFBSSxRQUFRLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsQ0FBUixDQURXOztBQUdmLFNBQUssSUFBSSxJQUFFLENBQUYsRUFBSyxJQUFFLE1BQU0sTUFBTixFQUFjLEdBQTlCLEVBQW1DO0FBQ2xDLFNBQUksTUFBTSxDQUFOLEVBQVMsVUFBVCxDQUFvQixZQUFwQixLQUFxQyxNQUFNLENBQU4sRUFBUyxVQUFULENBQW9CLFlBQXBCLEVBQWtDLFNBQWxDLENBQTRDLFdBQTVDLE1BQTZELGtCQUE3RCxFQUFpRjtBQUN6SCxrQkFBWSxNQUFNLENBQU4sRUFBUyxVQUFULENBQW9CLFNBQXBCLEVBQStCLFNBQS9CLENBRDZHO01BQTFIO0tBREQ7SUFIRDs7QUFXQSxPQUFJLENBQUMsU0FBRCxFQUFZO0FBQ2YsZ0JBQVksS0FBSyxhQUFMLENBREc7SUFBaEI7O0FBSUEsT0FBSSxpQkFBaUIsVUFBVSxLQUFWLENBQWdCLG9CQUFoQixDQUFqQixDQXZCVTs7QUEwQmQsT0FBSSxVQUFVLE1BQVYsSUFBb0IsQ0FBcEIsRUFBdUI7QUFDMUIsU0FBSyxJQUFJLGFBQUosSUFBcUIsS0FBSyxJQUFMLEVBQVc7QUFDcEMsU0FBSSxjQUFjLE1BQWQsQ0FBcUIsQ0FBckIsRUFBdUIsQ0FBdkIsRUFBMEIsV0FBMUIsTUFBMkMsVUFBVSxXQUFWLEVBQTNDLEVBQW9FO0FBQ3ZFLHVCQUFpQixhQUFqQixDQUR1RTtBQUV2RSxZQUZ1RTtNQUF4RTtLQUREO0lBREQsTUFPTyxJQUFJLGNBQUosRUFBb0I7QUFDMUIscUJBQWlCLGVBQWUsQ0FBZixFQUFrQixXQUFsQixLQUFrQyxHQUFsQyxHQUF3QyxlQUFlLENBQWYsRUFBa0IsV0FBbEIsRUFBeEMsQ0FEUztJQUFwQjs7QUFJUCxVQUFPLGNBQVAsQ0FyQ2M7Ozs7MkJBNkNOLEtBQUssUUFBUSxJQUFJLFlBQVk7QUFDckMsT0FBSSxJQUFJLGdCQUFKLEVBQXNCO0FBQ3pCLFFBQUksZ0JBQUosQ0FBcUIsTUFBckIsRUFBNkIsRUFBN0IsRUFBaUMsVUFBakMsRUFEeUI7QUFFekIsV0FBTyxJQUFQLENBRnlCO0lBQTFCLE1BR08sSUFBSSxJQUFJLFdBQUosRUFBaUI7QUFDM0IsV0FBTyxJQUFJLFdBQUosQ0FBZ0IsT0FBTyxNQUFQLEVBQWUsRUFBL0IsQ0FBUCxDQUQyQjtJQUFyQixNQUVBO0FBQ04sWUFBUSxHQUFSLENBQVksK0JBQVosRUFETTtJQUZBOzs7O1FBak5IOzs7QUF5Tk4sSUFBSSxRQUFRLElBQUksSUFBSixFQUFSOztBQUdKLE9BQU8sRUFBUCxHQUFZLE9BQU8sT0FBTyxFQUFQLEtBQWMsV0FBckIsR0FBbUMsT0FBTyxFQUFQLEdBQVksRUFBL0M7QUFDWixPQUFPLEVBQVAsQ0FBVSxJQUFWLEdBQWlCLE9BQU8sSUFBUCxHQUFjLEtBQWQ7O2tCQUVGOzs7Ozs7Ozs7QUMxT2YsSUFBSSxTQUFTLE9BQU8sT0FBTyxNQUFQLEtBQWtCLFdBQXpCLEdBQXVDLE9BQU8sTUFBUCxHQUFnQixJQUF2RDs7a0JBRUUiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwicmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnkvanF1ZXJ5LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS1vbmRlbWFuZC9qcXVlcnkub25kZW1hbmQuanMnKTtcbnJlcXVpcmUoJy4uLy4uL3NyYy9zc3BhdGguanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LXVpL2pxdWVyeS11aS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qc29uLWpzL2pzb24yLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS1lbnR3aW5lL2Rpc3QvanF1ZXJ5LmVudHdpbmUtZGlzdC5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktY29va2llL2pxdWVyeS5jb29raWUuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LXF1ZXJ5L2pxdWVyeS5xdWVyeS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktZm9ybS9qcXVlcnkuZm9ybS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktbm90aWNlL2pxdWVyeS5ub3RpY2UuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvanNpemVzL2xpYi9qcXVlcnkuc2l6ZXMuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvamxheW91dC9saWIvamxheW91dC5ib3JkZXIuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvamxheW91dC9saWIvanF1ZXJ5LmpsYXlvdXQuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvaGlzdG9yeS1qcy9zY3JpcHRzL3VuY29tcHJlc3NlZC9oaXN0b3J5LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2hpc3RvcnktanMvc2NyaXB0cy91bmNvbXByZXNzZWQvaGlzdG9yeS5hZGFwdGVyLmpxdWVyeS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vdGhpcmRwYXJ0eS9oaXN0b3J5LWpzL3NjcmlwdHMvdW5jb21wcmVzc2VkL2hpc3RvcnkuaHRtbDQuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanN0cmVlL2pxdWVyeS5qc3RyZWUuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvY2hvc2VuL2Nob3Nlbi9jaG9zZW4uanF1ZXJ5LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS1ob3ZlckludGVudC9qcXVlcnkuaG92ZXJJbnRlbnQuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LWNoYW5nZXRyYWNrZXIvbGliL2pxdWVyeS5jaGFuZ2V0cmFja2VyLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3NyYy9UcmVlRHJvcGRvd25GaWVsZC5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vamF2YXNjcmlwdC9zcmMvRGF0ZUZpZWxkLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3NyYy9IdG1sRWRpdG9yRmllbGQuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvc3JjL1RhYlNldC5qcycpO1xucmVxdWlyZSgnLi4vLi4vc3JjL3NzdWkuY29yZS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vamF2YXNjcmlwdC9zcmMvR3JpZEZpZWxkLmpzJyk7XG4iLCJpbXBvcnQgJCBmcm9tICdqUXVlcnknO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgSm9obiBSZXNpZywgaHR0cDovL2pxdWVyeS5jb20vXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuLy8gYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4vLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbi8vIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vZGVmaW5lIHZhcnMgZm9yIGludGVyYWwgdXNlXG52YXIgJHdpbmRvdyA9ICQoIHdpbmRvdyApLFxuXHQkaHRtbCA9ICQoICdodG1sJyApLFxuXHQkaGVhZCA9ICQoICdoZWFkJyApLFxuXG5cdC8vdXJsIHBhdGggaGVscGVycyBmb3IgdXNlIGluIHJlbGF0aXZlIHVybCBtYW5hZ2VtZW50XG5cdHBhdGggPSB7XG5cblx0XHQvLyBUaGlzIHNjYXJ5IGxvb2tpbmcgcmVndWxhciBleHByZXNzaW9uIHBhcnNlcyBhbiBhYnNvbHV0ZSBVUkwgb3IgaXRzIHJlbGF0aXZlXG5cdFx0Ly8gdmFyaWFudHMgKHByb3RvY29sLCBzaXRlLCBkb2N1bWVudCwgcXVlcnksIGFuZCBoYXNoKSwgaW50byB0aGUgdmFyaW91c1xuXHRcdC8vIGNvbXBvbmVudHMgKHByb3RvY29sLCBob3N0LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQsIGV0YyB0aGF0IG1ha2UgdXAgdGhlXG5cdFx0Ly8gVVJMIGFzIHdlbGwgYXMgc29tZSBvdGhlciBjb21tb25seSB1c2VkIHN1Yi1wYXJ0cy4gV2hlbiB1c2VkIHdpdGggUmVnRXhwLmV4ZWMoKVxuXHRcdC8vIG9yIFN0cmluZy5tYXRjaCwgaXQgcGFyc2VzIHRoZSBVUkwgaW50byBhIHJlc3VsdHMgYXJyYXkgdGhhdCBsb29rcyBsaWtlIHRoaXM6XG5cdFx0Ly9cblx0XHQvLyAgICAgWzBdOiBodHRwOi8vamJsYXM6cGFzc3dvcmRAbXljb21wYW55LmNvbTo4MDgwL21haWwvaW5ib3g/bXNnPTEyMzQmdHlwZT11bnJlYWQjbXNnLWNvbnRlbnRcblx0XHQvLyAgICAgWzFdOiBodHRwOi8vamJsYXM6cGFzc3dvcmRAbXljb21wYW55LmNvbTo4MDgwL21haWwvaW5ib3g/bXNnPTEyMzQmdHlwZT11bnJlYWRcblx0XHQvLyAgICAgWzJdOiBodHRwOi8vamJsYXM6cGFzc3dvcmRAbXljb21wYW55LmNvbTo4MDgwL21haWwvaW5ib3hcblx0XHQvLyAgICAgWzNdOiBodHRwOi8vamJsYXM6cGFzc3dvcmRAbXljb21wYW55LmNvbTo4MDgwXG5cdFx0Ly8gICAgIFs0XTogaHR0cDpcblx0XHQvLyAgICAgWzVdOiAvL1xuXHRcdC8vICAgICBbNl06IGpibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MFxuXHRcdC8vICAgICBbN106IGpibGFzOnBhc3N3b3JkXG5cdFx0Ly8gICAgIFs4XTogamJsYXNcblx0XHQvLyAgICAgWzldOiBwYXNzd29yZFxuXHRcdC8vICAgIFsxMF06IG15Y29tcGFueS5jb206ODA4MFxuXHRcdC8vICAgIFsxMV06IG15Y29tcGFueS5jb21cblx0XHQvLyAgICBbMTJdOiA4MDgwXG5cdFx0Ly8gICAgWzEzXTogL21haWwvaW5ib3hcblx0XHQvLyAgICBbMTRdOiAvbWFpbC9cblx0XHQvLyAgICBbMTVdOiBpbmJveFxuXHRcdC8vICAgIFsxNl06ID9tc2c9MTIzNCZ0eXBlPXVucmVhZFxuXHRcdC8vICAgIFsxN106ICNtc2ctY29udGVudFxuXHRcdC8vXG5cdFx0dXJsUGFyc2VSRTogL14oKCgoW146XFwvI1xcP10rOik/KD86KFxcL1xcLykoKD86KChbXjpAXFwvI1xcP10rKSg/OlxcOihbXjpAXFwvI1xcP10rKSk/KUApPygoW146XFwvI1xcP1xcXVxcW10rfFxcW1teXFwvXFxdQCM/XStcXF0pKD86XFw6KFswLTldKykpPykpPyk/KT8oKFxcLz8oPzpbXlxcL1xcPyNdK1xcLyspKikoW15cXD8jXSopKSk/KFxcP1teI10rKT8pKCMuKik/LyxcblxuXHRcdC8vUGFyc2UgYSBVUkwgaW50byBhIHN0cnVjdHVyZSB0aGF0IGFsbG93cyBlYXN5IGFjY2VzcyB0b1xuXHRcdC8vYWxsIG9mIHRoZSBVUkwgY29tcG9uZW50cyBieSBuYW1lLlxuXHRcdHBhcnNlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0Ly8gSWYgd2UncmUgcGFzc2VkIGFuIG9iamVjdCwgd2UnbGwgYXNzdW1lIHRoYXQgaXQgaXNcblx0XHRcdC8vIGEgcGFyc2VkIHVybCBvYmplY3QgYW5kIGp1c3QgcmV0dXJuIGl0IGJhY2sgdG8gdGhlIGNhbGxlci5cblx0XHRcdGlmICggJC50eXBlKCB1cmwgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0cmV0dXJuIHVybDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoZXMgPSBwYXRoLnVybFBhcnNlUkUuZXhlYyggdXJsIHx8IFwiXCIgKSB8fCBbXTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgYWxsb3dzIHRoZSBjYWxsZXIgdG8gYWNjZXNzIHRoZSBzdWItbWF0Y2hlc1xuXHRcdFx0XHQvLyBieSBuYW1lLiBOb3RlIHRoYXQgSUUgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIGxpa2UgYWxsIG90aGVyIGJyb3dzZXJzIGRvLCBzbyB3ZSBub3JtYWxpemUgZXZlcnl0aGluZyBzbyBpdHMgY29uc2lzdGVudFxuXHRcdFx0XHQvLyBubyBtYXR0ZXIgd2hhdCBicm93c2VyIHdlJ3JlIHJ1bm5pbmcgb24uXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aHJlZjogICAgICAgICBtYXRjaGVzWyAgMCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0aHJlZk5vSGFzaDogICBtYXRjaGVzWyAgMSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0aHJlZk5vU2VhcmNoOiBtYXRjaGVzWyAgMiBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0ZG9tYWluOiAgICAgICBtYXRjaGVzWyAgMyBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0cHJvdG9jb2w6ICAgICBtYXRjaGVzWyAgNCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0ZG91YmxlU2xhc2g6ICBtYXRjaGVzWyAgNSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0YXV0aG9yaXR5OiAgICBtYXRjaGVzWyAgNiBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0dXNlcm5hbWU6ICAgICBtYXRjaGVzWyAgOCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0cGFzc3dvcmQ6ICAgICBtYXRjaGVzWyAgOSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0aG9zdDogICAgICAgICBtYXRjaGVzWyAxMCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0aG9zdG5hbWU6ICAgICBtYXRjaGVzWyAxMSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0cG9ydDogICAgICAgICBtYXRjaGVzWyAxMiBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0cGF0aG5hbWU6ICAgICBtYXRjaGVzWyAxMyBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0ZGlyZWN0b3J5OiAgICBtYXRjaGVzWyAxNCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0ZmlsZW5hbWU6ICAgICBtYXRjaGVzWyAxNSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0c2VhcmNoOiAgICAgICBtYXRjaGVzWyAxNiBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0aGFzaDogICAgICAgICBtYXRjaGVzWyAxNyBdIHx8IFwiXCJcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly9UdXJuIHJlbFBhdGggaW50byBhbiBhc2JvbHV0ZSBwYXRoLiBhYnNQYXRoIGlzXG5cdFx0Ly9hbiBvcHRpb25hbCBhYnNvbHV0ZSBwYXRoIHdoaWNoIGRlc2NyaWJlcyB3aGF0XG5cdFx0Ly9yZWxQYXRoIGlzIHJlbGF0aXZlIHRvLlxuXHRcdG1ha2VQYXRoQWJzb2x1dGU6IGZ1bmN0aW9uKCByZWxQYXRoLCBhYnNQYXRoICkge1xuXHRcdFx0aWYgKCByZWxQYXRoICYmIHJlbFBhdGguY2hhckF0KCAwICkgPT09IFwiL1wiICkge1xuXHRcdFx0XHRyZXR1cm4gcmVsUGF0aDtcblx0XHRcdH1cblxuXHRcdFx0cmVsUGF0aCA9IHJlbFBhdGggfHwgXCJcIjtcblx0XHRcdGFic1BhdGggPSBhYnNQYXRoID8gYWJzUGF0aC5yZXBsYWNlKCAvXlxcL3woXFwvW15cXC9dKnxbXlxcL10rKSQvZywgXCJcIiApIDogXCJcIjtcblxuXHRcdFx0dmFyIGFic1N0YWNrID0gYWJzUGF0aCA/IGFic1BhdGguc3BsaXQoIFwiL1wiICkgOiBbXSxcblx0XHRcdFx0cmVsU3RhY2sgPSByZWxQYXRoLnNwbGl0KCBcIi9cIiApO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmVsU3RhY2subGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhciBkID0gcmVsU3RhY2tbIGkgXTtcblx0XHRcdFx0c3dpdGNoICggZCApIHtcblx0XHRcdFx0XHRjYXNlIFwiLlwiOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIi4uXCI6XG5cdFx0XHRcdFx0XHRpZiAoIGFic1N0YWNrLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0YWJzU3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0YWJzU3RhY2sucHVzaCggZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBcIi9cIiArIGFic1N0YWNrLmpvaW4oIFwiL1wiICk7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIGJvdGggdXJscyBoYXZlIHRoZSBzYW1lIGRvbWFpbi5cblx0XHRpc1NhbWVEb21haW46IGZ1bmN0aW9uKCBhYnNVcmwxLCBhYnNVcmwyICkge1xuXHRcdFx0cmV0dXJuIHBhdGgucGFyc2VVcmwoIGFic1VybDEgKS5kb21haW4gPT09IHBhdGgucGFyc2VVcmwoIGFic1VybDIgKS5kb21haW47XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGZvciBhbnkgcmVsYXRpdmUgdmFyaWFudC5cblx0XHRpc1JlbGF0aXZlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0Ly8gQWxsIHJlbGF0aXZlIFVybCB2YXJpYW50cyBoYXZlIG9uZSB0aGluZyBpbiBjb21tb24sIG5vIHByb3RvY29sLlxuXHRcdFx0cmV0dXJuIHBhdGgucGFyc2VVcmwoIHVybCApLnByb3RvY29sID09PSBcIlwiO1xuXHRcdH0sXG5cblx0XHQvL1JldHVybnMgdHJ1ZSBmb3IgYW4gYWJzb2x1dGUgdXJsLlxuXHRcdGlzQWJzb2x1dGVVcmw6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5wYXJzZVVybCggdXJsICkucHJvdG9jb2wgIT09IFwiXCI7XG5cdFx0fSxcblxuXHRcdC8vVHVybiB0aGUgc3BlY2lmaWVkIHJlYWx0aXZlIFVSTCBpbnRvIGFuIGFic29sdXRlIG9uZS4gVGhpcyBmdW5jdGlvblxuXHRcdC8vY2FuIGhhbmRsZSBhbGwgcmVsYXRpdmUgdmFyaWFudHMgKHByb3RvY29sLCBzaXRlLCBkb2N1bWVudCwgcXVlcnksIGZyYWdtZW50KS5cblx0XHRtYWtlVXJsQWJzb2x1dGU6IGZ1bmN0aW9uKCByZWxVcmwsIGFic1VybCApIHtcblx0XHRcdGlmICggIXBhdGguaXNSZWxhdGl2ZVVybCggcmVsVXJsICkgKSB7XG5cdFx0XHRcdHJldHVybiByZWxVcmw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWxPYmogPSBwYXRoLnBhcnNlVXJsKCByZWxVcmwgKSxcblx0XHRcdFx0YWJzT2JqID0gcGF0aC5wYXJzZVVybCggYWJzVXJsICksXG5cdFx0XHRcdHByb3RvY29sID0gcmVsT2JqLnByb3RvY29sIHx8IGFic09iai5wcm90b2NvbCxcblx0XHRcdFx0ZG91YmxlU2xhc2ggPSByZWxPYmoucHJvdG9jb2wgPyByZWxPYmouZG91YmxlU2xhc2ggOiAoIHJlbE9iai5kb3VibGVTbGFzaCB8fCBhYnNPYmouZG91YmxlU2xhc2ggKSxcblx0XHRcdFx0YXV0aG9yaXR5ID0gcmVsT2JqLmF1dGhvcml0eSB8fCBhYnNPYmouYXV0aG9yaXR5LFxuXHRcdFx0XHRoYXNQYXRoID0gcmVsT2JqLnBhdGhuYW1lICE9PSBcIlwiLFxuXHRcdFx0XHRwYXRobmFtZSA9IHBhdGgubWFrZVBhdGhBYnNvbHV0ZSggcmVsT2JqLnBhdGhuYW1lIHx8IGFic09iai5maWxlbmFtZSwgYWJzT2JqLnBhdGhuYW1lICksXG5cdFx0XHRcdHNlYXJjaCA9IHJlbE9iai5zZWFyY2ggfHwgKCAhaGFzUGF0aCAmJiBhYnNPYmouc2VhcmNoICkgfHwgXCJcIixcblx0XHRcdFx0aGFzaCA9IHJlbE9iai5oYXNoO1xuXG5cdFx0XHRyZXR1cm4gcHJvdG9jb2wgKyBkb3VibGVTbGFzaCArIGF1dGhvcml0eSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblx0XHR9LFxuXG5cdFx0Ly9BZGQgc2VhcmNoIChha2EgcXVlcnkpIHBhcmFtcyB0byB0aGUgc3BlY2lmaWVkIHVybC5cblx0XHQvLyAyMDEzLTEyLTA2IGlzY2hvbW1lcjogQ3VzdG9taXplZCB0byBtZXJnZSB3aXRoIGV4aXN0aW5nIGtleXNcblx0XHRhZGRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcyApIHtcblx0XHRcdHZhciB1ID0gcGF0aC5wYXJzZVVybCggdXJsICksXG5cdFx0XHRcdHBhcmFtcyA9ICggdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiApID8gcGF0aC5jb252ZXJ0U2VhcmNoVG9BcnJheSggcGFyYW1zICkgOiBwYXJhbXMsXG5cdFx0XHRcdG5ld1BhcmFtcyA9ICQuZXh0ZW5kKCBwYXRoLmNvbnZlcnRTZWFyY2hUb0FycmF5KCB1LnNlYXJjaCApLCBwYXJhbXMgKTtcblx0XHRcdHJldHVybiB1LmhyZWZOb1NlYXJjaCArICc/JyArICQucGFyYW0oIG5ld1BhcmFtcyApICsgKCB1Lmhhc2ggfHwgXCJcIiApO1xuXHRcdH0sXG5cblx0XHQvLyAyMDEzLTEyLTA2IGlzY2hvbW1lcjogQWRkZWQgdG8gYWxsb3cgbWVyZ2Ugd2l0aCBleGlzdGluZyBrZXlzXG5cdFx0Z2V0U2VhcmNoUGFyYW1zOiBmdW5jdGlvbih1cmwpIHtcblx0XHRcdHZhciB1ID0gcGF0aC5wYXJzZVVybCggdXJsICk7XG5cdFx0XHRyZXR1cm4gcGF0aC5jb252ZXJ0U2VhcmNoVG9BcnJheSggdS5zZWFyY2ggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udmVydHMgcXVlcnkgc3RyaW5ncyAoZm9vPWJhciZiYXo9YmxhKSB0byBhIGhhc2guXG5cdFx0Ly8gVE9ETyBIYW5kbGUgcmVwZWF0aW5nIGVsZW1lbnRzIChlLmcuIGFycltdPW9uZSZhcnJbXT10d28pXG5cdFx0Ly8gMjAxMy0xMi0wNiBpc2Nob21tZXI6IEFkZGVkIHRvIGFsbG93IG1lcmdlIHdpdGggZXhpc3Rpbmcga2V5c1xuXHRcdGNvbnZlcnRTZWFyY2hUb0FycmF5OiBmdW5jdGlvbihzZWFyY2gpIHtcblx0XHRcdHZhciBwYXJhbXMgPSB7fSwgXG5cdFx0XHRcdHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCAvXlxcPy8sICcnICksXG5cdFx0XHRcdHBhcnRzID0gc2VhcmNoID8gc2VhcmNoLnNwbGl0KCAnJicgKSA6IFtdLCBpLCB0bXA7XG5cdFx0XHRmb3IoaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dG1wID0gcGFydHNbaV0uc3BsaXQoICc9JyApO1xuXHRcdFx0XHRwYXJhbXNbdG1wWzBdXSA9IHRtcFsxXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJhbXM7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnRVcmxUb0RhdGFVcmw6IGZ1bmN0aW9uKCBhYnNVcmwgKSB7XG5cdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIGFic1VybCApO1xuXHRcdFx0aWYgKCBwYXRoLmlzRW1iZWRkZWRQYWdlKCB1ICkgKSB7XG5cdFx0XHRcdC8vIEZvciBlbWJlZGRlZCBwYWdlcywgcmVtb3ZlIHRoZSBkaWFsb2cgaGFzaCBrZXkgYXMgaW4gZ2V0RmlsZVBhdGgoKSxcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHRoZSBEYXRhIFVybCB3b24ndCBtYXRjaCB0aGUgaWQgb2YgdGhlIGVtYmVkZGVkIFBhZ2UuXG5cdFx0XHRcdHJldHVybiB1Lmhhc2guc3BsaXQoIGRpYWxvZ0hhc2hLZXkgKVswXS5yZXBsYWNlKCAvXiMvLCBcIlwiICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBwYXRoLmlzU2FtZURvbWFpbiggdSwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIHUuaHJlZk5vSGFzaC5yZXBsYWNlKCBkb2N1bWVudC5kb21haW4sIFwiXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhYnNVcmw7XG5cdFx0fSxcblxuXHRcdC8vZ2V0IHBhdGggZnJvbSBjdXJyZW50IGhhc2gsIG9yIGZyb20gYSBmaWxlIHBhdGhcblx0XHRnZXQ6IGZ1bmN0aW9uKCBuZXdQYXRoICkge1xuXHRcdFx0aWYoIG5ld1BhdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0bmV3UGF0aCA9IGxvY2F0aW9uLmhhc2g7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGF0aC5zdHJpcEhhc2goIG5ld1BhdGggKS5yZXBsYWNlKCAvW15cXC9dKlxcLlteXFwvKl0rJC8sICcnICk7XG5cdFx0fSxcblxuXHRcdC8vcmV0dXJuIHRoZSBzdWJzdHJpbmcgb2YgYSBmaWxlcGF0aCBiZWZvcmUgdGhlIHN1Yi1wYWdlIGtleSwgZm9yIG1ha2luZyBhIHNlcnZlciByZXF1ZXN0XG5cdFx0Z2V0RmlsZVBhdGg6IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdFx0dmFyIHNwbGl0a2V5ID0gJyYnICsgJC5tb2JpbGUuc3ViUGFnZVVybEtleTtcblx0XHRcdHJldHVybiBwYXRoICYmIHBhdGguc3BsaXQoIHNwbGl0a2V5IClbMF0uc3BsaXQoIGRpYWxvZ0hhc2hLZXkgKVswXTtcblx0XHR9LFxuXG5cdFx0Ly9zZXQgbG9jYXRpb24gaGFzaCB0byBwYXRoXG5cdFx0c2V0OiBmdW5jdGlvbiggcGF0aCApIHtcblx0XHRcdGxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuXHRcdH0sXG5cblx0XHQvL3Rlc3QgaWYgYSBnaXZlbiB1cmwgKHN0cmluZykgaXMgYSBwYXRoXG5cdFx0Ly9OT1RFIG1pZ2h0IGJlIGV4Y2VwdGlvbmFsbHkgbmFpdmVcblx0XHRpc1BhdGg6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRyZXR1cm4gKCAvXFwvLyApLnRlc3QoIHVybCApO1xuXHRcdH0sXG5cblx0XHQvL3JldHVybiBhIHVybCBwYXRoIHdpdGggdGhlIHdpbmRvdydzIGxvY2F0aW9uIHByb3RvY29sL2hvc3RuYW1lL3BhdGhuYW1lIHJlbW92ZWRcblx0XHRjbGVhbjogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdHJldHVybiB1cmwucmVwbGFjZSggZG9jdW1lbnQuZG9tYWluLCBcIlwiICk7XG5cdFx0fSxcblxuXHRcdC8vanVzdCByZXR1cm4gdGhlIHVybCB3aXRob3V0IGFuIGluaXRpYWwgI1xuXHRcdHN0cmlwSGFzaDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdHJldHVybiB1cmwucmVwbGFjZSggL14jLywgXCJcIiApO1xuXHRcdH0sXG5cblx0XHQvL3JlbW92ZSB0aGUgcHJlY2VkaW5nIGhhc2gsIGFueSBxdWVyeSBwYXJhbXMsIGFuZCBkaWFsb2cgbm90YXRpb25zXG5cdFx0Y2xlYW5IYXNoOiBmdW5jdGlvbiggaGFzaCApIHtcblx0XHRcdHJldHVybiBwYXRoLnN0cmlwSGFzaCggaGFzaC5yZXBsYWNlKCAvXFw/LiokLywgXCJcIiApLnJlcGxhY2UoIGRpYWxvZ0hhc2hLZXksIFwiXCIgKSApO1xuXHRcdH0sXG5cblx0XHQvL2NoZWNrIHdoZXRoZXIgYSB1cmwgaXMgcmVmZXJlbmNpbmcgdGhlIHNhbWUgZG9tYWluLCBvciBhbiBleHRlcm5hbCBkb21haW4gb3IgZGlmZmVyZW50IHByb3RvY29sXG5cdFx0Ly9jb3VsZCBiZSBtYWlsdG8sIGV0Y1xuXHRcdGlzRXh0ZXJuYWw6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIHVybCApO1xuXHRcdFx0cmV0dXJuIHUucHJvdG9jb2wgJiYgdS5kb21haW4gIT09IGRvY3VtZW50LmRvbWFpbiA/IHRydWUgOiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0aGFzUHJvdG9jb2w6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRyZXR1cm4gKCAvXig6P1xcdys6KS8gKS50ZXN0KCB1cmwgKTtcblx0XHR9XG59O1xuXG4kLnBhdGggPSBwYXRoO1xuIiwiaW1wb3J0ICQgZnJvbSAnalF1ZXJ5JztcblxuLyoqXG4gKiBBbGxvd3MgaWNvbiBkZWZpbml0aW9uIHZpYSBIVE1MNSBkYXRhIGF0dHJzIGZvciBlYXNpZXIgaGFuZGxpbmcgaW4gUEhQLlxuICpcbiAqIEFkZHMgYW4gYWx0ZXJuYXRpdmUgYXBwZWFyYW5jZSBzbyB3ZSBjYW4gdG9nZ2xlIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlbVxuICogYW5kIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIHRvIGFkZCBjdXN0b20gc3R5bGluZyBhbmQgYmVoYXZpb3VyLiBFeGFtcGxlIHVzZVxuICogaXMgaW4gdGhlIENNUyB3aXRoIHRoZSBzYXZpbmcgYnV0dG9ucyAtIGRlcGVuZGluZyBvbiB0aGUgcGFnZSdzIHN0YXRlIG9uZSBvZlxuICogdGhlbSB3aWxsIGVpdGhlciBzYXkgXCJTYXZlIGRyYWZ0XCIgb3IgXCJTYXZlZFwiLCBhbmQgd2lsbCBoYXZlIGRpZmZlcmVudCBjb2xvdXIuXG4gKi9cbiQud2lkZ2V0KCdzc3VpLmJ1dHRvbicsICQudWkuYnV0dG9uLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRhbHRlcm5hdGU6IHtcblx0XHRcdGljb246IG51bGwsXG5cdFx0XHR0ZXh0OiBudWxsXG5cdFx0fSxcblx0XHRzaG93aW5nQWx0ZXJuYXRlOiBmYWxzZVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTd2l0Y2ggYmV0d2VlbiB0aGUgYWx0ZXJuYXRlIGFwcGVhcmFuY2VzLlxuXHQgKi9cblx0dG9nZ2xlQWx0ZXJuYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fdHJpZ2dlcignb250b2dnbGVhbHRlcm5hdGUnKT09PWZhbHNlKSByZXR1cm47XG5cblx0XHQvLyBPbmx5IHN3aXRjaCB0byBhbHRlcm5hdGUgaWYgaXQgaGFzIGJlZW4gZW5hYmxlZCB0aHJvdWdoIG9wdGlvbnMuIFxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFsdGVybmF0ZS5pY29uICYmICF0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLnRleHQpIHJldHVybjtcblxuXHRcdHRoaXMub3B0aW9ucy5zaG93aW5nQWx0ZXJuYXRlID0gIXRoaXMub3B0aW9ucy5zaG93aW5nQWx0ZXJuYXRlO1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGp1c3QgdGhlIGFwcGVhcmFuY2UgdG8gZml0IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3MuXG5cdCAqL1xuXHRfcmVmcmVzaEFsdGVybmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdHJpZ2dlcignYmVmb3JlcmVmcmVzaGFsdGVybmF0ZScpO1xuXG5cdFx0Ly8gT25seSBzd2l0Y2ggdG8gYWx0ZXJuYXRlIGlmIGl0IGhhcyBiZWVuIGVuYWJsZWQgdGhyb3VnaCBvcHRpb25zLiBcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hbHRlcm5hdGUuaWNvbiAmJiAhdGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0KSByZXR1cm47XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnNob3dpbmdBbHRlcm5hdGUpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLWljb24tcHJpbWFyeScpLmhpZGUoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLXRleHQnKS5oaWRlKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi1pY29uLWFsdGVybmF0ZScpLnNob3coKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLXRleHQtYWx0ZXJuYXRlJykuc2hvdygpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLWljb24tcHJpbWFyeScpLnNob3coKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLXRleHQnKS5zaG93KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi1pY29uLWFsdGVybmF0ZScpLmhpZGUoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLXRleHQtYWx0ZXJuYXRlJykuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyaWdnZXIoJ2FmdGVycmVmcmVzaGFsdGVybmF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3QgYnV0dG9uIC0gcHVsbHMgaW4gb3B0aW9ucyBmcm9tIGRhdGEgYXR0cmlidXRlcy5cblx0ICogSW5qZWN0cyBuZXcgZWxlbWVudHMgZm9yIGFsdGVybmF0ZSBhcHBlYXJhbmNlIChpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMpLlxuXHQgKi9cblx0X3Jlc2V0QnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWNvblByaW1hcnkgPSB0aGlzLmVsZW1lbnQuZGF0YSgnaWNvbi1wcmltYXJ5JyksXG5cdFx0XHRpY29uU2Vjb25kYXJ5ID0gdGhpcy5lbGVtZW50LmRhdGEoJ2ljb24tc2Vjb25kYXJ5Jyk7XG5cblx0XHRpZiAoIWljb25QcmltYXJ5KSBpY29uUHJpbWFyeSA9IHRoaXMuZWxlbWVudC5kYXRhKCdpY29uJyk7XG5cblx0XHQvLyBUT0RPIE1vdmUgcHJlZml4IG91dCBvZiB0aGlzIG1ldGhvZCwgd2l0aG91dCByZXF1cmlpbmcgaXQgZm9yIGV2ZXJ5IGljb24gZGVmaW5pdGlvbiBpbiBhIGRhdGEgYXR0clxuXHRcdGlmKGljb25QcmltYXJ5KSB0aGlzLm9wdGlvbnMuaWNvbnMucHJpbWFyeSA9ICdidG4taWNvbi0nICsgaWNvblByaW1hcnk7XG5cdFx0aWYoaWNvblNlY29uZGFyeSkgdGhpcy5vcHRpb25zLmljb25zLnNlY29uZGFyeSA9ICdidG4taWNvbi0nICsgaWNvblNlY29uZGFyeTtcblxuXHRcdCQudWkuYnV0dG9uLnByb3RvdHlwZS5fcmVzZXRCdXR0b24uY2FsbCh0aGlzKTtcblxuXHRcdC8vIFB1bGwgb3B0aW9ucyBmcm9tIGRhdGEgYXR0cmlidXRlcy4gT3ZlcnJpZGVuIGJ5IGV4cGxpY2l0IG9wdGlvbnMgZ2l2ZW4gb24gd2lkZ2V0IGNyZWF0aW9uLlxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0KSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLnRleHQgPSB0aGlzLmVsZW1lbnQuZGF0YSgndGV4dC1hbHRlcm5hdGUnKTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLmljb24pIHtcblx0XHRcdHRoaXMub3B0aW9ucy5hbHRlcm5hdGUuaWNvbiA9IHRoaXMuZWxlbWVudC5kYXRhKCdpY29uLWFsdGVybmF0ZScpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5zaG93aW5nQWx0ZXJuYXRlKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc2hvd2luZ0FsdGVybmF0ZSA9IHRoaXMuZWxlbWVudC5oYXNDbGFzcygnc3MtdWktYWx0ZXJuYXRlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIG1pc3NpbmcgZWxlbWVudHMuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hbHRlcm5hdGUuaWNvbikge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmFwcGVuZChcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tYWx0ZXJuYXRlIHVpLWJ1dHRvbi1pY29uLXByaW1hcnkgdWktaWNvbiBidG4taWNvbi1cIiBcblx0XHRcdFx0KyB0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLmljb24gKyBcIic+PC9zcGFuPlwiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0KSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQuYXBwZW5kKFxuXHRcdFx0XHRcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24tdGV4dC1hbHRlcm5hdGUgdWktYnV0dG9uLXRleHQnPlwiICsgdGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0ICsgXCI8L3NwYW4+XCJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVmcmVzaEFsdGVybmF0ZSgpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdCQudWkuYnV0dG9uLnByb3RvdHlwZS5yZWZyZXNoLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLl9yZWZyZXNoQWx0ZXJuYXRlKCk7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoJy51aS1idXR0b24tdGV4dC1hbHRlcm5hdGUnKS5yZW1vdmUoKTtcblx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi1pY29uLWFsdGVybmF0ZScpLnJlbW92ZSgpO1xuXG5cdFx0JC51aS5idXR0b24ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCggdGhpcyApO1xuXHR9XG59KTtcblxuLyoqXG4gKiBFeHRlbmRzIGpRdWVyeVVJIGRpYWxvZyB3aXRoIGlmcmFtZSBhYmlsaXRpZXMgKGFuZCByZWxhdGVkIHJlc2l6aW5nIGxvZ2ljKSxcbiAqIGFuZCBzZXRzIHNvbWUgQ01TLXdpZGUgZGVmYXVsdHMuXG4gKlxuICogQWRkaXRpb25hbCBzZXR0aW5nczpcbiAqIC0gJ2F1dG9Qb3NpdGlvbic6IEF1dG9tYXRpY2FsbHkgcmVwb3NpdGlvbiB3aW5kb3cgb24gcmVzaXplIGJhc2VkIG9uICdwb3NpdGlvbicgb3B0aW9uXG4gKiAtICd3aWR0aFJhdGlvJzogU2V0cyB3aWR0aCBiYXNlZCBvbiBwZXJjZW50YWdlIG9mIHdpbmRvdyAodmFsdWUgYmV0d2VlbiAwIGFuZCAxKVxuICogLSAnaGVpZ2h0UmF0aW8nOiBTZXRzIHdpZHRoIGJhc2VkIG9uIHBlcmNlbnRhZ2Ugb2Ygd2luZG93ICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEpXG4gKiAtICdyZWxvYWRPbk9wZW4nOiBSZWxvYWRzIHRoZSBpZnJhbWUgd2hlbmV2ZXIgdGhlIGRpYWxvZyBpcyByZW9wZW5lZFxuICogLSAnaWZyYW1lVXJsJzogQ3JlYXRlIGFuIGlmcmFtZSBlbGVtZW50IGFuZCBsb2FkIHRoaXMgVVJMIHdoZW4gdGhlIGRpYWxvZyBpcyBjcmVhdGVkXG4gKi9cbiQud2lkZ2V0KFwic3N1aS5zc2RpYWxvZ1wiLCAkLnVpLmRpYWxvZywge1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQ3VzdG9tIHByb3BlcnRpZXNcblx0XHRpZnJhbWVVcmw6ICcnLFxuXHRcdHJlbG9hZE9uT3BlbjogdHJ1ZSxcblx0XHRkaWFsb2dFeHRyYUNsYXNzOiAnJyxcblxuXHRcdC8vIERlZmF1bHRzXG5cdFx0bW9kYWw6IHRydWUsXG5cdFx0YmdpZnJhbWU6IHRydWUsXG5cdFx0YXV0b09wZW46IGZhbHNlLFxuXHRcdGF1dG9Qb3NpdGlvbjogdHJ1ZSxcblx0XHRtaW5XaWR0aDogNTAwLFxuXHRcdG1heFdpZHRoOiA4MDAsXG5cdFx0bWluSGVpZ2h0OiAzMDAsXG5cdFx0bWF4SGVpZ2h0OiA3MDAsXG5cdFx0d2lkdGhSYXRpbzogMC44LFxuXHRcdGhlaWdodFJhdGlvOiAwLjgsXG5cdFx0cmVzaXphYmxlOiBmYWxzZVxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHQkLnVpLmRpYWxvZy5wcm90b3R5cGUuX2NyZWF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gQ3JlYXRlIGlmcmFtZVxuXHRcdHZhciBpZnJhbWUgPSAkKCc8aWZyYW1lIG1hcmdpbldpZHRoPVwiMFwiIG1hcmdpbkhlaWdodD1cIjBcIiBmcmFtZUJvcmRlcj1cIjBcIiBzY3JvbGxpbmc9XCJhdXRvXCI+PC9pZnJhbWU+Jyk7XG5cdFx0aWZyYW1lLmJpbmQoJ2xvYWQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZigkKHRoaXMpLmF0dHIoJ3NyYycpID09ICdhYm91dDpibGFuaycpIHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWZyYW1lLmFkZENsYXNzKCdsb2FkZWQnKS5zaG93KCk7IC8vIG1vcmUgcmVsaWFibGUgdGhhbiAnc3JjJyBhdHRyIGNoZWNrIChpbiBJRSlcblx0XHRcdHNlbGYuX3Jlc2l6ZUlmcmFtZSgpO1xuXHRcdFx0c2VsZi51aURpYWxvZy5yZW1vdmVDbGFzcygnbG9hZGluZycpO1xuXHRcdH0pLmhpZGUoKTtcblx0XHRcblx0XHRpZih0aGlzLm9wdGlvbnMuZGlhbG9nRXh0cmFDbGFzcykgdGhpcy51aURpYWxvZy5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlhbG9nRXh0cmFDbGFzcyk7XG5cdFx0dGhpcy5lbGVtZW50LmFwcGVuZChpZnJhbWUpO1xuXG5cdFx0Ly8gTGV0IHRoZSBpZnJhbWUgaGFuZGxlIGl0cyBzY3JvbGxpbmdcblx0XHRpZih0aGlzLm9wdGlvbnMuaWZyYW1lVXJsKSB0aGlzLmVsZW1lbnQuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcblx0fSxcblx0b3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0JC51aS5kaWFsb2cucHJvdG90eXBlLm9wZW4uY2FsbCh0aGlzKTtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXMsIGlmcmFtZSA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbignaWZyYW1lJyk7XG5cblx0XHQvLyBMb2FkIGlmcmFtZVxuXHRcdGlmKHRoaXMub3B0aW9ucy5pZnJhbWVVcmwgJiYgKCFpZnJhbWUuaGFzQ2xhc3MoJ2xvYWRlZCcpIHx8IHRoaXMub3B0aW9ucy5yZWxvYWRPbk9wZW4pKSB7XG5cdFx0XHRpZnJhbWUuaGlkZSgpO1xuXHRcdFx0aWZyYW1lLmF0dHIoJ3NyYycsIHRoaXMub3B0aW9ucy5pZnJhbWVVcmwpO1xuXHRcdFx0dGhpcy51aURpYWxvZy5hZGRDbGFzcygnbG9hZGluZycpO1xuXHRcdH1cblxuXHRcdC8vIFJlc2l6ZSBldmVudHNcblx0XHQkKHdpbmRvdykuYmluZCgncmVzaXplLnNzZGlhbG9nJywgZnVuY3Rpb24oKSB7c2VsZi5fcmVzaXplSWZyYW1lKCk7fSk7XG5cdH0sXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHQkLnVpLmRpYWxvZy5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMudWlEaWFsb2cudW5iaW5kKCdyZXNpemUuc3NkaWFsb2cnKTtcblx0XHQkKHdpbmRvdykudW5iaW5kKCdyZXNpemUuc3NkaWFsb2cnKTtcblx0fSxcblx0X3Jlc2l6ZUlmcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdHMgPSB7fSwgbmV3V2lkdGgsIG5ld0hlaWdodCwgaWZyYW1lID0gdGhpcy5lbGVtZW50LmNoaWxkcmVuKCdpZnJhbWUnKTs7XG5cdFx0aWYodGhpcy5vcHRpb25zLndpZHRoUmF0aW8pIHtcblx0XHRcdG5ld1dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCkgKiB0aGlzLm9wdGlvbnMud2lkdGhSYXRpbztcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5taW5XaWR0aCAmJiBuZXdXaWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuXHRcdFx0XHRvcHRzLndpZHRoID0gdGhpcy5vcHRpb25zLm1pbldpZHRoXG5cdFx0XHR9IGVsc2UgaWYodGhpcy5vcHRpb25zLm1heFdpZHRoICYmIG5ld1dpZHRoID4gdGhpcy5vcHRpb25zLm1heFdpZHRoKSB7XG5cdFx0XHRcdG9wdHMud2lkdGggPSB0aGlzLm9wdGlvbnMubWF4V2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRzLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWlnaHRSYXRpbykge1xuXHRcdFx0bmV3SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpICogdGhpcy5vcHRpb25zLmhlaWdodFJhdGlvO1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLm1pbkhlaWdodCAmJiBuZXdIZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG5cdFx0XHRcdG9wdHMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodFxuXHRcdFx0fSBlbHNlIGlmKHRoaXMub3B0aW9ucy5tYXhIZWlnaHQgJiYgbmV3SGVpZ2h0ID4gdGhpcy5vcHRpb25zLm1heEhlaWdodCkge1xuXHRcdFx0XHRvcHRzLmhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRzLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZighalF1ZXJ5LmlzRW1wdHlPYmplY3Qob3B0cykpIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbnMob3B0cyk7XG5cblx0XHRcdC8vIFJlc2l6ZSBpZnJhbWUgd2l0aGluIGRpYWxvZ1xuXHRcdFx0aWZyYW1lLmF0dHIoJ3dpZHRoJywgXG5cdFx0XHRcdG9wdHMud2lkdGggXG5cdFx0XHRcdC0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuY3NzKCdwYWRkaW5nTGVmdCcpKVxuXHRcdFx0XHQtIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LmNzcygncGFkZGluZ1JpZ2h0JykpXG5cdFx0XHQpO1xuXHRcdFx0aWZyYW1lLmF0dHIoJ2hlaWdodCcsIFxuXHRcdFx0XHRvcHRzLmhlaWdodFxuXHRcdFx0XHQtIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LmNzcygncGFkZGluZ1RvcCcpKSBcblx0XHRcdFx0LSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5jc3MoJ3BhZGRpbmdCb3R0b20nKSlcblx0XHRcdCk7XG5cblx0XHRcdC8vIEVuZm9yY2UgbmV3IHBvc2l0aW9uXG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuYXV0b1Bvc2l0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3NldE9wdGlvbihcInBvc2l0aW9uXCIsIHRoaXMub3B0aW9ucy5wb3NpdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuJC53aWRnZXQoXCJzc3VpLnRpdGxlYmFyXCIsIHtcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmlnaW5hbFRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoJ3RpdGxlJyk7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR2YXIgdGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IHRoaXMub3JpZ2luYWxUaXRsZSB8fCAnJm5ic3A7Jztcblx0XHR2YXIgdGl0bGVJZCA9ICQudWkuZGlhbG9nLmdldFRpdGxlSWQodGhpcy5lbGVtZW50KTtcblxuXHRcdHRoaXMuZWxlbWVudC5wYXJlbnQoKS5hZGRDbGFzcygndWktZGlhbG9nJyk7XG5cblx0XHR2YXIgdWlEaWFsb2dUaXRsZWJhciA9IHRoaXMuZWxlbWVudC5cblx0XHRcdGFkZENsYXNzKFxuXHRcdFx0XHQndWktZGlhbG9nLXRpdGxlYmFyICcgK1xuXHRcdFx0XHQndWktd2lkZ2V0LWhlYWRlciAnICtcblx0XHRcdFx0J3VpLWNvcm5lci1hbGwgJyArXG5cdFx0XHRcdCd1aS1oZWxwZXItY2xlYXJmaXgnXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCB0aGVcblxuXHRcdFx0aWYob3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuXHRcdFx0XHR2YXIgdWlEaWFsb2dUaXRsZWJhckNsb3NlID0gJCgnPGEgaHJlZj1cIiNcIi8+Jylcblx0XHRcdFx0XHQuYWRkQ2xhc3MoXG5cdFx0XHRcdFx0XHQndWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlICcgK1xuXHRcdFx0XHRcdFx0J3VpLWNvcm5lci1hbGwnXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKCdyb2xlJywgJ2J1dHRvbicpXG5cdFx0XHRcdFx0LmhvdmVyKFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHVpRGlhbG9nVGl0bGViYXJDbG9zZS5hZGRDbGFzcygndWktc3RhdGUtaG92ZXInKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dWlEaWFsb2dUaXRsZWJhckNsb3NlLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuZm9jdXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR1aURpYWxvZ1RpdGxlYmFyQ2xvc2UuYWRkQ2xhc3MoJ3VpLXN0YXRlLWZvY3VzJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYmx1cihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHVpRGlhbG9nVGl0bGViYXJDbG9zZS5yZW1vdmVDbGFzcygndWktc3RhdGUtZm9jdXMnKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tb3VzZWRvd24oZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRcdGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFwcGVuZFRvKHVpRGlhbG9nVGl0bGViYXIpO1xuXG5cdFx0XHRcdHZhciB1aURpYWxvZ1RpdGxlYmFyQ2xvc2VUZXh0ID0gKHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlVGV4dCA9ICQoJzxzcGFuLz4nKSlcblx0XHRcdFx0XHQuYWRkQ2xhc3MoXG5cdFx0XHRcdFx0XHQndWktaWNvbiAnICtcblx0XHRcdFx0XHRcdCd1aS1pY29uLWNsb3NldGhpY2snXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC50ZXh0KG9wdGlvbnMuY2xvc2VUZXh0KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyh1aURpYWxvZ1RpdGxlYmFyQ2xvc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdWlEaWFsb2dUaXRsZSA9ICQoJzxzcGFuLz4nKVxuXHRcdFx0XHQuYWRkQ2xhc3MoJ3VpLWRpYWxvZy10aXRsZScpXG5cdFx0XHRcdC5hdHRyKCdpZCcsIHRpdGxlSWQpXG5cdFx0XHRcdC5odG1sKHRpdGxlKVxuXHRcdFx0XHQucHJlcGVuZFRvKHVpRGlhbG9nVGl0bGViYXIpO1xuXG5cdFx0XHR1aURpYWxvZ1RpdGxlYmFyLmZpbmQoXCIqXCIpLmFkZCh1aURpYWxvZ1RpdGxlYmFyKS5kaXNhYmxlU2VsZWN0aW9uKCk7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCcuZGlhbG9nJylcblx0XHRcdC5yZW1vdmVEYXRhKCdkaWFsb2cnKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCd1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudCcpXG5cdFx0XHQuaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG5cblx0XHQodGhpcy5vcmlnaW5hbFRpdGxlICYmIHRoaXMuZWxlbWVudC5hdHRyKCd0aXRsZScsIHRoaXMub3JpZ2luYWxUaXRsZSkpO1xuXHR9XG59KTtcblxuJC5leHRlbmQoJC5zc3VpLnRpdGxlYmFyLCB7XG5cdHZlcnNpb246IFwiMC4wLjFcIixcblx0b3B0aW9uczoge1xuXHRcdHRpdGxlOiAnJyxcblx0XHRjbG9zZUJ1dHRvbjogZmFsc2UsXG5cdFx0Y2xvc2VUZXh0OiAnY2xvc2UnXG5cdH0sXG5cblx0dXVpZDogMCxcblxuXHRnZXRUaXRsZUlkOiBmdW5jdGlvbigkZWwpIHtcblx0XHRyZXR1cm4gJ3VpLWRpYWxvZy10aXRsZS0nICsgKCRlbC5hdHRyKCdpZCcpIHx8ICsrdGhpcy51dWlkKTtcblx0fVxufSk7XG4iLCIvLyBDaG9zZW4sIGEgU2VsZWN0IEJveCBFbmhhbmNlciBmb3IgalF1ZXJ5IGFuZCBQcm90b3lwZVxuLy8gYnkgUGF0cmljayBGaWxsZXIgZm9yIEhhcnZlc3QsIGh0dHA6Ly9nZXRoYXJ2ZXN0LmNvbVxuLy8gXG4vLyBWZXJzaW9uIDAuOS44XG4vLyBGdWxsIHNvdXJjZSBhdCBodHRwczovL2dpdGh1Yi5jb20vaGFydmVzdGhxL2Nob3NlblxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEhhcnZlc3QgaHR0cDovL2dldGhhcnZlc3QuY29tXG5cbi8vIE1JVCBMaWNlbnNlLCBodHRwczovL2dpdGh1Yi5jb20vaGFydmVzdGhxL2Nob3Nlbi9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4vLyBiYXNlZCBvbiB2ZXJzaW9uIDAuOS44LCBhcHBsaWVkIGEgdmVyeSBzaW1wbGUgcGF0Y2ggdGhhdCBmaXhlcyBwZXJjZW50YWdlIHdpZHRoIHN1cHBvcnQgb24gc2VsZWN0IHRhZywgYW5kIGVuYWJsZXMgcmlzZS11cCBmdW5jdGlvbmFsaXR5XG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGBjYWtlIGJ1aWxkYCwgZG8gbm90IGVkaXQgaXQgYnkgaGFuZC5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFNlbGVjdFBhcnNlcjtcblxuICBTZWxlY3RQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBPcmlnaW9uYWwgLSBZb3UgY2FuJ3QgYXNzaWduIHRvIGZ1bmN0aW9ucyBsaWtlIHRoaXMgaW4gc3RyaWN0IG1vZGUuXG4gICAgLy9TZWxlY3RQYXJzZXIubmFtZSA9ICdTZWxlY3RQYXJzZXInO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0UGFyc2VyKCkge1xuICAgICAgdGhpcy5vcHRpb25zX2luZGV4ID0gMDtcbiAgICAgIHRoaXMucGFyc2VkID0gW107XG4gICAgfVxuXG4gICAgLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUubmFtZSA9ICdTZWxlY3RQYXJzZXInO1xuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfbm9kZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9ncm91cChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfb3B0aW9uKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgdmFyIGdyb3VwX3Bvc2l0aW9uLCBvcHRpb24sIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIGdyb3VwX3Bvc2l0aW9uID0gdGhpcy5wYXJzZWQubGVuZ3RoO1xuICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgIGFycmF5X2luZGV4OiBncm91cF9wb3NpdGlvbixcbiAgICAgICAgZ3JvdXA6IHRydWUsXG4gICAgICAgIGxhYmVsOiBncm91cC5sYWJlbCxcbiAgICAgICAgY2hpbGRyZW46IDAsXG4gICAgICAgIGRpc2FibGVkOiBncm91cC5kaXNhYmxlZFxuICAgICAgfSk7XG4gICAgICBfcmVmID0gZ3JvdXAuY2hpbGROb2RlcztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb3B0aW9uID0gX3JlZltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hZGRfb3B0aW9uKG9wdGlvbiwgZ3JvdXBfcG9zaXRpb24sIGdyb3VwLmRpc2FibGVkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUuYWRkX29wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbiwgZ3JvdXBfcG9zaXRpb24sIGdyb3VwX2Rpc2FibGVkKSB7XG4gICAgICBpZiAob3B0aW9uLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiT1BUSU9OXCIpIHtcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW4vaXNzdWVzLzIxMjVcbiAgICAgICAgaWYgKCFvcHRpb24udGV4dC5tYXRjaCgvXlxccyokL2cpKSB7XG4gICAgICAgICAgaWYgKGdyb3VwX3Bvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkW2dyb3VwX3Bvc2l0aW9uXS5jaGlsZHJlbiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgIGFycmF5X2luZGV4OiB0aGlzLnBhcnNlZC5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zX2luZGV4OiB0aGlzLm9wdGlvbnNfaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICAgICAgdGV4dDogb3B0aW9uLnRleHQsXG4gICAgICAgICAgICBodG1sOiBvcHRpb24uaW5uZXJIVE1MLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBncm91cF9kaXNhYmxlZCA9PT0gdHJ1ZSA/IGdyb3VwX2Rpc2FibGVkIDogb3B0aW9uLmRpc2FibGVkLFxuICAgICAgICAgICAgZ3JvdXBfYXJyYXlfaW5kZXg6IGdyb3VwX3Bvc2l0aW9uLFxuICAgICAgICAgICAgY2xhc3Nlczogb3B0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb24uc3R5bGUuY3NzVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgYXJyYXlfaW5kZXg6IHRoaXMucGFyc2VkLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnNfaW5kZXg6IHRoaXMub3B0aW9uc19pbmRleCxcbiAgICAgICAgICAgIGVtcHR5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc19pbmRleCArPSAxO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0UGFyc2VyO1xuXG4gIH0pKCk7XG5cbiAgU2VsZWN0UGFyc2VyLnNlbGVjdF90b19hcnJheSA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICAgIHZhciBjaGlsZCwgcGFyc2VyLCBfaSwgX2xlbiwgX3JlZjtcbiAgICBwYXJzZXIgPSBuZXcgU2VsZWN0UGFyc2VyKCk7XG4gICAgX3JlZiA9IHNlbGVjdC5jaGlsZE5vZGVzO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgY2hpbGQgPSBfcmVmW19pXTtcbiAgICAgIHBhcnNlci5hZGRfbm9kZShjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucGFyc2VkO1xuICB9O1xuXG4gIHRoaXMuU2VsZWN0UGFyc2VyID0gU2VsZWN0UGFyc2VyO1xuXG4vLyBPcmlnaW9uYWwgLSAndGhpcycgIT09ICd3aW5kb3cnIGluIGJyb3dzZXJpZnlcbi8vfSkuY2FsbCh0aGlzKTtcblxuLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxufSkuY2FsbCh3aW5kb3cpO1xuXG4vKlxuQ2hvc2VuIHNvdXJjZTogZ2VuZXJhdGUgb3V0cHV0IHVzaW5nICdjYWtlIGJ1aWxkJ1xuQ29weXJpZ2h0IChjKSAyMDExIGJ5IEhhcnZlc3RcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQWJzdHJhY3RDaG9zZW4sIHJvb3Q7XG5cbiAgcm9vdCA9IHRoaXM7XG5cbiAgQWJzdHJhY3RDaG9zZW4gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBPcmlnaW9uYWwgLSBZb3UgY2FuJ3QgYXNzaWduIHRvIGZ1bmN0aW9ucyBsaWtlIHRoaXMgaW4gc3RyaWN0IG1vZGUuXG4gICAgLy9BYnN0cmFjdENob3Nlbi5uYW1lID0gJ0Fic3RyYWN0Q2hvc2VuJztcblxuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2hvc2VuKGZvcm1fZmllbGQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZCA9IGZvcm1fZmllbGQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3ZhbHVlcygpO1xuICAgICAgdGhpcy5pc19tdWx0aXBsZSA9IHRoaXMuZm9ybV9maWVsZC5tdWx0aXBsZTtcbiAgICAgIHRoaXMuc2V0X2RlZmF1bHRfdGV4dCgpO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgICAgdGhpcy5zZXRfdXBfaHRtbCgpO1xuICAgICAgdGhpcy5yZWdpc3Rlcl9vYnNlcnZlcnMoKTtcbiAgICAgIHRoaXMuZmluaXNoX3NldHVwKCk7XG4gICAgfVxuXG4gICAgLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5uYW1lID0gJ0Fic3RyYWN0Q2hvc2VuJztcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZXRfZGVmYXVsdF92YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50ZXN0X2FjdGl2ZV9jbGljayhldnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZhdGVfYWN0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hY3RpdmF0ZV9maWVsZChldnQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXN1bHRzX3Nob3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCA9IG51bGw7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA9ICh0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0ICE9IG51bGwpXG5cdFx0XHQgICYmICh0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXSAhPSBudWxsKVxuXHRcdFx0ICAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vaGFydmVzdGhxL2Nob3Nlbi9pc3N1ZXMvMjEyNVxuXHRcdFx0ICAmJiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS50ZXh0Lm1hdGNoKC9eXFxzKiQvZylcblx0XHRcdFx0PyB0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0XG5cdFx0XHRcdDogZmFsc2U7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoX3RocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgfHwgMDtcbiAgICAgIHRoaXMuZGlzYWJsZV9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2ggfHwgZmFsc2U7XG4gICAgICB0aGlzLnNlYXJjaF9jb250YWlucyA9IHRoaXMub3B0aW9ucy5zZWFyY2hfY29udGFpbnMgfHwgZmFsc2U7XG4gICAgICB0aGlzLmNob2ljZXMgPSAwO1xuICAgICAgdGhpcy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgPSB0aGlzLm9wdGlvbnMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMubWF4X3NlbGVjdGVkX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMubWF4X3NlbGVjdGVkX29wdGlvbnMgfHwgSW5maW5pdHk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZXRfZGVmYXVsdF90ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLmZvcm1fZmllbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZWhvbGRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0X211bHRpcGxlIHx8IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0IHx8IFwiU2VsZWN0IFNvbWUgT3B0aW9uc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dF9zaW5nbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHQgfHwgXCJTZWxlY3QgYW4gT3B0aW9uXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX25vbmVfZm91bmQgPSB0aGlzLmZvcm1fZmllbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS1ub19yZXN1bHRzX3RleHRcIikgfHwgdGhpcy5vcHRpb25zLm5vX3Jlc3VsdHNfdGV4dCB8fCBcIk5vIHJlc3VsdHMgbWF0Y2hcIjtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2VudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSB0cnVlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUubW91c2VfbGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5wdXRfZm9jdXMgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oKTtcbiAgICAgICAgICB9KSwgNTApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVfZmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5wdXRfYmx1ciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5tb3VzZV9vbl9jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5ibHVyX3Rlc3QoKTtcbiAgICAgICAgfSksIDEwMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfYWRkX29wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgdmFyIGNsYXNzZXMsIHN0eWxlO1xuICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgb3B0aW9uLmRvbV9pZCA9IHRoaXMuY29udGFpbmVyX2lkICsgXCJfb19cIiArIG9wdGlvbi5hcnJheV9pbmRleDtcbiAgICAgICAgY2xhc3NlcyA9IG9wdGlvbi5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlID8gW10gOiBbXCJhY3RpdmUtcmVzdWx0XCJdO1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVzdWx0LXNlbGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChcImdyb3VwLW9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uLmNsYXNzZXMgIT09IFwiXCIpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2gob3B0aW9uLmNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb3B0aW9uLnN0eWxlLmNzc1RleHQgIT09IFwiXCIgPyBcIiBzdHlsZT1cXFwiXCIgKyBvcHRpb24uc3R5bGUgKyBcIlxcXCJcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiAnPGxpIGlkPVwiJyArIG9wdGlvbi5kb21faWQgKyAnXCIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgc3R5bGUgKyAnPicgKyBvcHRpb24uaHRtbCArICc8L2xpPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfdXBkYXRlX2ZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRzX3Jlc2V0X2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgdGhpcy5yZXN1bHRfc2luZ2xlX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfYnVpbGQoKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfdG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfc2VhcmNoID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lubm93X3Jlc3VsdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUua2V5dXBfY2hlY2tlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHN0cm9rZSwgX3JlZjtcbiAgICAgIHN0cm9rZSA9IChfcmVmID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZiA6IGV2dC5rZXlDb2RlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHN3aXRjaCAoc3Ryb2tlKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmJhY2tzdHJva2VfbGVuZ3RoIDwgMSAmJiB0aGlzLmNob2ljZXMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9zZWxlY3QoZXZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDkxOlxuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2VhcmNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5nZW5lcmF0ZV9maWVsZF9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld19pZDtcbiAgICAgIG5ld19pZCA9IHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2lkKCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGQuaWQgPSBuZXdfaWQ7XG4gICAgICByZXR1cm4gbmV3X2lkO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuZ2VuZXJhdGVfcmFuZG9tX2NoYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFycywgbmV3Y2hhciwgcmFuZDtcbiAgICAgIGNoYXJzID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcbiAgICAgIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld2NoYXIgPSBjaGFycy5zdWJzdHJpbmcocmFuZCwgcmFuZCArIDEpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWJzdHJhY3RDaG9zZW47XG5cbiAgfSkoKTtcblxuICByb290LkFic3RyYWN0Q2hvc2VuID0gQWJzdHJhY3RDaG9zZW47XG5cbi8vIE9yaWdpb25hbCAtICd0aGlzJyAhPT0gJ3dpbmRvdycgaW4gYnJvd3NlcmlmeVxuLy99KS5jYWxsKHRoaXMpO1xuXG4vLyBTaWx2ZXJTdHJpcGUgY3VzdG9tXG59KS5jYWxsKHdpbmRvdyk7XG5cbi8qXG5DaG9zZW4gc291cmNlOiBnZW5lcmF0ZSBvdXRwdXQgdXNpbmcgJ2Nha2UgYnVpbGQnXG5Db3B5cmlnaHQgKGMpIDIwMTEgYnkgSGFydmVzdFxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciAkLCBDaG9zZW4sIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nLCByb290LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3I7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICByb290ID0gdGhpcztcblxuICAkID0galF1ZXJ5O1xuXG4gICQuZm4uZXh0ZW5kKHtcbiAgICBjaG9zZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICgkLmJyb3dzZXIubXNpZSAmJiAoJC5icm93c2VyLnZlcnNpb24gPT09IFwiNi4wXCIgfHwgKCQuYnJvd3Nlci52ZXJzaW9uID09PSBcIjcuMFwiICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gNykpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbnB1dF9maWVsZCkge1xuICAgICAgICB2YXIgJHRoaXM7XG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgaWYgKCEkdGhpcy5oYXNDbGFzcyhcImNoem4tZG9uZVwiKSkge1xuICAgICAgICAgIHJldHVybiAkdGhpcy5kYXRhKCdjaG9zZW4nLCBuZXcgQ2hvc2VuKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBDaG9zZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cbiAgICBfX2V4dGVuZHMoQ2hvc2VuLCBfc3VwZXIpO1xuXG4gICAgLy8gT3JpZ2lvbmFsIC0gWW91IGNhbid0IGFzc2lnbiB0byBmdW5jdGlvbnMgbGlrZSB0aGlzIGluIHN0cmljdCBtb2RlLlxuICAgIC8vQ2hvc2VuLm5hbWUgPSAnQ2hvc2VuJztcblxuICAgIGZ1bmN0aW9uIENob3NlbigpIHtcbiAgICAgIHJldHVybiBDaG9zZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxuICAgIENob3Nlbi5wcm90b3R5cGUubmFtZSA9ICdDaG9zZW4nO1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxID0gJCh0aGlzLmZvcm1fZmllbGQpO1xuICAgICAgdGhpcy5jdXJyZW50X3ZhbHVlID0gdGhpcy5mb3JtX2ZpZWxkX2pxLnZhbCgpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNfcnRsID0gdGhpcy5mb3JtX2ZpZWxkX2pxLmhhc0NsYXNzKFwiY2h6bi1ydGxcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuZmluaXNoX3NldHVwID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtX2ZpZWxkX2pxLmFkZENsYXNzKFwiY2h6bi1kb25lXCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNldF91cF9odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGFpbmVyX2RpdiwgZGRfdG9wLCBkZF93aWR0aCwgcmlzZSwgc2Zfd2lkdGg7XG4gICAgICB0aGlzLmNvbnRhaW5lcl9pZCA9IHRoaXMuZm9ybV9maWVsZC5pZC5sZW5ndGggPyB0aGlzLmZvcm1fZmllbGQuaWQucmVwbGFjZSgvKDp8XFwuKS9nLCAnXycpIDogdGhpcy5nZW5lcmF0ZV9maWVsZF9pZCgpO1xuICAgICAgdGhpcy5jb250YWluZXJfaWQgKz0gXCJfY2h6blwiO1xuICAgICAgdGhpcy5mX3dpZHRoID0gdGhpcy5mb3JtX2ZpZWxkX2pxLm91dGVyV2lkdGgoKTtcbiAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5mb3JtX2ZpZWxkX2pxLmRhdGEoJ3BsYWNlaG9sZGVyJykgPyB0aGlzLmZvcm1fZmllbGRfanEuZGF0YSgncGxhY2Vob2xkZXInKSA6IHRoaXMuZGVmYXVsdF90ZXh0X2RlZmF1bHQ7XG4gICAgICBjb250YWluZXJfZGl2ID0gJChcIjxkaXYgLz5cIiwge1xuICAgICAgICBpZDogdGhpcy5jb250YWluZXJfaWQsXG4gICAgICAgIFwiY2xhc3NcIjogXCJjaHpuLWNvbnRhaW5lclwiICsgKHRoaXMuaXNfcnRsID8gJyBjaHpuLXJ0bCcgOiAnJyksXG4gICAgICAgIHN0eWxlOiAnd2lkdGg6ICcgKyAodGhpcy5vcHRpb25zLndpZHRoIHx8IHRoaXMuZl93aWR0aCkgKyAncHg7J1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBjb250YWluZXJfZGl2Lmh0bWwoJzx1bCBjbGFzcz1cImNoem4tY2hvaWNlc1wiPjxsaSBjbGFzcz1cInNlYXJjaC1maWVsZFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPVwiJyArIHRoaXMuZGVmYXVsdF90ZXh0ICsgJ1wiIGNsYXNzPVwiZGVmYXVsdFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIHN0eWxlPVwid2lkdGg6MjVweDtcIiAvPjwvbGk+PC91bD48ZGl2IGNsYXNzPVwiY2h6bi1kcm9wXCIgc3R5bGU9XCJsZWZ0Oi05MDAwcHg7XCI+PHVsIGNsYXNzPVwiY2h6bi1yZXN1bHRzXCI+PC91bD48L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lcl9kaXYuaHRtbCgnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiY2h6bi1zaW5nbGUgY2h6bi1kZWZhdWx0XCIgdGFiaW5kZXg9XCItMVwiPjxzcGFuPicgKyB0aGlzLmRlZmF1bHRfdGV4dCArICc8L3NwYW4+PGRpdj48Yj48L2I+PC9kaXY+PC9hPjxkaXYgY2xhc3M9XCJjaHpuLWRyb3BcIiBzdHlsZT1cImxlZnQ6LTkwMDBweDtcIj48ZGl2IGNsYXNzPVwiY2h6bi1zZWFyY2hcIj48aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiAvPjwvZGl2Pjx1bCBjbGFzcz1cImNoem4tcmVzdWx0c1wiPjwvdWw+PC9kaXY+Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuaGlkZSgpLmFmdGVyKGNvbnRhaW5lcl9kaXYpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSAkKCcjJyArIHRoaXMuY29udGFpbmVyX2lkKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2h6bi1jb250YWluZXItXCIgKyAodGhpcy5pc19tdWx0aXBsZSA/IFwibXVsdGlcIiA6IFwic2luZ2xlXCIpKTtcbiAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2h6bi1kcm9wJykuZmlyc3QoKTtcbiAgICAgIC8qXG4gICAgICAgICAgICBDQUxMIENVU1RPTSBGVU5DVElPTjogcmlzZV91cFxuICAgICAgICAgICAgICAjIGlmIHJpc2UtdXAgdHJ1ZSwgcmV2ZXJzZSBkcm9wLXVwIGRpcmVjdGlvblxuICAgICAgKi9cblxuICAgICAgcmlzZSA9IHRoaXMucmlzZV91cCh0aGlzLmNvbnRhaW5lciwgdGhpcy5kcm9wZG93bik7XG4gICAgICBkZF90b3AgPSByaXNlID8gLXRoaXMuY29udGFpbmVyLmZpbmQoJy5jaHpuLWRyb3AnKS5oZWlnaHQoKSA6IHRoaXMuY29udGFpbmVyLmhlaWdodCgpO1xuICAgICAgZGRfd2lkdGggPSB0aGlzLmNvbnRhaW5lci53aWR0aCgpIC0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcodGhpcy5kcm9wZG93bik7XG4gICAgICB0aGlzLmRyb3Bkb3duLmNzcyh7XG4gICAgICAgIFwid2lkdGhcIjogZGRfd2lkdGggKyBcInB4XCIsXG4gICAgICAgIFwidG9wXCI6IGRkX3RvcCArIFwicHhcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZCA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0JykuZmlyc3QoKTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCd1bC5jaHpuLXJlc3VsdHMnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHRoaXMuc2VhcmNoX25vX3Jlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdsaS5uby1yZXN1bHRzJykuZmlyc3QoKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2Nob2ljZXMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCd1bC5jaHpuLWNob2ljZXMnKS5maXJzdCgpO1xuICAgICAgICB0aGlzLnNlYXJjaF9jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdsaS5zZWFyY2gtZmllbGQnKS5maXJzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIuZmluZCgnZGl2LmNoem4tc2VhcmNoJykuZmlyc3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtID0gdGhpcy5jb250YWluZXIuZmluZCgnLmNoem4tc2luZ2xlJykuZmlyc3QoKTtcbiAgICAgICAgc2Zfd2lkdGggPSBkZF93aWR0aCAtIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nKHRoaXMuc2VhcmNoX2NvbnRhaW5lcikgLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLnNlYXJjaF9maWVsZCk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmNzcyh7XG4gICAgICAgICAgXCJ3aWR0aFwiOiBzZl93aWR0aCArIFwicHhcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgdGhpcy5zZXRfdGFiX2luZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJsaXN6dDpyZWFkeVwiLCB7XG4gICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVnaXN0ZXJfb2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5jb250YWluZXIubW91c2Vkb3duKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29udGFpbmVyX21vdXNlZG93bihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5tb3VzZXVwKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29udGFpbmVyX21vdXNldXAoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIubW91c2VlbnRlcihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm1vdXNlX2VudGVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNlbGVhdmUoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tb3VzZV9sZWF2ZShldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLm1vdXNldXAoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMubW91c2VvdmVyKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdmVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMubW91c2VvdXQoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZW91dChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuYmluZChcImxpc3p0OnVwZGF0ZWRcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXN1bHRzX3VwZGF0ZV9maWVsZChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuYmluZChcImxpc3p0OmFjdGl2YXRlXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJsaXN6dDpvcGVuXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29udGFpbmVyX21vdXNlZG93bihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5ibHVyKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaW5wdXRfYmx1cihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5rZXl1cChmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmtleXVwX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQua2V5ZG93bihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmtleWRvd25fY2hlY2tlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cyhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmlucHV0X2ZvY3VzKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9jaG9pY2VzLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jaG9pY2VzX2NsaWNrKGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX2ZpZWxkX2Rpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzX2Rpc2FibGVkID0gdGhpcy5mb3JtX2ZpZWxkX2pxWzBdLmRpc2FibGVkO1xuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Noem4tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0udW5iaW5kKFwiZm9jdXNcIiwgdGhpcy5hY3RpdmF0ZV9hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY2h6bi1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZFswXS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmJpbmQoXCJmb2N1c1wiLCB0aGlzLmFjdGl2YXRlX2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jb250YWluZXJfbW91c2Vkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgdGFyZ2V0X2Nsb3NlbGluaztcbiAgICAgIGlmICghdGhpcy5pc19kaXNhYmxlZCkge1xuICAgICAgICB0YXJnZXRfY2xvc2VsaW5rID0gZXZ0ICE9IG51bGwgPyAoJChldnQudGFyZ2V0KSkuaGFzQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWNsb3NlXCIpIDogZmFsc2U7XG4gICAgICAgIGlmIChldnQgJiYgZXZ0LnR5cGUgPT09IFwibW91c2Vkb3duXCIgJiYgIXRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nX2Rlc3Ryb3lfY2xpY2sgJiYgIXRhcmdldF9jbG9zZWxpbmspIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKGRvY3VtZW50KS5jbGljayh0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19tdWx0aXBsZSAmJiBldnQgJiYgKCgkKGV2dC50YXJnZXQpWzBdID09PSB0aGlzLnNlbGVjdGVkX2l0ZW1bMF0pIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcImEuY2h6bi1zaW5nbGVcIikubGVuZ3RoKSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfdG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19kZXN0cm95X2NsaWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jb250YWluZXJfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKGV2dC50YXJnZXQubm9kZU5hbWUgPT09IFwiQUJCUlwiICYmICF0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfcmVzZXQoZXZ0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5ibHVyX3Rlc3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICghdGhpcy5hY3RpdmVfZmllbGQgJiYgdGhpcy5jb250YWluZXIuaGFzQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1hY3RpdmVcIikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VfZmllbGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbG9zZV9maWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgJChkb2N1bWVudCkudW5iaW5kKFwiY2xpY2tcIiwgdGhpcy5jbGlja190ZXN0X2FjdGlvbik7XG4gICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmF0dHIoXCJ0YWJpbmRleFwiLCB0aGlzLnNlYXJjaF9maWVsZC5hdHRyKFwidGFiaW5kZXhcIikpO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC5hdHRyKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNoem4tY29udGFpbmVyLWFjdGl2ZVwiKTtcbiAgICAgIHRoaXMud2lubm93X3Jlc3VsdHNfY2xlYXIoKTtcbiAgICAgIHRoaXMuY2xlYXJfYmFja3N0cm9rZSgpO1xuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5hY3RpdmF0ZV9maWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IHRydWU7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUudGVzdF9hY3RpdmVfY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICgkKGV2dC50YXJnZXQpLnBhcmVudHMoJyMnICsgdGhpcy5jb250YWluZXJfaWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVfZmllbGQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VfZmllbGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX2J1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGVudCwgZGF0YSwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5yZXN1bHRzX2RhdGEgPSByb290LlNlbGVjdFBhcnNlci5zZWxlY3RfdG9fYXJyYXkodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlcyA+IDApIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcy5maW5kKFwibGkuc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jaG9pY2VzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2h6bi1kZWZhdWx0XCIpLmZpbmQoXCJzcGFuXCIpLnRleHQodGhpcy5kZWZhdWx0X3RleHQpO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlX3NlYXJjaCB8fCB0aGlzLmZvcm1fZmllbGQub3B0aW9ucy5sZW5ndGggPD0gdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNoem4tY29udGFpbmVyLXNpbmdsZS1ub3NlYXJjaFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNoem4tY29udGFpbmVyLXNpbmdsZS1ub3NlYXJjaFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGVudCA9ICcnO1xuICAgICAgX3JlZiA9IHRoaXMucmVzdWx0c19kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRhdGEgPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGRhdGEuZ3JvdXApIHtcbiAgICAgICAgICBjb250ZW50ICs9IHRoaXMucmVzdWx0X2FkZF9ncm91cChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YS5lbXB0eSkge1xuICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5yZXN1bHRfYWRkX29wdGlvbihkYXRhKTtcbiAgICAgICAgICBpZiAoZGF0YS5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNoem4tZGVmYXVsdFwiKS5maW5kKFwic3BhblwiKS50ZXh0KGRhdGEudGV4dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaW5nbGVfZGVzZWxlY3RfY29udHJvbF9idWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfZGlzYWJsZWQoKTtcbiAgICAgIHRoaXMuc2hvd19zZWFyY2hfZmllbGRfZGVmYXVsdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuaHRtbChjb250ZW50KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfYWRkX2dyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIGlmICghZ3JvdXAuZGlzYWJsZWQpIHtcbiAgICAgICAgZ3JvdXAuZG9tX2lkID0gdGhpcy5jb250YWluZXJfaWQgKyBcIl9nX1wiICsgZ3JvdXAuYXJyYXlfaW5kZXg7XG4gICAgICAgIHJldHVybiAnPGxpIGlkPVwiJyArIGdyb3VwLmRvbV9pZCArICdcIiBjbGFzcz1cImdyb3VwLXJlc3VsdFwiPicgKyAkKFwiPGRpdiAvPlwiKS50ZXh0KGdyb3VwLmxhYmVsKS5odG1sKCkgKyAnPC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2RvX2hpZ2hsaWdodCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgaGlnaF9ib3R0b20sIGhpZ2hfdG9wLCBtYXhIZWlnaHQsIHZpc2libGVfYm90dG9tLCB2aXNpYmxlX3RvcDtcbiAgICAgIGlmIChlbC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IGVsO1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQuYWRkQ2xhc3MoXCJoaWdobGlnaHRlZFwiKTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5zZWFyY2hfcmVzdWx0cy5jc3MoXCJtYXhIZWlnaHRcIiksIDEwKTtcbiAgICAgICAgdmlzaWJsZV90b3AgPSB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICB2aXNpYmxlX2JvdHRvbSA9IG1heEhlaWdodCArIHZpc2libGVfdG9wO1xuICAgICAgICBoaWdoX3RvcCA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodC5wb3NpdGlvbigpLnRvcCArIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKCk7XG4gICAgICAgIGhpZ2hfYm90dG9tID0gaGlnaF90b3AgKyB0aGlzLnJlc3VsdF9oaWdobGlnaHQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgaWYgKGhpZ2hfYm90dG9tID49IHZpc2libGVfYm90dG9tKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKChoaWdoX2JvdHRvbSAtIG1heEhlaWdodCkgPiAwID8gaGlnaF9ib3R0b20gLSBtYXhIZWlnaHQgOiAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChoaWdoX3RvcCA8IHZpc2libGVfdG9wKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKGhpZ2hfdG9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LnJlbW92ZUNsYXNzKFwiaGlnaGxpZ2h0ZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Nob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZF90b3AsIGRkX3dpZHRoLCByaXNlO1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5hZGRDbGFzcyhcImNoem4tc2luZ2xlLXdpdGgtZHJvcFwiKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodCh0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZF93aWR0aCA9IHRoaXMuY29udGFpbmVyLndpZHRoKCkgLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLmRyb3Bkb3duKTtcbiAgICAgIC8qXG4gICAgICAgICAgICBDQUxMIENVU1RPTSBGVU5DVElPTjogcmlzZV91cFxuICAgICAgICAgICAgICAjIGlmIHJpc2UtdXAgdHJ1ZSwgcmV2ZXJzZSBkcm9wLXVwIGRpcmVjdGlvblxuICAgICAgKi9cblxuICAgICAgcmlzZSA9IHRoaXMucmlzZV91cCh0aGlzLmNvbnRhaW5lciwgdGhpcy5kcm9wZG93bik7XG4gICAgICBkZF90b3AgPSByaXNlID8gLXRoaXMuY29udGFpbmVyLmZpbmQoJy5jaHpuLWRyb3AnKS5oZWlnaHQoKSA6IHRoaXMuaXNfbXVsdGlwbGUgPyB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKSA6IHRoaXMuY29udGFpbmVyLmhlaWdodCgpIC0gMTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwibGlzenQ6c2hvd2luZ19kcm9wZG93blwiLCB7XG4gICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRyb3Bkb3duLmNzcyh7XG4gICAgICAgIFwidG9wXCI6IGRkX3RvcCArIFwicHhcIixcbiAgICAgICAgXCJsZWZ0XCI6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXN1bHRzX3Nob3dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuY3NzKCd3aWR0aCcsIChkZF93aWR0aCAtIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nKHRoaXMuc2VhcmNoX2NvbnRhaW5lcikgLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLnNlYXJjaF9maWVsZCkpICsgJ3B4Jyk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKTtcbiAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLnJlbW92ZUNsYXNzKFwiY2h6bi1zaW5nbGUtd2l0aC1kcm9wXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImxpc3p0OmhpZGluZ19kcm9wZG93blwiLCB7XG4gICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRyb3Bkb3duLmNzcyh7XG4gICAgICAgIFwibGVmdFwiOiBcIi05MDAwcHhcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3dpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZXRfdGFiX2luZGV4ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciB0aTtcbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGRfanEuYXR0cihcInRhYmluZGV4XCIpKSB7XG4gICAgICAgIHRpID0gdGhpcy5mb3JtX2ZpZWxkX2pxLmF0dHIoXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmF0dHIoXCJ0YWJpbmRleFwiLCAtMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hdHRyKFwidGFiaW5kZXhcIiwgdGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlcyA8IDEgJiYgIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hZGRDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5yZW1vdmVDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHRhcmdldCA9ICQoZXZ0LnRhcmdldCkuaGFzQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpID8gJChldnQudGFyZ2V0KSA6ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c19tb3VzZW92ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKSA/ICQoZXZ0LnRhcmdldCkgOiAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICgkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cygnLmFjdGl2ZS1yZXN1bHQnKS5maXJzdCgpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlc19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVfZmllbGQgJiYgISgkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwic2VhcmNoLWNob2ljZVwiIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cygnLnNlYXJjaC1jaG9pY2UnKS5maXJzdCkpICYmICF0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jaG9pY2VfYnVpbGQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB2YXIgY2hvaWNlX2lkLCBodG1sLCBsaW5rLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBjaG9pY2VfaWQgPSB0aGlzLmNvbnRhaW5lcl9pZCArIFwiX2NfXCIgKyBpdGVtLmFycmF5X2luZGV4O1xuICAgICAgdGhpcy5jaG9pY2VzICs9IDE7XG4gICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICBodG1sID0gJzxsaSBjbGFzcz1cInNlYXJjaC1jaG9pY2Ugc2VhcmNoLWNob2ljZS1kaXNhYmxlZFwiIGlkPVwiJyArIGNob2ljZV9pZCArICdcIj48c3Bhbj4nICsgaXRlbS5odG1sICsgJzwvc3Bhbj48L2xpPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gJzxsaSBjbGFzcz1cInNlYXJjaC1jaG9pY2VcIiBpZD1cIicgKyBjaG9pY2VfaWQgKyAnXCI+PHNwYW4+JyArIGl0ZW0uaHRtbCArICc8L3NwYW4+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwic2VhcmNoLWNob2ljZS1jbG9zZVwiIHJlbD1cIicgKyBpdGVtLmFycmF5X2luZGV4ICsgJ1wiPjwvYT48L2xpPic7XG4gICAgICB9XG4gICAgICB0aGlzLnNlYXJjaF9jb250YWluZXIuYmVmb3JlKGh0bWwpO1xuICAgICAgbGluayA9ICQoJyMnICsgY2hvaWNlX2lkKS5maW5kKFwiYVwiKS5maXJzdCgpO1xuICAgICAgcmV0dXJuIGxpbmsuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaG9pY2VfZGVzdHJveV9saW5rX2NsaWNrKGV2dCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jaG9pY2VfZGVzdHJveV9saW5rX2NsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghdGhpcy5pc19kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfZGVzdHJveV9jbGljayA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmNob2ljZV9kZXN0cm95KCQoZXZ0LnRhcmdldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2dC5zdG9wUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3kgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfZGVzZWxlY3QobGluay5hdHRyKFwicmVsXCIpKSkge1xuICAgICAgICB0aGlzLmNob2ljZXMgLT0gMTtcbiAgICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlcyA+IDAgJiYgdGhpcy5zZWFyY2hfZmllbGQudmFsKCkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmsucGFyZW50cygnbGknKS5maXJzdCgpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS50ZXh0KHRoaXMuZGVmYXVsdF90ZXh0KTtcbiAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uYWRkQ2xhc3MoXCJjaHpuLWRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Jlc2V0X2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudF92YWx1ZSA9IHRoaXMuZm9ybV9maWVsZF9qcS52YWwoKTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcImFiYnJcIikucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X3NlbGVjdCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGhpZ2gsIGhpZ2hfaWQsIGl0ZW0sIHBvc2l0aW9uO1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBoaWdoID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0O1xuICAgICAgICBoaWdoX2lkID0gaGlnaC5hdHRyKFwiaWRcIik7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RlYWN0aXZhdGUoaGlnaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLnJlc3VsdC1zZWxlY3RlZFwiKS5yZW1vdmVDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQgPSBoaWdoO1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNoem4tZGVmYXVsdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBoaWdoLmFkZENsYXNzKFwicmVzdWx0LXNlbGVjdGVkXCIpO1xuICAgICAgICBwb3NpdGlvbiA9IGhpZ2hfaWQuc3Vic3RyKGhpZ2hfaWQubGFzdEluZGV4T2YoXCJfXCIpICsgMSk7XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NpdGlvbl07XG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tpdGVtLm9wdGlvbnNfaW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcInNwYW5cIikuZmlyc3QoKS50ZXh0KGl0ZW0udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGV2dC5tZXRhS2V5ICYmIHRoaXMuaXNfbXVsdGlwbGUpKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlIHx8IHRoaXMuZm9ybV9maWVsZF9qcS52YWwoKSAhPT0gdGhpcy5jdXJyZW50X3ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbaXRlbS5vcHRpb25zX2luZGV4XS52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudF92YWx1ZSA9IHRoaXMuZm9ybV9maWVsZF9qcS52YWwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2FjdGl2YXRlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5hZGRDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2RlYWN0aXZhdGUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLnJlbW92ZUNsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfZGVzZWxlY3QgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciByZXN1bHQsIHJlc3VsdF9kYXRhO1xuICAgICAgcmVzdWx0X2RhdGEgPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NdO1xuICAgICAgaWYgKCF0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICByZXN1bHRfZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQgPSAkKFwiI1wiICsgdGhpcy5jb250YWluZXJfaWQgKyBcIl9vX1wiICsgcG9zKTtcbiAgICAgICAgcmVzdWx0LnJlbW92ZUNsYXNzKFwicmVzdWx0LXNlbGVjdGVkXCIpLmFkZENsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKS5zaG93KCk7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcbiAgICAgICAgICBkZXNlbGVjdGVkOiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2luZ2xlX2Rlc2VsZWN0X2NvbnRyb2xfYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCAmJiB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcImFiYnJcIikubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuYWZ0ZXIoXCI8YWJiciBjbGFzcz1cXFwic2VhcmNoLWNob2ljZS1jbG9zZVxcXCI+PC9hYmJyPlwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS53aW5ub3dfcmVzdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZvdW5kLCBvcHRpb24sIHBhcnQsIHBhcnRzLCByZWdleCwgcmVnZXhBbmNob3IsIHJlc3VsdCwgcmVzdWx0X2lkLCByZXN1bHRzLCBzZWFyY2hUZXh0LCBzdGFydHBvcywgdGV4dCwgenJlZ2V4LCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmO1xuICAgICAgdGhpcy5ub19yZXN1bHRzX2NsZWFyKCk7XG4gICAgICByZXN1bHRzID0gMDtcbiAgICAgIHNlYXJjaFRleHQgPSB0aGlzLnNlYXJjaF9maWVsZC52YWwoKSA9PT0gdGhpcy5kZWZhdWx0X3RleHQgPyBcIlwiIDogJCgnPGRpdi8+JykudGV4dCgkLnRyaW0odGhpcy5zZWFyY2hfZmllbGQudmFsKCkpKS5odG1sKCk7XG4gICAgICByZWdleEFuY2hvciA9IHRoaXMuc2VhcmNoX2NvbnRhaW5zID8gXCJcIiA6IFwiXlwiO1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4QW5jaG9yICsgc2VhcmNoVGV4dC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIiksICdpJyk7XG4gICAgICB6cmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpLCAnaScpO1xuICAgICAgX3JlZiA9IHRoaXMucmVzdWx0c19kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoIW9wdGlvbi5kaXNhYmxlZCAmJiAhb3B0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgaWYgKG9wdGlvbi5ncm91cCkge1xuICAgICAgICAgICAgJCgnIycgKyBvcHRpb24uZG9tX2lkKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISh0aGlzLmlzX211bHRpcGxlICYmIG9wdGlvbi5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHRfaWQgPSBvcHRpb24uZG9tX2lkO1xuICAgICAgICAgICAgcmVzdWx0ID0gJChcIiNcIiArIHJlc3VsdF9pZCk7XG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChvcHRpb24uaHRtbCkpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXN1bHRzICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5odG1sLmluZGV4T2YoXCIgXCIpID49IDAgfHwgb3B0aW9uLmh0bWwuaW5kZXhPZihcIltcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgcGFydHMgPSBvcHRpb24uaHRtbC5yZXBsYWNlKC9cXFt8XFxdL2csIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHBhcnRzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW19qXTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyArPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIGlmIChzZWFyY2hUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0cG9zID0gb3B0aW9uLmh0bWwuc2VhcmNoKHpyZWdleCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9wdGlvbi5odG1sLnN1YnN0cigwLCBzdGFydHBvcyArIHNlYXJjaFRleHQubGVuZ3RoKSArICc8L2VtPicgKyBvcHRpb24uaHRtbC5zdWJzdHIoc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIHN0YXJ0cG9zKSArICc8ZW0+JyArIHRleHQuc3Vic3RyKHN0YXJ0cG9zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3B0aW9uLmh0bWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0Lmh0bWwodGV4dCk7XG4gICAgICAgICAgICAgIHRoaXMucmVzdWx0X2FjdGl2YXRlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICQoXCIjXCIgKyB0aGlzLnJlc3VsdHNfZGF0YVtvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXhdLmRvbV9pZCkuY3NzKCdkaXNwbGF5JywgJ2xpc3QtaXRlbScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0ICYmIHJlc3VsdF9pZCA9PT0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmF0dHIoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnJlc3VsdF9kZWFjdGl2YXRlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0cyA8IDEgJiYgc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9fcmVzdWx0cyhzZWFyY2hUZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS53aW5ub3dfcmVzdWx0c19jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpLCBsaXMsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbChcIlwiKTtcbiAgICAgIGxpcyA9IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcImxpXCIpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbGlzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGxpID0gbGlzW19pXTtcbiAgICAgICAgbGkgPSAkKGxpKTtcbiAgICAgICAgaWYgKGxpLmhhc0NsYXNzKFwiZ3JvdXAtcmVzdWx0XCIpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChsaS5jc3MoJ2Rpc3BsYXknLCAnYXV0bycpKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19tdWx0aXBsZSB8fCAhbGkuaGFzQ2xhc3MoXCJyZXN1bHQtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMucmVzdWx0X2FjdGl2YXRlKGxpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHNfc2V0X2hpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRvX2hpZ2gsIHNlbGVjdGVkX3Jlc3VsdHM7XG4gICAgICBpZiAoIXRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBzZWxlY3RlZF9yZXN1bHRzID0gIXRoaXMuaXNfbXVsdGlwbGUgPyB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIucmVzdWx0LXNlbGVjdGVkLmFjdGl2ZS1yZXN1bHRcIikgOiBbXTtcbiAgICAgICAgZG9faGlnaCA9IHNlbGVjdGVkX3Jlc3VsdHMubGVuZ3RoID8gc2VsZWN0ZWRfcmVzdWx0cy5maXJzdCgpIDogdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgICAgaWYgKGRvX2hpZ2ggIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQoZG9faGlnaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5ub19yZXN1bHRzID0gZnVuY3Rpb24odGVybXMpIHtcbiAgICAgIHZhciBub19yZXN1bHRzX2h0bWw7XG4gICAgICBub19yZXN1bHRzX2h0bWwgPSAkKCc8bGkgY2xhc3M9XCJuby1yZXN1bHRzXCI+JyArIHRoaXMucmVzdWx0c19ub25lX2ZvdW5kICsgJyBcIjxzcGFuPjwvc3Bhbj5cIjwvbGk+Jyk7XG4gICAgICBub19yZXN1bHRzX2h0bWwuZmluZChcInNwYW5cIikuZmlyc3QoKS5odG1sKHRlcm1zKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmFwcGVuZChub19yZXN1bHRzX2h0bWwpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIubm8tcmVzdWx0c1wiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3RfYWN0aXZlLCBuZXh0X3NpYjtcbiAgICAgIGlmICghdGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIGZpcnN0X2FjdGl2ZSA9IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcImxpLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgICAgaWYgKGZpcnN0X2FjdGl2ZSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodCgkKGZpcnN0X2FjdGl2ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIG5leHRfc2liID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm5leHRBbGwoXCJsaS5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChuZXh0X3NpYikge1xuICAgICAgICAgIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodChuZXh0X3NpYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5dXBfYXJyb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmV2X3NpYnM7XG4gICAgICBpZiAoIXRoaXMucmVzdWx0c19zaG93aW5nICYmICF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgcHJldl9zaWJzID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LnByZXZBbGwoXCJsaS5hY3RpdmUtcmVzdWx0XCIpO1xuICAgICAgICBpZiAocHJldl9zaWJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQocHJldl9zaWJzLmZpcnN0KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmNob2ljZXMgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2JhY2tzdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXh0X2F2YWlsYWJsZV9kZXN0cm95O1xuICAgICAgaWYgKHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY2hvaWNlX2Rlc3Ryb3kodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UuZmluZChcImFcIikuZmlyc3QoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyX2JhY2tzdHJva2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3kgPSB0aGlzLnNlYXJjaF9jb250YWluZXIuc2libGluZ3MoXCJsaS5zZWFyY2gtY2hvaWNlXCIpLmxhc3QoKTtcbiAgICAgICAgaWYgKG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3kubGVuZ3RoICYmICFuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmhhc0NsYXNzKFwic2VhcmNoLWNob2ljZS1kaXNhYmxlZFwiKSkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgICAgICBpZiAodGhpcy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleWRvd25fYmFja3N0cm9rZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UuYWRkQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNsZWFyX2JhY2tzdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZS5yZW1vdmVDbGFzcyhcInNlYXJjaC1jaG9pY2UtZm9jdXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmtleWRvd25fY2hlY2tlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHN0cm9rZSwgX3JlZjtcbiAgICAgIHN0cm9rZSA9IChfcmVmID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZiA6IGV2dC5rZXlDb2RlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIGlmIChzdHJva2UgIT09IDggJiYgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0cm9rZSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgdGhpcy5iYWNrc3Ryb2tlX2xlbmd0aCA9IHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZyAmJiAhdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5rZXl1cF9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIHRoaXMua2V5ZG93bl9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9maWVsZF9zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRkX3RvcCwgZGl2LCBoLCByaXNlLCBzdHlsZSwgc3R5bGVfYmxvY2ssIHN0eWxlcywgdywgX2ksIF9sZW47XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBoID0gMDtcbiAgICAgICAgdyA9IDA7XG4gICAgICAgIHN0eWxlX2Jsb2NrID0gXCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDogLTEwMDBweDsgdG9wOiAtMTAwMHB4OyBkaXNwbGF5Om5vbmU7XCI7XG4gICAgICAgIHN0eWxlcyA9IFsnZm9udC1zaXplJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC13ZWlnaHQnLCAnZm9udC1mYW1pbHknLCAnbGluZS1oZWlnaHQnLCAndGV4dC10cmFuc2Zvcm0nLCAnbGV0dGVyLXNwYWNpbmcnXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzdHlsZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tfaV07XG4gICAgICAgICAgc3R5bGVfYmxvY2sgKz0gc3R5bGUgKyBcIjpcIiArIHRoaXMuc2VhcmNoX2ZpZWxkLmNzcyhzdHlsZSkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBkaXYgPSAkKCc8ZGl2IC8+Jywge1xuICAgICAgICAgICdzdHlsZSc6IHN0eWxlX2Jsb2NrXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYudGV4dCh0aGlzLnNlYXJjaF9maWVsZC52YWwoKSk7XG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQoZGl2KTtcbiAgICAgICAgdyA9IGRpdi53aWR0aCgpICsgMjU7XG4gICAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHcgPiB0aGlzLmZfd2lkdGggLSAxMCkge1xuICAgICAgICAgIHcgPSB0aGlzLmZfd2lkdGggLSAxMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IHcgKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIENBTEwgQ1VTVE9NIEZVTkNUSU9OOiByaXNlX3VwXG4gICAgICAgICAgICAgICAgICAjIGlmIHJpc2UtdXAgdHJ1ZSwgcmV2ZXJzZSBkcm9wLXVwIGRpcmVjdGlvblxuICAgICAgICAqL1xuXG4gICAgICAgIHJpc2UgPSB0aGlzLnJpc2VfdXAodGhpcy5jb250YWluZXIsIHRoaXMuZHJvcGRvd24pO1xuICAgICAgICBkZF90b3AgPSByaXNlID8gLXRoaXMuY29udGFpbmVyLmZpbmQoJy5jaHpuLWRyb3AnKS5oZWlnaHQoKSA6IHRoaXMuY29udGFpbmVyLmhlaWdodCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5jc3Moe1xuICAgICAgICAgIFwidG9wXCI6IGRkX3RvcCArIFwicHhcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5nZW5lcmF0ZV9yYW5kb21faWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBcInNlbFwiICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpICsgdGhpcy5nZW5lcmF0ZV9yYW5kb21fY2hhcigpO1xuICAgICAgd2hpbGUgKCQoXCIjXCIgKyBzdHJpbmcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5nICs9IHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2NoYXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICBTSUxWRVJTVFJJUEUgQ1VTVE9NIEZVTkNUSU9OXG4gICAgICAgIFJpc2VfdXAgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIGRyb3Bkb3duIGV4Y2VlZHMgdGhlIGhlaWdodCBvZiB0aGUgd2luZG93XG4gICAgICAgICAgIyBBZGRzIGNsYXNzIGlmIHRydWUsIHJldHVybnMgdHJ1ZVxuICAgICAgICAgICMgUmVtb3ZlcyBjbGFzcyBpZiBmYWxzZSwgcmV0dXJucyBmYWxzZSBcbiAgICAgICAgVGhpcyBmYWNpbGl0YXRlcyB0aGUgYmVoYXZpb3VyIHdoZXJlIHRoZSBkcm9wLWRvd24gd2lsbCBkcm9wIHVwIGlmIHRoZXJlIGlzIG5vIHJvb20gXG4gICAgICAgIHRvIGRyb3AgZG93blxuICAgICovXG5cblxuICAgIENob3Nlbi5wcm90b3R5cGUucmlzZV91cCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZHJvcGRvd24pIHtcbiAgICAgIHZhciBlbEhlaWdodCwgZWxQb3MsIGVuZE9mV2luZG93LCB0cmlnZ2VyO1xuICAgICAgdHJpZ2dlciA9IGNvbnRhaW5lci5maW5kKCdhLmNoem4tc2luZ2xlJyk7XG4gICAgICBpZiAodHJpZ2dlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVuZE9mV2luZG93ID0gKCQod2luZG93KS5oZWlnaHQoKSArICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKSAtIGNvbnRhaW5lci5maW5kKCdhJykuaW5uZXJIZWlnaHQoKTtcbiAgICAgICAgZWxQb3MgPSB0cmlnZ2VyLm9mZnNldCgpLnRvcDtcbiAgICAgICAgZWxIZWlnaHQgPSBkcm9wZG93bi5pbm5lckhlaWdodCgpO1xuICAgICAgICBpZiAoZWxQb3MgKyBlbEhlaWdodCA+IGVuZE9mV2luZG93ICYmIGVsUG9zIC0gZWxIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKCdjaHpuLXdpdGgtcmlzZScpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDbGFzcygnY2h6bi13aXRoLXJpc2UnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENob3NlbjtcblxuICB9KShBYnN0cmFjdENob3Nlbik7XG5cbiAgZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcgPSBmdW5jdGlvbihlbG10KSB7XG4gICAgdmFyIHNpZGVfYm9yZGVyX3BhZGRpbmc7XG4gICAgcmV0dXJuIHNpZGVfYm9yZGVyX3BhZGRpbmcgPSBlbG10Lm91dGVyV2lkdGgoKSAtIGVsbXQud2lkdGgoKTtcbiAgfTtcblxuICByb290LmdldF9zaWRlX2JvcmRlcl9wYWRkaW5nID0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmc7XG5cbi8vIE9yaWdpb25hbCAtICd0aGlzJyAhPT0gJ3dpbmRvdycgaW4gYnJvd3NlcmlmeVxuLy99KS5jYWxsKHRoaXMpO1xuXG4vLyBTaWx2ZXJTdHJpcGUgY3VzdG9tXG59KS5jYWxsKHdpbmRvdyk7XG4iLCIvKipcbiAqIEhpc3RvcnkuanMgalF1ZXJ5IEFkYXB0ZXJcbiAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAY29weXJpZ2h0IDIwMTAtMjAxMSBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBsaWNlbnNlIE5ldyBCU0QgTGljZW5zZSA8aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvQlNELz5cbiAqL1xuXG4vLyBDbG9zdXJlXG4oZnVuY3Rpb24od2luZG93LHVuZGVmaW5lZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIExvY2FsaXNlIEdsb2JhbHNcblx0dmFyXG5cdFx0SGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5ID0gd2luZG93Lkhpc3Rvcnl8fHt9LFxuXHRcdGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG5cblx0Ly8gQ2hlY2sgRXhpc3RlbmNlXG5cdGlmICggdHlwZW9mIEhpc3RvcnkuQWRhcHRlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIEFkYXB0ZXIgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuLi4nKTtcblx0fVxuXG5cdC8vIEFkZCB0aGUgQWRhcHRlclxuXHRIaXN0b3J5LkFkYXB0ZXIgPSB7XG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLmJpbmQoZWwsZXZlbnQsY2FsbGJhY2spXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBjdXN0b20gYW5kIHN0YW5kYXJkIGV2ZW50c1xuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogQHJldHVybiB7dm9pZH1cblx0XHQgKi9cblx0XHRiaW5kOiBmdW5jdGlvbihlbCxldmVudCxjYWxsYmFjayl7XG5cdFx0XHRqUXVlcnkoZWwpLmJpbmQoZXZlbnQsY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcihlbCxldmVudClcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGN1c3RvbSBhbmQgc3RhbmRhcmQgZXZlbnRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBleHRyYSAtIGEgb2JqZWN0IG9mIGV4dHJhIGV2ZW50IGRhdGEgKG9wdGlvbmFsKVxuXHRcdCAqIEByZXR1cm4ge3ZvaWR9XG5cdFx0ICovXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oZWwsZXZlbnQsZXh0cmEpe1xuXHRcdFx0alF1ZXJ5KGVsKS50cmlnZ2VyKGV2ZW50LGV4dHJhKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLmV4dHJhY3RFdmVudERhdGEoa2V5LGV2ZW50LGV4dHJhKVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBrZXkgZm9yIHRoZSBldmVudCBkYXRhIHRvIGV4dHJhY3Rcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBjdXN0b20gYW5kIHN0YW5kYXJkIGV2ZW50c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZXh0cmEgLSBhIG9iamVjdCBvZiBleHRyYSBldmVudCBkYXRhIChvcHRpb25hbClcblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRleHRyYWN0RXZlbnREYXRhOiBmdW5jdGlvbihrZXksZXZlbnQsZXh0cmEpe1xuXHRcdFx0Ly8galF1ZXJ5IE5hdGl2ZSB0aGVuIGpRdWVyeSBDdXN0b21cblx0XHRcdHZhciByZXN1bHQgPSAoZXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50W2tleV0pIHx8IChleHRyYSAmJiBleHRyYVtrZXldKSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLm9uRG9tTG9hZChjYWxsYmFjaylcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqIEByZXR1cm4ge3ZvaWR9XG5cdFx0ICovXG5cdFx0b25Eb21Mb2FkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0alF1ZXJ5KGNhbGxiYWNrKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gVHJ5IGFuZCBJbml0aWFsaXNlIEhpc3Rvcnlcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRIaXN0b3J5LmluaXQoKTtcblx0fVxuXG59KSh3aW5kb3cpO1xuXG4iLCIvKipcbiAqIEhpc3RvcnkuanMgSFRNTDQgU3VwcG9ydFxuICogRGVwZW5kcyBvbiB0aGUgSFRNTDUgU3VwcG9ydFxuICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAxMC0yMDExIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGxpY2Vuc2UgTmV3IEJTRCBMaWNlbnNlIDxodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9CU0QvPlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csdW5kZWZpbmVkKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2VcblxuXHQvLyBMb2NhbGlzZSBHbG9iYWxzXG5cdHZhclxuXHRcdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LCAvLyBNYWtlIHN1cmUgd2UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IGRvY3VtZW50XG5cdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0fHxzZXRUaW1lb3V0LFxuXHRcdGNsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXR8fGNsZWFyVGltZW91dCxcblx0XHRzZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbHx8c2V0SW50ZXJ2YWwsXG5cdFx0SGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5ID0gd2luZG93Lkhpc3Rvcnl8fHt9OyAvLyBQdWJsaWMgSGlzdG9yeSBPYmplY3RcblxuXHQvLyBDaGVjayBFeGlzdGVuY2Vcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0SHRtbDQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBIVE1MNCBTdXBwb3J0IGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLi4uJyk7XG5cdH1cblxuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBJbml0aWFsaXNlIEhUTUw0IFN1cHBvcnRcblxuXHQvLyBJbml0aWFsaXNlIEhUTUw0IFN1cHBvcnRcblx0SGlzdG9yeS5pbml0SHRtbDQgPSBmdW5jdGlvbigpe1xuXHRcdC8vIEluaXRpYWxpc2Vcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRIdG1sNC5pbml0aWFsaXplZCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHQvLyBBbHJlYWR5IExvYWRlZFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdEhpc3RvcnkuaW5pdEh0bWw0LmluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHR9XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gUHJvcGVydGllc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5lbmFibGVkXG5cdFx0ICogSXMgSGlzdG9yeSBlbmFibGVkP1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZW5hYmxlZCA9IHRydWU7XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSGFzaCBTdG9yYWdlXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhdmVkSGFzaGVzXG5cdFx0ICogU3RvcmUgdGhlIGhhc2hlcyBpbiBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc2F2ZWRIYXNoZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNMYXN0SGFzaChuZXdIYXNoKVxuXHRcdCAqIENoZWNrcyBpZiB0aGUgaGFzaCBpcyB0aGUgbGFzdCBoYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5ld0hhc2hcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0xhc3RIYXNoID0gZnVuY3Rpb24obmV3SGFzaCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgb2xkSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5SW5kZXgoKSxcblx0XHRcdFx0aXNMYXN0O1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aXNMYXN0ID0gbmV3SGFzaCA9PT0gb2xkSGFzaDtcblxuXHRcdFx0Ly8gUmV0dXJuIGlzTGFzdFxuXHRcdFx0cmV0dXJuIGlzTGFzdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc0hhc2hFcXVhbChuZXdIYXNoLCBvbGRIYXNoKVxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdHdvIGhhc2hlcyBhcmUgZnVuY3Rpb25hbGx5IGVxdWFsXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5ld0hhc2hcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gb2xkSGFzaFxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmlzSGFzaEVxdWFsID0gZnVuY3Rpb24obmV3SGFzaCwgb2xkSGFzaCl7XG5cdFx0XHRuZXdIYXNoID0gZW5jb2RlVVJJQ29tcG9uZW50KG5ld0hhc2gpLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG5cdFx0XHRvbGRIYXNoID0gZW5jb2RlVVJJQ29tcG9uZW50KG9sZEhhc2gpLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG5cdFx0XHRyZXR1cm4gbmV3SGFzaCA9PT0gb2xkSGFzaDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlSGFzaChuZXdIYXNoKVxuXHRcdCAqIFB1c2ggYSBIYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5ld0hhc2hcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlSGFzaCA9IGZ1bmN0aW9uKG5ld0hhc2gpe1xuXHRcdFx0Ly8gQ2hlY2sgSGFzaFxuXHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdEhhc2gobmV3SGFzaCkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHVzaCB0aGUgSGFzaFxuXHRcdFx0SGlzdG9yeS5zYXZlZEhhc2hlcy5wdXNoKG5ld0hhc2gpO1xuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0SGFzaEJ5SW5kZXgoKVxuXHRcdCAqIEdldHMgYSBoYXNoIGJ5IHRoZSBpbmRleFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXhcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoQnlJbmRleCA9IGZ1bmN0aW9uKGluZGV4KXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBoYXNoID0gbnVsbDtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgbGFzdCBpbnNlcnRlZFxuXHRcdFx0XHRoYXNoID0gSGlzdG9yeS5zYXZlZEhhc2hlc1tIaXN0b3J5LnNhdmVkSGFzaGVzLmxlbmd0aC0xXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdC8vIEdldCBmcm9tIHRoZSBlbmRcblx0XHRcdFx0aGFzaCA9IEhpc3Rvcnkuc2F2ZWRIYXNoZXNbSGlzdG9yeS5zYXZlZEhhc2hlcy5sZW5ndGgraW5kZXhdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIEdldCBmcm9tIHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0aGFzaCA9IEhpc3Rvcnkuc2F2ZWRIYXNoZXNbaW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gaGFzaFxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBEaXNjYXJkZWQgU3RhdGVzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRlZEhhc2hlc1xuXHRcdCAqIEEgaGFzaGVkIGFycmF5IG9mIGRpc2NhcmRlZCBoYXNoZXNcblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRlZEhhc2hlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZXNcblx0XHQgKiBBIGhhc2hlZCBhcnJheSBvZiBkaXNjYXJkZWQgc3RhdGVzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkZWRTdGF0ZXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZFN0YXRlKFN0YXRlKVxuXHRcdCAqIERpc2NhcmRzIHRoZSBzdGF0ZSBieSBpZ25vcmluZyBpdCB0aHJvdWdoIEhpc3Rvcnlcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gU3RhdGVcblx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZFN0YXRlID0gZnVuY3Rpb24oZGlzY2FyZGVkU3RhdGUsZm9yd2FyZFN0YXRlLGJhY2tTdGF0ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZGlzY2FyZFN0YXRlJywgYXJndW1lbnRzKTtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBkaXNjYXJkZWRTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKGRpc2NhcmRlZFN0YXRlKSxcblx0XHRcdFx0ZGlzY2FyZE9iamVjdDtcblxuXHRcdFx0Ly8gQ3JlYXRlIERpc2NhcmQgT2JqZWN0XG5cdFx0XHRkaXNjYXJkT2JqZWN0ID0ge1xuXHRcdFx0XHQnZGlzY2FyZGVkU3RhdGUnOiBkaXNjYXJkZWRTdGF0ZSxcblx0XHRcdFx0J2JhY2tTdGF0ZSc6IGJhY2tTdGF0ZSxcblx0XHRcdFx0J2ZvcndhcmRTdGF0ZSc6IGZvcndhcmRTdGF0ZVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQWRkIHRvIERpc2NhcmRlZFN0YXRlc1xuXHRcdFx0SGlzdG9yeS5kaXNjYXJkZWRTdGF0ZXNbZGlzY2FyZGVkU3RhdGVIYXNoXSA9IGRpc2NhcmRPYmplY3Q7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkSGFzaChoYXNoKVxuXHRcdCAqIERpc2NhcmRzIHRoZSBoYXNoIGJ5IGlnbm9yaW5nIGl0IHRocm91Z2ggSGlzdG9yeVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRIYXNoID0gZnVuY3Rpb24oZGlzY2FyZGVkSGFzaCxmb3J3YXJkU3RhdGUsYmFja1N0YXRlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5kaXNjYXJkU3RhdGUnLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gQ3JlYXRlIERpc2NhcmQgT2JqZWN0XG5cdFx0XHR2YXIgZGlzY2FyZE9iamVjdCA9IHtcblx0XHRcdFx0J2Rpc2NhcmRlZEhhc2gnOiBkaXNjYXJkZWRIYXNoLFxuXHRcdFx0XHQnYmFja1N0YXRlJzogYmFja1N0YXRlLFxuXHRcdFx0XHQnZm9yd2FyZFN0YXRlJzogZm9yd2FyZFN0YXRlXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBBZGQgdG8gZGlzY2FyZGVkSGFzaFxuXHRcdFx0SGlzdG9yeS5kaXNjYXJkZWRIYXNoZXNbZGlzY2FyZGVkSGFzaF0gPSBkaXNjYXJkT2JqZWN0O1xuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZGVkU3RhdGUoU3RhdGUpXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgc3RhdGUgaXMgZGlzY2FyZGVkXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFN0YXRlXG5cdFx0ICogQHJldHVybiB7Ym9vbH1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRlZFN0YXRlID0gZnVuY3Rpb24oU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUoU3RhdGUpLFxuXHRcdFx0XHRkaXNjYXJkZWQ7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRkaXNjYXJkZWQgPSBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlc1tTdGF0ZUhhc2hdfHxmYWxzZTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiBkaXNjYXJkZWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZGVkSGFzaChoYXNoKVxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHN0YXRlIGlzIGRpc2NhcmRlZFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge2Jvb2x9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkZWRIYXNoID0gZnVuY3Rpb24oaGFzaCl7XG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0dmFyIGRpc2NhcmRlZCA9IEhpc3RvcnkuZGlzY2FyZGVkSGFzaGVzW2hhc2hdfHxmYWxzZTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiBkaXNjYXJkZWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkucmVjeWNsZVN0YXRlKFN0YXRlKVxuXHRcdCAqIEFsbG93cyBhIGRpc2NhcmRlZCBzdGF0ZSB0byBiZSB1c2VkIGFnYWluXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnJlY3ljbGVTdGF0ZSA9IGZ1bmN0aW9uKFN0YXRlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZWN5Y2xlU3RhdGUnLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUoU3RhdGUpO1xuXG5cdFx0XHQvLyBSZW1vdmUgZnJvbSBEaXNjYXJkZWRTdGF0ZXNcblx0XHRcdGlmICggSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZShTdGF0ZSkgKSB7XG5cdFx0XHRcdGRlbGV0ZSBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlc1tTdGF0ZUhhc2hdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBIVE1MNCBIYXNoQ2hhbmdlIFN1cHBvcnRcblxuXHRcdGlmICggSGlzdG9yeS5lbXVsYXRlZC5oYXNoQ2hhbmdlICkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFdlIG11c3QgZW11bGF0ZSB0aGUgSFRNTDQgSGFzaENoYW5nZSBTdXBwb3J0IGJ5IG1hbnVhbGx5IGNoZWNraW5nIGZvciBoYXNoIGNoYW5nZXNcblx0XHRcdCAqL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkuaGFzaENoYW5nZUluaXQoKVxuXHRcdFx0ICogSW5pdCB0aGUgSGFzaENoYW5nZSBFbXVsYXRpb25cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5oYXNoQ2hhbmdlSW5pdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIERlZmluZSBvdXIgQ2hlY2tlciBGdW5jdGlvblxuXHRcdFx0XHRIaXN0b3J5LmNoZWNrZXJGdW5jdGlvbiA9IG51bGw7XG5cblx0XHRcdFx0Ly8gRGVmaW5lIHNvbWUgdmFyaWFibGVzIHRoYXQgd2lsbCBoZWxwIGluIG91ciBjaGVja2VyIGZ1bmN0aW9uXG5cdFx0XHRcdHZhciBsYXN0RG9jdW1lbnRIYXNoID0gJycsXG5cdFx0XHRcdFx0aWZyYW1lSWQsIGlmcmFtZSxcblx0XHRcdFx0XHRsYXN0SWZyYW1lSGFzaCwgY2hlY2tlclJ1bm5pbmcsXG5cdFx0XHRcdFx0c3RhcnRlZFdpdGhIYXNoID0gQm9vbGVhbihIaXN0b3J5LmdldEhhc2goKSk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKCkgKSB7XG5cdFx0XHRcdFx0Ly8gSUU2IGFuZCBJRTdcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHVzZSBhbiBpZnJhbWUgdG8gZW11bGF0ZSB0aGUgYmFjayBhbmQgZm9yd2FyZCBidXR0b25zXG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgaUZyYW1lXG5cdFx0XHRcdFx0aWZyYW1lSWQgPSAnaGlzdG9yeWpzLWlmcmFtZSc7XG5cdFx0XHRcdFx0aWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgaUZhcm1lXG5cdFx0XHRcdFx0Ly8gSUUgNiByZXF1aXJlcyBpZnJhbWUgdG8gaGF2ZSBhIHNyYyBvbiBIVFRQUyBwYWdlcywgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYVxuXHRcdFx0XHRcdC8vIFwiVGhpcyBwYWdlIGNvbnRhaW5zIGJvdGggc2VjdXJlIGFuZCBub25zZWN1cmUgaXRlbXNcIiB3YXJuaW5nLlxuXHRcdFx0XHRcdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWZyYW1lSWQpO1xuXHRcdFx0XHRcdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsICcjJyk7XG5cdFx0XHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHRcdFx0XHQvLyBBcHBlbmQgaUZyYW1lXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGluaXRpYWwgaGlzdG9yeSBlbnRyeVxuXHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50Lm9wZW4oKTtcblx0XHRcdFx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuXG5cdFx0XHRcdFx0Ly8gRGVmaW5lIHNvbWUgdmFyaWFibGVzIHRoYXQgd2lsbCBoZWxwIGluIG91ciBjaGVja2VyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0bGFzdElmcmFtZUhhc2ggPSAnJztcblx0XHRcdFx0XHRjaGVja2VyUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gRGVmaW5lIHRoZSBjaGVja2VyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0SGlzdG9yeS5jaGVja2VyRnVuY3Rpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgUnVubmluZ1xuXHRcdFx0XHRcdFx0aWYgKCBjaGVja2VyUnVubmluZyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBVcGRhdGUgUnVubmluZ1xuXHRcdFx0XHRcdFx0Y2hlY2tlclJ1bm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBGZXRjaFxuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdGRvY3VtZW50SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaCgpLFxuXHRcdFx0XHRcdFx0XHRpZnJhbWVIYXNoID0gSGlzdG9yeS5nZXRIYXNoKGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmxvY2F0aW9uKTtcblxuXHRcdFx0XHRcdFx0Ly8gVGhlIERvY3VtZW50IEhhc2ggaGFzIGNoYW5nZWQgKGFwcGxpY2F0aW9uIGNhdXNlZClcblx0XHRcdFx0XHRcdGlmICggZG9jdW1lbnRIYXNoICE9PSBsYXN0RG9jdW1lbnRIYXNoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBFcXVhbGlzZVxuXHRcdFx0XHRcdFx0XHRsYXN0RG9jdW1lbnRIYXNoID0gZG9jdW1lbnRIYXNoO1xuXG5cdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIGhpc3RvcnkgZW50cnkgaW4gdGhlIGlmcmFtZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlmcmFtZUhhc2ggIT09IGRvY3VtZW50SGFzaCApIHtcblx0XHRcdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ2hhc2hjaGFuZ2UuY2hlY2tlcjogaWZyYW1lIGhhc2ggY2hhbmdlJywgJ2RvY3VtZW50SGFzaCAobmV3KTonLCBkb2N1bWVudEhhc2gsICdpZnJhbWVIYXNoIChvbGQpOicsIGlmcmFtZUhhc2gpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRXF1YWxpc2Vcblx0XHRcdFx0XHRcdFx0XHRsYXN0SWZyYW1lSGFzaCA9IGlmcmFtZUhhc2ggPSBkb2N1bWVudEhhc2g7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDcmVhdGUgSGlzdG9yeSBFbnRyeVxuXHRcdFx0XHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50Lm9wZW4oKTtcblx0XHRcdFx0XHRcdFx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBpZnJhbWUncyBoYXNoXG5cdFx0XHRcdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IEhpc3RvcnkuZXNjYXBlSGFzaChkb2N1bWVudEhhc2gpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gVHJpZ2dlciBIYXNoY2hhbmdlIEV2ZW50XG5cdFx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnaGFzaGNoYW5nZScpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGUgaUZyYW1lIEhhc2ggaGFzIGNoYW5nZWQgKGJhY2sgYnV0dG9uIGNhdXNlZClcblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBpZnJhbWVIYXNoICE9PSBsYXN0SWZyYW1lSGFzaCApIHtcblx0XHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdoYXNoY2hhbmdlLmNoZWNrZXI6IGlmcmFtZSBoYXNoIG91dCBvZiBzeW5jJywgJ2lmcmFtZUhhc2ggKG5ldyk6JywgaWZyYW1lSGFzaCwgJ2RvY3VtZW50SGFzaCAob2xkKTonLCBkb2N1bWVudEhhc2gpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEVxdWFsaXNlXG5cdFx0XHRcdFx0XHRcdGxhc3RJZnJhbWVIYXNoID0gaWZyYW1lSGFzaDtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIGlmcmFtZSBoYXNoIHRoYXQgbWVhbnMgd2UncmUgYXQgdGhlIG9yaWdpbmFsXG5cdFx0XHRcdFx0XHRcdC8vIGlmcmFtZSBzdGF0ZS5cblx0XHRcdFx0XHRcdFx0Ly8gQW5kIGlmIHRoZXJlIHdhcyBhIGhhc2ggb24gdGhlIG9yaWdpbmFsIHJlcXVlc3QsIHRoZSBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0XHQvLyBpZnJhbWUgc3RhdGUgd2FzIHJlcGxhY2VkIGluc3RhbnRseSwgc28gc2tpcCB0aGlzIHN0YXRlIGFuZCB0YWtlXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSB1c2VyIGJhY2sgdG8gd2hlcmUgdGhleSBjYW1lIGZyb20uXG5cdFx0XHRcdFx0XHRcdGlmIChzdGFydGVkV2l0aEhhc2ggJiYgaWZyYW1lSGFzaCA9PT0gJycpIHtcblx0XHRcdFx0XHRcdFx0XHRIaXN0b3J5LmJhY2soKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIEhhc2hcblx0XHRcdFx0XHRcdFx0XHRIaXN0b3J5LnNldEhhc2goaWZyYW1lSGFzaCxmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUmVzZXQgUnVubmluZ1xuXHRcdFx0XHRcdFx0Y2hlY2tlclJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gV2UgYXJlIG5vdCBJRVxuXHRcdFx0XHRcdC8vIEZpcmVmb3ggMSBvciAyLCBPcGVyYVxuXG5cdFx0XHRcdFx0Ly8gRGVmaW5lIHRoZSBjaGVja2VyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0SGlzdG9yeS5jaGVja2VyRnVuY3Rpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0XHRcdFx0dmFyIGRvY3VtZW50SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaCgpfHwnJztcblxuXHRcdFx0XHRcdFx0Ly8gVGhlIERvY3VtZW50IEhhc2ggaGFzIGNoYW5nZWQgKGFwcGxpY2F0aW9uIGNhdXNlZClcblx0XHRcdFx0XHRcdGlmICggZG9jdW1lbnRIYXNoICE9PSBsYXN0RG9jdW1lbnRIYXNoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBFcXVhbGlzZVxuXHRcdFx0XHRcdFx0XHRsYXN0RG9jdW1lbnRIYXNoID0gZG9jdW1lbnRIYXNoO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRyaWdnZXIgSGFzaGNoYW5nZSBFdmVudFxuXHRcdFx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ2hhc2hjaGFuZ2UnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSB0aGUgY2hlY2tlciBmdW5jdGlvblxuXHRcdFx0XHRIaXN0b3J5LmludGVydmFsTGlzdC5wdXNoKHNldEludGVydmFsKEhpc3RvcnkuY2hlY2tlckZ1bmN0aW9uLCBIaXN0b3J5Lm9wdGlvbnMuaGFzaENoYW5nZUludGVydmFsKSk7XG5cblx0XHRcdFx0Ly8gRG9uZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07IC8vIEhpc3RvcnkuaGFzaENoYW5nZUluaXRcblxuXHRcdFx0Ly8gQmluZCBoYXNoQ2hhbmdlSW5pdFxuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLm9uRG9tTG9hZChIaXN0b3J5Lmhhc2hDaGFuZ2VJbml0KTtcblxuXHRcdH0gLy8gSGlzdG9yeS5lbXVsYXRlZC5oYXNoQ2hhbmdlXG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSFRNTDUgU3RhdGUgU3VwcG9ydFxuXG5cdFx0Ly8gTm9uLU5hdGl2ZSBwdXNoU3RhdGUgSW1wbGVtZW50YXRpb25cblx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFdlIG11c3QgZW11bGF0ZSB0aGUgSFRNTDUgU3RhdGUgTWFuYWdlbWVudCBieSB1c2luZyBIVE1MNCBIYXNoQ2hhbmdlXG5cdFx0XHQgKi9cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5Lm9uSGFzaENoYW5nZShldmVudClcblx0XHRcdCAqIFRyaWdnZXIgSFRNTDUncyB3aW5kb3cub25wb3BzdGF0ZSB2aWEgSFRNTDQgSGFzaENoYW5nZSBTdXBwb3J0XG5cdFx0XHQgKi9cblx0XHRcdEhpc3Rvcnkub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlJywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRcdHZhciBjdXJyZW50VXJsID0gKChldmVudCAmJiBldmVudC5uZXdVUkwpIHx8IEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLFxuXHRcdFx0XHRcdGN1cnJlbnRIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlVcmwoY3VycmVudFVybCksXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlID0gbnVsbCxcblx0XHRcdFx0XHRjdXJyZW50U3RhdGVIYXNoID0gbnVsbCxcblx0XHRcdFx0XHRjdXJyZW50U3RhdGVIYXNoRXhpdHMgPSBudWxsLFxuXHRcdFx0XHRcdGRpc2NhcmRPYmplY3Q7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIHRoZSBzYW1lIHN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5pc0xhc3RIYXNoKGN1cnJlbnRIYXNoKSApIHtcblx0XHRcdFx0XHQvLyBUaGVyZSBoYXMgYmVlbiBubyBjaGFuZ2UgKGp1c3QgdGhlIHBhZ2UncyBoYXNoIGhhcyBmaW5hbGx5IHByb3BhZ2F0ZWQpXG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogbm8gY2hhbmdlJyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgZG91YmxlIGNoZWNrXG5cdFx0XHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDb21wbGV0ZSgpO1xuXG5cdFx0XHRcdC8vIFN0b3JlIG91ciBsb2NhdGlvbiBmb3IgdXNlIGluIGRldGVjdGluZyBiYWNrL2ZvcndhcmQgZGlyZWN0aW9uXG5cdFx0XHRcdEhpc3Rvcnkuc2F2ZUhhc2goY3VycmVudEhhc2gpO1xuXG5cdFx0XHRcdC8vIEV4cGFuZCBIYXNoXG5cdFx0XHRcdGlmICggY3VycmVudEhhc2ggJiYgSGlzdG9yeS5pc1RyYWRpdGlvbmFsQW5jaG9yKGN1cnJlbnRIYXNoKSApIHtcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiB0cmFkaXRpb25hbCBhbmNob3InLCBjdXJyZW50SGFzaCk7XG5cdFx0XHRcdFx0Ly8gVHJhZGl0aW9uYWwgQW5jaG9yIEhhc2hcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ2FuY2hvcmNoYW5nZScpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIFN0YXRlXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0RnVsbFVybChjdXJyZW50SGFzaHx8SGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSksdHJ1ZSk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIHRoZSBzYW1lIHN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKGN1cnJlbnRTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogbm8gY2hhbmdlJyk7XG5cdFx0XHRcdFx0Ly8gVGhlcmUgaGFzIGJlZW4gbm8gY2hhbmdlIChqdXN0IHRoZSBwYWdlJ3MgaGFzaCBoYXMgZmluYWxseSBwcm9wYWdhdGVkKVxuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBzdGF0ZSBIYXNoXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKGN1cnJlbnRTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIERpc2NhcmRlZFN0YXRlXG5cdFx0XHRcdGRpc2NhcmRPYmplY3QgPSBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlKGN1cnJlbnRTdGF0ZSk7XG5cdFx0XHRcdGlmICggZGlzY2FyZE9iamVjdCApIHtcblx0XHRcdFx0XHQvLyBJZ25vcmUgdGhpcyBzdGF0ZSBhcyBpdCBoYXMgYmVlbiBkaXNjYXJkZWQgYW5kIGdvIGJhY2sgdG8gdGhlIHN0YXRlIGJlZm9yZSBpdFxuXHRcdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlJbmRleCgtMikgPT09IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUoZGlzY2FyZE9iamVjdC5mb3J3YXJkU3RhdGUpICkge1xuXHRcdFx0XHRcdFx0Ly8gV2UgYXJlIGdvaW5nIGJhY2t3YXJkc1xuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogZ28gYmFja3dhcmRzJyk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmJhY2soZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBhcmUgZ29pbmcgZm9yd2FyZHNcblx0XHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IGdvIGZvcndhcmRzJyk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmZvcndhcmQoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQdXNoIHRoZSBuZXcgSFRNTDUgU3RhdGVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogc3VjY2VzcyBoYXNoY2hhbmdlJyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFN0YXRlKGN1cnJlbnRTdGF0ZS5kYXRhLGN1cnJlbnRTdGF0ZS50aXRsZSxlbmNvZGVVUkkoY3VycmVudFN0YXRlLnVybCksZmFsc2UpO1xuXG5cdFx0XHRcdC8vIEVuZCBvbkhhc2hDaGFuZ2UgY2xvc3VyZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ2hhc2hjaGFuZ2UnLEhpc3Rvcnkub25IYXNoQ2hhbmdlKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5LnB1c2hTdGF0ZShkYXRhLHRpdGxlLHVybClcblx0XHRcdCAqIEFkZCBhIG5ldyBTdGF0ZSB0byB0aGUgaGlzdG9yeSBvYmplY3QsIGJlY29tZSBpdCwgYW5kIHRyaWdnZXIgb25wb3BzdGF0ZVxuXHRcdFx0ICogV2UgaGF2ZSB0byB0cmlnZ2VyIGZvciBIVE1MNCBjb21wYXRpYmlsaXR5XG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsLHF1ZXVlKXtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnB1c2hTdGF0ZTogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgVVJMIHBhc3NlZCBpbiBpcyBVUkktZW5jb2RlZCwgYnV0IHRoaXMgbWFrZXNcblx0XHRcdFx0Ly8gc3VyZSB0aGF0IGl0J3MgZnVsbHkgVVJJIGVuY29kZWQ7IGFueSAnJSdzIHRoYXQgYXJlIGVuY29kZWQgYXJlXG5cdFx0XHRcdC8vIGNvbnZlcnRlZCBiYWNrIGludG8gJyUnc1xuXHRcdFx0XHR1cmwgPSBlbmNvZGVVUkkodXJsKS5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHRoZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIGRvZXMgbm90IHN1cHBvcnQgc3RhdGVzIHdpdGggZnJhZ21lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5wdXNoU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3lcblx0XHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHRcdC8vIEZldGNoIHRoZSBTdGF0ZSBPYmplY3Rcblx0XHRcdFx0dmFyIG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybCksXG5cdFx0XHRcdFx0bmV3U3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShuZXdTdGF0ZSksXG5cdFx0XHRcdFx0b2xkU3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlKGZhbHNlKSxcblx0XHRcdFx0XHRvbGRTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKG9sZFN0YXRlKSxcblx0XHRcdFx0XHRodG1sNEhhc2ggPSBIaXN0b3J5LmdldEhhc2goKSxcblx0XHRcdFx0XHR3YXNFeHBlY3RlZCA9IEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID09IG5ld1N0YXRlLmlkO1xuXG5cdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRIaXN0b3J5LnN0b3JlU3RhdGUobmV3U3RhdGUpO1xuXHRcdFx0XHRIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCA9IG5ld1N0YXRlLmlkO1xuXG5cdFx0XHRcdC8vIFJlY3ljbGUgdGhlIFN0YXRlXG5cdFx0XHRcdEhpc3RvcnkucmVjeWNsZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBGb3JjZSB1cGRhdGUgb2YgdGhlIHRpdGxlXG5cdFx0XHRcdEhpc3Rvcnkuc2V0VGl0bGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSB0aGUgc2FtZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIG5ld1N0YXRlSGFzaCA9PT0gb2xkU3RhdGVIYXNoICkge1xuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IG5vIGNoYW5nZScsIG5ld1N0YXRlSGFzaCk7XG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgSFRNTDUgU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5zYXZlU3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0aWYoIXdhc0V4cGVjdGVkKVxuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnc3RhdGVjaGFuZ2UnKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgSFRNTDQgSGFzaFxuXHRcdFx0XHRpZiAoICFIaXN0b3J5LmlzSGFzaEVxdWFsKG5ld1N0YXRlSGFzaCwgaHRtbDRIYXNoKSAmJiAhSGlzdG9yeS5pc0hhc2hFcXVhbChuZXdTdGF0ZUhhc2gsIEhpc3RvcnkuZ2V0U2hvcnRVcmwoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSkpICkge1xuXHRcdFx0XHRcdEhpc3Rvcnkuc2V0SGFzaChuZXdTdGF0ZUhhc2gsZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXG5cdFx0XHRcdC8vIEVuZCBwdXNoU3RhdGUgY2xvc3VyZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5yZXBsYWNlU3RhdGUoZGF0YSx0aXRsZSx1cmwpXG5cdFx0XHQgKiBSZXBsYWNlIHRoZSBTdGF0ZSBhbmQgdHJpZ2dlciBvbnBvcHN0YXRlXG5cdFx0XHQgKiBXZSBoYXZlIHRvIHRyaWdnZXIgZm9yIEhUTUw0IGNvbXBhdGliaWxpdHlcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwscXVldWUpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucmVwbGFjZVN0YXRlOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBVUkwgcGFzc2VkIGluIGlzIFVSSS1lbmNvZGVkLCBidXQgdGhpcyBtYWtlc1xuXHRcdFx0XHQvLyBzdXJlIHRoYXQgaXQncyBmdWxseSBVUkkgZW5jb2RlZDsgYW55ICclJ3MgdGhhdCBhcmUgZW5jb2RlZCBhcmVcblx0XHRcdFx0Ly8gY29udmVydGVkIGJhY2sgaW50byAnJSdzXG5cdFx0XHRcdHVybCA9IGVuY29kZVVSSSh1cmwpLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnbWVudC1pZGVudGlmaWVycyAoaGFzaGVzL2FuY2hvcnMpLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRcdC8vIFdhaXQgKyBQdXNoIHRvIFF1ZXVlXG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnJlcGxhY2VTdGF0ZTogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZSh7XG5cdFx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LnJlcGxhY2VTdGF0ZSxcblx0XHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ha2UgQnVzeVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gRmV0Y2ggdGhlIFN0YXRlIE9iamVjdHNcblx0XHRcdFx0dmFyIG5ld1N0YXRlICAgICAgICA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpLFxuXHRcdFx0XHRcdG5ld1N0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUobmV3U3RhdGUpLFxuXHRcdFx0XHRcdG9sZFN0YXRlICAgICAgICA9IEhpc3RvcnkuZ2V0U3RhdGUoZmFsc2UpLFxuXHRcdFx0XHRcdG9sZFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUob2xkU3RhdGUpLFxuXHRcdFx0XHRcdHByZXZpb3VzU3RhdGUgICA9IEhpc3RvcnkuZ2V0U3RhdGVCeUluZGV4KC0yKTtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIE9sZCBTdGF0ZVxuXHRcdFx0XHRIaXN0b3J5LmRpc2NhcmRTdGF0ZShvbGRTdGF0ZSxuZXdTdGF0ZSxwcmV2aW91c1N0YXRlKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdXJsIGhhc24ndCBjaGFuZ2VkLCBqdXN0IHN0b3JlIGFuZCBzYXZlIHRoZSBzdGF0ZVxuXHRcdFx0XHQvLyBhbmQgZmlyZSBhIHN0YXRlY2hhbmdlIGV2ZW50IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGVcblx0XHRcdFx0Ly8gaHRtbCA1IGFwaVxuXHRcdFx0XHRpZiAoIG5ld1N0YXRlSGFzaCA9PT0gb2xkU3RhdGVIYXNoICkge1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblx0XG5cdFx0XHRcdFx0Ly8gUmVjeWNsZSB0aGUgU3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnJlY3ljbGVTdGF0ZShuZXdTdGF0ZSk7XG5cdFxuXHRcdFx0XHRcdC8vIEZvcmNlIHVwZGF0ZSBvZiB0aGUgdGl0bGVcblx0XHRcdFx0XHRIaXN0b3J5LnNldFRpdGxlKG5ld1N0YXRlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBVcGRhdGUgSFRNTDUgU3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnNhdmVTdGF0ZShuZXdTdGF0ZSk7XG5cblx0XHRcdFx0XHQvLyBGaXJlIEhUTUw1IEV2ZW50XG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnB1c2hTdGF0ZTogdHJpZ2dlciBwb3BzdGF0ZScpO1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnc3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFsaWFzIHRvIFB1c2hTdGF0ZVxuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFN0YXRlKG5ld1N0YXRlLmRhdGEsbmV3U3RhdGUudGl0bGUsbmV3U3RhdGUudXJsLGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuZCByZXBsYWNlU3RhdGUgY2xvc3VyZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cblx0XHR9IC8vIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlXG5cblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBJbml0aWFsaXNlXG5cblx0XHQvLyBOb24tTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGlmICggSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuc3VyZSBpbml0aWFsIHN0YXRlIGlzIGhhbmRsZWQgY29ycmVjdGx5XG5cdFx0XHQgKi9cblx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoKCkgJiYgIUhpc3RvcnkuZW11bGF0ZWQuaGFzaENoYW5nZSApIHtcblx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLm9uRG9tTG9hZChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnaGFzaGNoYW5nZScpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdH0gLy8gSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXHR9OyAvLyBIaXN0b3J5LmluaXRIdG1sNFxuXG5cdC8vIFRyeSB0byBJbml0aWFsaXNlIEhpc3Rvcnlcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRIaXN0b3J5LmluaXQoKTtcblx0fVxuXG59KSh3aW5kb3cpO1xuIiwiLyoqXG4gKiBIaXN0b3J5LmpzIENvcmVcbiAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAY29weXJpZ2h0IDIwMTAtMjAxMSBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBsaWNlbnNlIE5ldyBCU0QgTGljZW5zZSA8aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvQlNELz5cbiAqL1xuXG4oZnVuY3Rpb24od2luZG93LHVuZGVmaW5lZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBJbml0aWFsaXNlXG5cblx0Ly8gTG9jYWxpc2UgR2xvYmFsc1xuXHR2YXJcblx0XHRjb25zb2xlID0gd2luZG93LmNvbnNvbGV8fHVuZGVmaW5lZCwgLy8gUHJldmVudCBhIEpTTGludCBjb21wbGFpblxuXHRcdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LCAvLyBNYWtlIHN1cmUgd2UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IGRvY3VtZW50XG5cdFx0bmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvciwgLy8gTWFrZSBzdXJlIHdlIGFyZSB1c2luZyB0aGUgY29ycmVjdCBuYXZpZ2F0b3Jcblx0XHRzZXNzaW9uU3RvcmFnZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZXx8ZmFsc2UsIC8vIHNlc3Npb25TdG9yYWdlXG5cdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0LFxuXHRcdGNsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXQsXG5cdFx0c2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwsXG5cdFx0Y2xlYXJJbnRlcnZhbCA9IHdpbmRvdy5jbGVhckludGVydmFsLFxuXHRcdEpTT04gPSB3aW5kb3cuSlNPTixcblx0XHRhbGVydCA9IHdpbmRvdy5hbGVydCxcblx0XHRIaXN0b3J5ID0gd2luZG93Lkhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeXx8e30sIC8vIFB1YmxpYyBIaXN0b3J5IE9iamVjdFxuXHRcdGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTsgLy8gT2xkIEhpc3RvcnkgT2JqZWN0XG5cblx0dHJ5IHtcblx0XHRzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdURVNUJywgJzEnKTtcblx0XHRzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdURVNUJyk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHNlc3Npb25TdG9yYWdlID0gZmFsc2U7XG5cdH1cblxuXHQvLyBNb29Ub29scyBDb21wYXRpYmlsaXR5XG5cdEpTT04uc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnl8fEpTT04uZW5jb2RlO1xuXHRKU09OLnBhcnNlID0gSlNPTi5wYXJzZXx8SlNPTi5kZWNvZGU7XG5cblx0Ly8gQ2hlY2sgRXhpc3RlbmNlXG5cdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIENvcmUgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuLi4nKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpc2UgSGlzdG9yeVxuXHRIaXN0b3J5LmluaXQgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0XHQvLyBDaGVjayBMb2FkIFN0YXR1cyBvZiBBZGFwdGVyXG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5BZGFwdGVyID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBMb2FkIFN0YXR1cyBvZiBDb3JlXG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0Q29yZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRIaXN0b3J5LmluaXRDb3JlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgTG9hZCBTdGF0dXMgb2YgSFRNTDQgU3VwcG9ydFxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdEh0bWw0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdEhpc3RvcnkuaW5pdEh0bWw0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBJbml0aWFsaXNlIENvcmVcblxuXHQvLyBJbml0aWFsaXNlIENvcmVcblx0SGlzdG9yeS5pbml0Q29yZSA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHRcdC8vIEluaXRpYWxpc2Vcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRDb3JlLmluaXRpYWxpemVkICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdC8vIEFscmVhZHkgTG9hZGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0SGlzdG9yeS5pbml0Q29yZS5pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0fVxuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIE9wdGlvbnNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9uc1xuXHRcdCAqIENvbmZpZ3VyYWJsZSBvcHRpb25zXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zID0gSGlzdG9yeS5vcHRpb25zfHx7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5oYXNoQ2hhbmdlSW50ZXJ2YWxcblx0XHQgKiBIb3cgbG9uZyBzaG91bGQgdGhlIGludGVydmFsIGJlIGJlZm9yZSBoYXNoY2hhbmdlIGNoZWNrc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5oYXNoQ2hhbmdlSW50ZXJ2YWwgPSBIaXN0b3J5Lm9wdGlvbnMuaGFzaENoYW5nZUludGVydmFsIHx8IDEwMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5zYWZhcmlQb2xsSW50ZXJ2YWxcblx0XHQgKiBIb3cgbG9uZyBzaG91bGQgdGhlIGludGVydmFsIGJlIGJlZm9yZSBzYWZhcmkgcG9sbCBjaGVja3Ncblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsID0gSGlzdG9yeS5vcHRpb25zLnNhZmFyaVBvbGxJbnRlcnZhbCB8fCA1MDA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuZG91YmxlQ2hlY2tJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB0aGUgaW50ZXJ2YWwgYmUgYmVmb3JlIHdlIHBlcmZvcm0gYSBkb3VibGUgY2hlY2tcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuZG91YmxlQ2hlY2tJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsIHx8IDUwMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZFxuXHRcdCAqIEZvcmNlIEhpc3Rvcnkgbm90IHRvIGFwcGVuZCBzdWlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmRpc2FibGVTdWlkID0gSGlzdG9yeS5vcHRpb25zLmRpc2FibGVTdWlkIHx8IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLnN0b3JlSW50ZXJ2YWxcblx0XHQgKiBIb3cgbG9uZyBzaG91bGQgd2Ugd2FpdCBiZXR3ZWVuIHN0b3JlIGNhbGxzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLnN0b3JlSW50ZXJ2YWwgPSBIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbCB8fCAxMDAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmJ1c3lEZWxheVxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IGJldHdlZW4gYnVzeSBldmVudHNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuYnVzeURlbGF5ID0gSGlzdG9yeS5vcHRpb25zLmJ1c3lEZWxheSB8fCAyNTA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuZGVidWdcblx0XHQgKiBJZiB0cnVlIHdpbGwgZW5hYmxlIGRlYnVnIG1lc3NhZ2VzIHRvIGJlIGxvZ2dlZFxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kZWJ1ZyA9IEhpc3Rvcnkub3B0aW9ucy5kZWJ1ZyB8fCBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5pbml0aWFsVGl0bGVcblx0XHQgKiBXaGF0IGlzIHRoZSB0aXRsZSBvZiB0aGUgaW5pdGlhbCBzdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5pbml0aWFsVGl0bGUgPSBIaXN0b3J5Lm9wdGlvbnMuaW5pdGlhbFRpdGxlIHx8IGRvY3VtZW50LnRpdGxlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZVxuXHRcdCAqIElmIHRydWUsIHdpbGwgZm9yY2UgSFRNbDQgbW9kZSAoaGFzaHRhZ3MpXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZSA9IEhpc3Rvcnkub3B0aW9ucy5odG1sNE1vZGUgfHwgZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuZGVsYXlJbml0XG5cdFx0ICogV2FudCB0byBvdmVycmlkZSBkZWZhdWx0IG9wdGlvbnMgYW5kIGNhbGwgaW5pdCBtYW51YWxseS5cblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuZGVsYXlJbml0ID0gSGlzdG9yeS5vcHRpb25zLmRlbGF5SW5pdCB8fCBmYWxzZTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBJbnRlcnZhbCByZWNvcmRcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaW50ZXJ2YWxMaXN0XG5cdFx0ICogTGlzdCBvZiBpbnRlcnZhbHMgc2V0LCB0byBiZSBjbGVhcmVkIHdoZW4gZG9jdW1lbnQgaXMgdW5sb2FkZWQuXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHNcblx0XHQgKiBDbGVhcnMgYWxsIHNldEludGVydmFsIGluc3RhbmNlcy5cblx0XHQgKi9cblx0XHRIaXN0b3J5LmNsZWFyQWxsSW50ZXJ2YWxzID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBpLCBpbCA9IEhpc3RvcnkuaW50ZXJ2YWxMaXN0O1xuXHRcdFx0aWYgKHR5cGVvZiBpbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgaWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKGlsW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRIaXN0b3J5LmludGVydmFsTGlzdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBEZWJ1Z1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kZWJ1ZyhtZXNzYWdlLC4uLilcblx0XHQgKiBMb2dzIHRoZSBwYXNzZWQgYXJndW1lbnRzIGlmIGRlYnVnIGVuYWJsZWRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmRlYnVnID0gZnVuY3Rpb24oKXtcblx0XHRcdGlmICggKEhpc3Rvcnkub3B0aW9ucy5kZWJ1Z3x8ZmFsc2UpICkge1xuXHRcdFx0XHRIaXN0b3J5LmxvZy5hcHBseShIaXN0b3J5LGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkubG9nKG1lc3NhZ2UsLi4uKVxuXHRcdCAqIExvZ3MgdGhlIHBhc3NlZCBhcmd1bWVudHNcblx0XHQgKi9cblx0XHRIaXN0b3J5LmxvZyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXJcblx0XHRcdFx0Y29uc29sZUV4aXN0cyA9ICEodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNvbnNvbGUubG9nLmFwcGx5ID09PSAndW5kZWZpbmVkJyksXG5cdFx0XHRcdHRleHRhcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpLFxuXHRcdFx0XHRtZXNzYWdlLFxuXHRcdFx0XHRpLG4sXG5cdFx0XHRcdGFyZ3MsYXJnXG5cdFx0XHRcdDtcblxuXHRcdFx0Ly8gV3JpdGUgdG8gQ29uc29sZVxuXHRcdFx0aWYgKCBjb25zb2xlRXhpc3RzICkge1xuXHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0bWVzc2FnZSA9IGFyZ3Muc2hpZnQoKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgY29uc29sZS5kZWJ1ZyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLFttZXNzYWdlLGFyZ3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLFttZXNzYWdlLGFyZ3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1lc3NhZ2UgPSAoXCJcXG5cIithcmd1bWVudHNbMF0rXCJcXG5cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdyaXRlIHRvIGxvZ1xuXHRcdFx0Zm9yICggaT0xLG49YXJndW1lbnRzLmxlbmd0aDsgaTxuOyArK2kgKSB7XG5cdFx0XHRcdGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGFyZyA9IEpTT04uc3RyaW5naWZ5KGFyZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoICggRXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVjdXJzaXZlIE9iamVjdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNzYWdlICs9IFwiXFxuXCIrYXJnK1wiXFxuXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRleHRhcmVhXG5cdFx0XHRpZiAoIHRleHRhcmVhICkge1xuXHRcdFx0XHR0ZXh0YXJlYS52YWx1ZSArPSBtZXNzYWdlK1wiXFxuLS0tLS1cXG5cIjtcblx0XHRcdFx0dGV4dGFyZWEuc2Nyb2xsVG9wID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0IC0gdGV4dGFyZWEuY2xpZW50SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm8gVGV4dGFyZWEsIE5vIENvbnNvbGVcblx0XHRcdGVsc2UgaWYgKCAhY29uc29sZUV4aXN0cyApIHtcblx0XHRcdFx0YWxlcnQobWVzc2FnZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEVtdWxhdGVkIFN0YXR1c1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKClcblx0XHQgKiBHZXQncyB0aGUgbWFqb3IgdmVyc2lvbiBvZiBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdCAqIEByZXR1cm4ge2ludGVnZXJ9XG5cdFx0ICogQGxpY2Vuc2UgUHVibGljIERvbWFpblxuXHRcdCAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG5cdFx0ICogQGF1dGhvciBKYW1lcyBQYWRvbHNleSA8aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vNTI3NjgzPlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVzdWx0ID0gSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uLmNhY2hlZCA9XG5cdFx0XHRcdFx0KHR5cGVvZiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24uY2FjaGVkICE9PSAndW5kZWZpbmVkJylcblx0XHRcdFx0P1x0SGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uLmNhY2hlZFxuXHRcdFx0XHQ6XHQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHZhciB2ID0gMyxcblx0XHRcdFx0XHRcdFx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHRcdFx0XHRcdFx0XHRhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2knKTtcblx0XHRcdFx0XHRcdHdoaWxlICggKGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnICsgKCsrdikgKyAnXT48aT48L2k+PCFbZW5kaWZdLS0+JykgJiYgYWxsWzBdICkge31cblx0XHRcdFx0XHRcdHJldHVybiAodiA+IDQpID8gdiA6IGZhbHNlO1xuXHRcdFx0XHRcdH0pKClcblx0XHRcdFx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKVxuXHRcdCAqIEFyZSB3ZSB1c2luZyBJbnRlcm5ldCBFeHBsb3Jlcj9cblx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdCAqIEBsaWNlbnNlIFB1YmxpYyBEb21haW5cblx0XHQgKiBAYXV0aG9yIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciByZXN1bHQgPVxuXHRcdFx0XHRIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3Jlci5jYWNoZWQgPVxuXHRcdFx0XHQodHlwZW9mIEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyLmNhY2hlZCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdFx0P1x0SGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIuY2FjaGVkXG5cdFx0XHRcdFx0Olx0Qm9vbGVhbihIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKSlcblx0XHRcdFx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5lbXVsYXRlZFxuXHRcdCAqIFdoaWNoIGZlYXR1cmVzIHJlcXVpcmUgZW11bGF0aW5nP1xuXHRcdCAqL1xuXG5cdFx0aWYgKEhpc3Rvcnkub3B0aW9ucy5odG1sNE1vZGUpIHtcblx0XHRcdEhpc3RvcnkuZW11bGF0ZWQgPSB7XG5cdFx0XHRcdHB1c2hTdGF0ZSA6IHRydWUsXG5cdFx0XHRcdGhhc2hDaGFuZ2U6IHRydWVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZWxzZSB7XG5cblx0XHRcdEhpc3RvcnkuZW11bGF0ZWQgPSB7XG5cdFx0XHRcdHB1c2hTdGF0ZTogIUJvb2xlYW4oXG5cdFx0XHRcdFx0d2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlICYmIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZVxuXHRcdFx0XHRcdCYmICEoXG5cdFx0XHRcdFx0XHQoLyBNb2JpbGVcXC8oWzEtN11bYS16XXwoOChbYWJjZGVdfGYoMVswLThdKSkpKS9pKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIC8qIGRpc2FibGUgZm9yIHZlcnNpb25zIG9mIGlPUyBiZWZvcmUgdmVyc2lvbiA0LjMgKDhGMTkwKSAqL1xuXHRcdFx0XHRcdFx0fHwgKC9BcHBsZVdlYktpdFxcLzUoWzAtMl18M1swLTJdKS9pKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIC8qIGRpc2FibGUgZm9yIHRoZSBtZXJjdXJ5IGlPUyBicm93c2VyLCBvciBhdCBsZWFzdCBvbGRlciB2ZXJzaW9ucyBvZiB0aGUgd2Via2l0IGVuZ2luZSAqL1xuXHRcdFx0XHRcdClcblx0XHRcdFx0KSxcblx0XHRcdFx0aGFzaENoYW5nZTogQm9vbGVhbihcblx0XHRcdFx0XHQhKCgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpIHx8ICgnb25oYXNoY2hhbmdlJyBpbiBkb2N1bWVudCkpXG5cdFx0XHRcdFx0fHxcblx0XHRcdFx0XHQoSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKSAmJiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKSA8IDgpXG5cdFx0XHRcdClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5lbmFibGVkXG5cdFx0ICogSXMgSGlzdG9yeSBlbmFibGVkP1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZW5hYmxlZCA9ICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuYnVnc1xuXHRcdCAqIFdoaWNoIGJ1Z3MgYXJlIHByZXNlbnRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmJ1Z3MgPSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFNhZmFyaSA1IGFuZCBTYWZhcmkgaU9TIDQgZmFpbCB0byByZXR1cm4gdG8gdGhlIGNvcnJlY3Qgc3RhdGUgb25jZSBhIGhhc2ggaXMgcmVwbGFjZWQgYnkgYSBgcmVwbGFjZVN0YXRlYCBjYWxsXG5cdFx0XHQgKiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTYyNDlcblx0XHRcdCAqL1xuXHRcdFx0c2V0SGFzaDogQm9vbGVhbighSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgJiYgbmF2aWdhdG9yLnZlbmRvciA9PT0gJ0FwcGxlIENvbXB1dGVyLCBJbmMuJyAmJiAvQXBwbGVXZWJLaXRcXC81KFswLTJdfDNbMC0zXSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNhZmFyaSA1IGFuZCBTYWZhcmkgaU9TIDQgc29tZXRpbWVzIGZhaWwgdG8gYXBwbHkgdGhlIHN0YXRlIGNoYW5nZSB1bmRlciBidXN5IGNvbmRpdGlvbnNcblx0XHRcdCAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00Mjk0MFxuXHRcdFx0ICovXG5cdFx0XHRzYWZhcmlQb2xsOiBCb29sZWFuKCFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSAmJiBuYXZpZ2F0b3IudmVuZG9yID09PSAnQXBwbGUgQ29tcHV0ZXIsIEluYy4nICYmIC9BcHBsZVdlYktpdFxcLzUoWzAtMl18M1swLTNdKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSksXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTVNJRSA2IGFuZCA3IHNvbWV0aW1lcyBkbyBub3QgYXBwbHkgYSBoYXNoIGV2ZW4gaXQgd2FzIHRvbGQgdG8gKHJlcXVpcmluZyBhIHNlY29uZCBjYWxsIHRvIHRoZSBhcHBseSBmdW5jdGlvbilcblx0XHRcdCAqL1xuXHRcdFx0aWVEb3VibGVDaGVjazogQm9vbGVhbihIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpICYmIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpIDwgOCksXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTVNJRSA2IHJlcXVpcmVzIHRoZSBlbnRpcmUgaGFzaCB0byBiZSBlbmNvZGVkIGZvciB0aGUgaGFzaGVzIHRvIHRyaWdnZXIgdGhlIG9uSGFzaENoYW5nZSBldmVudFxuXHRcdFx0ICovXG5cdFx0XHRoYXNoRXNjYXBlOiBCb29sZWFuKEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKCkgJiYgSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKCkgPCA3KVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlzRW1wdHlPYmplY3Qob2JqKVxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIE9iamVjdCBpcyBFbXB0eVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmNsb25lT2JqZWN0KG9iailcblx0XHQgKiBDbG9uZXMgYSBvYmplY3QgYW5kIGVsaW1pbmF0ZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgb3JpZ2luYWwgY29udGV4dHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuY2xvbmVPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcblx0XHRcdHZhciBoYXNoLG5ld09iajtcblx0XHRcdGlmICggb2JqICkge1xuXHRcdFx0XHRoYXNoID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcblx0XHRcdFx0bmV3T2JqID0gSlNPTi5wYXJzZShoYXNoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRuZXdPYmogPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdPYmo7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBVUkwgSGVscGVyc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRSb290VXJsKClcblx0XHQgKiBUdXJucyBcImh0dHA6Ly9teXNpdGUuY29tL2Rpci9wYWdlLmh0bWw/YXNkXCIgaW50byBcImh0dHA6Ly9teXNpdGUuY29tXCJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHJvb3RVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFJvb3RVcmwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHR2YXIgcm9vdFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sKycvLycrKGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lfHxkb2N1bWVudC5sb2NhdGlvbi5ob3N0KTtcblx0XHRcdGlmICggZG9jdW1lbnQubG9jYXRpb24ucG9ydHx8ZmFsc2UgKSB7XG5cdFx0XHRcdHJvb3RVcmwgKz0gJzonK2RvY3VtZW50LmxvY2F0aW9uLnBvcnQ7XG5cdFx0XHR9XG5cdFx0XHRyb290VXJsICs9ICcvJztcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gcm9vdFVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRCYXNlSHJlZigpXG5cdFx0ICogRmV0Y2hlcyB0aGUgYGhyZWZgIGF0dHJpYnV0ZSBvZiB0aGUgYDxiYXNlIGhyZWY9XCIuLi5cIj5gIGVsZW1lbnQgaWYgaXQgZXhpc3RzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBiYXNlSHJlZlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHR2YXJcblx0XHRcdFx0YmFzZUVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKSxcblx0XHRcdFx0YmFzZUVsZW1lbnQgPSBudWxsLFxuXHRcdFx0XHRiYXNlSHJlZiA9ICcnO1xuXG5cdFx0XHQvLyBUZXN0IGZvciBCYXNlIEVsZW1lbnRcblx0XHRcdGlmICggYmFzZUVsZW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0Ly8gUHJlcGFyZSBmb3IgQmFzZSBFbGVtZW50XG5cdFx0XHRcdGJhc2VFbGVtZW50ID0gYmFzZUVsZW1lbnRzWzBdO1xuXHRcdFx0XHRiYXNlSHJlZiA9IGJhc2VFbGVtZW50LmhyZWYucmVwbGFjZSgvW15cXC9dKyQvLCcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRqdXN0IHRyYWlsaW5nIHNsYXNoXG5cdFx0XHRiYXNlSHJlZiA9IGJhc2VIcmVmLnJlcGxhY2UoL1xcLyskLywnJyk7XG5cdFx0XHRpZiAoIGJhc2VIcmVmICkgYmFzZUhyZWYgKz0gJy8nO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBiYXNlSHJlZjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRCYXNlVXJsKClcblx0XHQgKiBGZXRjaGVzIHRoZSBiYXNlSHJlZiBvciBiYXNlUGFnZVVybCBvciByb290VXJsICh3aGljaGV2ZXIgb25lIGV4aXN0cyBmaXJzdClcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2VVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEJhc2VVcmwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHR2YXIgYmFzZVVybCA9IEhpc3RvcnkuZ2V0QmFzZUhyZWYoKXx8SGlzdG9yeS5nZXRCYXNlUGFnZVVybCgpfHxIaXN0b3J5LmdldFJvb3RVcmwoKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gYmFzZVVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRQYWdlVXJsKClcblx0XHQgKiBGZXRjaGVzIHRoZSBVUkwgb2YgdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcGFnZVVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0UGFnZVVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dmFyXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZShmYWxzZSxmYWxzZSksXG5cdFx0XHRcdHN0YXRlVXJsID0gKFN0YXRlfHx7fSkudXJsfHxIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpLFxuXHRcdFx0XHRwYWdlVXJsO1xuXG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHBhZ2VVcmwgPSBzdGF0ZVVybC5yZXBsYWNlKC9cXC8rJC8sJycpLnJlcGxhY2UoL1teXFwvXSskLyxmdW5jdGlvbihwYXJ0LGluZGV4LHN0cmluZyl7XG5cdFx0XHRcdHJldHVybiAoL1xcLi8pLnRlc3QocGFydCkgPyBwYXJ0IDogcGFydCsnLyc7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gcGFnZVVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRCYXNlUGFnZVVybCgpXG5cdFx0ICogRmV0Y2hlcyB0aGUgVXJsIG9mIHRoZSBkaXJlY3Rvcnkgb2YgdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gYmFzZVBhZ2VVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEJhc2VQYWdlVXJsID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0dmFyIGJhc2VQYWdlVXJsID0gKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLnJlcGxhY2UoL1sjXFw/XS4qLywnJykucmVwbGFjZSgvW15cXC9dKyQvLGZ1bmN0aW9uKHBhcnQsaW5kZXgsc3RyaW5nKXtcblx0XHRcdFx0cmV0dXJuICgvW15cXC9dJC8pLnRlc3QocGFydCkgPyAnJyA6IHBhcnQ7XG5cdFx0XHR9KS5yZXBsYWNlKC9cXC8rJC8sJycpKycvJztcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gYmFzZVBhZ2VVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0RnVsbFVybCh1cmwpXG5cdFx0ICogRW5zdXJlcyB0aGF0IHdlIGhhdmUgYW4gYWJzb2x1dGUgVVJMIGFuZCBub3QgYSByZWxhdGl2ZSBVUkxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0Jhc2VIcmVmXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBmdWxsVXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRGdWxsVXJsID0gZnVuY3Rpb24odXJsLGFsbG93QmFzZUhyZWYpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGZ1bGxVcmwgPSB1cmwsIGZpcnN0Q2hhciA9IHVybC5zdWJzdHJpbmcoMCwxKTtcblx0XHRcdGFsbG93QmFzZUhyZWYgPSAodHlwZW9mIGFsbG93QmFzZUhyZWYgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBhbGxvd0Jhc2VIcmVmO1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aWYgKCAvW2Etel0rXFw6XFwvXFwvLy50ZXN0KHVybCkgKSB7XG5cdFx0XHRcdC8vIEZ1bGwgVVJMXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggZmlyc3RDaGFyID09PSAnLycgKSB7XG5cdFx0XHRcdC8vIFJvb3QgVVJMXG5cdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldFJvb3RVcmwoKSt1cmwucmVwbGFjZSgvXlxcLysvLCcnKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBmaXJzdENoYXIgPT09ICcjJyApIHtcblx0XHRcdFx0Ly8gQW5jaG9yIFVSTFxuXHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRQYWdlVXJsKCkucmVwbGFjZSgvIy4qLywnJykrdXJsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZpcnN0Q2hhciA9PT0gJz8nICkge1xuXHRcdFx0XHQvLyBRdWVyeSBVUkxcblx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0UGFnZVVybCgpLnJlcGxhY2UoL1tcXD8jXS4qLywnJykrdXJsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIFJlbGF0aXZlIFVSTFxuXHRcdFx0XHRpZiAoIGFsbG93QmFzZUhyZWYgKSB7XG5cdFx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0QmFzZVVybCgpK3VybC5yZXBsYWNlKC9eKFxcLlxcLykrLywnJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0QmFzZVBhZ2VVcmwoKSt1cmwucmVwbGFjZSgvXihcXC5cXC8pKy8sJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFdlIGhhdmUgYW4gaWYgY29uZGl0aW9uIGFib3ZlIGFzIHdlIGRvIG5vdCB3YW50IGhhc2hlc1xuXHRcdFx0XHQvLyB3aGljaCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJhc2VIcmVmIGluIG91ciBVUkxzXG5cdFx0XHRcdC8vIGFzIGlmIHRoZSBiYXNlSHJlZiBjaGFuZ2VzLCB0aGVuIGFsbCBvdXIgYm9va21hcmtzXG5cdFx0XHRcdC8vIHdvdWxkIG5vdyBwb2ludCB0byBkaWZmZXJlbnQgbG9jYXRpb25zXG5cdFx0XHRcdC8vIHdoZXJlYXMgdGhlIGJhc2VQYWdlVXJsIHdpbGwgYWx3YXlzIHN0YXkgdGhlIHNhbWVcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gZnVsbFVybC5yZXBsYWNlKC9cXCMkLywnJyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0U2hvcnRVcmwodXJsKVxuXHRcdCAqIEVuc3VyZXMgdGhhdCB3ZSBoYXZlIGEgcmVsYXRpdmUgVVJMIGFuZCBub3QgYSBhYnNvbHV0ZSBVUkxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSB1cmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFNob3J0VXJsID0gZnVuY3Rpb24odXJsKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBzaG9ydFVybCA9IHVybCwgYmFzZVVybCA9IEhpc3RvcnkuZ2V0QmFzZVVybCgpLCByb290VXJsID0gSGlzdG9yeS5nZXRSb290VXJsKCk7XG5cblx0XHRcdC8vIFRyaW0gYmFzZVVybFxuXHRcdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0Ly8gV2UgYXJlIGluIGEgaWYgc3RhdGVtZW50IGFzIHdoZW4gcHVzaFN0YXRlIGlzIG5vdCBlbXVsYXRlZFxuXHRcdFx0XHQvLyBUaGUgYWN0dWFsIHVybCB0aGVzZSBzaG9ydCB1cmxzIGFyZSByZWxhdGl2ZSB0byBjYW4gY2hhbmdlXG5cdFx0XHRcdC8vIFNvIHdpdGhpbiB0aGUgc2FtZSBzZXNzaW9uLCB3ZSB0aGUgdXJsIG1heSBlbmQgdXAgc29tZXdoZXJlIGRpZmZlcmVudFxuXHRcdFx0XHRzaG9ydFVybCA9IHNob3J0VXJsLnJlcGxhY2UoYmFzZVVybCwnJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyaW0gcm9vdFVybFxuXHRcdFx0c2hvcnRVcmwgPSBzaG9ydFVybC5yZXBsYWNlKHJvb3RVcmwsJy8nKTtcblxuXHRcdFx0Ly8gRW5zdXJlIHdlIGNhbiBzdGlsbCBkZXRlY3QgaXQgYXMgYSBzdGF0ZVxuXHRcdFx0aWYgKCBIaXN0b3J5LmlzVHJhZGl0aW9uYWxBbmNob3Ioc2hvcnRVcmwpICkge1xuXHRcdFx0XHRzaG9ydFVybCA9ICcuLycrc2hvcnRVcmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFuIEl0XG5cdFx0XHRzaG9ydFVybCA9IHNob3J0VXJsLnJlcGxhY2UoL14oXFwuXFwvKSsvZywnLi8nKS5yZXBsYWNlKC9cXCMkLywnJyk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIHNob3J0VXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldExvY2F0aW9uSHJlZihkb2N1bWVudClcblx0XHQgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcblx0XHQgKiBhY2NvdW50aW5nIGZvciBicm93c2VyIGluY29uc2lzdGVuY2llcywgZXRjLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBVUkwgd2lsbCBiZSBVUkktZW5jb2RlZCBhbmQgd2lsbCBpbmNsdWRlIHRoZSBoYXNoXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZG9jdW1lbnRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmID0gZnVuY3Rpb24oZG9jKSB7XG5cdFx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHRcdC8vIG1vc3Qgb2YgdGhlIHRpbWUsIHRoaXMgd2lsbCBiZSB0cnVlXG5cdFx0XHRpZiAoZG9jLlVSTCA9PT0gZG9jLmxvY2F0aW9uLmhyZWYpXG5cdFx0XHRcdHJldHVybiBkb2MubG9jYXRpb24uaHJlZjtcblxuXHRcdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB3ZWJraXQgVVJJLWRlY29kZSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmXG5cdFx0XHQvLyBidXQgdGhleSBsZWF2ZSBkb2N1bWVudC5VUkwgaW4gYW4gZW5jb2RlZCBzdGF0ZVxuXHRcdFx0aWYgKGRvYy5sb2NhdGlvbi5ocmVmID09PSBkZWNvZGVVUklDb21wb25lbnQoZG9jLlVSTCkpXG5cdFx0XHRcdHJldHVybiBkb2MuVVJMO1xuXG5cdFx0XHQvLyBGRiAzLjYgb25seSB1cGRhdGVzIGRvY3VtZW50LlVSTCB3aGVuIGEgcGFnZSBpcyByZWxvYWRlZFxuXHRcdFx0Ly8gZG9jdW1lbnQubG9jYXRpb24uaHJlZiBpcyB1cGRhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKGRvYy5sb2NhdGlvbi5oYXNoICYmIGRlY29kZVVSSUNvbXBvbmVudChkb2MubG9jYXRpb24uaHJlZi5yZXBsYWNlKC9eW14jXSsvLCBcIlwiKSkgPT09IGRvYy5sb2NhdGlvbi5oYXNoKVxuXHRcdFx0XHRyZXR1cm4gZG9jLmxvY2F0aW9uLmhyZWY7XG5cblx0XHRcdGlmIChkb2MuVVJMLmluZGV4T2YoJyMnKSA9PSAtMSAmJiBkb2MubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJykgIT0gLTEpXG5cdFx0XHRcdHJldHVybiBkb2MubG9jYXRpb24uaHJlZjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRvYy5VUkwgfHwgZG9jLmxvY2F0aW9uLmhyZWY7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBTdGF0ZSBTdG9yYWdlXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0b3JlXG5cdFx0ICogVGhlIHN0b3JlIGZvciBhbGwgc2Vzc2lvbiBzcGVjaWZpYyBkYXRhXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdG9yZSA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pZFRvU3RhdGVcblx0XHQgKiAxLTE6IFN0YXRlIElEIHRvIFN0YXRlIE9iamVjdFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaWRUb1N0YXRlID0gSGlzdG9yeS5pZFRvU3RhdGV8fHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdGF0ZVRvSWRcblx0XHQgKiAxLTE6IFN0YXRlIFN0cmluZyB0byBTdGF0ZSBJRFxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc3RhdGVUb0lkID0gSGlzdG9yeS5zdGF0ZVRvSWR8fHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS51cmxUb0lkXG5cdFx0ICogMS0xOiBTdGF0ZSBVUkwgdG8gU3RhdGUgSURcblx0XHQgKi9cblx0XHRIaXN0b3J5LnVybFRvSWQgPSBIaXN0b3J5LnVybFRvSWR8fHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdG9yZWRTdGF0ZXNcblx0XHQgKiBTdG9yZSB0aGUgc3RhdGVzIGluIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdG9yZWRTdGF0ZXMgPSBIaXN0b3J5LnN0b3JlZFN0YXRlc3x8W107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhdmVkU3RhdGVzXG5cdFx0ICogU2F2ZWQgdGhlIHN0YXRlcyBpbiBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc2F2ZWRTdGF0ZXMgPSBIaXN0b3J5LnNhdmVkU3RhdGVzfHxbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkubm9yYW1saXplU3RvcmUoKVxuXHRcdCAqIE5vcmFtbGl6ZSB0aGUgc3RvcmUgYnkgYWRkaW5nIG5lY2Vzc2FyeSB2YWx1ZXNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm5vcm1hbGl6ZVN0b3JlID0gZnVuY3Rpb24oKXtcblx0XHRcdEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlID0gSGlzdG9yeS5zdG9yZS5pZFRvU3RhdGV8fHt9O1xuXHRcdFx0SGlzdG9yeS5zdG9yZS51cmxUb0lkID0gSGlzdG9yeS5zdG9yZS51cmxUb0lkfHx7fTtcblx0XHRcdEhpc3Rvcnkuc3RvcmUuc3RhdGVUb0lkID0gSGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWR8fHt9O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFN0YXRlKClcblx0XHQgKiBHZXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEsIHRpdGxlIGFuZCB1cmwgb2YgdGhlIGN1cnJlbnQgc3RhdGVcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZyaWVuZGx5XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKGZyaWVuZGx5LGNyZWF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBmcmllbmRseSA9PT0gJ3VuZGVmaW5lZCcgKSB7IGZyaWVuZGx5ID0gdHJ1ZTsgfVxuXHRcdFx0aWYgKCB0eXBlb2YgY3JlYXRlID09PSAndW5kZWZpbmVkJyApIHsgY3JlYXRlID0gdHJ1ZTsgfVxuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dmFyIFN0YXRlID0gSGlzdG9yeS5nZXRMYXN0U2F2ZWRTdGF0ZSgpO1xuXG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdGlmICggIVN0YXRlICYmIGNyZWF0ZSApIHtcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkanVzdFxuXHRcdFx0aWYgKCBmcmllbmRseSApIHtcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmNsb25lT2JqZWN0KFN0YXRlKTtcblx0XHRcdFx0U3RhdGUudXJsID0gU3RhdGUuY2xlYW5Vcmx8fFN0YXRlLnVybDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gU3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0SWRCeVN0YXRlKFN0YXRlKVxuXHRcdCAqIEdldHMgYSBJRCBmb3IgYSBTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SWRCeVN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXG5cdFx0XHQvLyBGZXRjaCBJRFxuXHRcdFx0dmFyIGlkID0gSGlzdG9yeS5leHRyYWN0SWQobmV3U3RhdGUudXJsKSxcblx0XHRcdFx0c3RyO1xuXG5cdFx0XHRpZiAoICFpZCApIHtcblx0XHRcdFx0Ly8gRmluZCBJRCB2aWEgU3RhdGUgU3RyaW5nXG5cdFx0XHRcdHN0ciA9IEhpc3RvcnkuZ2V0U3RhdGVTdHJpbmcobmV3U3RhdGUpO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LnN0YXRlVG9JZFtzdHJdICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRpZCA9IEhpc3Rvcnkuc3RhdGVUb0lkW3N0cl07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBIaXN0b3J5LnN0b3JlLnN0YXRlVG9JZFtzdHJdICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRpZCA9IEhpc3Rvcnkuc3RvcmUuc3RhdGVUb0lkW3N0cl07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gR2VuZXJhdGUgYSBuZXcgSURcblx0XHRcdFx0XHR3aGlsZSAoIHRydWUgKSB7XG5cdFx0XHRcdFx0XHRpZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csJycpO1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pZFRvU3RhdGVbaWRdID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgSGlzdG9yeS5zdG9yZS5pZFRvU3RhdGVbaWRdID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIG5ldyBTdGF0ZSB0byB0aGUgSURcblx0XHRcdFx0XHRIaXN0b3J5LnN0YXRlVG9JZFtzdHJdID0gaWQ7XG5cdFx0XHRcdFx0SGlzdG9yeS5pZFRvU3RhdGVbaWRdID0gbmV3U3RhdGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIElEXG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkubm9ybWFsaXplU3RhdGUoU3RhdGUpXG5cdFx0ICogRXhwYW5kcyBhIFN0YXRlIE9iamVjdFxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlID0gZnVuY3Rpb24ob2xkU3RhdGUpe1xuXHRcdFx0Ly8gVmFyaWFibGVzXG5cdFx0XHR2YXIgbmV3U3RhdGUsIGRhdGFOb3RFbXB0eTtcblxuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0aWYgKCAhb2xkU3RhdGUgfHwgKHR5cGVvZiBvbGRTdGF0ZSAhPT0gJ29iamVjdCcpICkge1xuXHRcdFx0XHRvbGRTdGF0ZSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aWYgKCB0eXBlb2Ygb2xkU3RhdGUubm9ybWFsaXplZCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdHJldHVybiBvbGRTdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRqdXN0XG5cdFx0XHRpZiAoICFvbGRTdGF0ZS5kYXRhIHx8ICh0eXBlb2Ygb2xkU3RhdGUuZGF0YSAhPT0gJ29iamVjdCcpICkge1xuXHRcdFx0XHRvbGRTdGF0ZS5kYXRhID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHRuZXdTdGF0ZSA9IHt9O1xuXHRcdFx0bmV3U3RhdGUubm9ybWFsaXplZCA9IHRydWU7XG5cdFx0XHRuZXdTdGF0ZS50aXRsZSA9IG9sZFN0YXRlLnRpdGxlfHwnJztcblx0XHRcdG5ld1N0YXRlLnVybCA9IEhpc3RvcnkuZ2V0RnVsbFVybChvbGRTdGF0ZS51cmw/ZGVjb2RlVVJJQ29tcG9uZW50KG9sZFN0YXRlLnVybCk6KEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpKTtcblx0XHRcdG5ld1N0YXRlLmhhc2ggPSBIaXN0b3J5LmdldFNob3J0VXJsKG5ld1N0YXRlLnVybCk7XG5cdFx0XHRuZXdTdGF0ZS5kYXRhID0gSGlzdG9yeS5jbG9uZU9iamVjdChvbGRTdGF0ZS5kYXRhKTtcblxuXHRcdFx0Ly8gRmV0Y2ggSURcblx0XHRcdG5ld1N0YXRlLmlkID0gSGlzdG9yeS5nZXRJZEJ5U3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRcdC8vIENsZWFuIHRoZSBVUkxcblx0XHRcdG5ld1N0YXRlLmNsZWFuVXJsID0gbmV3U3RhdGUudXJsLnJlcGxhY2UoL1xcPz9cXCZfc3VpZC4qLywnJyk7XG5cdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5jbGVhblVybDtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgbW9yZSB0aGFuIGp1c3QgYSB1cmxcblx0XHRcdGRhdGFOb3RFbXB0eSA9ICFIaXN0b3J5LmlzRW1wdHlPYmplY3QobmV3U3RhdGUuZGF0YSk7XG5cblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIChuZXdTdGF0ZS50aXRsZSB8fCBkYXRhTm90RW1wdHkpICYmIEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZCAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0Ly8gQWRkIElEIHRvIEhhc2hcblx0XHRcdFx0bmV3U3RhdGUuaGFzaCA9IEhpc3RvcnkuZ2V0U2hvcnRVcmwobmV3U3RhdGUudXJsKS5yZXBsYWNlKC9cXD8/XFwmX3N1aWQuKi8sJycpO1xuXHRcdFx0XHRpZiAoICEvXFw/Ly50ZXN0KG5ld1N0YXRlLmhhc2gpICkge1xuXHRcdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJz8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJyZfc3VpZD0nK25ld1N0YXRlLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIEhhc2hlZCBVUkxcblx0XHRcdG5ld1N0YXRlLmhhc2hlZFVybCA9IEhpc3RvcnkuZ2V0RnVsbFVybChuZXdTdGF0ZS5oYXNoKTtcblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIFVSTCBpZiB3ZSBoYXZlIGEgZHVwbGljYXRlXG5cdFx0XHRpZiAoIChIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSB8fCBIaXN0b3J5LmJ1Z3Muc2FmYXJpUG9sbCkgJiYgSGlzdG9yeS5oYXNVcmxEdXBsaWNhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5oYXNoZWRVcmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpXG5cdFx0ICogQ3JlYXRlcyBhIG9iamVjdCBiYXNlZCBvbiB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBzdGF0ZSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsKXtcblx0XHRcdC8vIEhhc2hpZnlcblx0XHRcdHZhciBTdGF0ZSA9IHtcblx0XHRcdFx0J2RhdGEnOiBkYXRhLFxuXHRcdFx0XHQndGl0bGUnOiB0aXRsZSxcblx0XHRcdFx0J3VybCc6IHVybFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXhwYW5kIHRoZSBTdGF0ZVxuXHRcdFx0U3RhdGUgPSBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG9iamVjdFxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFN0YXRlQnlJZChpZClcblx0XHQgKiBHZXQgYSBzdGF0ZSBieSBpdCdzIFVJRFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24oaWQpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0aWQgPSBTdHJpbmcoaWQpO1xuXG5cdFx0XHQvLyBSZXRyaWV2ZVxuXHRcdFx0dmFyIFN0YXRlID0gSGlzdG9yeS5pZFRvU3RhdGVbaWRdIHx8IEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlW2lkXSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVybiBTdGF0ZVxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIFN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgY2xlYW5lZFN0YXRlLCBzdHI7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRTdGF0ZSA9IEhpc3Rvcnkubm9ybWFsaXplU3RhdGUocGFzc2VkU3RhdGUpO1xuXG5cdFx0XHQvLyBDbGVhblxuXHRcdFx0Y2xlYW5lZFN0YXRlID0ge1xuXHRcdFx0XHRkYXRhOiBTdGF0ZS5kYXRhLFxuXHRcdFx0XHR0aXRsZTogcGFzc2VkU3RhdGUudGl0bGUsXG5cdFx0XHRcdHVybDogcGFzc2VkU3RhdGUudXJsXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0c3RyID0gSlNPTi5zdHJpbmdpZnkoY2xlYW5lZFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIElEXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gcGFzc2VkU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZUlkID0gZnVuY3Rpb24ocGFzc2VkU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBpZDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRpZCA9IFN0YXRlLmlkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShTdGF0ZSlcblx0XHQgKiBDcmVhdGVzIGEgSGFzaCBmb3IgdGhlIFN0YXRlIE9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBoYXNoXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoQnlTdGF0ZSA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgaGFzaDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEhhc2hcblx0XHRcdGhhc2ggPSBTdGF0ZS5oYXNoO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmV4dHJhY3RJZCh1cmxfb3JfaGFzaClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBpdCdzIFVSTCBvciBIYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybF9vcl9oYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXh0cmFjdElkID0gZnVuY3Rpb24gKCB1cmxfb3JfaGFzaCApIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpZCxwYXJ0cyx1cmwsIHRtcDtcblxuXHRcdFx0Ly8gRXh0cmFjdFxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgVVJMIGhhcyBhICMsIHVzZSB0aGUgaWQgZnJvbSBiZWZvcmUgdGhlICNcblx0XHRcdGlmICh1cmxfb3JfaGFzaC5pbmRleE9mKCcjJykgIT0gLTEpXG5cdFx0XHR7XG5cdFx0XHRcdHRtcCA9IHVybF9vcl9oYXNoLnNwbGl0KFwiI1wiKVswXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dG1wID0gdXJsX29yX2hhc2g7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHBhcnRzID0gLyguKilcXCZfc3VpZD0oWzAtOV0rKSQvLmV4ZWModG1wKTtcblx0XHRcdHVybCA9IHBhcnRzID8gKHBhcnRzWzFdfHx1cmxfb3JfaGFzaCkgOiB1cmxfb3JfaGFzaDtcblx0XHRcdGlkID0gcGFydHMgPyBTdHJpbmcocGFydHNbMl18fCcnKSA6ICcnO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZHx8ZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvclxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBhIHRyYWRpdGlvbmFsIGFuY2hvciBvciBub3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsX29yX2hhc2hcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvciA9IGZ1bmN0aW9uKHVybF9vcl9oYXNoKXtcblx0XHRcdC8vIENoZWNrXG5cdFx0XHR2YXIgaXNUcmFkaXRpb25hbCA9ICEoL1tcXC9cXD9cXC5dLy50ZXN0KHVybF9vcl9oYXNoKSk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzVHJhZGl0aW9uYWw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZXh0cmFjdFN0YXRlXG5cdFx0ICogR2V0IGEgU3RhdGUgYnkgaXQncyBVUkwgb3IgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxfb3JfaGFzaFxuXHRcdCAqIEByZXR1cm4ge1N0YXRlfG51bGx9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5leHRyYWN0U3RhdGUgPSBmdW5jdGlvbih1cmxfb3JfaGFzaCxjcmVhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbCwgaWQsIHVybDtcblx0XHRcdGNyZWF0ZSA9IGNyZWF0ZXx8ZmFsc2U7XG5cblx0XHRcdC8vIEZldGNoIFNVSURcblx0XHRcdGlkID0gSGlzdG9yeS5leHRyYWN0SWQodXJsX29yX2hhc2gpO1xuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZldGNoIFNVSUQgcmV0dXJuZWQgbm8gU3RhdGVcblx0XHRcdGlmICggIVN0YXRlICkge1xuXHRcdFx0XHQvLyBGZXRjaCBVUkxcblx0XHRcdFx0dXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKHVybF9vcl9oYXNoKTtcblxuXHRcdFx0XHQvLyBDaGVjayBVUkxcblx0XHRcdFx0aWQgPSBIaXN0b3J5LmdldElkQnlVcmwodXJsKXx8ZmFsc2U7XG5cdFx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgU3RhdGVcblx0XHRcdFx0aWYgKCAhU3RhdGUgJiYgY3JlYXRlICYmICFIaXN0b3J5LmlzVHJhZGl0aW9uYWxBbmNob3IodXJsX29yX2hhc2gpICkge1xuXHRcdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChudWxsLG51bGwsdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJZEJ5VXJsKClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBhIFN0YXRlIFVSTFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SWRCeVVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dmFyIGlkID0gSGlzdG9yeS51cmxUb0lkW3VybF0gfHwgSGlzdG9yeS5zdG9yZS51cmxUb0lkW3VybF0gfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U2F2ZWRTdGF0ZSgpXG5cdFx0ICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0TGFzdFNhdmVkU3RhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV18fHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U3RvcmVkU3RhdGUoKVxuXHRcdCAqIEdldCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldExhc3RTdG9yZWRTdGF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gSGlzdG9yeS5zdG9yZWRTdGF0ZXNbSGlzdG9yeS5zdG9yZWRTdGF0ZXMubGVuZ3RoLTFdfHx1bmRlZmluZWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlXG5cdFx0ICogQ2hlY2tzIGlmIGEgVXJsIHdpbGwgaGF2ZSBhIHVybCBjb25mbGljdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGhhc0R1cGxpY2F0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBoYXNEdXBsaWNhdGUgPSBmYWxzZSxcblx0XHRcdFx0b2xkU3RhdGU7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRvbGRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRoYXNEdXBsaWNhdGUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5pZCAhPT0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGhhc0R1cGxpY2F0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdG9yZVN0YXRlXG5cdFx0ICogU3RvcmUgYSBTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBTdG9yZSB0aGUgU3RhdGVcblx0XHRcdEhpc3RvcnkudXJsVG9JZFtuZXdTdGF0ZS51cmxdID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFB1c2ggdGhlIFN0YXRlXG5cdFx0XHRIaXN0b3J5LnN0b3JlZFN0YXRlcy5wdXNoKEhpc3RvcnkuY2xvbmVPYmplY3QobmV3U3RhdGUpKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5ld1N0YXRlXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSlcblx0XHQgKiBUZXN0cyB0byBzZWUgaWYgdGhlIHN0YXRlIGlzIHRoZSBsYXN0IHN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaXNMYXN0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGlzTGFzdCA9IGZhbHNlLFxuXHRcdFx0XHRuZXdJZCwgb2xkU3RhdGUsIG9sZElkO1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aWYgKCBIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bmV3SWQgPSBuZXdTdGF0ZS5pZDtcblx0XHRcdFx0b2xkU3RhdGUgPSBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKCk7XG5cdFx0XHRcdG9sZElkID0gb2xkU3RhdGUuaWQ7XG5cblx0XHRcdFx0Ly8gQ2hlY2tcblx0XHRcdFx0aXNMYXN0ID0gKG5ld0lkID09PSBvbGRJZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzTGFzdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlU3RhdGVcblx0XHQgKiBQdXNoIGEgU3RhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBDaGVjayBIYXNoXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHVzaCB0aGUgU3RhdGVcblx0XHRcdEhpc3Rvcnkuc2F2ZWRTdGF0ZXMucHVzaChIaXN0b3J5LmNsb25lT2JqZWN0KG5ld1N0YXRlKSk7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoKVxuXHRcdCAqIEdldHMgYSBzdGF0ZSBieSB0aGUgaW5kZXhcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4XG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbDtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgbGFzdCBpbnNlcnRlZFxuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgZW5kXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5zYXZlZFN0YXRlc1tIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gR2V0IGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbaW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gU3RhdGVcblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4KClcblx0XHQgKiBHZXRzIHRoZSBjdXJyZW50IGluZGV4XG5cdFx0ICogQHJldHVybiAoaW50ZWdlcilcblx0XHQqL1xuXHRcdEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpbmRleCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIE5vIHN0YXRlcyBzYXZlZFxuXHRcdFx0aWYoSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGggPCAxKSB7XG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpbmRleCA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXMubGVuZ3RoLTE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fTtcblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSGFzaCBIZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2goKVxuXHRcdCAqIEBwYXJhbSB7TG9jYXRpb249fSBsb2NhdGlvblxuXHRcdCAqIEdldHMgdGhlIGN1cnJlbnQgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIE5vdGU6IHVubGlrZSBsb2NhdGlvbi5oYXNoLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIHRoZSBlc2NhcGVkIGhhc2ggaW4gYWxsIGJyb3dzZXJzXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaCA9IGZ1bmN0aW9uKGRvYyl7XG5cdFx0XHR2YXIgdXJsID0gSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoZG9jKSxcblx0XHRcdFx0aGFzaDtcblx0XHRcdGhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpO1xuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkudW5lc2NhcGVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYW5kIFVuZXNjYXBlIGEgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkudW5lc2NhcGVIYXNoID0gZnVuY3Rpb24oaGFzaCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgcmVzdWx0ID0gSGlzdG9yeS5ub3JtYWxpemVIYXNoKGhhc2gpO1xuXG5cdFx0XHQvLyBVbmVzY2FwZSBoYXNoXG5cdFx0XHRyZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JtYWxpemVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYSBoYXNoIGFjcm9zcyBicm93c2Vyc1xuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHRIaXN0b3J5Lm5vcm1hbGl6ZUhhc2ggPSBmdW5jdGlvbihoYXNoKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciByZXN1bHQgPSBoYXNoLnJlcGxhY2UoL1teI10qIy8sJycpLnJlcGxhY2UoLyMuKi8sICcnKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zZXRIYXNoKGhhc2gpXG5cdFx0ICogU2V0cyB0aGUgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldEhhc2ggPSBmdW5jdGlvbihoYXNoLHF1ZXVlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgcGFnZVVybDtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5zZXRIYXNoLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9nXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2V0SGFzaDogY2FsbGVkJyxoYXNoKTtcblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaGFzaCBpcyBhIHN0YXRlXG5cdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGhhc2gsdHJ1ZSk7XG5cdFx0XHRpZiAoIFN0YXRlICYmICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0Ly8gSGFzaCBpcyBhIHN0YXRlIHNvIHNraXAgdGhlIHNldEhhc2hcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IEhhc2ggaXMgYSBzdGF0ZSBzbyBza2lwcGluZyB0aGUgaGFzaCBzZXQgd2l0aCBhIGRpcmVjdCBwdXNoU3RhdGUgY2FsbCcsYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBQdXNoU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUoU3RhdGUuZGF0YSxTdGF0ZS50aXRsZSxTdGF0ZS51cmwsZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICE9PSBoYXNoICkge1xuXHRcdFx0XHQvLyBIYXNoIGlzIGEgcHJvcGVyIGhhc2gsIHNvIGFwcGx5IGl0XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGJyb3dzZXIgYnVnc1xuXHRcdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5zZXRIYXNoICkge1xuXHRcdFx0XHRcdC8vIEZpeCBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NjI0OVxuXG5cdFx0XHRcdFx0Ly8gRmV0Y2ggdGhlIGJhc2UgcGFnZVxuXHRcdFx0XHRcdHBhZ2VVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKTtcblxuXHRcdFx0XHRcdC8vIFNhZmFyaSBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLHBhZ2VVcmwrJyMnK2hhc2gsZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcm1hbCBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0ZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGhhc2g7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVzY2FwZSgpXG5cdFx0ICogbm9ybWFsaXplIGFuZCBFc2NhcGUgYSBIYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXNjYXBlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHJlc3VsdCA9IEhpc3Rvcnkubm9ybWFsaXplSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gRXNjYXBlIGhhc2hcblx0XHRcdHJlc3VsdCA9IHdpbmRvdy5lbmNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gSUU2IEVzY2FwZSBCdWdcblx0XHRcdGlmICggIUhpc3RvcnkuYnVncy5oYXNoRXNjYXBlICkge1xuXHRcdFx0XHQvLyBSZXN0b3JlIGNvbW1vbiBwYXJ0c1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHRcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlMjEvZywnIScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcJTI2L2csJyYnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXCUzRC9nLCc9Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlM0YvZywnPycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpXG5cdFx0ICogRXh0cmFjdHMgdGhlIEhhc2ggZnJvbSBhIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaEJ5VXJsID0gZnVuY3Rpb24odXJsKXtcblx0XHRcdC8vIEV4dHJhY3QgdGhlIGhhc2hcblx0XHRcdHZhciBoYXNoID0gU3RyaW5nKHVybClcblx0XHRcdFx0LnJlcGxhY2UoLyhbXiNdKikjPyhbXiNdKikjPyguKikvLCAnJDInKVxuXHRcdFx0XHQ7XG5cblx0XHRcdC8vIFVuZXNjYXBlIGhhc2hcblx0XHRcdGhhc2ggPSBIaXN0b3J5LnVuZXNjYXBlSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGhhc2hcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNldFRpdGxlKHRpdGxlKVxuXHRcdCAqIEFwcGxpZXMgdGhlIHRpdGxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldFRpdGxlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHRpdGxlID0gbmV3U3RhdGUudGl0bGUsXG5cdFx0XHRcdGZpcnN0U3RhdGU7XG5cblx0XHRcdC8vIEluaXRpYWxcblx0XHRcdGlmICggIXRpdGxlICkge1xuXHRcdFx0XHRmaXJzdFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoMCk7XG5cdFx0XHRcdGlmICggZmlyc3RTdGF0ZSAmJiBmaXJzdFN0YXRlLnVybCA9PT0gbmV3U3RhdGUudXJsICkge1xuXHRcdFx0XHRcdHRpdGxlID0gZmlyc3RTdGF0ZS50aXRsZXx8SGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJylbMF0uaW5uZXJIVE1MID0gdGl0bGUucmVwbGFjZSgnPCcsJyZsdDsnKS5yZXBsYWNlKCc+JywnJmd0OycpLnJlcGxhY2UoJyAmICcsJyAmYW1wOyAnKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoICggRXhjZXB0aW9uICkgeyB9XG5cdFx0XHRkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBRdWV1ZWluZ1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5xdWV1ZXNcblx0XHQgKiBUaGUgbGlzdCBvZiBxdWV1ZXMgdG8gdXNlXG5cdFx0ICogRmlyc3QgSW4sIEZpcnN0IE91dFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmJ1c3kodmFsdWUpXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBbb3B0aW9uYWxdXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gYnVzeVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVzeSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5idXN5OiBjaGFuZ2luZyBbJysoSGlzdG9yeS5idXN5LmZsYWd8fGZhbHNlKSsnXSB0byBbJysodmFsdWV8fGZhbHNlKSsnXScsIEhpc3RvcnkucXVldWVzLmxlbmd0aCk7XG5cdFx0XHRcdEhpc3RvcnkuYnVzeS5mbGFnID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZWZhdWx0XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIEhpc3RvcnkuYnVzeS5mbGFnID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUXVldWVcblx0XHRcdGlmICggIUhpc3RvcnkuYnVzeS5mbGFnICkge1xuXHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdGNsZWFyVGltZW91dChIaXN0b3J5LmJ1c3kudGltZW91dCk7XG5cdFx0XHRcdHZhciBmaXJlTmV4dCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGksIHF1ZXVlLCBpdGVtO1xuXHRcdFx0XHRcdGlmICggSGlzdG9yeS5idXN5LmZsYWcgKSByZXR1cm47XG5cdFx0XHRcdFx0Zm9yICggaT1IaXN0b3J5LnF1ZXVlcy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkgKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZSA9IEhpc3RvcnkucXVldWVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCBxdWV1ZS5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBIaXN0b3J5LmJ1c3kuZmxhZztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5idXN5LmZsYWdcblx0XHQgKi9cblx0XHRIaXN0b3J5LmJ1c3kuZmxhZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pXG5cdFx0ICogRmlyZSBhIFF1ZXVlIEl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHRcdCAqIEByZXR1cm4ge01peGVkfSByZXN1bHRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmZpcmVRdWV1ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdHJldHVybiBpdGVtLmNhbGxiYWNrLmFwcGx5KGl0ZW0uc2NvcGV8fEhpc3RvcnksaXRlbS5hcmdzfHxbXSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkucHVzaFF1ZXVlKGNhbGxiYWNrLGFyZ3MpXG5cdFx0ICogQWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gW3Njb3BlLGNhbGxiYWNrLGFyZ3MscXVldWVdXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5wdXNoUXVldWUgPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vIFByZXBhcmUgdGhlIHF1ZXVlXG5cdFx0XHRIaXN0b3J5LnF1ZXVlc1tpdGVtLnF1ZXVlfHwwXSA9IEhpc3RvcnkucXVldWVzW2l0ZW0ucXVldWV8fDBdfHxbXTtcblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBxdWV1ZVxuXHRcdFx0SGlzdG9yeS5xdWV1ZXNbaXRlbS5xdWV1ZXx8MF0ucHVzaChpdGVtKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnF1ZXVlIChpdGVtLHF1ZXVlKSwgKGZ1bmMscXVldWUpLCAoZnVuYyksIChpdGVtKVxuXHRcdCAqIEVpdGhlciBmaXJzIHRoZSBpdGVtIG5vdyBpZiBub3QgYnVzeSwgb3IgYWRkcyBpdCB0byB0aGUgcXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnF1ZXVlID0gZnVuY3Rpb24oaXRlbSxxdWV1ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRpdGVtID0ge1xuXHRcdFx0XHRcdGNhbGxiYWNrOiBpdGVtXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBxdWV1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdGl0ZW0ucXVldWUgPSBxdWV1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEhpc3RvcnkuZmlyZVF1ZXVlSXRlbShpdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmNsZWFyUXVldWUoKVxuXHRcdCAqIENsZWFycyB0aGUgUXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmNsZWFyUXVldWUgPSBmdW5jdGlvbigpe1xuXHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIElFIEJ1ZyBGaXhcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RhdGVDaGFuZ2VkXG5cdFx0ICogU3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBkb3VibGUgY2hlY2sgd2FzIGluaXRpYWxpc2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdGF0ZUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZG91YmxlQ2hlY2tlclxuXHRcdCAqIENvbnRhaW5zIHRoZSB0aW1lb3V0IHVzZWQgZm9yIHRoZSBkb3VibGUgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKVxuXHRcdCAqIENvbXBsZXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRIaXN0b3J5LnN0YXRlQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKVxuXHRcdCAqIENsZWFyIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2xlYXJcblx0XHRcdGlmICggSGlzdG9yeS5kb3VibGVDaGVja2VyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoSGlzdG9yeS5kb3VibGVDaGVja2VyKTtcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kb3VibGVDaGVjaygpXG5cdFx0ICogQ3JlYXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrID0gZnVuY3Rpb24odHJ5QWdhaW4pe1xuXHRcdFx0Ly8gUmVzZXRcblx0XHRcdEhpc3Rvcnkuc3RhdGVDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gRml4IElFNixJRTcgYnVnIHdoZXJlIGNhbGxpbmcgaGlzdG9yeS5iYWNrIG9yIGhpc3RvcnkuZm9yd2FyZCBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2UgdGhlIGhhc2ggKHdoZXJlYXMgZG9pbmcgaXQgbWFudWFsbHkgZG9lcylcblx0XHRcdC8vIEZpeCBTYWZhcmkgNSBidWcgd2hlcmUgc29tZXRpbWVzIHRoZSBzdGF0ZSBkb2VzIG5vdCBjaGFuZ2U6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00Mjk0MFxuXHRcdFx0aWYgKCBIaXN0b3J5LmJ1Z3MuaWVEb3VibGVDaGVjayApIHtcblx0XHRcdFx0Ly8gQXBwbHkgQ2hlY2tcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gc2V0VGltZW91dChcblx0XHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja0NsZWFyKCk7XG5cdFx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LnN0YXRlQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmRvdWJsZUNoZWNrOiBTdGF0ZSBoYXMgbm90IHlldCBjaGFuZ2VkLCB0cnlpbmcgYWdhaW4nLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1BdHRlbXB0XG5cdFx0XHRcdFx0XHRcdHRyeUFnYWluKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFNhZmFyaSBCdWcgRml4XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbCgpXG5cdFx0ICogUG9sbCB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0hpc3Rvcnl9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYWZhcmlTdGF0ZVBvbGwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUG9sbCB0aGUgVVJMXG5cblx0XHRcdC8vIEdldCB0aGUgTGFzdCBTdGF0ZSB3aGljaCBoYXMgdGhlIG5ldyBVUkxcblx0XHRcdHZhclxuXHRcdFx0XHR1cmxTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLFxuXHRcdFx0XHRuZXdTdGF0ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGEgZGlmZmVyZW5jZVxuXHRcdFx0aWYgKCAhSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKHVybFN0YXRlKSApIHtcblx0XHRcdFx0bmV3U3RhdGUgPSB1cmxTdGF0ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdlIGhhdmUgYSBzdGF0ZSB3aXRoIHRoYXQgdXJsXG5cdFx0XHQvLyBJZiBub3QgY3JlYXRlIGl0XG5cdFx0XHRpZiAoICFuZXdTdGF0ZSApIHtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbDogbmV3Jyk7XG5cdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSB0aGUgTmV3IFN0YXRlXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsOiB0cmlnZ2VyJyk7XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFN0YXRlIEFsaWFzZXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuYmFjayhxdWV1ZSlcblx0XHQgKiBTZW5kIHRoZSBicm93c2VyIGhpc3RvcnkgYmFjayBvbmUgaXRlbVxuXHRcdCAqIEBwYXJhbSB7SW50ZWdlcn0gcXVldWUgW29wdGlvbmFsXVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYmFjayA9IGZ1bmN0aW9uKHF1ZXVlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5iYWNrOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuYmFjazogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LmJhY2ssXG5cdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHQvLyBGaXggY2VydGFpbiBicm93c2VyIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBzdGF0ZSBmcm9tIGNoYW5naW5nXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdEhpc3RvcnkuYmFjayhmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gR28gYmFja1xuXHRcdFx0aGlzdG9yeS5nbygtMSk7XG5cblx0XHRcdC8vIEVuZCBiYWNrIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmZvcndhcmQocXVldWUpXG5cdFx0ICogU2VuZCB0aGUgYnJvd3NlciBoaXN0b3J5IGZvcndhcmQgb25lIGl0ZW1cblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmZvcndhcmQgPSBmdW5jdGlvbihxdWV1ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZm9yd2FyZDogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmZvcndhcmQ6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5mb3J3YXJkLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gRml4IGNlcnRhaW4gYnJvd3NlciBidWdzIHRoYXQgcHJldmVudCB0aGUgc3RhdGUgZnJvbSBjaGFuZ2luZ1xuXHRcdFx0SGlzdG9yeS5kb3VibGVDaGVjayhmdW5jdGlvbigpe1xuXHRcdFx0XHRIaXN0b3J5LmZvcndhcmQoZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEdvIGZvcndhcmRcblx0XHRcdGhpc3RvcnkuZ28oMSk7XG5cblx0XHRcdC8vIEVuZCBmb3J3YXJkIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdvKGluZGV4LHF1ZXVlKVxuXHRcdCAqIFNlbmQgdGhlIGJyb3dzZXIgaGlzdG9yeSBiYWNrIG9yIGZvcndhcmQgaW5kZXggdGltZXNcblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmdvID0gZnVuY3Rpb24oaW5kZXgscXVldWUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmdvOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIGluZGV4ID4gMCApIHtcblx0XHRcdFx0Ly8gRm9yd2FyZFxuXHRcdFx0XHRmb3IgKCBpPTE7IGk8PWluZGV4OyArK2kgKSB7XG5cdFx0XHRcdFx0SGlzdG9yeS5mb3J3YXJkKHF1ZXVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0Ly8gQmFja3dhcmRcblx0XHRcdFx0Zm9yICggaT0tMTsgaT49aW5kZXg7IC0taSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LmJhY2socXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmdvOiBIaXN0b3J5LmdvIHJlcXVpcmVzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBwYXNzZWQuJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhUTUw1IFN0YXRlIFN1cHBvcnRcblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBQcm92aWRlIFNrZWxldG9uIGZvciBIVE1MNCBCcm93c2Vyc1xuXHRcdFx0ICovXG5cblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKXt9O1xuXHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUgPSBIaXN0b3J5LnB1c2hTdGF0ZXx8ZW1wdHlGdW5jdGlvbjtcblx0XHRcdEhpc3RvcnkucmVwbGFjZVN0YXRlID0gSGlzdG9yeS5yZXBsYWNlU3RhdGV8fGVtcHR5RnVuY3Rpb247XG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cdFx0Ly8gTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGVsc2Uge1xuXHRcdFx0Lypcblx0XHRcdCAqIFVzZSBuYXRpdmUgSFRNTDUgSGlzdG9yeSBBUEkgSW1wbGVtZW50YXRpb25cblx0XHRcdCAqL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3Rvcnkub25Qb3BTdGF0ZShldmVudCxleHRyYSlcblx0XHRcdCAqIFJlZnJlc2ggdGhlIEN1cnJlbnQgU3RhdGVcblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5vblBvcFN0YXRlID0gZnVuY3Rpb24oZXZlbnQsZXh0cmEpe1xuXHRcdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRcdHZhciBzdGF0ZUlkID0gZmFsc2UsIG5ld1N0YXRlID0gZmFsc2UsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGU7XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIGRvdWJsZSBjaGVja1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKTtcblxuXHRcdFx0XHQvLyBDaGVjayBmb3IgYSBIYXNoLCBhbmQgaGFuZGxlIGFwcG9yaWF0bHlcblx0XHRcdFx0Y3VycmVudEhhc2ggPSBIaXN0b3J5LmdldEhhc2goKTtcblx0XHRcdFx0aWYgKCBjdXJyZW50SGFzaCApIHtcblx0XHRcdFx0XHQvLyBFeHBhbmQgSGFzaFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGN1cnJlbnRIYXNofHxIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpLHRydWUpO1xuXHRcdFx0XHRcdGlmICggY3VycmVudFN0YXRlICkge1xuXHRcdFx0XHRcdFx0Ly8gV2Ugd2VyZSBhYmxlIHRvIHBhcnNlIGl0LCBpdCBtdXN0IGJlIGEgU3RhdGUhXG5cdFx0XHRcdFx0XHQvLyBMZXQncyBmb3J3YXJkIHRvIHJlcGxhY2VTdGF0ZVxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHN0YXRlIGFuY2hvcicsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLmRhdGEsIGN1cnJlbnRTdGF0ZS50aXRsZSwgY3VycmVudFN0YXRlLnVybCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFRyYWRpdGlvbmFsIEFuY2hvclxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHRyYWRpdGlvbmFsIGFuY2hvcicsIGN1cnJlbnRIYXNoKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnYW5jaG9yY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdlIGRvbid0IGNhcmUgZm9yIGhhc2hlc1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5zdXJlXG5cdFx0XHRcdHN0YXRlSWQgPSBIaXN0b3J5LkFkYXB0ZXIuZXh0cmFjdEV2ZW50RGF0YSgnc3RhdGUnLGV2ZW50LGV4dHJhKSB8fCBmYWxzZTtcblxuXHRcdFx0XHQvLyBGZXRjaCBTdGF0ZVxuXHRcdFx0XHRpZiAoIHN0YXRlSWQgKSB7XG5cdFx0XHRcdFx0Ly8gVmFuaWxsYTogQmFjay9mb3J3YXJkIGJ1dHRvbiB3YXMgdXNlZFxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SWQoc3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkICkge1xuXHRcdFx0XHRcdC8vIFZhbmlsbGE6IEEgbmV3IHN0YXRlIHdhcyBwdXNoZWQsIGFuZCBwb3BzdGF0ZSB3YXMgY2FsbGVkIG1hbnVhbGx5XG5cdFx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbCBTdGF0ZVxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgU3RhdGUgZGlkIG5vdCBleGlzdCBpbiBvdXIgc3RvcmVcblx0XHRcdFx0aWYgKCAhbmV3U3RhdGUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVnZW5lcmF0ZSB0aGUgU3RhdGVcblx0XHRcdFx0XHRuZXdTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QobnVsbCxudWxsLEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xlYW5cblx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgc3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFRoZXJlIGhhcyBiZWVuIG5vIGNoYW5nZSAoanVzdCB0aGUgcGFnZSdzIGhhc2ggaGFzIGZpbmFsbHkgcHJvcGFnYXRlZClcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25Qb3BTdGF0ZTogbm8gY2hhbmdlJywgbmV3U3RhdGUsIEhpc3Rvcnkuc2F2ZWRTdGF0ZXMpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIFN0YXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdEhpc3Rvcnkuc2F2ZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBGb3JjZSB1cGRhdGUgb2YgdGhlIHRpdGxlXG5cdFx0XHRcdEhpc3Rvcnkuc2V0VGl0bGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZpcmUgT3VyIEV2ZW50XG5cdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnc3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ3BvcHN0YXRlJyxIaXN0b3J5Lm9uUG9wU3RhdGUpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucHVzaFN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogQWRkIGEgbmV3IFN0YXRlIHRvIHRoZSBoaXN0b3J5IG9iamVjdCwgYmVjb21lIGl0LCBhbmQgdHJpZ2dlciBvbnBvcHN0YXRlXG5cdFx0XHQgKiBXZSBoYXZlIHRvIHRyaWdnZXIgZm9yIEhUTUw0IGNvbXBhdGliaWxpdHlcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwscXVldWUpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHRoZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCkgJiYgSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIGRvZXMgbm90IHN1cHBvcnQgc3RhdGVzIHdpdGggZnJhZ2VtZW50LWlkZW50aWZpZXJzIChoYXNoZXMvYW5jaG9ycykuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkucHVzaFN0YXRlLFxuXHRcdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0dmFyIG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybCk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaXRcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFdvbid0IGJlIGEgY2hhbmdlXG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnN0b3JlU3RhdGUobmV3U3RhdGUpO1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdFx0XHQvLyBQdXNoIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdGhpc3RvcnkucHVzaFN0YXRlKG5ld1N0YXRlLmlkLG5ld1N0YXRlLnRpdGxlLG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdFx0XHQvLyBGaXJlIEhUTUw1IEV2ZW50XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdwb3BzdGF0ZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5kIHB1c2hTdGF0ZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLHRpdGxlLHVybClcblx0XHRcdCAqIFJlcGxhY2UgdGhlIFN0YXRlIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSAmJiBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnZW1lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5yZXBsYWNlU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHR2YXIgbmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpdFxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly8gV29uJ3QgYmUgYSBjaGFuZ2Vcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHRcdC8vIFB1c2ggdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUobmV3U3RhdGUuaWQsbmV3U3RhdGUudGl0bGUsbmV3U3RhdGUudXJsKTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbmQgcmVwbGFjZVN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0fSAvLyAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBJbml0aWFsaXNlXG5cblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWxpemVcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEZWZhdWx0IExvYWRcblx0XHRcdEhpc3Rvcnkuc3RvcmUgPSB7fTtcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDbGVhciBJbnRlcnZhbHMgb24gZXhpdCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdyxcInVubG9hZFwiLEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHMpO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBpbml0aWFsIFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUoSGlzdG9yeS5zdG9yZVN0YXRlKEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksdHJ1ZSkpKTtcblxuXHRcdC8qKlxuXHRcdCAqIEJpbmQgZm9yIFNhdmluZyBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBXaGVuIHRoZSBwYWdlIGlzIGNsb3NlZFxuXHRcdFx0SGlzdG9yeS5vblVubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0dmFyXHRjdXJyZW50U3RvcmUsIGl0ZW0sIGN1cnJlbnRTdG9yZVN0cmluZztcblxuXHRcdFx0XHQvLyBGZXRjaFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbnN1cmVcblx0XHRcdFx0Y3VycmVudFN0b3JlLmlkVG9TdGF0ZSA9IGN1cnJlbnRTdG9yZS5pZFRvU3RhdGUgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkID0gY3VycmVudFN0b3JlLnVybFRvSWQgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS5zdGF0ZVRvSWQgPSBjdXJyZW50U3RvcmUuc3RhdGVUb0lkIHx8IHt9O1xuXG5cdFx0XHRcdC8vIFN5bmNcblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LmlkVG9TdGF0ZSApIHtcblx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LmlkVG9TdGF0ZS5oYXNPd25Qcm9wZXJ0eShpdGVtKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50U3RvcmUuaWRUb1N0YXRlW2l0ZW1dID0gSGlzdG9yeS5pZFRvU3RhdGVbaXRlbV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LnVybFRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS51cmxUb0lkLmhhc093blByb3BlcnR5KGl0ZW0pICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkW2l0ZW1dID0gSGlzdG9yeS51cmxUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGl0ZW0gaW4gSGlzdG9yeS5zdGF0ZVRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS5zdGF0ZVRvSWQuaGFzT3duUHJvcGVydHkoaXRlbSkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlLnN0YXRlVG9JZFtpdGVtXSA9IEhpc3Rvcnkuc3RhdGVUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmUgPSBjdXJyZW50U3RvcmU7XG5cdFx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblxuXHRcdFx0XHQvLyBJbiBTYWZhcmksIGdvaW5nIGludG8gUHJpdmF0ZSBCcm93c2luZyBtb2RlIGNhdXNlcyB0aGVcblx0XHRcdFx0Ly8gU2Vzc2lvbiBTdG9yYWdlIG9iamVjdCB0byBzdGlsbCBleGlzdCBidXQgaWYgeW91IHRyeSBhbmQgdXNlXG5cdFx0XHRcdC8vIG9yIHNldCBhbnkgcHJvcGVydHkvZnVuY3Rpb24gb2YgaXQgaXQgdGhyb3dzIHRoZSBleGNlcHRpb25cblx0XHRcdFx0Ly8gXCJRVU9UQV9FWENFRURFRF9FUlI6IERPTSBFeGNlcHRpb24gMjI6IEFuIGF0dGVtcHQgd2FzIG1hZGUgdG9cblx0XHRcdFx0Ly8gYWRkIHNvbWV0aGluZyB0byBzdG9yYWdlIHRoYXQgZXhjZWVkZWQgdGhlIHF1b3RhLlwiIGluZmluaXRlbHlcblx0XHRcdFx0Ly8gZXZlcnkgc2Vjb25kLlxuXHRcdFx0XHRjdXJyZW50U3RvcmVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50U3RvcmUpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFN0b3JlXG5cdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBXb3JrYXJvdW5kIGZvciBhIGJ1ZyBzZWVuIG9uIGlQYWRzLiBTb21ldGltZXMgdGhlIHF1b3RhIGV4Y2VlZGVkIGVycm9yIGNvbWVzIHVwIGFuZCBzaW1wbHlcblx0XHRcdFx0XHQvLyByZW1vdmluZy9yZXNldHRpbmcgdGhlIHN0b3JhZ2UgY2FuIHdvcmsuXG5cdFx0XHRcdFx0aWYgKC9RVU9UQV9FWENFRURFRF9FUlIvLnRlc3QoZS5tZXNzYWdlKSkge1xuXHRcdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnSGlzdG9yeS5zdG9yZScpO1xuXHRcdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGb3IgSW50ZXJuZXQgRXhwbG9yZXJcblx0XHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0LnB1c2goc2V0SW50ZXJ2YWwoSGlzdG9yeS5vblVubG9hZCxIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbCkpO1xuXG5cdFx0XHQvLyBGb3IgT3RoZXIgQnJvd3NlcnNcblx0XHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdywnYmVmb3JldW5sb2FkJyxIaXN0b3J5Lm9uVW5sb2FkKTtcblx0XHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdywndW5sb2FkJyxIaXN0b3J5Lm9uVW5sb2FkKTtcblxuXHRcdFx0Ly8gQm90aCBhcmUgZW5hYmxlZCBmb3IgY29uc2lzdGVuY3lcblx0XHR9XG5cblx0XHQvLyBOb24tTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGlmICggIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0Ly8gQmUgYXdhcmUsIHRoZSBmb2xsb3dpbmcgaXMgb25seSBmb3IgbmF0aXZlIHB1c2hTdGF0ZSBpbXBsZW1lbnRhdGlvbnNcblx0XHRcdC8vIElmIHlvdSBhcmUgd2FudGluZyB0byBpbmNsdWRlIHNvbWV0aGluZyBmb3IgYWxsIGJyb3dzZXJzXG5cdFx0XHQvLyBUaGVuIGluY2x1ZGUgaXQgYWJvdmUgdGhpcyBpZiBibG9ja1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHVwIFNhZmFyaSBGaXhcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBIaXN0b3J5LmJ1Z3Muc2FmYXJpUG9sbCApIHtcblx0XHRcdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QucHVzaChzZXRJbnRlcnZhbChIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbCwgSGlzdG9yeS5vcHRpb25zLnNhZmFyaVBvbGxJbnRlcnZhbCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEVuc3VyZSBDcm9zcyBCcm93c2VyIENvbXBhdGliaWxpdHlcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBuYXZpZ2F0b3IudmVuZG9yID09PSAnQXBwbGUgQ29tcHV0ZXIsIEluYy4nIHx8IChuYXZpZ2F0b3IuYXBwQ29kZU5hbWV8fCcnKSA9PT0gJ01vemlsbGEnICkge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogRml4IFNhZmFyaSBIYXNoQ2hhbmdlIElzc3VlXG5cdFx0XHRcdCAqL1xuXG5cdFx0XHRcdC8vIFNldHVwIEFsaWFzXG5cdFx0XHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdywnaGFzaGNoYW5nZScsZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEluaXRpYWxpc2UgQWxpYXNcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2goKSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIub25Eb21Mb2FkKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ2hhc2hjaGFuZ2UnKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSAvLyAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXG5cdH07IC8vIEhpc3RvcnkuaW5pdENvcmVcblxuXHQvLyBUcnkgdG8gSW5pdGlhbGlzZSBIaXN0b3J5XG5cdGlmICghSGlzdG9yeS5vcHRpb25zIHx8ICFIaXN0b3J5Lm9wdGlvbnMuZGVsYXlJbml0KSB7XG5cdFx0SGlzdG9yeS5pbml0KCk7XG5cdH1cblxufSkod2luZG93KTtcbiIsIi8qKlxuICogQHByZXNlcnZlIGpMYXlvdXQgQm9yZGVyIExheW91dCAtIEphdmFTY3JpcHQgTGF5b3V0IEFsZ29yaXRobXMgdjAuNFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBuZXcgQlNEIExpY2Vuc2UuXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDA5LCBCcmFtIFN0ZWluXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4vKmdsb2JhbCBqTGF5b3V0OnRydWUgKi9cbihmdW5jdGlvbiAoKSB7XG5cdC8vIEN1c3RvbWlzZWRcblx0Ly8gRGVmaW5pbmcgZ2xvYmFsIGFsaWFzIGJlY2F1c2UgQnJvd3NlcmlmeSBhZGRzICd1c2Ugc3RyaWN0J1xuXHQvLyB3aGljaCB0aHJvd3MgYSBydW50aW1lIGVycm9yIGlmIGdsb2JhbHMgYXJlIHVuZGVmaW5lZCBhbmQgbm90IGRlY2xhcmVkLlxuXG5cdC8vIE9yaWdpbmFsXG5cdC8vIGpMYXlvdXQgPSAodHlwZW9mIGpMYXlvdXQgPT09ICd1bmRlZmluZWQnKSA/IHt9IDogakxheW91dDtcblxuXHR3aW5kb3cuakxheW91dCA9ICh0eXBlb2Ygd2luZG93LmpMYXlvdXQgPT09ICd1bmRlZmluZWQnKSA/IHt9IDogd2luZG93LmpMYXlvdXQ7XG5cblx0akxheW91dC5ib3JkZXIgPSBmdW5jdGlvbiAoc3BlYykge1xuXHRcdHZhciBteSA9IHt9LFxuXHRcdFx0dGhhdCA9IHt9LFxuXHRcdFx0ZWFzdCA9IHNwZWMuZWFzdCxcblx0XHRcdHdlc3QgPSBzcGVjLndlc3QsXG5cdFx0XHRub3J0aCA9IHNwZWMubm9ydGgsXG5cdFx0XHRzb3V0aCA9IHNwZWMuc291dGgsXG5cdFx0XHRjZW50ZXIgPSBzcGVjLmNlbnRlcjtcblxuXHRcdG15LmhnYXAgPSBzcGVjLmhnYXAgfHwgMDtcblx0XHRteS52Z2FwID0gc3BlYy52Z2FwIHx8IDA7XG5cblx0XHR0aGF0Lml0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHRpZiAoZWFzdCkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKGVhc3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2VzdCkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKHdlc3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9ydGgpIHtcblx0XHRcdFx0aXRlbXMucHVzaChub3J0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzb3V0aCkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKHNvdXRoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRpdGVtcy5wdXNoKGNlbnRlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fTtcdFx0XG5cblx0XHR0aGF0LmxheW91dCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0XHRcdHZhciBzaXplID0gY29udGFpbmVyLmJvdW5kcygpLFxuXHRcdFx0XHRpbnNldHMgPSBjb250YWluZXIuaW5zZXRzKCksXG5cdFx0XHRcdHRvcCA9IGluc2V0cy50b3AsXG5cdFx0XHRcdGJvdHRvbSA9IHNpemUuaGVpZ2h0IC0gaW5zZXRzLmJvdHRvbSxcblx0XHRcdFx0bGVmdCA9IGluc2V0cy5sZWZ0LFxuXHRcdFx0XHRyaWdodCA9IHNpemUud2lkdGggLSBpbnNldHMucmlnaHQsXG5cdFx0XHRcdHRtcDtcblxuXHRcdFx0aWYgKG5vcnRoICYmIG5vcnRoLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdHRtcCA9IG5vcnRoLnByZWZlcnJlZFNpemUoKTtcblx0XHRcdFx0bm9ydGguYm91bmRzKHsneCc6IGxlZnQsICd5JzogdG9wLCAnd2lkdGgnOiByaWdodCAtIGxlZnQsICdoZWlnaHQnOiB0bXAuaGVpZ2h0fSk7XG5cdFx0XHRcdG5vcnRoLmRvTGF5b3V0KCk7XG5cblx0XHRcdFx0dG9wICs9IHRtcC5oZWlnaHQgKyBteS52Z2FwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNvdXRoICYmIHNvdXRoLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdHRtcCA9IHNvdXRoLnByZWZlcnJlZFNpemUoKTtcblx0XHRcdFx0c291dGguYm91bmRzKHsneCc6IGxlZnQsICd5JzogYm90dG9tIC0gdG1wLmhlaWdodCwgJ3dpZHRoJzogcmlnaHQgLSBsZWZ0LCAnaGVpZ2h0JzogdG1wLmhlaWdodH0pO1xuXHRcdFx0XHRzb3V0aC5kb0xheW91dCgpO1xuXG5cdFx0XHRcdGJvdHRvbSAtPSB0bXAuaGVpZ2h0ICsgbXkudmdhcDtcblx0XHRcdH1cblx0XHRcdGlmIChlYXN0ICYmIGVhc3QuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0dG1wID0gZWFzdC5wcmVmZXJyZWRTaXplKCk7XG5cdFx0XHRcdGVhc3QuYm91bmRzKHsneCc6IHJpZ2h0IC0gdG1wLndpZHRoLCAneSc6IHRvcCwgJ3dpZHRoJzogdG1wLndpZHRoLCAnaGVpZ2h0JzogYm90dG9tIC0gdG9wfSk7XG5cdFx0XHRcdGVhc3QuZG9MYXlvdXQoKTtcblxuXHRcdFx0XHRyaWdodCAtPSB0bXAud2lkdGggKyBteS5oZ2FwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdlc3QgJiYgd2VzdC5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHR0bXAgPSB3ZXN0LnByZWZlcnJlZFNpemUoKTtcblx0XHRcdFx0d2VzdC5ib3VuZHMoeyd4JzogbGVmdCwgJ3knOiB0b3AsICd3aWR0aCc6IHRtcC53aWR0aCwgJ2hlaWdodCc6IGJvdHRvbSAtIHRvcH0pO1xuXHRcdFx0XHR3ZXN0LmRvTGF5b3V0KCk7XG5cblx0XHRcdFx0bGVmdCArPSB0bXAud2lkdGggKyBteS5oZ2FwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNlbnRlciAmJiBjZW50ZXIuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0Y2VudGVyLmJvdW5kcyh7J3gnOiBsZWZ0LCAneSc6IHRvcCwgJ3dpZHRoJzogcmlnaHQgLSBsZWZ0LCAnaGVpZ2h0JzogYm90dG9tIC0gdG9wfSk7XG5cdFx0XHRcdGNlbnRlci5kb0xheW91dCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHlwZUxheW91dCh0eXBlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdFx0XHR2YXIgaW5zZXRzID0gY29udGFpbmVyLmluc2V0cygpLFxuXHRcdFx0XHRcdHdpZHRoID0gMCxcblx0XHRcdFx0XHRoZWlnaHQgPSAwLFxuXHRcdFx0XHRcdHR5cGVfc2l6ZTtcblxuXHRcdFx0XHRpZiAoZWFzdCAmJiBlYXN0LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0dHlwZV9zaXplID0gZWFzdFt0eXBlICsgJ1NpemUnXSgpO1xuXHRcdFx0XHRcdHdpZHRoICs9IHR5cGVfc2l6ZS53aWR0aCArIG15LmhnYXA7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gdHlwZV9zaXplLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAod2VzdCAmJiB3ZXN0LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0dHlwZV9zaXplID0gd2VzdFt0eXBlICsgJ1NpemUnXSgpO1xuXHRcdFx0XHRcdHdpZHRoICs9IHR5cGVfc2l6ZS53aWR0aCArIG15LmhnYXA7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gTWF0aC5tYXgodHlwZV9zaXplLmhlaWdodCwgaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2VudGVyICYmIGNlbnRlci5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdHR5cGVfc2l6ZSA9IGNlbnRlclt0eXBlICsgJ1NpemUnXSgpO1xuXHRcdFx0XHRcdHdpZHRoICs9IHR5cGVfc2l6ZS53aWR0aDtcblx0XHRcdFx0XHRoZWlnaHQgPSBNYXRoLm1heCh0eXBlX3NpemUuaGVpZ2h0LCBoZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3J0aCAmJiBub3J0aC5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdHR5cGVfc2l6ZSA9IG5vcnRoW3R5cGUgKyAnU2l6ZSddKCk7XG5cdFx0XHRcdFx0d2lkdGggPSBNYXRoLm1heCh0eXBlX3NpemUud2lkdGgsIHdpZHRoKTtcblx0XHRcdFx0XHRoZWlnaHQgKz0gdHlwZV9zaXplLmhlaWdodCArIG15LnZnYXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNvdXRoICYmIHNvdXRoLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0dHlwZV9zaXplID0gc291dGhbdHlwZSArICdTaXplJ10oKTtcblx0XHRcdFx0XHR3aWR0aCA9IE1hdGgubWF4KHR5cGVfc2l6ZS53aWR0aCwgd2lkdGgpO1xuXHRcdFx0XHRcdGhlaWdodCArPSB0eXBlX3NpemUuaGVpZ2h0ICsgbXkudmdhcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0J3dpZHRoJzogd2lkdGggKyBpbnNldHMubGVmdCArIGluc2V0cy5yaWdodCwgXG5cdFx0XHRcdFx0J2hlaWdodCc6IGhlaWdodCArIGluc2V0cy50b3AgKyBpbnNldHMuYm90dG9tXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGF0LnByZWZlcnJlZCA9IHR5cGVMYXlvdXQoJ3ByZWZlcnJlZCcpO1xuXHRcdHRoYXQubWluaW11bSA9IHR5cGVMYXlvdXQoJ21pbmltdW0nKTtcblx0XHR0aGF0Lm1heGltdW0gPSB0eXBlTGF5b3V0KCdtYXhpbXVtJyk7XG5cdFx0cmV0dXJuIHRoYXQ7XG5cdH07XG59KCkpO1xuIiwiLyoqXG4gKiBAcHJlc2VydmUgakxheW91dCBKUXVlcnkgUGx1Z2luIHYwLjE3XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIG5ldyBCU0QgTGljZW5zZS5cbiAqIENvcHlyaWdodCAyMDA4LTIwMDkgQnJhbSBTdGVpblxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuLypnbG9iYWwgalF1ZXJ5IGpMYXlvdXQqL1xuXG4vLyBDdXN0b21pc2VkXG4vLyBEZWZpbmluZyBnbG9iYWwgYWxpYXMgYmVjYXVzZSBCcm93c2VyaWZ5IGFkZHMgJ3VzZSBzdHJpY3QnXG4vLyB3aGljaCB0aHJvd3MgYSBydW50aW1lIGVycm9yIGlmIGdsb2JhbHMgYXJlIHVuZGVmaW5lZCBhbmQgbm90IGRlY2xhcmVkLlxudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cdGpMYXlvdXQgPSB3aW5kb3cuakxheW91dDtcblxuaWYgKGpRdWVyeSAmJiBqTGF5b3V0KSB7XG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoaXMgd3JhcHMgalF1ZXJ5IG9iamVjdHMgaW4gYW5vdGhlciBvYmplY3QgdGhhdCBzdXBwbGllc1xuXHRcdCAqIHRoZSBtZXRob2RzIHJlcXVpcmVkIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobXMuXG5cdFx0ICovXG5cdFx0Ly8gQ1VTVE9NIGhmcmllZGxhbmRlciAyMDEyLTEwLTI2IGZvciBzaWRlLWJ5LXNpZGUgZWRpdGluZy5cblx0XHQvLyBmdW5jdGlvbiB3cmFwKGl0ZW0sIHJlc2l6ZSkge1xuXHRcdHZhciB3cmFwID0gJC5qTGF5b3V0V3JhcCA9IGZ1bmN0aW9uKGl0ZW0sIHJlc2l6ZSkge1xuXHRcdC8vIENVU1RPTSBFTkRcblx0XHRcdHZhciB0aGF0ID0ge307XG5cdFx0XHQvLyBDVVNUT00gaGZyaWVkbGFuZGVyIDIwMTItMTAtMjYgZm9yIHNpZGUtYnktc2lkZSBlZGl0aW5nLlxuXHRcdFx0dGhhdC5pdGVtID0gaXRlbTtcblx0XHRcdC8vIENVU1RPTSBFTkRcblxuXHRcdFx0JC5lYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuXHRcdFx0XHR0aGF0W25hbWUgKyAnaW11bVNpemUnXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGl0ZW0uZGF0YSgnamxheW91dCcpO1xuICAgICAgICAgICAgICAgICAgICBcblx0XHRcdFx0XHRpZiAobCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxbbmFtZSArICdpbXVtJ10odGhhdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtW25hbWUgKyAnU2l6ZSddKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblxuXHRcdFx0JC5leHRlbmQodGhhdCwge1xuXHRcdFx0XHRkb0xheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIENVU1RPTSBoZnJpZWRsYW5kZXIgMjAxMi0xMC0yNiBmb3Igc2lkZS1ieS1zaWRlIGVkaXRpbmcuXG5cdFx0XHRcdFx0Ly92YXIgbCA9IGl0ZW0uZGF0YSgnamxheW91dCcpO1xuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly9pZiAobCkge1xuXHRcdFx0XHRcdC8vXHRsLmxheW91dCh0aGF0KTtcblx0XHRcdFx0XHQvL31cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdHZhciBsID0gaXRlbS5kYXRhKCdqbGF5b3V0Jyk7XG5cdFx0XHRcdFx0aWYgKGwpIGwubGF5b3V0KHRoYXQpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGl0ZW0uaXMoJ1tkYXRhLWxheW91dC10eXBlXScpKSB7XG5cdFx0XHRcdFx0XHRpdGVtLmxheW91dCh7cmVzaXplOiBmYWxzZX0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDVVNUT00gRU5EXG5cblx0XHRcdFx0XHRpdGVtLmNzcyh7cG9zaXRpb246ICdhYnNvbHV0ZSd9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aXNWaXNpYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uaXNWaXNpYmxlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2V0czogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBwID0gaXRlbS5wYWRkaW5nKCksXG5cdFx0XHRcdFx0XHRiID0gaXRlbS5ib3JkZXIoKTtcblxuXHRcdFx0XHRcdHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndG9wJzogcC50b3AsIFxuXHRcdFx0XHRcdFx0J2JvdHRvbSc6IHAuYm90dG9tICsgYi5ib3R0b20gKyBiLnRvcCwgXG5cdFx0XHRcdFx0XHQnbGVmdCc6IHAubGVmdCwgXG5cdFx0XHRcdFx0XHQncmlnaHQnOiBwLnJpZ2h0ICsgYi5yaWdodCArIGIubGVmdFxuICAgICAgICAgICAgICAgICAgICB9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRib3VuZHM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB7fTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZS54ID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdFx0XHR0bXAubGVmdCA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlLnkgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC50b3AgPSB2YWx1ZS55O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZS53aWR0aCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdFx0dG1wLndpZHRoID0gKHZhbHVlLndpZHRoIC0gKGl0ZW0ub3V0ZXJXaWR0aCh0cnVlKSAtIGl0ZW0ud2lkdGgoKSkpO1xuXHRcdFx0XHRcdFx0XHR0bXAud2lkdGggPSAodG1wLndpZHRoID49IDApID8gdG1wLndpZHRoIDogMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUuaGVpZ2h0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdFx0XHR0bXAuaGVpZ2h0ID0gdmFsdWUuaGVpZ2h0IC0gKGl0ZW0ub3V0ZXJIZWlnaHQodHJ1ZSkgLSBpdGVtLmhlaWdodCgpKTtcblx0XHRcdFx0XHRcdFx0dG1wLmhlaWdodCA9ICh0bXAuaGVpZ2h0ID49IDApID8gdG1wLmhlaWdodCA6IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpdGVtLmNzcyh0bXApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRtcCA9IGl0ZW0ucG9zaXRpb24oKTtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdCd4JzogdG1wLmxlZnQsXG5cdFx0XHRcdFx0XHRcdCd5JzogdG1wLnRvcCxcblx0XHRcdFx0XHRcdFx0J3dpZHRoJzogaXRlbS5vdXRlcldpZHRoKGZhbHNlKSxcblx0XHRcdFx0XHRcdFx0J2hlaWdodCc6IGl0ZW0ub3V0ZXJIZWlnaHQoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cHJlZmVycmVkU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBtaW5TaXplLFxuXHRcdFx0XHRcdFx0bWF4U2l6ZSxcblx0XHRcdFx0XHRcdG1hcmdpbiA9IGl0ZW0ubWFyZ2luKCksXG5cdFx0XHRcdFx0XHRzaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGl0ZW0uZGF0YSgnamxheW91dCcpO1xuXG5cdFx0XHRcdFx0aWYgKGwgJiYgcmVzaXplKSB7XG5cdFx0XHRcdFx0XHRzaXplID0gbC5wcmVmZXJyZWQodGhhdCk7XG5cblx0XHRcdFx0XHRcdG1pblNpemUgPSB0aGF0Lm1pbmltdW1TaXplKCk7XG5cdFx0XHRcdFx0XHRtYXhTaXplID0gdGhhdC5tYXhpbXVtU2l6ZSgpO1xuXG5cdFx0XHRcdFx0XHRzaXplLndpZHRoICs9IG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0O1xuXHRcdFx0XHRcdFx0c2l6ZS5oZWlnaHQgKz0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b207XG5cblx0XHRcdFx0XHRcdGlmIChzaXplLndpZHRoIDwgbWluU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCA8IG1pblNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdHNpemUud2lkdGggPSBNYXRoLm1heChzaXplLndpZHRoLCBtaW5TaXplLndpZHRoKTtcblx0XHRcdFx0XHRcdFx0c2l6ZS5oZWlnaHQgPSBNYXRoLm1heChzaXplLmhlaWdodCwgbWluU2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzaXplLndpZHRoID4gbWF4U2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCA+IG1heFNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdHNpemUud2lkdGggPSBNYXRoLm1pbihzaXplLndpZHRoLCBtYXhTaXplLndpZHRoKTtcblx0XHRcdFx0XHRcdFx0c2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihzaXplLmhlaWdodCwgbWF4U2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gdGhhdC5ib3VuZHMoKTtcblx0XHRcdFx0XHRcdHNpemUud2lkdGggKz0gbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQ7XG5cdFx0XHRcdFx0XHRzaXplLmhlaWdodCArPSBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoYXQ7XG5cdFx0fVxuXG5cdFx0JC5mbi5sYXlvdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0dmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5sYXlvdXQuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuICQuZWFjaCh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gJCh0aGlzKSxcblx0XHRcdFx0XHRvID0gJC5tZXRhZGF0YSAmJiBlbGVtZW50Lm1ldGFkYXRhKCkubGF5b3V0ID8gJC5leHRlbmQob3B0cywgZWxlbWVudC5tZXRhZGF0YSgpLmxheW91dCkgOiBvcHRzLFxuXHRcdFx0XHRcdC8vIENVU1RPTSBpc2Nob21tZXIgMjAxMi0xNi0wMiBBbGxvdyB0eXBlIHNldHRpbmcgdGhyb2doIGJ1aWx0LWluIGpRdWVyeSBIVE1MNSBkYXRhIGdldHRlcnMsIHRvIGF2b2lkIGluY2x1ZGluZyBqUXVlcnkubWV0YWRhdGEuanNcblx0XHRcdFx0XHRvID0gZWxlbWVudC5kYXRhKCdsYXlvdXRUeXBlJykgPyAkLmV4dGVuZChvLCB7dHlwZTogZWxlbWVudC5kYXRhKCdsYXlvdXRUeXBlJyl9KSA6IG8sXG5cdFx0XHRcdFx0Ly8gQ1VTVE9NIEVORFxuXHRcdFx0XHRcdGVsZW1lbnRXcmFwcGVyID0gd3JhcChlbGVtZW50LCBvLnJlc2l6ZSk7XG5cdFx0XHRcdGlmIChvLnR5cGUgPT09ICdib3JkZXInICYmIHR5cGVvZiBqTGF5b3V0LmJvcmRlciAhPT0gJ3VuZGVmaW5lZCcpIHsgICAgICAgICAgICAgICAgXG5cdFx0XHRcdFx0JC5lYWNoKFsnbm9ydGgnLCAnc291dGgnLCAnd2VzdCcsICdlYXN0JywgJ2NlbnRlciddLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2hpbGRyZW4oKS5oYXNDbGFzcyhuYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRvW25hbWVdID0gd3JhcChlbGVtZW50LmNoaWxkcmVuKCcuJyArIG5hbWUgKyAnOmZpcnN0JykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsZW1lbnQuZGF0YSgnamxheW91dCcsIGpMYXlvdXQuYm9yZGVyKG8pKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvLnR5cGUgPT09ICdncmlkJyAmJiB0eXBlb2YgakxheW91dC5ncmlkICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdG8uaXRlbXMgPSBbXTtcblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRcdFx0aWYgKCEkKHRoaXMpLmhhc0NsYXNzKCd1aS1yZXNpemFibGUtaGFuZGxlJykpIHtcblx0XHRcdFx0XHRcdFx0by5pdGVtc1tpXSA9IHdyYXAoJCh0aGlzKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxlbWVudC5kYXRhKCdqbGF5b3V0JywgakxheW91dC5ncmlkKG8pKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvLnR5cGUgPT09ICdmbGV4R3JpZCcgJiYgdHlwZW9mIGpMYXlvdXQuZmxleEdyaWQgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0by5pdGVtcyA9IFtdO1xuXHRcdFx0XHRcdGVsZW1lbnQuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISQodGhpcykuaGFzQ2xhc3MoJ3VpLXJlc2l6YWJsZS1oYW5kbGUnKSkge1xuXHRcdFx0XHRcdFx0XHRvLml0ZW1zW2ldID0gd3JhcCgkKHRoaXMpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRlbGVtZW50LmRhdGEoJ2psYXlvdXQnLCBqTGF5b3V0LmZsZXhHcmlkKG8pKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvLnR5cGUgPT09ICdjb2x1bW4nICYmIHR5cGVvZiBqTGF5b3V0LmNvbHVtbiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRvLml0ZW1zID0gW107XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHRcdGlmICghJCh0aGlzKS5oYXNDbGFzcygndWktcmVzaXphYmxlLWhhbmRsZScpKSB7XG5cdFx0XHRcdFx0XHRcdG8uaXRlbXNbaV0gPSB3cmFwKCQodGhpcykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsZW1lbnQuZGF0YSgnamxheW91dCcsIGpMYXlvdXQuY29sdW1uKG8pKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvLnR5cGUgPT09ICdmbG93JyAmJiB0eXBlb2YgakxheW91dC5mbG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdG8uaXRlbXMgPSBbXTtcblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRcdFx0aWYgKCEkKHRoaXMpLmhhc0NsYXNzKCd1aS1yZXNpemFibGUtaGFuZGxlJykpIHtcblx0XHRcdFx0XHRcdFx0by5pdGVtc1tpXSA9IHdyYXAoJCh0aGlzKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxlbWVudC5kYXRhKCdqbGF5b3V0JywgakxheW91dC5mbG93KG8pKTtcdFx0XHRcdFx0XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBcblx0XHRcdFx0aWYgKG8ucmVzaXplKSB7XG5cdFx0XHRcdFx0ZWxlbWVudFdyYXBwZXIuYm91bmRzKGVsZW1lbnRXcmFwcGVyLnByZWZlcnJlZFNpemUoKSk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBcblx0XHRcdFx0ZWxlbWVudFdyYXBwZXIuZG9MYXlvdXQoKTtcblx0XHRcdFx0ZWxlbWVudC5jc3Moe3Bvc2l0aW9uOiAncmVsYXRpdmUnfSk7XG5cdFx0XHRcdGlmICgkLnVpICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRlbGVtZW50LmFkZENsYXNzKCd1aS13aWRnZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdCQuZm4ubGF5b3V0LmRlZmF1bHRzID0ge1xuXHRcdFx0cmVzaXplOiB0cnVlLFxuXHRcdFx0dHlwZTogJ2dyaWQnXG5cdFx0fTtcblx0fShqUXVlcnkpKTtcbn1cbiIsIi8qKlxuKiBob3ZlckludGVudCBpcyBzaW1pbGFyIHRvIGpRdWVyeSdzIGJ1aWx0LWluIFwiaG92ZXJcIiBmdW5jdGlvbiBleGNlcHQgdGhhdFxuKiBpbnN0ZWFkIG9mIGZpcmluZyB0aGUgb25Nb3VzZU92ZXIgZXZlbnQgaW1tZWRpYXRlbHksIGhvdmVySW50ZW50IGNoZWNrc1xuKiB0byBzZWUgaWYgdGhlIHVzZXIncyBtb3VzZSBoYXMgc2xvd2VkIGRvd24gKGJlbmVhdGggdGhlIHNlbnNpdGl2aXR5XG4qIHRocmVzaG9sZCkgYmVmb3JlIGZpcmluZyB0aGUgb25Nb3VzZU92ZXIgZXZlbnQuXG4qXG4qIGhvdmVySW50ZW50IHI2IC8vIDIwMTEuMDIuMjYgLy8galF1ZXJ5IDEuNS4xK1xuKiA8aHR0cDovL2NoZXJuZS5uZXQvYnJpYW4vcmVzb3VyY2VzL2pxdWVyeS5ob3ZlckludGVudC5odG1sPlxuKlxuKiBob3ZlckludGVudCBpcyBjdXJyZW50bHkgYXZhaWxhYmxlIGZvciB1c2UgaW4gYWxsIHBlcnNvbmFsIG9yIGNvbW1lcmNpYWxcbiogcHJvamVjdHMgdW5kZXIgYm90aCBNSVQgYW5kIEdQTCBsaWNlbnNlcy4gVGhpcyBtZWFucyB0aGF0IHlvdSBjYW4gY2hvb3NlXG4qIHRoZSBsaWNlbnNlIHRoYXQgYmVzdCBzdWl0cyB5b3VyIHByb2plY3QsIGFuZCB1c2UgaXQgYWNjb3JkaW5nbHkuXG4qXG4qIC8vIGJhc2ljIHVzYWdlIChqdXN0IGxpa2UgLmhvdmVyKSByZWNlaXZlcyBvbk1vdXNlT3ZlciBhbmQgb25Nb3VzZU91dCBmdW5jdGlvbnNcbiogJChcInVsIGxpXCIpLmhvdmVySW50ZW50KCBzaG93TmF2ICwgaGlkZU5hdiApO1xuKlxuKiAvLyBhZHZhbmNlZCB1c2FnZSByZWNlaXZlcyBjb25maWd1cmF0aW9uIG9iamVjdCBvbmx5XG4qICQoXCJ1bCBsaVwiKS5ob3ZlckludGVudCh7XG4qXHRzZW5zaXRpdml0eTogNywgLy8gbnVtYmVyID0gc2Vuc2l0aXZpdHkgdGhyZXNob2xkIChtdXN0IGJlIDEgb3IgaGlnaGVyKVxuKlx0aW50ZXJ2YWw6IDEwMCwgICAvLyBudW1iZXIgPSBtaWxsaXNlY29uZHMgb2YgcG9sbGluZyBpbnRlcnZhbFxuKlx0b3Zlcjogc2hvd05hdiwgIC8vIGZ1bmN0aW9uID0gb25Nb3VzZU92ZXIgY2FsbGJhY2sgKHJlcXVpcmVkKVxuKlx0dGltZW91dDogMzUwLCAgIC8vIG51bWJlciA9IG1pbGxpc2Vjb25kcyBkZWxheSBiZWZvcmUgb25Nb3VzZU91dCBmdW5jdGlvbiBjYWxsXG4qXHRvdXQ6IGhpZGVOYXYgICAgLy8gZnVuY3Rpb24gPSBvbk1vdXNlT3V0IGNhbGxiYWNrIChyZXF1aXJlZClcbiogfSk7XG4qXG4qIEBwYXJhbSAgZiAgb25Nb3VzZU92ZXIgZnVuY3Rpb24gfHwgQW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zXG4qIEBwYXJhbSAgZyAgb25Nb3VzZU91dCBmdW5jdGlvbiAgfHwgTm90aGluZyAodXNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvYmplY3QpXG4qIEBhdXRob3IgICAgQnJpYW4gQ2hlcm5lIGJyaWFuKGF0KWNoZXJuZShkb3QpbmV0XG4qL1xuKGZ1bmN0aW9uKCQpIHtcblx0JC5mbi5ob3ZlckludGVudCA9IGZ1bmN0aW9uKGYsZykge1xuXHRcdC8vIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zXG5cdFx0dmFyIGNmZyA9IHtcblx0XHRcdHNlbnNpdGl2aXR5OiA3LFxuXHRcdFx0aW50ZXJ2YWw6IDEwMCxcblx0XHRcdHRpbWVvdXQ6IDM1MFxuXHRcdH07XG5cdFx0Ly8gb3ZlcnJpZGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHdpdGggdXNlciBzdXBwbGllZCBvYmplY3Rcblx0XHRjZmcgPSAkLmV4dGVuZChjZmcsIGcgPyB7IG92ZXI6IGYsIG91dDogZyB9IDogZiApO1xuXG5cdFx0Ly8gaW5zdGFudGlhdGUgdmFyaWFibGVzXG5cdFx0Ly8gY1gsIGNZID0gY3VycmVudCBYIGFuZCBZIHBvc2l0aW9uIG9mIG1vdXNlLCB1cGRhdGVkIGJ5IG1vdXNlbW92ZSBldmVudFxuXHRcdC8vIHBYLCBwWSA9IHByZXZpb3VzIFggYW5kIFkgcG9zaXRpb24gb2YgbW91c2UsIHNldCBieSBtb3VzZW92ZXIgYW5kIHBvbGxpbmcgaW50ZXJ2YWxcblx0XHR2YXIgY1gsIGNZLCBwWCwgcFk7XG5cblx0XHQvLyBBIHByaXZhdGUgZnVuY3Rpb24gZm9yIGdldHRpbmcgbW91c2UgcG9zaXRpb25cblx0XHR2YXIgdHJhY2sgPSBmdW5jdGlvbihldikge1xuXHRcdFx0Y1ggPSBldi5wYWdlWDtcblx0XHRcdGNZID0gZXYucGFnZVk7XG5cdFx0fTtcblxuXHRcdC8vIEEgcHJpdmF0ZSBmdW5jdGlvbiBmb3IgY29tcGFyaW5nIGN1cnJlbnQgYW5kIHByZXZpb3VzIG1vdXNlIHBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSBmdW5jdGlvbihldixvYikge1xuXHRcdFx0b2IuaG92ZXJJbnRlbnRfdCA9IGNsZWFyVGltZW91dChvYi5ob3ZlckludGVudF90KTtcblx0XHRcdC8vIGNvbXBhcmUgbW91c2UgcG9zaXRpb25zIHRvIHNlZSBpZiB0aGV5J3ZlIGNyb3NzZWQgdGhlIHRocmVzaG9sZFxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKHBYLWNYKSArIE1hdGguYWJzKHBZLWNZKSApIDwgY2ZnLnNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHQkKG9iKS51bmJpbmQoXCJtb3VzZW1vdmVcIix0cmFjayk7XG5cdFx0XHRcdC8vIHNldCBob3ZlckludGVudCBzdGF0ZSB0byB0cnVlIChzbyBtb3VzZU91dCBjYW4gYmUgY2FsbGVkKVxuXHRcdFx0XHRvYi5ob3ZlckludGVudF9zID0gMTtcblx0XHRcdFx0cmV0dXJuIGNmZy5vdmVyLmFwcGx5KG9iLFtldl0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2V0IHByZXZpb3VzIGNvb3JkaW5hdGVzIGZvciBuZXh0IHRpbWVcblx0XHRcdFx0cFggPSBjWDsgcFkgPSBjWTtcblx0XHRcdFx0Ly8gdXNlIHNlbGYtY2FsbGluZyB0aW1lb3V0LCBndWFyYW50ZWVzIGludGVydmFscyBhcmUgc3BhY2VkIG91dCBwcm9wZXJseSAoYXZvaWRzIEphdmFTY3JpcHQgdGltZXIgYnVncylcblx0XHRcdFx0b2IuaG92ZXJJbnRlbnRfdCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7Y29tcGFyZShldiwgb2IpO30gLCBjZmcuaW50ZXJ2YWwgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gQSBwcml2YXRlIGZ1bmN0aW9uIGZvciBkZWxheWluZyB0aGUgbW91c2VPdXQgZnVuY3Rpb25cblx0XHR2YXIgZGVsYXkgPSBmdW5jdGlvbihldixvYikge1xuXHRcdFx0b2IuaG92ZXJJbnRlbnRfdCA9IGNsZWFyVGltZW91dChvYi5ob3ZlckludGVudF90KTtcblx0XHRcdG9iLmhvdmVySW50ZW50X3MgPSAwO1xuXHRcdFx0cmV0dXJuIGNmZy5vdXQuYXBwbHkob2IsW2V2XSk7XG5cdFx0fTtcblxuXHRcdC8vIEEgcHJpdmF0ZSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgbW91c2UgJ2hvdmVyaW5nJ1xuXHRcdHZhciBoYW5kbGVIb3ZlciA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIGNvcHkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW50byB0IChyZXF1aXJlZCBmb3IgZXZlbnQgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiBJRSlcblx0XHRcdHZhciBldiA9IGpRdWVyeS5leHRlbmQoe30sZSk7XG5cdFx0XHR2YXIgb2IgPSB0aGlzO1xuXG5cdFx0XHQvLyBjYW5jZWwgaG92ZXJJbnRlbnQgdGltZXIgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAob2IuaG92ZXJJbnRlbnRfdCkgeyBvYi5ob3ZlckludGVudF90ID0gY2xlYXJUaW1lb3V0KG9iLmhvdmVySW50ZW50X3QpOyB9XG5cblx0XHRcdC8vIGlmIGUudHlwZSA9PSBcIm1vdXNlZW50ZXJcIlxuXHRcdFx0aWYgKGUudHlwZSA9PSBcIm1vdXNlZW50ZXJcIikge1xuXHRcdFx0XHQvLyBzZXQgXCJwcmV2aW91c1wiIFggYW5kIFkgcG9zaXRpb24gYmFzZWQgb24gaW5pdGlhbCBlbnRyeSBwb2ludFxuXHRcdFx0XHRwWCA9IGV2LnBhZ2VYOyBwWSA9IGV2LnBhZ2VZO1xuXHRcdFx0XHQvLyB1cGRhdGUgXCJjdXJyZW50XCIgWCBhbmQgWSBwb3NpdGlvbiBiYXNlZCBvbiBtb3VzZW1vdmVcblx0XHRcdFx0JChvYikuYmluZChcIm1vdXNlbW92ZVwiLHRyYWNrKTtcblx0XHRcdFx0Ly8gc3RhcnQgcG9sbGluZyBpbnRlcnZhbCAoc2VsZi1jYWxsaW5nIHRpbWVvdXQpIHRvIGNvbXBhcmUgbW91c2UgY29vcmRpbmF0ZXMgb3ZlciB0aW1lXG5cdFx0XHRcdGlmIChvYi5ob3ZlckludGVudF9zICE9IDEpIHsgb2IuaG92ZXJJbnRlbnRfdCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7Y29tcGFyZShldixvYik7fSAsIGNmZy5pbnRlcnZhbCApO31cblxuXHRcdFx0Ly8gZWxzZSBlLnR5cGUgPT0gXCJtb3VzZWxlYXZlXCJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVuYmluZCBleHBlbnNpdmUgbW91c2Vtb3ZlIGV2ZW50XG5cdFx0XHRcdCQob2IpLnVuYmluZChcIm1vdXNlbW92ZVwiLHRyYWNrKTtcblx0XHRcdFx0Ly8gaWYgaG92ZXJJbnRlbnQgc3RhdGUgaXMgdHJ1ZSwgdGhlbiBjYWxsIHRoZSBtb3VzZU91dCBmdW5jdGlvbiBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5XG5cdFx0XHRcdGlmIChvYi5ob3ZlckludGVudF9zID09IDEpIHsgb2IuaG92ZXJJbnRlbnRfdCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7ZGVsYXkoZXYsb2IpO30gLCBjZmcudGltZW91dCApO31cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gYmluZCB0aGUgZnVuY3Rpb24gdG8gdGhlIHR3byBldmVudCBsaXN0ZW5lcnNcblx0XHRyZXR1cm4gdGhpcy5iaW5kKCdtb3VzZWVudGVyJyxoYW5kbGVIb3ZlcikuYmluZCgnbW91c2VsZWF2ZScsaGFuZGxlSG92ZXIpO1xuXHR9O1xufSkoalF1ZXJ5KTsiLCIvKipcbipcdGpRdWVyeS5ub3RpY2VBZGQoKSBhbmQgalF1ZXJ5Lm5vdGljZVJlbW92ZSgpXG4qXHRUaGVzZSBmdW5jdGlvbnMgY3JlYXRlIGFuZCByZW1vdmUgZ3Jvd2wtbGlrZSBub3RpY2VzXG4qXHRcdFxuKiAgIENvcHlyaWdodCAoYykgMjAwOSBUaW0gQmVubmlrc1xuKlxuKlx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuKlx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuKlx0aW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuKlx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKlx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4qXHRmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuKlxuKlx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbipcdGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKlx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuKlx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4qXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbipcdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbipcdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4qXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4qXHRUSEUgU09GVFdBUkUuXG4qXHRcbipcdEBhdXRob3IgXHRUaW0gQmVubmlrcyA8dGltQHRpbWJlbm5pa3MuY29tPlxuKiBcdEBjb3B5cmlnaHQgIDIwMDkgdGltYmVubmlrcy5jb21cbipcdEB2ZXJzaW9uICAgICRJZDoganF1ZXJ5Lm5vdGljZS5qcyAxIDIwMDktMDEtMjQgMTI6MjQ6MThaIHRpbWJlbm5pa3MgJFxuKiovXG4oZnVuY3Rpb24oalF1ZXJ5KVxue1xuXHRqUXVlcnkuZXh0ZW5kKHtcdFx0XHRcblx0XHRub3RpY2VBZGQ6IGZ1bmN0aW9uKG9wdGlvbnMpXG5cdFx0e1x0XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0XHRcdGluRWZmZWN0OiBcdFx0XHR7b3BhY2l0eTogJ3Nob3cnfSxcdC8vIGluIGVmZmVjdFxuXHRcdFx0XHRpbkVmZmVjdER1cmF0aW9uOiBcdDYwMCxcdFx0XHRcdC8vIGluIGVmZmVjdCBkdXJhdGlvbiBpbiBtaWxpc2Vjb25kc1xuXHRcdFx0XHRzdGF5VGltZTogXHRcdFx0MzAwMCxcdFx0XHRcdC8vIHRpbWUgaW4gbWlsaXNlY29uZHMgYmVmb3JlIHRoZSBpdGVtIGhhcyB0byBkaXNhcHBlYXJcblx0XHRcdFx0dGV4dDogXHRcdFx0XHQnJyxcdFx0XHRcdFx0Ly8gY29udGVudCBvZiB0aGUgaXRlbVxuXHRcdFx0XHRzdGF5OiBcdFx0XHRcdGZhbHNlLFx0XHRcdFx0Ly8gc2hvdWxkIHRoZSBub3RpY2UgaXRlbSBzdGF5IG9yIG5vdD9cblx0XHRcdFx0dHlwZTogXHRcdFx0XHQnbm90aWNlJyBcdFx0XHQvLyBjb3VsZCBhbHNvIGJlIGVycm9yLCBzdWNjZXNcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gZGVjbGFyZSB2YXJhaWJsZXNcblx0XHRcdHZhciBvcHRpb25zLCBub3RpY2VXcmFwQWxsLCBub3RpY2VJdGVtT3V0ZXIsIG5vdGljZUl0ZW1Jbm5lciwgbm90aWNlSXRlbUNsb3NlLCBob3ZlciA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRvcHRpb25zIFx0XHQ9IGpRdWVyeS5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHRcdG5vdGljZVdyYXBBbGxcdD0gKCFqUXVlcnkoJy5ub3RpY2Utd3JhcCcpLmxlbmd0aCkgPyBqUXVlcnkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ25vdGljZS13cmFwJykuYXBwZW5kVG8oJ2JvZHknKSA6IGpRdWVyeSgnLm5vdGljZS13cmFwJyk7XG5cdFx0XHRub3RpY2VJdGVtT3V0ZXJcdD0galF1ZXJ5KCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdub3RpY2UtaXRlbS13cmFwcGVyJyk7XG5cdFx0XHRub3RpY2VJdGVtSW5uZXJcdD0galF1ZXJ5KCc8ZGl2PjwvZGl2PicpLmhpZGUoKS5hZGRDbGFzcygnbm90aWNlLWl0ZW0gJyArIG9wdGlvbnMudHlwZSkuYXBwZW5kVG8obm90aWNlV3JhcEFsbCkuaHRtbCgnPHA+JytvcHRpb25zLnRleHQrJzwvcD4nKS5hbmltYXRlKG9wdGlvbnMuaW5FZmZlY3QsIG9wdGlvbnMuaW5FZmZlY3REdXJhdGlvbikud3JhcChub3RpY2VJdGVtT3V0ZXIpO1xuXHRcdFx0bm90aWNlSXRlbUNsb3NlXHQ9IGpRdWVyeSgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbm90aWNlLWl0ZW0tY2xvc2UnKS5wcmVwZW5kVG8obm90aWNlSXRlbUlubmVyKS5odG1sKCd4JykuY2xpY2soZnVuY3Rpb24oKSB7IGpRdWVyeS5ub3RpY2VSZW1vdmUobm90aWNlSXRlbUlubmVyKSB9KTtcblx0XHRcdFxuXHRcdFx0bm90aWNlSXRlbUlubmVyLmhvdmVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob3ZlciA9IHRydWU7XG5cdFx0XHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGhvdmVyID0gZmFsc2U7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFvcHRpb25zLnN0YXkpIHtcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBub3RpY2VIb3ZlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmKCFob3Zlcikge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubm90aWNlUmVtb3ZlKG5vdGljZUl0ZW1Jbm5lcik7XG5cdFx0XHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwobm90aWNlSG92ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDEwMDApO1xuXHRcdFx0XHR9LCBvcHRpb25zLnN0YXlUaW1lKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdG5vdGljZVJlbW92ZTogZnVuY3Rpb24ob2JqKVxuXHRcdHtcblx0XHRcdG9iai5hbmltYXRlKHtvcGFjaXR5OiAnMCd9LCA2MDAsIGZ1bmN0aW9uKClcblx0XHRcdHtcblx0XHRcdFx0b2JqLnBhcmVudCgpLmFuaW1hdGUoe2hlaWdodDogJzBweCd9LCAzMDAsIGZ1bmN0aW9uKClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG9iai5wYXJlbnQoKS5yZW1vdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTsiLCIvKipcbiAqIEBwcmVzZXJ2ZSBKU2l6ZXMgLSBKUXVlcnkgcGx1Z2luIHYwLjMzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHJldmlzZWQgQlNEIExpY2Vuc2UuXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDEwIEJyYW0gU3RlaW5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbi8qZ2xvYmFsIGpRdWVyeSovXG4oZnVuY3Rpb24gKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgbnVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xuXHRcdH07XG5cblx0LyoqXG5cdCAqIFNldHMgb3IgZ2V0cyB0aGUgdmFsdWVzIGZvciBtaW4td2lkdGgsIG1pbi1oZWlnaHQsIG1heC13aWR0aFxuXHQgKiBhbmQgbWF4LWhlaWdodC5cblx0ICovXG5cdCQuZWFjaChbJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcblx0XHQkLmZuW25hbWUgKyAnU2l6ZSddID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR2YXIgd2lkdGgsIGhlaWdodDtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUud2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY3NzKG5hbWUgKyAnLXdpZHRoJywgdmFsdWUud2lkdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY3NzKG5hbWUgKyAnLWhlaWdodCcsIHZhbHVlLmhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpZHRoID0gdGhpcy5jc3MobmFtZSArICctd2lkdGgnKTtcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5jc3MobmFtZSArICctaGVpZ2h0Jyk7XG5cdFx0XHRcdC8vIEFwcGFyZW50bHk6XG5cdFx0XHRcdC8vICAqIE9wZXJhIHJldHVybnMgLTFweCBpbnN0ZWFkIG9mIG5vbmVcblx0XHRcdFx0Ly8gICogSUU2IHJldHVybnMgdW5kZWZpbmVkIGluc3RlYWQgb2Ygbm9uZVxuXHRcdFx0XHRyZXR1cm4geyd3aWR0aCc6IChuYW1lID09PSAnbWF4JyAmJiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCB3aWR0aCA9PT0gJ25vbmUnIHx8IG51bSh3aWR0aCkgPT09IC0xKSAmJiBOdW1iZXIuTUFYX1ZBTFVFKSB8fCBudW0od2lkdGgpLCBcblx0XHRcdFx0XHRcdCdoZWlnaHQnOiAobmFtZSA9PT0gJ21heCcgJiYgKGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gJ25vbmUnIHx8IG51bShoZWlnaHQpID09PSAtMSkgJiYgTnVtYmVyLk1BWF9WQUxVRSkgfHwgbnVtKGhlaWdodCl9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gZWxlbWVudCBpcyB2aXNpYmxlLlxuXHQgKi9cblx0JC5mbi5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXMoJzp2aXNpYmxlJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgb3IgZ2V0cyB0aGUgdmFsdWVzIGZvciBib3JkZXIsIG1hcmdpbiBhbmQgcGFkZGluZy5cblx0ICovXG5cdCQuZWFjaChbJ2JvcmRlcicsICdtYXJnaW4nLCAncGFkZGluZyddLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuXHRcdCQuZm5bbmFtZV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUudG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNzcyhuYW1lICsgJy10b3AnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJyksIHZhbHVlLnRvcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlLmJvdHRvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5jc3MobmFtZSArICctYm90dG9tJyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpLCB2YWx1ZS5ib3R0b20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZS5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNzcyhuYW1lICsgJy1sZWZ0JyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpLCB2YWx1ZS5sZWZ0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFsdWUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY3NzKG5hbWUgKyAnLXJpZ2h0JyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpLCB2YWx1ZS5yaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB7dG9wOiBudW0odGhpcy5jc3MobmFtZSArICctdG9wJyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpKSksXG5cdFx0XHRcdFx0XHRib3R0b206IG51bSh0aGlzLmNzcyhuYW1lICsgJy1ib3R0b20nICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJykpKSxcblx0XHRcdFx0XHRcdGxlZnQ6IG51bSh0aGlzLmNzcyhuYW1lICsgJy1sZWZ0JyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpKSksXG5cdFx0XHRcdFx0XHRyaWdodDogbnVtKHRoaXMuY3NzKG5hbWUgKyAnLXJpZ2h0JyArIChuYW1lID09PSAnYm9yZGVyJyA/ICctd2lkdGgnIDogJycpKSl9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG59KGpRdWVyeSkpO1xuIiwiaW1wb3J0ICQgZnJvbSAnLi9qUXVlcnknO1xuXG4kLmZuLmV4dGVuZCh7XG5cdHNzRGF0ZXBpY2tlcjogZnVuY3Rpb24ob3B0cykge1xuXHRcdHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZigkKHRoaXMpLmRhdGEoJ2RhdGVwaWNrZXInKSkgcmV0dXJuOyAvLyBhbHJlYWR5IGFwcGxpZWRcblxuXHRcdFx0JCh0aGlzKS5zaWJsaW5ncyhcImJ1dHRvblwiKS5hZGRDbGFzcyhcInVpLWljb24gdWktaWNvbi1jYWxlbmRhclwiKTtcblx0XHRcdFxuXHRcdFx0dmFyIGhvbGRlciA9ICQodGhpcykucGFyZW50cygnLmZpZWxkLmRhdGU6Zmlyc3QnKSwgXG5cdFx0XHRcdGNvbmZpZyA9ICQuZXh0ZW5kKG9wdHMgfHwge30sICQodGhpcykuZGF0YSgpLCAkKHRoaXMpLmRhdGEoJ2pxdWVyeXVpY29uZmlnJyksIHt9KTtcblx0XHRcdGlmKCFjb25maWcuc2hvd2NhbGVuZGFyKSByZXR1cm47XG5cblx0XHRcdGlmKGNvbmZpZy5sb2NhbGUgJiYgJC5kYXRlcGlja2VyLnJlZ2lvbmFsW2NvbmZpZy5sb2NhbGVdKSB7XG5cdFx0XHRcdGNvbmZpZyA9ICQuZXh0ZW5kKGNvbmZpZywgJC5kYXRlcGlja2VyLnJlZ2lvbmFsW2NvbmZpZy5sb2NhbGVdLCB7fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbmZpZy5taW4pIGNvbmZpZy5taW5EYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgneXktbW0tZGQnLCBjb25maWcubWluKTtcblx0XHRcdGlmKGNvbmZpZy5tYXgpIGNvbmZpZy5tYXhEYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgneXktbW0tZGQnLCBjb25maWcubWF4KTtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBhbmQgb3BlbiBhIGRhdGVwaWNrZXIgXG5cdFx0XHQvLyBsaXZlKCkgZG9lc24ndCBoYXZlIFwib25tYXRjaFwiLCBhbmQgalF1ZXJ5LmVudHdpbmUgaXMgYSBiaXQgdG9vIGhlYXZ5d2VpZ2h0IGZvciB0aGlzLCBzbyB3ZSBuZWVkIHRvIGRvIHRoaXMgb25jbGljay5cblx0XHRcdGNvbmZpZy5kYXRlRm9ybWF0ID0gY29uZmlnLmpxdWVyeWRhdGVmb3JtYXQ7XG5cdFx0XHQkKHRoaXMpLmRhdGVwaWNrZXIoY29uZmlnKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbiQoZG9jdW1lbnQpLm9uKFwiY2xpY2tcIiwgXCIuZmllbGQuZGF0ZSBpbnB1dC50ZXh0LGlucHV0LnRleHQuZGF0ZVwiLCBmdW5jdGlvbigpIHtcblx0JCh0aGlzKS5zc0RhdGVwaWNrZXIoKTtcblxuXHRpZigkKHRoaXMpLmRhdGEoJ2RhdGVwaWNrZXInKSkge1xuXHRcdCQodGhpcykuZGF0ZXBpY2tlcignc2hvdycpO1xuXHR9XG59KTtcbiIsImltcG9ydCAkIGZyb20gJy4valF1ZXJ5JztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5cbiQuZW50d2luZSgnc3MnLCBmdW5jdGlvbigkKSB7XG5cdCQoJy5zcy1ncmlkZmllbGQnKS5lbnR3aW5lKHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBqUXVlcnkuYWpheCgpIGNhbGxcblx0XHQgKiBAcGFyYW0ge3N1Y2Nlc3NDYWxsYmFja30gY2FsbGJhY2sgdG8gY2FsbCBhZnRlciByZWxvYWRpbmcgc3VjY2VlZGVkLlxuXHRcdCAqL1xuXG5cdFx0cmVsb2FkOiBmdW5jdGlvbihhamF4T3B0cywgc3VjY2Vzc0NhbGxiYWNrKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSxcblx0XHRcdFx0Zm9jdXNlZEVsTmFtZSA9IHRoaXMuZmluZCgnOmlucHV0OmZvY3VzJykuYXR0cignbmFtZScpLCAvLyBTYXZlIGZvY3VzZWQgZWxlbWVudCBmb3IgcmVzdG9yaW5nIGFmdGVyIHJlZnJlc2hcblx0XHRcdFx0ZGF0YSA9IGZvcm0uZmluZCgnOmlucHV0Jykuc2VyaWFsaXplQXJyYXkoKTtcblxuXHRcdFx0aWYoIWFqYXhPcHRzKSBhamF4T3B0cyA9IHt9O1xuXHRcdFx0aWYoIWFqYXhPcHRzLmRhdGEpIGFqYXhPcHRzLmRhdGEgPSBbXTtcblx0XHRcdGFqYXhPcHRzLmRhdGEgPSBhamF4T3B0cy5kYXRhLmNvbmNhdChkYXRhKTtcblxuXG5cdFx0XHQvLyBJbmNsdWRlIGFueSBHRVQgcGFyYW1ldGVycyBmcm9tIHRoZSBjdXJyZW50IFVSTCwgYXMgdGhlIHZpZXcgc3RhdGUgbWlnaHQgZGVwZW5kIG9uIGl0LlxuXHRcdFx0Ly8gRm9yIGV4YW1wbGUsIGEgbGlzdCBwcmVmaWx0ZXJlZCB0aHJvdWdoIGV4dGVybmFsIHNlYXJjaCBjcml0ZXJpYSBtaWdodCBiZSBwYXNzZWQgdG8gR3JpZEZpZWxkLlxuXHRcdFx0aWYod2luZG93LmxvY2F0aW9uLnNlYXJjaCkge1xuXHRcdFx0XHRhamF4T3B0cy5kYXRhID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpICsgJyYnICsgJC5wYXJhbShhamF4T3B0cy5kYXRhKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRm9yIGJyb3dzZXJzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IGhpc3RvcnkucHVzaFN0YXRlIGxpa2UgSUU5LCBzcyBmcmFtZXdvcmsgdXNlcyBoYXNoIHRvIHRyYWNrXG5cdFx0XHQvLyB0aGUgY3VycmVudCBsb2NhdGlvbiBmb3IgUEpBWCwgc28gZm9yIHRoZW0gd2UgcGFzcyB0aGUgcXVlcnkgc3RyaW5nIHN0b3JlZCBpbiB0aGUgaGFzaCBpbnN0ZWFkXG5cdFx0XHRpZighd2luZG93Lmhpc3RvcnkgfHwgIXdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSl7XG5cdFx0XHRcdGlmKHdpbmRvdy5sb2NhdGlvbi5oYXNoICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoLmluZGV4T2YoJz8nKSAhPSAtMSl7XG5cdFx0XHRcdFx0YWpheE9wdHMuZGF0YSA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZyh3aW5kb3cubG9jYXRpb24uaGFzaC5pbmRleE9mKCc/JykgKyAxKSArICcmJyArICQucGFyYW0oYWpheE9wdHMuZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9ybS5hZGRDbGFzcygnbG9hZGluZycpO1xuXG5cdFx0XHQkLmFqYXgoJC5leHRlbmQoe30sIHtcblx0XHRcdFx0aGVhZGVyczoge1wiWC1QamF4XCIgOiAnQ3VycmVudEZpZWxkJ30sXG5cdFx0XHRcdHR5cGU6IFwiUE9TVFwiLFxuXHRcdFx0XHR1cmw6IHRoaXMuZGF0YSgndXJsJyksXG5cdFx0XHRcdGRhdGFUeXBlOiAnaHRtbCcsXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHQvLyBSZXBsYWNlIHRoZSBncmlkIGZpZWxkIHdpdGggcmVzcG9uc2UsIG5vdCB0aGUgZm9ybS5cblx0XHRcdFx0XHQvLyBUT0RPIE9ubHkgcmVwbGFjZXMgYWxsIGl0cyBjaGlsZHJlbiwgdG8gYXZvaWQgcmVwbGFjaW5nIHRoZSBjdXJyZW50IHNjb3BlXG5cdFx0XHRcdFx0Ly8gb2YgdGhlIGV4ZWN1dGluZyBtZXRob2QuIE1lYW5zIHRoYXQgaXQgZG9lc24ndCByZXRyaWdnZXIgdGhlIG9ubWF0Y2goKSBvbiB0aGUgbWFpbiBjb250YWluZXIuXG5cdFx0XHRcdFx0c2VsZi5lbXB0eSgpLmFwcGVuZCgkKGRhdGEpLmNoaWxkcmVuKCkpO1xuXG5cdFx0XHRcdFx0Ly8gUmVmb2N1cyBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudC4gVXNlZnVsIGUuZy4gZm9yIGZpbmRpbmcrYWRkaW5nXG5cdFx0XHRcdFx0Ly8gbXVsdGlwbGUgcmVsYXRpb25zaGlwcyB2aWEga2V5Ym9hcmQuXG5cdFx0XHRcdFx0aWYoZm9jdXNlZEVsTmFtZSkgc2VsZi5maW5kKCc6aW5wdXRbbmFtZT1cIicgKyBmb2N1c2VkRWxOYW1lICsgJ1wiXScpLmZvY3VzKCk7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgZmlsdGVyXG5cdFx0XHRcdFx0aWYoc2VsZi5maW5kKCcuZmlsdGVyLWhlYWRlcicpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFyIGNvbnRlbnQ7XG5cdFx0XHRcdFx0XHRpZihhamF4T3B0cy5kYXRhWzBdLmZpbHRlcj09XCJzaG93XCIpIHtcblx0XHRcdFx0XHRcdFx0Y29udGVudCA9ICc8c3BhbiBjbGFzcz1cIm5vbi1zb3J0YWJsZVwiPjwvc3Bhbj4nO1xuXHRcdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCdzaG93LWZpbHRlcicpLmZpbmQoJy5maWx0ZXItaGVhZGVyJykuc2hvdygpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGVudCA9ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBuYW1lPVwic2hvd0ZpbHRlclwiIGNsYXNzPVwic3MtZ3JpZGZpZWxkLWJ1dHRvbi1maWx0ZXIgdHJpZ2dlclwiPjwvYnV0dG9uPic7XG5cdFx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoJ3Nob3ctZmlsdGVyJykuZmluZCgnLmZpbHRlci1oZWFkZXInKS5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNlbGYuZmluZCgnLnNvcnRhYmxlLWhlYWRlciB0aDpsYXN0JykuaHRtbChjb250ZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3JtLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdFx0aWYoc3VjY2Vzc0NhbGxiYWNrKSBzdWNjZXNzQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ3JlbG9hZCcsIHNlbGYpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGFsZXJ0KGkxOG4uX3QoJ0dSSURGSUVMRC5FUlJPUklOVFJBTlNBQ1RJT04nKSk7XG5cdFx0XHRcdFx0Zm9ybS5yZW1vdmVDbGFzcygnbG9hZGluZycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBhamF4T3B0cykpO1xuXHRcdH0sXG5cdFx0c2hvd0RldGFpbFZpZXc6IGZ1bmN0aW9uKHVybCkge1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cdFx0fSxcblx0XHRnZXRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcuc3MtZ3JpZGZpZWxkLWl0ZW0nKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfVxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9XG5cdFx0ICovXG5cdFx0c2V0U3RhdGU6IGZ1bmN0aW9uKGssIHYpIHtcblx0XHRcdHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcblx0XHRcdHN0YXRlW2tdID0gdjtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9XCInICsgdGhpcy5kYXRhKCduYW1lJykgKyAnW0dyaWRTdGF0ZV1cIl0nKS52YWwoSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVwiJyArIHRoaXMuZGF0YSgnbmFtZScpICsgJ1tHcmlkU3RhdGVdXCJdJykudmFsKCkpO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnLnNzLWdyaWRmaWVsZCAqJykuZW50d2luZSh7XG5cdFx0Z2V0R3JpZEZpZWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5zcy1ncmlkZmllbGQnKTtcblx0XHR9XG5cdH0pO1xuXG5cblxuXHQkKCcuc3MtZ3JpZGZpZWxkIDpidXR0b25bbmFtZT1zaG93RmlsdGVyXScpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdCQoJy5maWx0ZXItaGVhZGVyJylcblx0XHRcdFx0LnNob3coJ3Nsb3cnKSAvLyBhbmltYXRlIHZpc2liaWxpdHlcblx0XHRcdFx0LmZpbmQoJzppbnB1dDpmaXJzdCcpLmZvY3VzKCk7IC8vIGZvY3VzIGZpcnN0IHNlYXJjaCBmaWVsZFxuXHRcdFx0dGhpcy5jbG9zZXN0KCcuc3MtZ3JpZGZpZWxkJykuYWRkQ2xhc3MoJ3Nob3ctZmlsdGVyJyk7XG5cdFx0XHR0aGlzLnBhcmVudCgpLmh0bWwoJzxzcGFuIGNsYXNzPVwibm9uLXNvcnRhYmxlXCI+PC9zcGFuPicpO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSk7XG5cblxuXHQkKCcuc3MtZ3JpZGZpZWxkIC5zcy1ncmlkZmllbGQtaXRlbScpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmKCQoZS50YXJnZXQpLmNsb3Nlc3QoJy5hY3Rpb24nKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fc3VwZXIoZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGVkaXRMaW5rID0gdGhpcy5maW5kKCcuZWRpdC1saW5rJyk7XG5cdFx0XHRpZihlZGl0TGluay5sZW5ndGgpIHRoaXMuZ2V0R3JpZEZpZWxkKCkuc2hvd0RldGFpbFZpZXcoZWRpdExpbmsucHJvcCgnaHJlZicpKTtcblx0XHR9LFxuXHRcdG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmKHRoaXMuZmluZCgnLmVkaXQtbGluaycpLmxlbmd0aCkgdGhpcy5jc3MoJ2N1cnNvcicsICdwb2ludGVyJyk7XG5cdFx0fSxcblx0XHRvbm1vdXNlb3V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY3NzKCdjdXJzb3InLCAnZGVmYXVsdCcpO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnLnNzLWdyaWRmaWVsZCAuYWN0aW9uJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgZmlsdGVyU3RhdGU9J3Nob3cnOyAvL2ZpbHRlcnN0YXRlIHNob3VsZCBlcXVhbCBjdXJyZW50IHN0YXRlLlxuXG5cdFx0XHQvLyBJZiB0aGUgYnV0dG9uIGlzIGRpc2FibGVkLCBkbyBub3RoaW5nLlxuXHRcdFx0aWYgKHRoaXMuYnV0dG9uKCdvcHRpb24nLCAnZGlzYWJsZWQnKSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYodGhpcy5oYXNDbGFzcygnc3MtZ3JpZGZpZWxkLWJ1dHRvbi1jbG9zZScpIHx8ICEodGhpcy5jbG9zZXN0KCcuc3MtZ3JpZGZpZWxkJykuaGFzQ2xhc3MoJ3Nob3ctZmlsdGVyJykpKXtcblx0XHRcdFx0ZmlsdGVyU3RhdGU9J2hpZGRlbic7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ2V0R3JpZEZpZWxkKCkucmVsb2FkKHtkYXRhOiBbe25hbWU6IHRoaXMuYXR0cignbmFtZScpLCB2YWx1ZTogdGhpcy52YWwoKSwgZmlsdGVyOiBmaWx0ZXJTdGF0ZX1dfSk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogRG9uJ3QgYWxsb3cgdXNlcnMgdG8gc3VibWl0IGVtcHR5IHZhbHVlcyBpbiBncmlkIGZpZWxkIGF1dG8gY29tcGxldGUgaW5wdXRzLlxuXHQgKi9cblx0JCgnLnNzLWdyaWRmaWVsZCAuYWRkLWV4aXN0aW5nLWF1dG9jb21wbGV0ZXInKS5lbnR3aW5lKHtcblx0XHRvbmJ1dHRvbmNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLnRvZ2dsZURpc2FibGVkKCk7XG5cblx0XHRcdHRoaXMuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5vbigna2V5dXAnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYudG9nZ2xlRGlzYWJsZWQoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b251bm1hdGNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmZpbmQoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJykub2ZmKCdrZXl1cCcpO1xuXHRcdH0sXG5cdFx0dG9nZ2xlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciAkYnV0dG9uID0gdGhpcy5maW5kKCcuc3MtdWktYnV0dG9uJyksXG5cdFx0XHRcdCRpbnB1dCA9IHRoaXMuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKSxcblx0XHRcdFx0aW5wdXRIYXNWYWx1ZSA9ICRpbnB1dC52YWwoKSAhPT0gJycsXG5cdFx0XHRcdGJ1dHRvbkRpc2FibGVkID0gJGJ1dHRvbi5pcygnOmRpc2FibGVkJyk7XG5cblx0XHRcdGlmICgoaW5wdXRIYXNWYWx1ZSAmJiBidXR0b25EaXNhYmxlZCkgfHwgKCFpbnB1dEhhc1ZhbHVlICYmICFidXR0b25EaXNhYmxlZCkpIHtcblx0XHRcdFx0JGJ1dHRvbi5idXR0b24oXCJvcHRpb25cIiwgXCJkaXNhYmxlZFwiLCAhYnV0dG9uRGlzYWJsZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Ly8gQ292ZXJzIGJvdGggdGFidWxhciBkZWxldGUgYnV0dG9uLCBhbmQgdGhlIGJ1dHRvbiBvbiB0aGUgZGV0YWlsIGZvcm0gXG5cdCQoJy5zcy1ncmlkZmllbGQgLmNvbC1idXR0b25zIC5hY3Rpb24uZ3JpZGZpZWxkLWJ1dHRvbi1kZWxldGUsIC5jbXMtZWRpdC1mb3JtIC5BY3Rpb25zIGJ1dHRvbi5hY3Rpb24uYWN0aW9uLWRlbGV0ZScpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYoIWNvbmZpcm0oaTE4bi5fdCgnVEFCTEVGSUVMRC5ERUxFVEVDT05GSVJNTUVTU0FHRScpKSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdFxuXHQkKCcuc3MtZ3JpZGZpZWxkIC5hY3Rpb24uZ3JpZGZpZWxkLWJ1dHRvbi1wcmludCcpLmVudHdpbmUoe1xuXHRcdFVVSUQ6IG51bGwsXG5cdFx0b25tYXRjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0dGhpcy5zZXRVVUlEKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0XHR9LFxuXHRcdG9udW5tYXRjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cdFx0b25jbGljazogZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgYnRuID0gdGhpcy5jbG9zZXN0KCc6YnV0dG9uJyksIGdyaWQgPSB0aGlzLmdldEdyaWRGaWVsZCgpLFxuXHRcdFx0XHRmb3JtID0gdGhpcy5jbG9zZXN0KCdmb3JtJyksIGRhdGEgPSBmb3JtLmZpbmQoJzppbnB1dC5ncmlkc3RhdGUnKS5zZXJpYWxpemUoKTs7XG5cblx0XHRcdC8vIEFkZCBjdXJyZW50IGJ1dHRvblxuXHRcdFx0ZGF0YSArPSBcIiZcIiArIGVuY29kZVVSSUNvbXBvbmVudChidG4uYXR0cignbmFtZScpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChidG4udmFsKCkpO1xuXG5cdFx0XHQvLyBJbmNsdWRlIGFueSBHRVQgcGFyYW1ldGVycyBmcm9tIHRoZSBjdXJyZW50IFVSTCwgYXMgdGhlIHZpZXdcblx0XHRcdC8vIHN0YXRlIG1pZ2h0IGRlcGVuZCBvbiBpdC5cblx0XHRcdC8vIEZvciBleGFtcGxlLCBhIGxpc3QgcHJlZmlsdGVyZWQgdGhyb3VnaCBleHRlcm5hbCBzZWFyY2ggY3JpdGVyaWFcblx0XHRcdC8vIG1pZ2h0IGJlIHBhc3NlZCB0byBHcmlkRmllbGQuXG5cdFx0XHRpZih3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG5cdFx0XHRcdGRhdGEgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgKyAnJicgKyBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgdXNlID8gb3IgJiB0byBjb25uZWN0IHRoZSBVUkxcblx0XHRcdHZhciBjb25uZWN0b3IgPSBncmlkLmRhdGEoJ3VybCcpLmluZGV4T2YoJz8nKSA9PSAtMSA/ICc/JyA6ICcmJztcblxuXHRcdFx0dmFyIHVybCA9ICQucGF0aC5tYWtlVXJsQWJzb2x1dGUoXG5cdFx0XHRcdGdyaWQuZGF0YSgndXJsJykgKyBjb25uZWN0b3IgKyBkYXRhLFxuXHRcdFx0XHQkKCdiYXNlJykuYXR0cignaHJlZicpXG5cdFx0XHQpO1xuXG5cdFx0XHR2YXIgbmV3V2luZG93ID0gd2luZG93Lm9wZW4odXJsKTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQkKCcuc3MtZ3JpZGZpZWxkLXByaW50LWlmcmFtZScpLmVudHdpbmUoe1xuXHRcdG9ubWF0Y2g6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHR0aGlzLmhpZGUoKS5iaW5kKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0dmFyIGlmV2luID0gdGhpcy5jb250ZW50V2luZG93IHx8IHRoaXM7XG5cdFx0XHRcdGlmV2luLnByaW50KCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG9udW5tYXRjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogUHJldmVudHMgYWN0aW9ucyBmcm9tIGNhdXNpbmcgYW4gYWpheCByZWxvYWQgb2YgdGhlIGZpZWxkLlxuXHQgKlxuXHQgKiBVc2VmdWwgZS5nLiBmb3IgYWN0aW9ucyB3aGljaCByZWx5IG9uIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBiZWluZ1xuXHQgKiBpbnRlcnByZXRlZCBuYXRpdmVseSBieSB0aGUgYnJvd3NlciwgbGlrZSBmaWxlIGRvd25sb2FkIHRyaWdnZXJzLlxuXHQgKi9cblx0JCgnLnNzLWdyaWRmaWVsZCAuYWN0aW9uLm5vLWFqYXgnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgYnRuID0gdGhpcy5jbG9zZXN0KCc6YnV0dG9uJyksIGdyaWQgPSB0aGlzLmdldEdyaWRGaWVsZCgpLCBcblx0XHRcdFx0Zm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpLCBkYXRhID0gZm9ybS5maW5kKCc6aW5wdXQuZ3JpZHN0YXRlJykuc2VyaWFsaXplKCk7XG5cblx0XHRcdC8vIEFkZCBjdXJyZW50IGJ1dHRvblxuXHRcdFx0ZGF0YSArPSBcIiZcIiArIGVuY29kZVVSSUNvbXBvbmVudChidG4uYXR0cignbmFtZScpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChidG4udmFsKCkpO1xuXG5cdFx0XHQvLyBJbmNsdWRlIGFueSBHRVQgcGFyYW1ldGVycyBmcm9tIHRoZSBjdXJyZW50IFVSTCwgYXMgdGhlIHZpZXdcblx0XHRcdC8vIHN0YXRlIG1pZ2h0IGRlcGVuZCBvbiBpdC4gRm9yIGV4YW1wbGUsIGEgbGlzdCBwcmUtZmlsdGVyZWRcblx0XHRcdC8vIHRocm91Z2ggZXh0ZXJuYWwgc2VhcmNoIGNyaXRlcmlhIG1pZ2h0IGJlIHBhc3NlZCB0byBHcmlkRmllbGQuXG5cdFx0XHRpZih3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG5cdFx0XHRcdGRhdGEgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgKyAnJicgKyBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgdXNlID8gb3IgJiB0byBjb25uZWN0IHRoZSBVUkxcblx0XHRcdHZhciBjb25uZWN0b3IgPSBncmlkLmRhdGEoJ3VybCcpLmluZGV4T2YoJz8nKSA9PSAtMSA/ICc/JyA6ICcmJztcblxuXHRcdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSAkLnBhdGgubWFrZVVybEFic29sdXRlKFxuXHRcdFx0XHRncmlkLmRhdGEoJ3VybCcpICsgY29ubmVjdG9yICsgZGF0YSxcblx0XHRcdFx0JCgnYmFzZScpLmF0dHIoJ2hyZWYnKVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnLnNzLWdyaWRmaWVsZCAuYWN0aW9uLWRldGFpbCcpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRHcmlkRmllbGQoKS5zaG93RGV0YWlsVmlldygkKHRoaXMpLnByb3AoJ2hyZWYnKSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogQWxsb3dzIHNlbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSByb3dzIGluIHRoZSBncmlkIGZpZWxkLlxuXHQgKiBQdXJlbHkgY2xpZW50c2lkZSBhdCB0aGUgbW9tZW50LlxuXHQgKi9cblx0JCgnLnNzLWdyaWRmaWVsZFtkYXRhLXNlbGVjdGFibGVdJykuZW50d2luZSh7XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fSBDb2xsZWN0aW9uXG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcuc3MtZ3JpZGZpZWxkLWl0ZW0udWktc2VsZWN0ZWQnKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBPZiByZWNvcmQgSURzXG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWRJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpLCBmdW5jdGlvbihlbCkge3JldHVybiAkKGVsKS5kYXRhKCdpZCcpO30pO1xuXHRcdH1cblx0fSk7XG5cdCQoJy5zcy1ncmlkZmllbGRbZGF0YS1zZWxlY3RhYmxlXSAuc3MtZ3JpZGZpZWxkLWl0ZW1zJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdFx0Ly8gVE9ETyBMaW1pdCB0byBzaW5nbGUgc2VsZWN0aW9uXG5cdFx0XHR0aGlzLnNlbGVjdGFibGUoKTtcblx0XHR9LFxuXHRcdG9ucmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRpZiAodGhpcy5kYXRhKCdzZWxlY3RhYmxlJykpIHRoaXMuc2VsZWN0YWJsZSgnZGVzdHJveScpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogQ2F0Y2ggc3VibWlzc2lvbiBldmVudCBpbiBmaWx0ZXIgaW5wdXQgZmllbGRzLCBhbmQgc3VibWl0IHRoZSBjb3JyZWN0IGJ1dHRvblxuXHQgKiByYXRoZXIgdGhhbiB0aGUgd2hvbGUgZm9ybS5cblx0ICovXG5cdCQoJy5zcy1ncmlkZmllbGQgLmZpbHRlci1oZWFkZXIgOmlucHV0JykuZW50d2luZSh7XG5cdFx0b25tYXRjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZmlsdGVyYnRuID0gdGhpcy5jbG9zZXN0KCcuZmllbGRncm91cCcpLmZpbmQoJy5zcy1ncmlkZmllbGQtYnV0dG9uLWZpbHRlcicpLFxuXHRcdFx0XHRyZXNldGJ0biA9IHRoaXMuY2xvc2VzdCgnLmZpZWxkZ3JvdXAnKS5maW5kKCcuc3MtZ3JpZGZpZWxkLWJ1dHRvbi1yZXNldCcpO1xuXHRcdFx0XG5cdFx0XHRpZih0aGlzLnZhbCgpKSB7XG5cdFx0XHRcdGZpbHRlcmJ0bi5hZGRDbGFzcygnZmlsdGVyZWQnKTtcblx0XHRcdFx0cmVzZXRidG4uYWRkQ2xhc3MoJ2ZpbHRlcmVkJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cdFx0b251bm1hdGNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRvbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIFNraXAgcmVzZXQgYnV0dG9uIGV2ZW50cywgdGhleSBzaG91bGQgdHJpZ2dlciBkZWZhdWx0IHN1Ym1pc3Npb25cblx0XHRcdGlmKHRoaXMuY2xvc2VzdCgnLnNzLWdyaWRmaWVsZC1idXR0b24tcmVzZXQnKS5sZW5ndGgpIHJldHVybjtcblxuXHRcdFx0dmFyIGZpbHRlcmJ0biA9IHRoaXMuY2xvc2VzdCgnLmZpZWxkZ3JvdXAnKS5maW5kKCcuc3MtZ3JpZGZpZWxkLWJ1dHRvbi1maWx0ZXInKSxcblx0XHRcdFx0cmVzZXRidG4gPSB0aGlzLmNsb3Nlc3QoJy5maWVsZGdyb3VwJykuZmluZCgnLnNzLWdyaWRmaWVsZC1idXR0b24tcmVzZXQnKTtcblxuXHRcdFx0aWYoZS5rZXlDb2RlID09ICcxMycpIHtcblx0XHRcdFx0dmFyIGJ0bnMgPSB0aGlzLmNsb3Nlc3QoJy5maWx0ZXItaGVhZGVyJykuZmluZCgnLnNzLWdyaWRmaWVsZC1idXR0b24tZmlsdGVyJyk7XG5cdFx0XHRcdHZhciBmaWx0ZXJTdGF0ZT0nc2hvdyc7IC8vZmlsdGVyc3RhdGUgc2hvdWxkIGVxdWFsIGN1cnJlbnQgc3RhdGUuXHRcdFx0XHRcblx0XHRcdFx0aWYodGhpcy5oYXNDbGFzcygnc3MtZ3JpZGZpZWxkLWJ1dHRvbi1jbG9zZScpfHwhKHRoaXMuY2xvc2VzdCgnLnNzLWdyaWRmaWVsZCcpLmhhc0NsYXNzKCdzaG93LWZpbHRlcicpKSl7XG5cdFx0XHRcdFx0ZmlsdGVyU3RhdGU9J2hpZGRlbic7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuZ2V0R3JpZEZpZWxkKCkucmVsb2FkKHtkYXRhOiBbe25hbWU6IGJ0bnMuYXR0cignbmFtZScpLCB2YWx1ZTogYnRucy52YWwoKSwgZmlsdGVyOiBmaWx0ZXJTdGF0ZX1dfSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmaWx0ZXJidG4uYWRkQ2xhc3MoJ2hvdmVyLWFsaWtlJyk7XG5cdFx0XHRcdHJlc2V0YnRuLmFkZENsYXNzKCdob3Zlci1hbGlrZScpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JChcIi5zcy1ncmlkZmllbGQgLnJlbGF0aW9uLXNlYXJjaFwiKS5lbnR3aW5lKHtcblx0XHRvbmZvY3VzaW46IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0dGhpcy5hdXRvY29tcGxldGUoe1xuXHRcdFx0XHRzb3VyY2U6IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKXtcblx0XHRcdFx0XHR2YXIgc2VhcmNoRmllbGQgPSAkKHRoaXMuZWxlbWVudCk7XG5cdFx0XHRcdFx0dmFyIGZvcm0gPSAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdChcImZvcm1cIik7XG5cdFx0XHRcdFx0JC5hamF4KHtcblx0XHRcdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHRcdFx0XCJYLVBqYXhcIiA6ICdQYXJ0aWFsJ1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0XHRcdFx0XHR1cmw6ICQoc2VhcmNoRmllbGQpLmRhdGEoJ3NlYXJjaFVybCcpLFxuXHRcdFx0XHRcdFx0ZGF0YTogZW5jb2RlVVJJQ29tcG9uZW50KHNlYXJjaEZpZWxkLmF0dHIoJ25hbWUnKSkrJz0nK2VuY29kZVVSSUNvbXBvbmVudChzZWFyY2hGaWVsZC52YWwoKSksIFxuXHRcdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZShKU09OLnBhcnNlKGRhdGEpKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRhbGVydChpMThuLl90KCdHUklERklFTEQuRVJST1JJTlRSQU5TQUNUSU9OJywgJ0FuIGVycm9yIG9jY3VyZWQgd2hpbGUgZmV0Y2hpbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcXG4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5jbG9zZXN0KFwiLnNzLWdyaWRmaWVsZFwiKS5maW5kKFwiI2FjdGlvbl9ncmlkZmllbGRfcmVsYXRpb25maW5kXCIpLnJlcGxhY2VXaXRoKFxuXHRcdFx0XHRcdFx0JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInJlbGF0aW9uSURcIiB2YWx1ZT1cIicrdWkuaXRlbS5pZCsnXCIgaWQ9XCJyZWxhdGlvbklEXCIvPidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHZhciBhZGRidXR0b24gPSAkKHRoaXMpLmNsb3Nlc3QoXCIuc3MtZ3JpZGZpZWxkXCIpLmZpbmQoXCIjYWN0aW9uX2dyaWRmaWVsZF9yZWxhdGlvbmFkZFwiKTtcblx0XHRcdFx0XHRpZihhZGRidXR0b24uZGF0YSgnYnV0dG9uJykpe1xuXHRcdFx0XHRcdFx0YWRkYnV0dG9uLmJ1dHRvbignZW5hYmxlJyk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRhZGRidXR0b24ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0JChcIi5zcy1ncmlkZmllbGQgLnBhZ2luYXRpb24tcGFnZS1udW1iZXIgaW5wdXRcIikuZW50d2luZSh7XG5cdFx0b25rZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYoZXZlbnQua2V5Q29kZSA9PSAxMykge1xuXHRcdFx0XHR2YXIgbmV3cGFnZSA9IHBhcnNlSW50KCQodGhpcykudmFsKCksIDEwKTtcblxuXHRcdFx0XHR2YXIgZ3JpZGZpZWxkID0gJCh0aGlzKS5nZXRHcmlkRmllbGQoKTtcblx0XHRcdFx0Z3JpZGZpZWxkLnNldFN0YXRlKCdHcmlkRmllbGRQYWdpbmF0b3InLCB7Y3VycmVudFBhZ2U6IG5ld3BhZ2V9KTtcblx0XHRcdFx0Z3JpZGZpZWxkLnJlbG9hZCgpO1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSk7XG4iLCIvKipcbiAqIEZ1bmN0aW9ucyBmb3IgSHRtbEVkaXRvckZpZWxkcyBpbiB0aGUgYmFjayBlbmQuXG4gKiBJbmNsdWRlcyB0aGUgSlMgZm9yIHRoZSBJbWFnZVVwbG9hZCBmb3Jtcy5cbiAqXG4gKiBSZWxpZXMgb24gdGhlIGpxdWVyeS5mb3JtLmpzIHBsdWdpbiB0byBwb3dlciB0aGVcbiAqIGFqYXggLyBpZnJhbWUgc3VibWlzc2lvbnNcbiAqL1xuXG5pbXBvcnQgJCBmcm9tICcuL2pRdWVyeSc7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuXG52YXIgc3MgPSB0eXBlb2Ygd2luZG93LnNzICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zcyA6IHt9O1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIEhUTUwgV1lTSVdZRyBsaWJyYXJpZXMsIHdoaWNoIGFic3RyYWN0cyBsaWJyYXJ5IGludGVybmFsc1xuICogZnJvbSBpbnRlcmZhY2UgY29uY2VybnMgbGlrZSBpbnNlcnRpbmcgYW5kIGVkaXRpbmcgbGlua3MuXG4gKiBDYXV0aW9uOiBJbmNvbXBsZXRlIGFuZCB1bnN0YWJsZSBBUEkuXG4gKi9cbnNzLmVkaXRvcldyYXBwZXJzID0ge307XG5zcy5lZGl0b3JXcmFwcGVycy50aW55TUNFID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8vIElEIG9mIGVkaXRvciB0aGlzIGlzIGFzc2lnbmVkIHRvXG5cdHZhciBlZGl0b3JJRDtcblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2UgdGhlIGVkaXRvclxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IElEIG9mIHBhcmVudCB0ZXh0YXJlYSBkb21JRFxuICAgICAgICAgKi9cblx0XHRpbml0OiBmdW5jdGlvbihJRCkge1xuXHRcdFx0ZWRpdG9ySUQgPSBJRDtcblxuXHRcdFx0dGhpcy5jcmVhdGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBlZGl0b3IgYW5kIGNsZWFudXBcblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHRpbnltY2UuRWRpdG9yTWFuYWdlci5leGVjQ29tbWFuZCgnbWNlUmVtb3ZlRWRpdG9yJywgZmFsc2UsIGVkaXRvcklEKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IFRpbnlNQ0UgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyBFZGl0b3JcbiAgICAgICAgICovXG5cdFx0Z2V0SW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRpbnltY2UuRWRpdG9yTWFuYWdlci5nZXQoZWRpdG9ySUQpO1xuXHRcdH0sXG5cblx0XHQvKiooXG5cdFx0ICogSW52b2tlZCB3aGVuIGEgY29udGVudC1tb2RpZnlpbmcgVUkgaXMgb3BlbmVkLlxuXHRcdCAqL1xuXHRcdG9ub3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBOT09QXG5cdFx0fSxcblxuXHRcdC8qKihcblx0XHQgKiBJbnZva2VkIHdoZW4gYSBjb250ZW50LW1vZGlmeWluZyBVSSBpcyBjbG9zZWQuXG5cdFx0ICovXG5cdFx0b25jbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBOT09QXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBjb25maWcgZm9yIHRoaXMgZGF0YVxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMgYXJyYXlcbiAgICAgICAgICovXG5cdFx0Z2V0Q29uZmlnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IFwiI1wiICsgZWRpdG9ySUQsXG5cdFx0XHRcdGNvbmZpZyA9ICQoc2VsZWN0b3IpLmRhdGEoJ2NvbmZpZycpLFxuXHRcdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdFx0Ly8gQWRkIGluc3RhbmNlIHNwZWNpZmljIGRhdGEgdG8gY29uZmlnXG5cdFx0XHRjb25maWcuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gRW5zdXJlIHNhdmUgZXZlbnRzIHdyaXRlIGJhY2sgdG8gdGV4dGFyZWFcblx0XHRcdGNvbmZpZy5zZXR1cCA9IGZ1bmN0aW9uKGVkKSB7XG5cdFx0XHRcdGVkLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnNhdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogV3JpdGUgdGhlIEhUTUwgYmFjayB0byB0aGUgb3JpZ2luYWwgdGV4dCBhcmVhIGZpZWxkLlxuXHRcdCAqL1xuXHRcdHNhdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuXHRcdFx0aW5zdGFuY2Uuc2F2ZSgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgY2hhbmdlIGRldGVjdGlvblxuXHRcdFx0JChpbnN0YW5jZS5nZXRFbGVtZW50KCkpLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBiYXNlZCBvbiBhIHRleHRhcmVhIGZpZWxkLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcblx0XHRcdC8vIGhhY2sgdG8gc2V0IGJhc2VVUkwgc2FmZWx5XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmJhc2VVUkwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRpbnltY2UuRWRpdG9yTWFuYWdlci5iYXNlVVJMID0gY29uZmlnLmJhc2VVUkw7XG5cdFx0XHR9XG5cdFx0XHR0aW55bWNlLmluaXQoY29uZmlnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVxdWVzdCBhbiB1cGRhdGUgdG8gZWRpdG9yIGNvbnRlbnRcblx0XHQgKi9cblx0XHRyZXBhaW50OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE5PT1Bcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiBib29sZWFuXG5cdFx0ICovXG5cdFx0aXNEaXJ0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmlzRGlydHkoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWRpdGVkIGNvbnRlbnQuXG5cdFx0ICpcblx0XHQgKiBSZXR1cm5zOiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5nZXRDb250ZW50KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERPTSB0cmVlIG9mIHRoZSBlZGl0ZWQgY29udGVudFxuXHRcdCAqXG5cdFx0ICogUmV0dXJuczogRE9NRWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldERPTTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmdldEVsZW1lbnQoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuczogRE9NRWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmdldENvbnRhaW5lcigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGNsb3Nlc3Qgbm9kZSBtYXRjaGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBSZXR1cm5zOiB7alF1ZXJ5fSBET01FbGVtZW50XG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuc2VsZWN0aW9uLmdldE5vZGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2VsZWN0IHRoZSBnaXZlbiBub2RlIHdpdGhpbiB0aGUgZWRpdG9yIERPTVxuXHRcdCAqXG5cdFx0ICogUGFyYW1ldGVyczoge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0c2VsZWN0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5zZWxlY3Qobm9kZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgZW50aXJlIGNvbnRlbnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0XHQgKi9cblx0XHRzZXRDb250ZW50OiBmdW5jdGlvbihodG1sLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuc2V0Q29udGVudChodG1sLCBvcHRzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0IGNvbnRlbnQgYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0XHQgKi9cblx0XHRpbnNlcnRDb250ZW50OiBmdW5jdGlvbihodG1sLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuaW5zZXJ0Q29udGVudChodG1sLCBvcHRzKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgY3VycmVudGx5IHNlbGVjdGVkIGNvbnRlbnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICovXG5cdFx0cmVwbGFjZUNvbnRlbnQ6IGZ1bmN0aW9uKGh0bWwsIG9wdHMpIHtcblx0XHRcdHRoaXMuZ2V0SW5zdGFuY2UoKS5leGVjQ29tbWFuZCgnbWNlUmVwbGFjZUNvbnRlbnQnLCBmYWxzZSwgaHRtbCwgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBJbnNlcnQgb3IgdXBkYXRlIGEgbGluayBpbiB0aGUgY29udGVudCBhcmVhIChiYXNlZCBvbiBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24pXG5cdFx0ICpcblx0XHQgKiBQYXJhbWV0ZXJzOiB7T2JqZWN0fSBhdHRyc1xuXHRcdCAqL1xuXHRcdGluc2VydExpbms6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuZXhlY0NvbW1hbmQoXCJtY2VJbnNlcnRMaW5rXCIsIGZhbHNlLCBhdHRycywgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgKGlmIGFueSkuXG5cdFx0ICovXG5cdFx0cmVtb3ZlTGluazogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuZXhlY0NvbW1hbmQoJ3VubGluaycsIGZhbHNlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFN0cmlwIGFueSBlZGl0b3Itc3BlY2lmaWMgbm90YXRpb24gZnJvbSBsaW5rIGluIG9yZGVyIHRvIG1ha2UgaXQgcHJlc2VudGFibGUgaW4gdGhlIFVJLlxuXHRcdCAqXG5cdFx0ICogUGFyYW1ldGVyczpcblx0XHQgKiAge09iamVjdH1cblx0XHQgKiAge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0Y2xlYW5MaW5rOiBmdW5jdGlvbihocmVmLCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLmdldENvbmZpZyxcblx0XHRcdFx0Y2IgPSBzZXR0aW5nc1sndXJsY29udmVydGVyX2NhbGxiYWNrJ107XG5cdFx0XHRpZihjYikgaHJlZiA9IGV2YWwoY2IgKyBcIihocmVmLCBub2RlLCB0cnVlKTtcIik7XG5cblx0XHRcdC8vIFR1cm4gaW50byByZWxhdGl2ZVxuXHRcdFx0aWYoaHJlZi5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHRpbnlNQ0Uuc2V0dGluZ3NbJ2RvY3VtZW50X2Jhc2VfdXJsJ10gKyAnKC4qKSQnKSkpIHtcblx0XHRcdFx0aHJlZiA9IFJlZ0V4cC4kMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHJpZCBvZiBUaW55TUNFJ3MgdGVtcG9yYXJ5IFVSTHNcblx0XHRcdGlmKGhyZWYubWF0Y2goL15qYXZhc2NyaXB0OlxccyptY3RtcC8pKSBocmVmID0gJyc7XG5cblx0XHRcdHJldHVybiBocmVmO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGJvb2ttYXJrIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJhbmdlLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlc2VsZWN0IHRoaXMgcmFuZ2UgYXQgYSBsYXRlciBwb2ludC5cblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRjcmVhdGVCb29rbWFyazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogU2VsZWN0cyBhIGJvb2ttYXJrZWQgcmFuZ2UgcHJldmlvdXNseSBzYXZlZCB0aHJvdWdoIGNyZWF0ZUJvb2ttYXJrKCkuXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IGJvb2ttYXJrXG5cdFx0ICovXG5cdFx0bW92ZVRvQm9va21hcms6IGZ1bmN0aW9uKGJvb2ttYXJrKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcblx0XHRcdHRoaXMuZ2V0SW5zdGFuY2UoKS5mb2N1cygpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbnkgc2VsZWN0aW9uICYgZGUtZm9jdXNlcyB0aGlzIGVkaXRvclxuXHRcdCAqL1xuXHRcdGJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5jb2xsYXBzZSgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQWRkIG5ldyB1bmRvIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgRE9NIGNvbnRlbnQuXG5cdFx0ICovXG5cdFx0YWRkVW5kbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkudW5kb01hbmFnZXIuYWRkKCk7XG5cdFx0fVxuXHR9O1xufSk7XG4vLyBPdmVycmlkZSB0aGlzIHRvIHN3aXRjaCBlZGl0b3Igd3JhcHBlcnNcbnNzLmVkaXRvcldyYXBwZXJzWydkZWZhdWx0J10gPSBzcy5lZGl0b3JXcmFwcGVycy50aW55TUNFO1xuXG4kLmVudHdpbmUoJ3NzJywgZnVuY3Rpb24oJCkge1xuXG5cdC8qKlxuXHQgKiBDbGFzczogdGV4dGFyZWEuaHRtbGVkaXRvclxuXHQgKlxuXHQgKiBBZGQgdGlueW1jZSB0byBIdG1sRWRpdG9yRmllbGRzIHdpdGhpbiB0aGUgQ01TLiBXb3JrcyBpbiBjb21iaW5hdGlvblxuXHQgKiB3aXRoIGEgVGlueU1DRS5pbml0KCkgY2FsbCB3aGljaCBpcyBwcmVwb3B1bGF0ZWQgd2l0aCB0aGUgdXNlZCBIVE1MRWRpdG9yQ29uZmlnIHNldHRpbmdzLFxuXHQgKiBhbmQgaW5jbHVkZWQgaW4gdGhlIHBhZ2UgYXMgYW4gaW5saW5lIDxzY3JpcHQ+IHRhZy5cblx0ICovXG5cdCQoJ3RleHRhcmVhLmh0bWxlZGl0b3InKS5lbnR3aW5lKHtcblxuXHRcdEVkaXRvcjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdG9yOiBvbm1hdGNoXG5cdFx0ICovXG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVkQ2xhc3MgPSB0aGlzLmRhdGEoJ2VkaXRvcicpIHx8ICdkZWZhdWx0Jyxcblx0XHRcdFx0ZWQgPSBzcy5lZGl0b3JXcmFwcGVyc1tlZENsYXNzXSgpO1xuXHRcdFx0dGhpcy5zZXRFZGl0b3IoZWQpO1xuXG5cdFx0XHRlZC5pbml0KHRoaXMuYXR0cignaWQnKSk7XG5cblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3RydWN0b3I6IG9udW5tYXRjaFxuXHRcdCAqL1xuXHRcdG9ucmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0RWRpdG9yKCkuZGVzdHJveSgpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWFrZSBzdXJlIHRoZSBlZGl0b3IgaGFzIGZsdXNoZWQgYWxsIGl0J3MgYnVmZmVycyBiZWZvcmUgdGhlIGZvcm0gaXMgc3VibWl0dGVkLlxuXHRcdCAqL1xuXHRcdCdmcm9tIC5jbXMtZWRpdC1mb3JtJzoge1xuXHRcdFx0b25iZWZvcmVzdWJtaXRmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5nZXRFZGl0b3IoKS5zYXZlKCk7XG5cdFx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJzIGluc2VydC1saW5rIGRpYWxvZ1xuXHRcdCAqIFNlZSBlZGl0b3JfcGx1Z2luX3NyYy5qc1xuXHRcdCAqL1xuXHRcdG9wZW5MaW5rRGlhbG9nOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMub3BlbkRpYWxvZygnbGluaycpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmlnZ2VycyBpbnNlcnQtbWVkaWEgZGlhbG9nXG5cdFx0ICogU2VlIGVkaXRvcl9wbHVnaW5fc3JjLmpzXG5cdFx0ICovXG5cdFx0b3Blbk1lZGlhRGlhbG9nOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMub3BlbkRpYWxvZygnbWVkaWEnKTtcblx0XHR9LFxuXG5cdFx0b3BlbkRpYWxvZzogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHR1cmwgPSAkKCcjY21zLWVkaXRvci1kaWFsb2dzJykuZGF0YSgndXJsJyArIGNhcGl0YWxpemUodHlwZSkgKyAnZm9ybScpLFxuXHRcdFx0XHRkaWFsb2cgPSAkKCcuaHRtbGVkaXRvcmZpZWxkLScgKyB0eXBlICsgJ2RpYWxvZycpO1xuXG5cdFx0XHRpZihkaWFsb2cubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIENsZWFuIGV4aXN0aW5nIGRpYWxvZyBmb3IgcmVsb2FkXG5cdFx0XHRcdGRpYWxvZy5nZXRGb3JtKCkuc2V0RWxlbWVudCh0aGlzKTtcblx0XHRcdFx0ZGlhbG9nLmh0bWwoJycpO1xuXHRcdFx0XHRkaWFsb2cuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdFx0ZGlhbG9nLm9wZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFNob3cgYSBwbGFjZWhvbGRlciBmb3IgaW5zdGFudCBmZWVkYmFjay4gV2lsbCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbFxuXHRcdFx0XHQvLyBmb3JtIGRpYWxvZyBvbmNlIGl0cyBsb2FkZWQuXG5cdFx0XHRcdGRpYWxvZyA9ICQoJzxkaXYgY2xhc3M9XCJodG1sZWRpdG9yZmllbGQtZGlhbG9nIGh0bWxlZGl0b3JmaWVsZC0nICsgdHlwZSArICdkaWFsb2cgbG9hZGluZ1wiPicpO1xuXHRcdFx0XHQkKCdib2R5JykuYXBwZW5kKGRpYWxvZyk7XG5cdFx0XHR9XG5cblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGlhbG9nLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwpIHtcblx0XHRcdFx0XHRkaWFsb2cuaHRtbChodG1sKTtcblx0XHRcdFx0XHRkaWFsb2cuZ2V0Rm9ybSgpLnNldEVsZW1lbnQoc2VsZik7XG5cdFx0XHRcdFx0ZGlhbG9nLnRyaWdnZXIoJ3NzZGlhbG9nb3BlbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5odG1sZWRpdG9yZmllbGQtZGlhbG9nJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDcmVhdGUgalF1ZXJ5IGRpYWxvZ1xuXHRcdFx0aWYgKCF0aGlzLmlzKCcudWktZGlhbG9nLWNvbnRlbnQnKSkge1xuXHRcdFx0XHR0aGlzLnNzZGlhbG9nKHtcblx0XHRcdFx0XHRhdXRvT3BlbjogdHJ1ZSxcblx0XHRcdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdFx0XHQnaW5zZXJ0Jzoge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBpMThuLl90KFxuXHRcdFx0XHRcdFx0XHRcdCdIdG1sRWRpdG9yRmllbGQuSU5TRVJUJyxcblx0XHRcdFx0XHRcdFx0XHQnSW5zZXJ0J1xuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHQnZGF0YS1pY29uJzogJ2FjY2VwdCcsXG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAnc3MtdWktYWN0aW9uLWNvbnN0cnVjdGl2ZSBtZWRpYS1pbnNlcnQnLFxuXHRcdFx0XHRcdFx0XHRjbGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0JCh0aGlzKS5maW5kKCdmb3JtJykuc3VibWl0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRnZXRGb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbmQoJ2Zvcm0nKTtcblx0XHR9LFxuXHRcdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zc2RpYWxvZygnb3BlbicpO1xuXHRcdH0sXG5cdFx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zc2RpYWxvZygnY2xvc2UnKTtcblx0XHR9LFxuXHRcdHRvZ2dsZTogZnVuY3Rpb24oYm9vbCkge1xuXHRcdFx0aWYodGhpcy5pcygnOnZpc2libGUnKSkgdGhpcy5jbG9zZSgpO1xuXHRcdFx0ZWxzZSB0aGlzLm9wZW4oKTtcblx0XHR9LFxuXHRcdG9uc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGUoe1xuXHRcdFx0XHRzY3JvbGxUb3A6IHRoaXMuZmluZCgnZm9ybScpLmhlaWdodCgpXG5cdFx0XHR9LCA1MDApO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEJhc2UgZm9ybSBpbXBsZW1lbnRhdGlvbiBmb3IgaW50ZXJhY3Rpb25zIHdpdGggYW4gZWRpdG9yIGluc3RhbmNlLFxuXHQgKiBtb3N0bHkgZ2VhcmVkIHRvd2FyZHMgbW9kaWZpY2F0aW9uIGFuZCBpbnNlcnRpb24gb2YgY29udGVudC5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWZvcm0nKS5lbnR3aW5lKHtcblx0XHRTZWxlY3Rpb246IG51bGwsXG5cblx0XHQvLyBJbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQgc2VyaWFsaXphdGlvbiBvZiB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uIHN0YXRlXG5cdFx0Qm9va21hcms6IG51bGwsXG5cblx0XHQvLyBET01FbGVtZW50IHBvaW50aW5nIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRleHRhcmVhXG5cdFx0RWxlbWVudDogbnVsbCxcblxuXHRcdHNldFNlbGVjdGlvbjogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCQobm9kZSkpO1xuXHRcdH0sXG5cblx0XHRvbmFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBNb3ZlIHRpdGxlIGZyb20gaGVhZGxpbmUgdG8gKGpRdWVyeSBjb21wYXRpYmxlKSB0aXRsZSBhdHRyaWJ1dGVcblx0XHRcdHZhciB0aXRsZUVsID0gdGhpcy5maW5kKCc6aGVhZGVyOmZpcnN0Jyk7XG5cdFx0XHR0aGlzLmdldERpYWxvZygpLmF0dHIoJ3RpdGxlJywgdGl0bGVFbC50ZXh0KCkpO1xuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cdFx0b25yZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24obnVsbCk7XG5cdFx0XHR0aGlzLnNldEJvb2ttYXJrKG51bGwpO1xuXHRcdFx0dGhpcy5zZXRFbGVtZW50KG51bGwpO1xuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRnZXREaWFsb2c6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gVE9ETyBSZWZhY3RvciB0byBsaXN0ZW4gdG8gZm9ybSBldmVudHMgdG8gcmVtb3ZlIHR3by13YXkgY291cGxpbmdcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5odG1sZWRpdG9yZmllbGQtZGlhbG9nJyk7XG5cdFx0fSxcblxuXHRcdGZyb21EaWFsb2c6IHtcblx0XHRcdG9uc3NkaWFsb2dvcGVuOiBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgZWQgPSB0aGlzLmdldEVkaXRvcigpO1xuXG5cdFx0XHRcdHRoaXMuc2V0U2VsZWN0aW9uKGVkLmdldFNlbGVjdGVkTm9kZSgpKTtcblx0XHRcdFx0dGhpcy5zZXRCb29rbWFyayhlZC5jcmVhdGVCb29rbWFyaygpKTtcblxuXHRcdFx0XHRlZC5ibHVyKCk7XG5cblx0XHRcdFx0dGhpcy5maW5kKCc6aW5wdXQ6bm90KDpzdWJtaXQpW2RhdGEtc2tpcC1hdXRvZm9jdXMhPVwidHJ1ZVwiXScpXG5cdFx0XHRcdFx0LmZpbHRlcignOnZpc2libGU6ZW5hYmxlZCcpXG5cdFx0XHRcdFx0LmVxKDApXG5cdFx0XHRcdFx0LmZvY3VzKCk7XG5cblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVGcm9tRWRpdG9yKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvbnNzZGlhbG9nY2xvc2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cblx0XHRcdFx0ZWQubW92ZVRvQm9va21hcmsodGhpcy5nZXRCb29rbWFyaygpKTtcblxuXHRcdFx0XHR0aGlzLnNldFNlbGVjdGlvbihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRCb29rbWFyayhudWxsKTtcblxuXHRcdFx0XHR0aGlzLnJlc2V0RmllbGRzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4gT2JqZWN0IHNzLmVkaXRvcldyYXBwZXIgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRnZXRFZGl0b3I6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRFbGVtZW50KCkuZ2V0RWRpdG9yKCk7XG5cdFx0fSxcblxuXHRcdG1vZGlmeVNlbGVjdGlvbjogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cblx0XHRcdGVkLm1vdmVUb0Jvb2ttYXJrKHRoaXMuZ2V0Qm9va21hcmsoKSk7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGVkKTtcblxuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24oZWQuZ2V0U2VsZWN0ZWROb2RlKCkpO1xuXHRcdFx0dGhpcy5zZXRCb29rbWFyayhlZC5jcmVhdGVCb29rbWFyaygpKTtcblxuXHRcdFx0ZWQuYmx1cigpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVGcm9tRWRpdG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIE5PUCAqL1xuXHRcdH0sXG5cdFx0cmVkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIE5PUCAqL1xuXHRcdH0sXG5cdFx0cmVzZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRmx1c2ggdGhlIHRyZWUgZHJvcCBkb3duIGZpZWxkcywgYXMgdGhlaXIgY29udGVudCBtaWdodCBnZXQgY2hhbmdlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgQ01TLCBpZSBpbiBGaWxlcyBhbmQgaW1hZ2VzXG5cdFx0XHR0aGlzLmZpbmQoJy50cmVlLWhvbGRlcicpLmVtcHR5KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogSW5zZXJ0cyBhbmQgZWRpdHMgbGlua3MgaW4gYW4gaHRtbCBlZGl0b3IsIGluY2x1ZGluZyBpbnRlcm5hbC9leHRlcm5hbCB3ZWIgbGlua3MsXG5cdCAqIGxpbmtzIHRvIGZpbGVzIG9uIHRoZSB3ZWJzZXJ2ZXIsIGVtYWlsIGFkZHJlc3NlcywgYW5kIGFuY2hvcnMgaW4gdGhlIGV4aXN0aW5nIGh0bWwgY29udGVudC5cblx0ICogRXZlcnkgdmFyaWF0aW9uIGhhcyBpdHMgb3duIGZpZWxkcyAoZS5nLiBhIFwidGFyZ2V0XCIgYXR0cmlidXRlIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgYW4gZW1haWwgbGluayksXG5cdCAqIHdoaWNoIGFyZSB0b2dnbGVkIHRocm91Z2ggYSB0eXBlIGRyb3Bkb3duLiBWYXJpYXRpb25zIHNoYXJlIGZpZWxkcywgc28gdGhlcmUncyBvbmx5IG9uZSBcInRpdGxlXCIgZmllbGQgaW4gdGhlIGZvcm0uXG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1saW5rZm9ybScpLmVudHdpbmUoe1xuXG5cdFx0Ly8gVE9ETyBFbnR3aW5lIGRvZXNuJ3QgcmVzcGVjdCBzdWJtaXRzIHRyaWdnZXJlZCBieSBFTlRFUiBrZXlcblx0XHRvbnN1Ym1pdDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dGhpcy5pbnNlcnRMaW5rKCk7XG5cdFx0XHR0aGlzLmdldERpYWxvZygpLmNsb3NlKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRyZXNldEZpZWxkczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgZm9ybSB1c2luZyBhIG5hdGl2ZSBjYWxsLiBUaGlzIHdpbGwgYWxzbyBjb3JyZWN0bHkgcmVzZXQgY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucy5cblx0XHRcdHRoaXNbMF0ucmVzZXQoKTtcblx0XHR9LFxuXHRcdHJlZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHR2YXIgbGlua1R5cGUgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUxpbmtUeXBlXTpjaGVja2VkJykudmFsKCk7XG5cblx0XHRcdHRoaXMuYWRkQW5jaG9yU2VsZWN0b3IoKTtcblxuXHRcdFx0dGhpcy5yZXNldEZpbGVGaWVsZCgpO1xuXG5cdFx0XHQvLyBUb2dnbGUgZmllbGQgdmlzaWJpbGl0eSBkZXBlbmRpbmcgb24gdGhlIGxpbmsgdHlwZS5cblx0XHRcdHRoaXMuZmluZCgnZGl2LmNvbnRlbnQgLmZpZWxkJykuaGlkZSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuZmllbGRbaWQkPVwiTGlua1R5cGVcIl0nKS5zaG93KCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5maWVsZFtpZCQ9XCInICsgbGlua1R5cGUgKydfSG9sZGVyXCJdJykuc2hvdygpO1xuXG5cdFx0XHRpZihsaW5rVHlwZSA9PSAnaW50ZXJuYWwnIHx8IGxpbmtUeXBlID09ICdhbmNob3InKSB7XG5cdFx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkFuY2hvcl9Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGxpbmtUeXBlID09ICdlbWFpbCcpIHtcblx0XHRcdFx0dGhpcy5maW5kKCcuZmllbGRbaWQkPVwiU3ViamVjdF9Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmZpbmQoJy5maWVsZFtpZCQ9XCJUYXJnZXRCbGFua19Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGxpbmtUeXBlID09ICdhbmNob3InKSB7XG5cdFx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkFuY2hvclNlbGVjdG9yX0hvbGRlclwiXScpLnNob3coKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkRlc2NyaXB0aW9uX0hvbGRlclwiXScpLnNob3coKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4gT2JqZWN0IEtleXM6ICdocmVmJywgJ3RhcmdldCcsICd0aXRsZSdcblx0XHQgKi9cblx0XHRnZXRMaW5rQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaHJlZixcblx0XHRcdFx0dGFyZ2V0ID0gbnVsbCxcblx0XHRcdFx0c3ViamVjdCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9U3ViamVjdF0nKS52YWwoKSxcblx0XHRcdFx0YW5jaG9yID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JdJykudmFsKCk7XG5cblx0XHRcdC8vIERldGVybWluZSB0YXJnZXRcblx0XHRcdGlmKHRoaXMuZmluZCgnOmlucHV0W25hbWU9VGFyZ2V0QmxhbmtdJykuaXMoJzpjaGVja2VkJykpIHtcblx0XHRcdFx0dGFyZ2V0ID0gJ19ibGFuayc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsbCBvdGhlciBhdHRyaWJ1dGVzXG5cdFx0XHRzd2l0Y2godGhpcy5maW5kKCc6aW5wdXRbbmFtZT1MaW5rVHlwZV06Y2hlY2tlZCcpLnZhbCgpKSB7XG5cdFx0XHRcdGNhc2UgJ2ludGVybmFsJzpcblx0XHRcdFx0XHRocmVmID0gJ1tzaXRldHJlZV9saW5rLGlkPScgKyB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWludGVybmFsXScpLnZhbCgpICsgJ10nO1xuXG5cdFx0XHRcdFx0aWYoYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRocmVmICs9ICcjJyArIGFuY2hvcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhbmNob3InOlxuXHRcdFx0XHRcdGhyZWYgPSAnIycgKyBhbmNob3I7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZmlsZSc6XG5cdFx0XHRcdFx0aHJlZiA9ICdbZmlsZV9saW5rLGlkPScgKyB0aGlzLmZpbmQoJy5zcy11cGxvYWRmaWVsZCAuc3MtdXBsb2FkZmllbGQtaXRlbScpLmF0dHIoJ2RhdGEtZmlsZWlkJykgKyAnXSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZW1haWwnOlxuXHRcdFx0XHRcdGhyZWYgPSAnbWFpbHRvOicgKyB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWVtYWlsXScpLnZhbCgpO1xuXHRcdFx0XHRcdGlmKHN1YmplY3QpIHtcblx0XHRcdFx0XHRcdGhyZWYgKz0gJz9zdWJqZWN0PScgKyBlbmNvZGVVUklDb21wb25lbnQoc3ViamVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gY2FzZSAnZXh0ZXJuYWwnOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGhyZWYgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWV4dGVybmFsXScpLnZhbCgpO1xuXHRcdFx0XHRcdC8vIFByZWZpeCB0aGUgVVJMIHdpdGggXCJodHRwOi8vXCIgaWYgbm8gcHJlZml4IGlzIGZvdW5kXG5cdFx0XHRcdFx0aWYoaHJlZi5pbmRleE9mKCc6Ly8nKSA9PSAtMSkgaHJlZiA9ICdodHRwOi8vJyArIGhyZWY7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGhyZWYgOiBocmVmLFxuXHRcdFx0XHR0YXJnZXQgOiB0YXJnZXQsXG5cdFx0XHRcdHRpdGxlIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1EZXNjcmlwdGlvbl0nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGluc2VydExpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5pbnNlcnRMaW5rKHRoaXMuZ2V0TGlua0F0dHJpYnV0ZXMoKSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHJlbW92ZUxpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5yZW1vdmVMaW5rKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5yZXNldEZpbGVGaWVsZCgpO1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH0sXG5cblx0XHRyZXNldEZpbGVGaWVsZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB0aGVyZSdzIGFuIGF0dGFjaGVkIGl0ZW0sIHJlbW92ZSBpdFxuXHRcdFx0dmFyIGZpbGVGaWVsZCA9IHRoaXMuZmluZCgnLnNzLXVwbG9hZGZpZWxkW2lkJD1cImZpbGVfSG9sZGVyXCJdJyksXG5cdFx0XHRcdGZpbGVVcGxvYWQgPSBmaWxlRmllbGQuZGF0YSgnZmlsZXVwbG9hZCcpLFxuXHRcdFx0XHRjdXJyZW50SXRlbSA9IGZpbGVGaWVsZC5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbVtkYXRhLWZpbGVpZF0nKTtcblxuXHRcdFx0aWYoY3VycmVudEl0ZW0ubGVuZ3RoKSB7XG5cdFx0XHRcdGZpbGVVcGxvYWQuX3RyaWdnZXIoJ2Rlc3Ryb3knLCBudWxsLCB7Y29udGV4dDogY3VycmVudEl0ZW19KTtcblx0XHRcdFx0ZmlsZUZpZWxkLmZpbmQoJy5zcy11cGxvYWRmaWVsZC1hZGRmaWxlJykucmVtb3ZlQ2xhc3MoJ2JvcmRlclRvcCcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBCdWlsZHMgYW4gYW5jaG9yIHNlbGVjdG9yIGVsZW1lbnQgYW5kIGluamVjdHMgaXQgaW50byB0aGUgRE9NIG5leHQgdG8gdGhlIGFuY2hvciBmaWVsZC5cblx0XHQgKi9cblx0XHRhZGRBbmNob3JTZWxlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBBdm9pZCBhZGRpbmcgdHdpY2Vcblx0XHRcdGlmKHRoaXMuZmluZCgnOmlucHV0W25hbWU9QW5jaG9yU2VsZWN0b3JdJykubGVuZ3RoKSByZXR1cm47XG5cblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBhbmNob3JTZWxlY3RvciA9ICQoXG5cdFx0XHRcdCc8c2VsZWN0IGlkPVwiRm9ybV9FZGl0b3JUb29sYmFyTGlua0Zvcm1fQW5jaG9yU2VsZWN0b3JcIiBuYW1lPVwiQW5jaG9yU2VsZWN0b3JcIj48L3NlbGVjdD4nXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JdJykucGFyZW50KCkuYXBwZW5kKGFuY2hvclNlbGVjdG9yKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGlzZSB0aGUgYW5jaG9yIGRyb3Bkb3duLlxuXHRcdFx0dGhpcy51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXG5cdFx0XHQvLyBjb3B5IHRoZSB2YWx1ZSBmcm9tIGRyb3Bkb3duIHRvIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRhbmNob3JTZWxlY3Rvci5jaGFuZ2UoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRzZWxmLmZpbmQoJzppbnB1dFtuYW1lPVwiQW5jaG9yXCJdJykudmFsKCQodGhpcykudmFsKCkpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZldGNoIHJlbGV2YW50IGFuY2hvcnMsIGRlcGVuZGluZyBvbiB0aGUgbGluayB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiAkLkRlZmVycmVkIEEgcHJvbWlzZSBvZiBhbiBhbmNob3IgYXJyYXksIG9yIGFuIGVycm9yIG1lc3NhZ2UuXG5cdFx0ICovXG5cdFx0Z2V0QW5jaG9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGlua1R5cGUgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUxpbmtUeXBlXTpjaGVja2VkJykudmFsKCk7XG5cdFx0XHR2YXIgZGZkQW5jaG9ycyA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0c3dpdGNoIChsaW5rVHlwZSkge1xuXHRcdFx0XHRjYXNlICdhbmNob3InOlxuXHRcdFx0XHRcdC8vIEZldGNoIGZyb20gdGhlIGxvY2FsIGVkaXRvci5cblx0XHRcdFx0XHR2YXIgY29sbGVjdGVkQW5jaG9ycyA9IFtdO1xuXHRcdFx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cdFx0XHRcdFx0Ly8gbmFtZSBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhcyBDREFUQSwgc2hvdWxkIGFjY2VwdCBhbGwgY2hhcmFjdGVycyBhbmQgZW50aXRpZXNcblx0XHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy1odG1sNDAxLTE5OTkxMjI0L3N0cnVjdC9saW5rcy5odG1sI2gtMTIuMlxuXG5cdFx0XHRcdFx0aWYoZWQpIHtcblx0XHRcdFx0XHRcdHZhciByYXcgPSBlZC5nZXRDb250ZW50KClcblx0XHRcdFx0XHRcdFx0Lm1hdGNoKC9cXHMrKG5hbWV8aWQpXFxzKj1cXHMqKFtcIiddKShbXlxcMlxccz5dKj8pXFwyfFxccysobmFtZXxpZClcXHMqPVxccyooW15cIiddKylbXFxzICs+XS9naW0pO1xuXHRcdFx0XHRcdFx0aWYgKHJhdyAmJiByYXcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5kZXhTdGFydCA9IChyYXdbaV0uaW5kZXhPZignaWQ9JykgPT0gLTEpID8gNyA6IDU7XG5cdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGVkQW5jaG9ycy5wdXNoKHJhd1tpXS5zdWJzdHIoaW5kZXhTdGFydCkucmVwbGFjZSgvXCIkLywgJycpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRmZEFuY2hvcnMucmVzb2x2ZShjb2xsZWN0ZWRBbmNob3JzKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnRlcm5hbCc6XG5cdFx0XHRcdFx0Ly8gRmV0Y2ggYXZhaWxhYmxlIGFuY2hvcnMgZnJvbSB0aGUgdGFyZ2V0IGludGVybmFsIHBhZ2UuXG5cdFx0XHRcdFx0dmFyIHBhZ2VJZCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9aW50ZXJuYWxdJykudmFsKCk7XG5cblx0XHRcdFx0XHRpZiAocGFnZUlkKSB7XG5cdFx0XHRcdFx0XHQkLmFqYXgoe1xuXHRcdFx0XHRcdFx0XHR1cmw6ICQucGF0aC5hZGRTZWFyY2hQYXJhbXMoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCdhY3Rpb24nKS5yZXBsYWNlKCdMaW5rRm9ybScsICdnZXRhbmNob3JzJyksXG5cdFx0XHRcdFx0XHRcdFx0eydQYWdlSUQnOiBwYXJzZUludChwYWdlSWQpfVxuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbihib2R5LCBzdGF0dXMsIHhocikge1xuXHRcdFx0XHRcdFx0XHRcdGRmZEFuY2hvcnMucmVzb2x2ZSgkLnBhcnNlSlNPTihib2R5KSk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbih4aHIsIHN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRcdGRmZEFuY2hvcnMucmVqZWN0KHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGZkQW5jaG9ycy5yZXNvbHZlKFtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBUaGlzIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBhbmNob3JzIGF0IGFsbC5cblx0XHRcdFx0XHRkZmRBbmNob3JzLnJlamVjdChpMThuLl90KFxuXHRcdFx0XHRcdFx0J0h0bWxFZGl0b3JGaWVsZC5BTkNIT1JTTk9UU1VQUE9SVEVEJyxcblx0XHRcdFx0XHRcdCdBbmNob3JzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGxpbmsgdHlwZS4nXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZmRBbmNob3JzLnByb21pc2UoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBhbmNob3IgbGlzdCBpbiB0aGUgZHJvcGRvd24uXG5cdFx0ICovXG5cdFx0dXBkYXRlQW5jaG9yU2VsZWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JTZWxlY3Rvcl0nKTtcblx0XHRcdHZhciBkZmRBbmNob3JzID0gdGhpcy5nZXRBbmNob3JzKCk7XG5cblx0XHRcdC8vIEluZm9ybSB0aGUgdXNlciB3ZSBhcmUgbG9hZGluZy5cblx0XHRcdHNlbGVjdG9yLmVtcHR5KCk7XG5cdFx0XHRzZWxlY3Rvci5hcHBlbmQoJChcblx0XHRcdFx0JzxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD1cIjFcIj4nICtcblx0XHRcdFx0aTE4bi5fdCgnSHRtbEVkaXRvckZpZWxkLkxPT0tJTkdGT1JBTkNIT1JTJywgJ0xvb2tpbmcgZm9yIGFuY2hvcnMuLi4nKSArXG5cdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHQpKTtcblxuXHRcdFx0ZGZkQW5jaG9ycy5kb25lKGZ1bmN0aW9uKGFuY2hvcnMpIHtcblx0XHRcdFx0c2VsZWN0b3IuZW1wdHkoKTtcblx0XHRcdFx0c2VsZWN0b3IuYXBwZW5kKCQoXG5cdFx0XHRcdFx0JzxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD1cIjFcIj4nICtcblx0XHRcdFx0XHRpMThuLl90KCdIdG1sRWRpdG9yRmllbGQuU2VsZWN0QW5jaG9yJykgK1xuXHRcdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdGlmIChhbmNob3JzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhbmNob3JzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rvci5hcHBlbmQoJCgnPG9wdGlvbiB2YWx1ZT1cIicrYW5jaG9yc1tqXSsnXCI+JythbmNob3JzW2pdKyc8L29wdGlvbj4nKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0pLmZhaWwoZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdFx0XHRzZWxlY3Rvci5lbXB0eSgpO1xuXHRcdFx0XHRzZWxlY3Rvci5hcHBlbmQoJChcblx0XHRcdFx0XHQnPG9wdGlvbiB2YWx1ZT1cIlwiIHNlbGVjdGVkPVwiMVwiPicgK1xuXHRcdFx0XHRcdG1lc3NhZ2UgK1xuXHRcdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFBva2UgdGhlIHNlbGVjdG9yIGZvciBJRTgsIG90aGVyd2lzZSB0aGUgY2hhbmdlcyB3b24ndCBiZSBub3RpY2VkLlxuXHRcdFx0aWYgKCQuYnJvd3Nlci5tc2llKSBzZWxlY3Rvci5oaWRlKCkuc2hvdygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgZGlhbG9nIGlucHV0cyB0byBtYXRjaCB0aGUgZWRpdG9yIHNlbGVjdGlvbi5cblx0XHQgKiBJZiBzZWxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBhIGxpbmssIHJlc2V0cyB0aGUgZmllbGRzLlxuXHRcdCAqL1xuXHRcdHVwZGF0ZUZyb21FZGl0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGh0bWxUYWdQYXR0ZXJuID0gLzxcXFNbXj48XSo+L2csIGZpZWxkTmFtZSwgZGF0YSA9IHRoaXMuZ2V0Q3VycmVudExpbmsoKTtcblxuXHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRmb3IoZmllbGROYW1lIGluIGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgZWwgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPScgKyBmaWVsZE5hbWUgKyAnXScpLCBzZWxlY3RlZCA9IGRhdGFbZmllbGROYW1lXTtcblx0XHRcdFx0XHQvLyBSZW1vdmUgaHRtbCB0YWdzIGluIHRoZSBzZWxlY3RlZCB0ZXh0IHRoYXQgb2NjdXJzIG9uIElFIGJyb3dzZXJzXG5cdFx0XHRcdFx0aWYodHlwZW9mKHNlbGVjdGVkKSA9PSAnc3RyaW5nJykgc2VsZWN0ZWQgPSBzZWxlY3RlZC5yZXBsYWNlKGh0bWxUYWdQYXR0ZXJuLCAnJyk7XG5cblx0XHRcdFx0XHQvLyBTZXQgdmFsdWVzIGFuZCBpbnZva2UgdGhlIHRyaWdnZXJzIChlLmcuIGZvciBUcmVlRHJvcGRvd25GaWVsZCkuXG5cdFx0XHRcdFx0aWYoZWwuaXMoJzpjaGVja2JveCcpKSB7XG5cdFx0XHRcdFx0XHRlbC5wcm9wKCdjaGVja2VkJywgc2VsZWN0ZWQpLmNoYW5nZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihlbC5pcygnOnJhZGlvJykpIHtcblx0XHRcdFx0XHRcdGVsLnZhbChbc2VsZWN0ZWRdKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoZmllbGROYW1lID09ICdmaWxlJykge1xuXHRcdFx0XHRcdFx0Ly8gVXBsb2FkRmllbGQgaW5wdXRzIGhhdmUgYSBzbGlnaHRseSBkaWZmZXJlbnQgbmFtaW5nIGNvbnZlbnRpb25cblx0XHRcdFx0XHRcdGVsID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1cIicgKyBmaWVsZE5hbWUgKyAnW1VwbG9hZHNdW11cIl0nKTtcblx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdGhlIFVwbG9hZEZpZWxkIFwiZmllbGRcIiwgbm90IGp1c3QgdGhlIGlucHV0XG5cdFx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudHMoJy5zcy11cGxvYWRmaWVsZCcpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBoYXZlIHRvIHdhaXQgZm9yIHRoZSBVcGxvYWRGaWVsZCB0byBpbml0aWFsaXNlXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24gYXR0YWNoKGVsLCBzZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRpZiggISBlbC5nZXRDb25maWcoKSkge1xuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgYXR0YWNoKGVsLCBzZWxlY3RlZCk7IH0sIDUwKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbC5hdHRhY2hGaWxlcyhbc2VsZWN0ZWRdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSkoZWwsIHNlbGVjdGVkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWwudmFsKHNlbGVjdGVkKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbGluaywgc3VpdGFibGUgZm9yIHBvcHVsYXRpb24gb2YgdGhlIGxpbmsgZm9ybS5cblx0XHQgKlxuXHRcdCAqIFJldHVybnMgbnVsbCBpZiBubyBsaW5rIHdhcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG5cdFx0ICovXG5cdFx0Z2V0Q3VycmVudExpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVkRWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLFxuXHRcdFx0XHRocmVmID0gXCJcIiwgdGFyZ2V0ID0gXCJcIiwgdGl0bGUgPSBcIlwiLCBhY3Rpb24gPSBcImluc2VydFwiLCBzdHlsZV9jbGFzcyA9IFwiXCI7XG5cblx0XHRcdC8vIFdlIHVzZSBhIHNlcGFyYXRlIGZpZWxkIGZvciBsaW5rRGF0YVNvdXJjZSBmcm9tIHRpbnlNQ0UubGlua0VsZW1lbnQuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIHNlbGVjdGVkIGJleW9uZCB0aGUgcmFuZ2Ugb2YgYW4gPGE+IGVsZW1lbnQsIHRoZW4gdXNlIHVzZSB0aGF0IDxhPiBlbGVtZW50IHRvIGdldCB0aGUgbGluayBkYXRhIHNvdXJjZSxcblx0XHRcdC8vIGJ1dCB3ZSBkb24ndCB1c2UgaXQgYXMgdGhlIGRlc3RpbmF0aW9uIGZvciB0aGUgbGluayBpbnNlcnRpb25cblx0XHRcdHZhciBsaW5rRGF0YVNvdXJjZSA9IG51bGw7XG5cdFx0XHRpZihzZWxlY3RlZEVsLmxlbmd0aCkge1xuXHRcdFx0XHRpZihzZWxlY3RlZEVsLmlzKCdhJykpIHtcblx0XHRcdFx0XHQvLyBFbGVtZW50IGlzIGEgbGlua1xuXHRcdFx0XHRcdGxpbmtEYXRhU291cmNlID0gc2VsZWN0ZWRFbDtcblx0XHRcdFx0Ly8gVE9ETyBMaW1pdCB0byBpbmxpbmUgZWxlbWVudHMsIG90aGVyd2lzZSB3aWxsIGFsc28gYXBwbHkgdG8gZS5nLiBwYXJhZ3JhcGhzIHdoaWNoIGFscmVhZHkgY29udGFpbiBvbmUgb3IgbW9yZSBsaW5rc1xuXHRcdFx0XHQvLyB9IGVsc2UgaWYoKHNlbGVjdGVkRWwuZmluZCgnYScpLmxlbmd0aCkpIHtcblx0XHRcdFx0XHQvLyBcdC8vIEVsZW1lbnQgY29udGFpbnMgYSBsaW5rXG5cdFx0XHRcdFx0Ly8gXHR2YXIgZmlyc3RMaW5rRWwgPSBzZWxlY3RlZEVsLmZpbmQoJ2E6Zmlyc3QnKTtcblx0XHRcdFx0XHQvLyBcdGlmKGZpcnN0TGlua0VsLmxlbmd0aCkgbGlua0RhdGFTb3VyY2UgPSBmaXJzdExpbmtFbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBsaW5rXG5cdFx0XHRcdFx0bGlua0RhdGFTb3VyY2UgPSBzZWxlY3RlZEVsID0gc2VsZWN0ZWRFbC5wYXJlbnRzKCdhOmZpcnN0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGxpbmtEYXRhU291cmNlICYmIGxpbmtEYXRhU291cmNlLmxlbmd0aCkgdGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5zZWxlY3ROb2RlKGxpbmtEYXRhU291cmNlWzBdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJcyBhbmNob3Igbm90IGEgbGlua1xuXHRcdFx0aWYgKCFsaW5rRGF0YVNvdXJjZS5hdHRyKCdocmVmJykpIGxpbmtEYXRhU291cmNlID0gbnVsbDtcblxuXHRcdFx0aWYgKGxpbmtEYXRhU291cmNlKSB7XG5cdFx0XHRcdGhyZWYgPSBsaW5rRGF0YVNvdXJjZS5hdHRyKCdocmVmJyk7XG5cdFx0XHRcdHRhcmdldCA9IGxpbmtEYXRhU291cmNlLmF0dHIoJ3RhcmdldCcpO1xuXHRcdFx0XHR0aXRsZSA9IGxpbmtEYXRhU291cmNlLmF0dHIoJ3RpdGxlJyk7XG5cdFx0XHRcdHN0eWxlX2NsYXNzID0gbGlua0RhdGFTb3VyY2UuYXR0cignY2xhc3MnKTtcblx0XHRcdFx0aHJlZiA9IHRoaXMuZ2V0RWRpdG9yKCkuY2xlYW5MaW5rKGhyZWYsIGxpbmtEYXRhU291cmNlKTtcblx0XHRcdFx0YWN0aW9uID0gXCJ1cGRhdGVcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYoaHJlZi5tYXRjaCgvXm1haWx0bzooLiopJC8pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdlbWFpbCcsXG5cdFx0XHRcdFx0ZW1haWw6IFJlZ0V4cC4kMSxcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGVcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZihocmVmLm1hdGNoKC9eKGFzc2V0c1xcLy4qKSQvKSB8fCBocmVmLm1hdGNoKC9eXFxbZmlsZV9saW5rXFxzKig/Olxccyp8JTIwfCwpP2lkPShbMC05XSspXFxdPygjLiopPyQvKSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdExpbmtUeXBlOiAnZmlsZScsXG5cdFx0XHRcdFx0ZmlsZTogUmVnRXhwLiQxLFxuXHRcdFx0XHRcdERlc2NyaXB0aW9uOiB0aXRsZSxcblx0XHRcdFx0XHRUYXJnZXRCbGFuazogdGFyZ2V0ID8gdHJ1ZSA6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYoaHJlZi5tYXRjaCgvXiMoLiopJC8pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdhbmNob3InLFxuXHRcdFx0XHRcdEFuY2hvcjogUmVnRXhwLiQxLFxuXHRcdFx0XHRcdERlc2NyaXB0aW9uOiB0aXRsZSxcblx0XHRcdFx0XHRUYXJnZXRCbGFuazogdGFyZ2V0ID8gdHJ1ZSA6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYoaHJlZi5tYXRjaCgvXlxcW3NpdGV0cmVlX2xpbmsoPzpcXHMqfCUyMHwsKT9pZD0oWzAtOV0rKVxcXT8oIy4qKT8kL2kpKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdpbnRlcm5hbCcsXG5cdFx0XHRcdFx0aW50ZXJuYWw6IFJlZ0V4cC4kMSxcblx0XHRcdFx0XHRBbmNob3I6IFJlZ0V4cC4kMiA/IFJlZ0V4cC4kMi5zdWJzdHIoMSkgOiAnJyxcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGUsXG5cdFx0XHRcdFx0VGFyZ2V0Qmxhbms6IHRhcmdldCA/IHRydWUgOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmKGhyZWYpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRMaW5rVHlwZTogJ2V4dGVybmFsJyxcblx0XHRcdFx0XHRleHRlcm5hbDogaHJlZixcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGUsXG5cdFx0XHRcdFx0VGFyZ2V0Qmxhbms6IHRhcmdldCA/IHRydWUgOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTm8gbGluay9pbnZhbGlkIGxpbmsgc2VsZWN0ZWQuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0gaW5wdXRbbmFtZT1MaW5rVHlwZV0nKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR0aGlzLnBhcmVudHMoJ2Zvcm06Zmlyc3QnKS5yZWRyYXcoKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRvbmNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudHMoJ2Zvcm06Zmlyc3QnKS5yZWRyYXcoKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGlmIGEgYW5jaG9yLXN1cHBvcnRpbmcgbGluayB0eXBlIGlzIHNlbGVjdGVkLlxuXHRcdFx0dmFyIGxpbmtUeXBlID0gdGhpcy5wYXJlbnQoKS5maW5kKCc6Y2hlY2tlZCcpLnZhbCgpO1xuXHRcdFx0aWYgKGxpbmtUeXBlPT09J2FuY2hvcicgfHwgbGlua1R5cGU9PT0naW50ZXJuYWwnKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50cygnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0nKS51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWxpbmtmb3JtIGlucHV0W25hbWU9aW50ZXJuYWxdJykuZW50d2luZSh7XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBhbmNob3IgZHJvcGRvd24gaWYgYSBkaWZmZXJlbnQgcGFnZSBpcyBzZWxlY3RlZCBpbiB0aGUgXCJpbnRlcm5hbFwiIGRyb3Bkb3duLlxuXHRcdCAqL1xuXHRcdG9udmFsdWV1cGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucGFyZW50cygnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0nKS51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWxpbmtmb3JtIDpzdWJtaXRbbmFtZT1hY3Rpb25fcmVtb3ZlXScpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHRoaXMucGFyZW50cygnZm9ybTpmaXJzdCcpLnJlbW92ZUxpbmsoKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogUmVzcG9uc2libGUgZm9yIGluc2VydGluZyBtZWRpYSBmaWxlcywgYWx0aG91Z2ggb25seSBpbWFnZXMgYXJlIHN1cHBvcnRlZCBzbyBmYXIuXG5cdCAqIEFsbG93cyB0byBzZWxlY3Qgb25lIG9yIG1vcmUgZmlsZXMsIGFuZCBsb2FkIGZvcm0gZmllbGRzIGZvciBlYWNoIGZpbGUgdmlhIGFqYXguXG5cdCAqIFRoaXMgYWxsb3dzIHVzIHRvIHRhaWxvciB0aGUgZm9ybSBmaWVsZHMgdG8gdGhlIGZpbGUgdHlwZSAoZS5nLiBkaWZmZXJlbnQgb25lcyBmb3IgaW1hZ2VzIGFuZCBmbGFzaCksXG5cdCAqIGFzIHdlbGwgYXMgYWRkIG5ldyBmb3JtIGZpZWxkcyB2aWEgZnJhbWV3b3JrIGV4dGVuc2lvbnMuXG5cdCAqIFRoZSBpbnB1dHMgb24gZWFjaCBvZiB0aG9zZSBmaWxlcyBhcmUgdXNlZCBmb3IgY29uc3RydWN0aW5nIHRoZSBIVE1MIHRvIGluc2VydCBpbnRvXG5cdCAqIHRoZSByaWNoIHRleHQgZWRpdG9yLiBBbHNvIGFsbG93cyBlZGl0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGV4aXN0aW5nIGZpbGVzIGlmIGFueSBhcmUgc2VsZWN0ZWQgaW4gdGhlIGVkaXRvci5cblx0ICogTm90ZTogTm90IGVhY2ggZmlsZSBoYXMgYSByZXByZXNlbnRhdGlvbiBvbiB0aGUgd2Vic2VydmVyIGZpbGVzeXN0ZW0sIHN1cHBvcnRzIGluc2VydGlvbiBhbmQgZWRpdGluZ1xuXHQgKiBvZiByZW1vdmUgZmlsZXMgYXMgd2VsbC5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybScpLmVudHdpbmUoe1xuXHRcdHRvZ2dsZUNsb3NlQnV0dG9uOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHVwZGF0ZUV4aXN0aW5nID0gQm9vbGVhbih0aGlzLmZpbmQoJy5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmxlbmd0aCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5vdmVydmlldyAuYWN0aW9uLWRlbGV0ZScpW3VwZGF0ZUV4aXN0aW5nID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdH0sXG5cdFx0b25zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHR0aGlzLmZpbmQoJy5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5pbnNlcnRIVE1MKGVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5nZXREaWFsb2coKS5jbG9zZSgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dXBkYXRlRnJvbUVkaXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIG5vZGUgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHQvLyBUT0RPIERlcGVuZHMgb24gbWFuYWdlZCBtaW1lIHR5cGVcblx0XHRcdGlmKG5vZGUuaXMoJ2ltZycpKSB7XG5cdFx0XHRcdHRoaXMuc2hvd0ZpbGVWaWV3KG5vZGUuZGF0YSgndXJsJykgfHwgbm9kZS5hdHRyKCdzcmMnKSkuZG9uZShmdW5jdGlvbihmaWxlZmllbGQpIHtcblx0XHRcdFx0XHRmaWxlZmllbGQudXBkYXRlRnJvbU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0c2VsZi50b2dnbGVDbG9zZUJ1dHRvbigpO1xuXHRcdFx0XHRcdHNlbGYucmVkcmF3KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHR9LFxuXHRcdHJlZHJhdzogZnVuY3Rpb24odXBkYXRlRXhpc3RpbmcpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdHZhciBub2RlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSxcblx0XHRcdFx0aGFzSXRlbXMgPSBCb29sZWFuKHRoaXMuZmluZCgnLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykubGVuZ3RoKSxcblx0XHRcdFx0ZWRpdGluZ1NlbGVjdGVkID0gbm9kZS5pcygnaW1nJyksXG5cdFx0XHRcdGluc2VydGluZ1VSTCA9IHRoaXMuaGFzQ2xhc3MoJ2luc2VydGluZ1VSTCcpLFxuXHRcdFx0XHRoZWFkZXIgPSB0aGlzLmZpbmQoJy5oZWFkZXItZWRpdCcpO1xuXG5cdFx0XHQvLyBPbmx5IHNob3cgc2Vjb25kIHN0ZXAgaWYgZmlsZXMgYXJlIHNlbGVjdGVkXG5cdFx0XHRoZWFkZXJbKGhhc0l0ZW1zKSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblxuXHRcdFx0Ly8gRGlzYWJsZSBcImluc2VydFwiIGJ1dHRvbiBpZiBubyBmaWxlcyBhcmUgc2VsZWN0ZWRcblx0XHRcdHRoaXMuY2xvc2VzdCgndWktZGlhbG9nJylcblx0XHRcdFx0LmZpbmQoJ3VpLWRpYWxvZy1idXR0b25wYW5lIC5tZWRpYS1pbnNlcnQnKVxuXHRcdFx0XHQuYnV0dG9uKGhhc0l0ZW1zID8gJ2VuYWJsZScgOiAnZGlzYWJsZScpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygndWktc3RhdGUtZGlzYWJsZWQnLCAhaGFzSXRlbXMpO1xuXG5cdFx0XHQvLyBIaWRlIGZpbGUgc2VsZWN0aW9uIGFuZCBzdGVwIGxhYmVscyB3aGVuIGVkaXRpbmcgYW4gZXhpc3RpbmcgZmlsZVxuXHRcdFx0dGhpcy5maW5kKCcuaHRtbGVkaXRvcmZpZWxkLWRlZmF1bHQtcGFuZWwnKVtlZGl0aW5nU2VsZWN0ZWQgfHwgaW5zZXJ0aW5nVVJMID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuaHRtbGVkaXRvcmZpZWxkLXdlYi1wYW5lbCcpW2VkaXRpbmdTZWxlY3RlZCB8fCAhaW5zZXJ0aW5nVVJMID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXG5cdFx0XHR2YXIgbWVkaWFGb3JtSGVhZGluZyA9IHRoaXMuZmluZCgnLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0taGVhZGluZy5pbnNlcnQnKTtcblxuXHRcdFx0aWYgKGVkaXRpbmdTZWxlY3RlZCkge1xuXHRcdFx0XHQvL1doZW4gZWRpdGluZyBkZXRhaWxzIG9mIGEgZmlsZVxuXHRcdFx0XHRtZWRpYUZvcm1IZWFkaW5nLmhpZGUoKTtcblx0XHRcdH0gZWxzZSBpZiAoaW5zZXJ0aW5nVVJMKSB7XG5cdFx0XHRcdC8vV2hlbiBpbnNlcnRpbmcgYW4gaW1hZ2UgZnJvbSBhIFVSTFxuXHRcdFx0XHRtZWRpYUZvcm1IZWFkaW5nXG5cdFx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHRcdC50ZXh0KGkxOG4uX3QoXCJIdG1sRWRpdG9yRmllbGQuSU5TRVJUVVJMXCIpKVxuXHRcdFx0XHRcdC5wcmVwZW5kKCc8YnV0dG9uIGNsYXNzPVwiYmFjay1idXR0b24gZm9udC1pY29uLWxlZnQtb3BlbiBuby10ZXh0XCIgdGl0bGU9XCInICsgaTE4bi5fdChcIkh0bWxFZGl0b3JGaWVsZC5CQUNLXCIpICsgJ1wiPjwvYnV0dG9uPicpO1xuXG5cdFx0XHRcdHRoaXMuZmluZCgnLmh0bWxlZGl0b3JmaWVsZC13ZWItcGFuZWwgaW5wdXQucmVtb3RldXJsJykuZm9jdXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vRGVmYXVsdCB2aWV3IHdoZW4gbW9kYWwgaXMgb3BlbmVkXG5cdFx0XHRcdG1lZGlhRm9ybUhlYWRpbmdcblx0XHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdFx0LnRleHQoaTE4bi5fdChcIkh0bWxFZGl0b3JGaWVsZC5JTlNFUlRGUk9NXCIpKVxuXHRcdFx0XHRcdC5maW5kKCcuYmFjay1idXR0b24nKS5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETyBXYXkgdG9vIG11Y2gga25vd2xlZGdlIG9uIFVwbG9hZEZpZWxkIGludGVybmFscywgdXNlIHZpZXdmaWxlIFVSTCBkaXJlY3RseSBpbnN0ZWFkXG5cdFx0XHR0aGlzLmZpbmQoJy5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmcudXBkYXRlJylbZWRpdGluZ1NlbGVjdGVkID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1hY3Rpb25zJylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1uYW1lJylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1wcmV2aWV3JylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuQWN0aW9ucyAubWVkaWEtdXBkYXRlJylbZWRpdGluZ1NlbGVjdGVkID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1lZGl0Zm9ybScpLnRvZ2dsZUVkaXRGb3JtKGVkaXRpbmdTZWxlY3RlZCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5odG1sZWRpdG9yZmllbGQtZnJvbS1jbXMgLmZpZWxkLnRyZWVkcm9wZG93bicpLmNzcygnbGVmdCcsICQoJy5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmc6dmlzaWJsZScpLm91dGVyV2lkdGgoKSk7XG5cdFx0XHR0aGlzLmNsb3Nlc3QoJy51aS1kaWFsb2cnKS5hZGRDbGFzcygnc3MtdXBsb2FkZmllbGQtZHJvcHpvbmUnKTtcblx0XHRcdHRoaXMuY2xvc2VzdCgnLnVpLWRpYWxvZycpXG5cdFx0XHRcdC5maW5kKCcudWktZGlhbG9nLWJ1dHRvbnBhbmUgLm1lZGlhLWluc2VydCAudWktYnV0dG9uLXRleHQnKVxuXHRcdFx0XHQudGV4dChbZWRpdGluZ1NlbGVjdGVkID8gaTE4bi5fdChcblx0XHRcdFx0J0h0bWxFZGl0b3JGaWVsZC5VUERBVEUnLFxuXHRcdFx0XHQnVXBkYXRlJ1xuXHRcdFx0KSA6IGkxOG4uX3QoXG5cdFx0XHRcdCdIdG1sRWRpdG9yRmllbGQuSU5TRVJUJyxcblx0XHRcdFx0J0luc2VydCdcblx0XHRcdCldKTtcblx0XHR9LFxuXHRcdHJlc2V0RmllbGRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZmluZCgnLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykucmVtb3ZlKCk7IC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgdmlld3Ncblx0XHRcdHRoaXMuZmluZCgnLnNzLWdyaWRmaWVsZC1pdGVtcyAudWktc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygndWktc2VsZWN0ZWQnKTsgLy8gVW5zZWxlY3QgYWxsIGl0ZW1zXG5cdFx0XHR0aGlzLmZpbmQoJ2xpLnNzLXVwbG9hZGZpZWxkLWl0ZW0nKS5yZW1vdmUoKTsgLy8gUmVtb3ZlIGFsbCBzZWxlY3RlZCBpdGVtc1xuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdGdldEZpbGVWaWV3OiBmdW5jdGlvbihpZE9yVXJsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGVbZGF0YS1pZD0nICsgaWRPclVybCArICddJyk7XG5cdFx0fSxcblx0XHRzaG93RmlsZVZpZXc6IGZ1bmN0aW9uKGlkT3JVcmwpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gKE51bWJlcihpZE9yVXJsKSA9PSBpZE9yVXJsKSA/IHtJRDogaWRPclVybH0gOiB7RmlsZVVSTDogaWRPclVybH07XG5cblx0XHRcdHZhciBpdGVtID0gJCgnPGRpdiBjbGFzcz1cInNzLWh0bWxlZGl0b3JmaWVsZC1maWxlIGxvYWRpbmdcIiAvPicpO1xuXHRcdFx0dGhpcy5maW5kKCcuY29udGVudC1lZGl0JykucHJlcGVuZChpdGVtKTtcblxuXHRcdFx0dmFyIGRmciA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0JC5hamF4KHtcblx0XHRcdFx0dXJsOiAkLnBhdGguYWRkU2VhcmNoUGFyYW1zKHRoaXMuYXR0cignYWN0aW9uJykucmVwbGFjZSgvTWVkaWFGb3JtLywgJ3ZpZXdmaWxlJyksIHBhcmFtcyksXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwsIHN0YXR1cywgeGhyKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0l0ZW0gPSAkKGh0bWwpLmZpbHRlcignLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJyk7XG5cdFx0XHRcdFx0aXRlbS5yZXBsYWNlV2l0aChuZXdJdGVtKTtcblx0XHRcdFx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdFx0XHRcdGRmci5yZXNvbHZlKG5ld0l0ZW0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0XHRkZnIucmVqZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZGZyLnByb21pc2UoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vV2hlbiAnSW5zZXJ0IGZyb20gVVJMJyBidXR0b24gaXMgY2xpY2tlZFxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gZGl2LnNzLXVwbG9hZCAudXBsb2FkLXVybCcpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBmb3JtID0gdGhpcy5jbG9zZXN0KCdmb3JtJyk7XG5cblx0XHRcdGZvcm0uYWRkQ2xhc3MoJ2luc2VydGluZ1VSTCcpO1xuXHRcdFx0Zm9ybS5yZWRyYXcoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vV2hlbiBiYWNrIGJ1dHRvbiBpcyBjbGlja2VkIHdoaWxlIGluc2VydGluZyBVUkxcblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmcgLmJhY2stYnV0dG9uJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpO1xuXG5cdFx0XHRmb3JtLnJlbW92ZUNsYXNzKCdpbnNlcnRpbmdVUkwnKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gLnNzLWdyaWRmaWVsZC1pdGVtcycpLmVudHdpbmUoe1xuXHRcdG9uc2VsZWN0YWJsZXNlbGVjdGVkOiBmdW5jdGlvbihlLCB1aSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSwgaXRlbSA9ICQodWkuc2VsZWN0ZWQpO1xuXHRcdFx0aWYoIWl0ZW0uaXMoJy5zcy1ncmlkZmllbGQtaXRlbScpKSByZXR1cm47XG5cdFx0XHRmb3JtLmNsb3Nlc3QoJ2Zvcm0nKS5zaG93RmlsZVZpZXcoaXRlbS5kYXRhKCdpZCcpKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cblx0XHRcdGZvcm0ucGFyZW50KCkudHJpZ2dlcignc2Nyb2xsJyk7XG5cdFx0fSxcblx0XHRvbnNlbGVjdGFibGV1bnNlbGVjdGVkOiBmdW5jdGlvbihlLCB1aSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSwgaXRlbSA9ICQodWkudW5zZWxlY3RlZCk7XG5cdFx0XHRpZighaXRlbS5pcygnLnNzLWdyaWRmaWVsZC1pdGVtJykpIHJldHVybjtcblx0XHRcdGZvcm0uZ2V0RmlsZVZpZXcoaXRlbS5kYXRhKCdpZCcpKS5yZW1vdmUoKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogU2hvdyB0aGUgc2Vjb25kIHN0ZXAgYWZ0ZXIgdXBsb2FkaW5nIGFuIGltYWdlXG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1mb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gZGl2LnNzLWFzc2V0dXBsb2FkZmllbGQnKS5lbnR3aW5lKHtcblx0XHQvL3RoZSBVcGxvYWRGaWVsZCBkaXYuc3MtdXBsb2FkZmllbGQtZWRpdGFuZG9yZ2FuaXplIGlzIGhpZGRlbiBpbiBDU1MsXG5cdFx0Ly8gYmVjYXVzZSB3ZSB1c2UgdGhlIGRldGFpbCB2aWV3IGZvciBlYWNoIGluZGl2aWR1YWwgZmlsZSBpbnN0ZWFkXG5cdFx0b25maWxldXBsb2Fkc3RvcDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuXHRcdFx0Ly91cGRhdGUgdGhlIGVkaXRGaWVsZHMgdG8gc2hvdyB0aG9zZSBGaWxlcyB0aGF0IGFyZSBuZXdseSB1cGxvYWRlZFxuXHRcdFx0dmFyIGVkaXRGaWVsZElEcyA9IFtdO1xuXHRcdFx0Zm9ybS5maW5kKCdkaXYuY29udGVudC1lZGl0JykuZmluZCgnZGl2LnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0XHQvL2dldCB0aGUgdXBsb2FkZWQgZmlsZSBJRCB3aGVuIHRoaXMgZXZlbnQgdHJpZ2dlcnMsIHNpZ25hbGluZyB0aGUgdXBsb2FkIGhhcyBjb21wZWxldGVkIHN1Y2Nlc3NmdWxseVxuXHRcdFx0XHRlZGl0RmllbGRJRHMucHVzaCgkKHRoaXMpLmRhdGEoJ2lkJykpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyB3ZSBvbmx5IHdhbnQgdGhpcyAuc3MtdXBsb2FkZmllbGQtZmlsZXMgLSBlbHNlIHdlIGdldCBhbGwgc3MtdXBsb2FkZmllbGQtZmlsZXMgd2ljaCBpbmNsdWRlIHRoZSBvbmVzIG5vdCByZWxhdGVkIHRvICN0aW55bWNlIGluc2VydG1lZGlhXG5cdFx0XHR2YXIgdXBsb2FkZWRGaWxlcyA9ICQoJy5zcy11cGxvYWRmaWVsZC1maWxlcycsIHRoaXMpLmNoaWxkcmVuKCcuc3MtdXBsb2FkZmllbGQtaXRlbScpO1xuXHRcdFx0dXBsb2FkZWRGaWxlcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB1cGxvYWRlZElEID0gJCh0aGlzKS5kYXRhKCdmaWxlaWQnKTtcblx0XHRcdFx0aWYgKHVwbG9hZGVkSUQgJiYgJC5pbkFycmF5KHVwbG9hZGVkSUQsIGVkaXRGaWVsZElEcykgPT0gLTEpIHtcblx0XHRcdFx0XHQvL3RyaWdnZXIgdGhlIGRldGFpbCB2aWV3IGZvciBmaWxsaW5nIG91dCBkZXRhaWxzIGFib3V0IHRoZSBmaWxlIHdlIGFyZSBhYm91dCB0byBpbnNlcnQgaW50byBUaW55TUNFXG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmUoKTsgLy8gUmVtb3ZlIHN1Y2Nlc3NmdWxseSBhZGRlZCBpdGVtIGZyb20gdGhlIHF1ZXVlXG5cdFx0XHRcdFx0Zm9ybS5zaG93RmlsZVZpZXcodXBsb2FkZWRJRCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRmb3JtLnBhcmVudCgpLnRyaWdnZXIoJ3Njcm9sbCcpO1xuXG5cdFx0XHRmb3JtLnJlZHJhdygpO1xuXHRcdH1cblxuXHR9KTtcblxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1mb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gaW5wdXQucmVtb3RldXJsJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMudmFsaWRhdGUoKTtcblx0XHR9LFxuXG5cdFx0b25rZXl1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnZhbGlkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uY2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudmFsaWRhdGUoKTtcblx0XHR9LFxuXG5cdFx0Z2V0QWRkQnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5Db21wb3NpdGVGaWVsZCcpLmZpbmQoJ2J1dHRvbi5hZGQtdXJsJyk7XG5cdFx0fSxcblxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2YWwgPSB0aGlzLnZhbCgpLCBvcmlnID0gdmFsO1xuXG5cdFx0XHR2YWwgPSAkLnRyaW0odmFsKTtcblx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcLy9pLCAnJyk7XG5cdFx0XHRpZiAob3JpZyAhPT0gdmFsKSB0aGlzLnZhbCh2YWwpO1xuXG5cdFx0XHR0aGlzLmdldEFkZEJ1dHRvbigpLmJ1dHRvbighIXZhbCA/ICdlbmFibGUnIDogJ2Rpc2FibGUnKTtcblx0XHRcdHJldHVybiAhIXZhbDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSBzZWNvbmQgc3RlcCBhZnRlciBhZGRpbmcgYSBVUkxcblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWZvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuYWRkLXVybCcpLmVudHdpbmUoe1xuXHRcdGdldFVSTEZpZWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5Db21wb3NpdGVGaWVsZCcpLmZpbmQoJ2lucHV0LnJlbW90ZXVybCcpO1xuXHRcdH0sXG5cblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgdXJsRmllbGQgPSB0aGlzLmdldFVSTEZpZWxkKCksIGNvbnRhaW5lciA9IHRoaXMuY2xvc2VzdCgnLkNvbXBvc2l0ZUZpZWxkJyksIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuXHRcdFx0aWYgKHVybEZpZWxkLnZhbGlkYXRlKCkpIHtcblx0XHRcdFx0Y29udGFpbmVyLmFkZENsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdGZvcm0uc2hvd0ZpbGVWaWV3KCdodHRwOi8vJyArIHVybEZpZWxkLnZhbCgpKS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDbGFzcygnbG9hZGluZycpO1xuXG5cdFx0XHRcdFx0Zm9ybS5wYXJlbnQoKS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHNlbGVjdGVkIGZpbGUsIHRvZ2V0aGVyIHdpdGggYSBzZXQgb2YgZm9ybSBmaWVsZHMgdG8gZWRpdCBpdHMgcHJvcGVydGllcy5cblx0ICogT3ZlcmxvYWQgdGhpcyBiYXNlZCBvbiB0aGUgbWVkaWEgdHlwZSB0byBkZXRlcm1pbmUgaG93IHRoZSBIVE1MIHNob3VsZCBiZSBjcmVhdGVkLlxuXHQgKi9cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmVudHdpbmUoe1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gTWFwIG9mIEhUTUwgYXR0cmlidXRlcyB3aGljaCBjYW4gYmUgc2V0IG9uIHRoZSBjcmVhdGVkIERPTSBub2RlLlxuXHRcdCAqL1xuXHRcdGdldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBNYXAgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWRcblx0XHQgKiBieSB0aGUgc3BlY2lmaWMgbWVkaWEgdHlwZS5cblx0XHQgKi9cblx0XHRnZXRFeHRyYURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBIVE1MIHN1aXRhYmxlIGZvciBpbnNlcnRpb24gaW50byB0aGUgcmljaCB0ZXh0IGVkaXRvclxuXHRcdCAqL1xuXHRcdGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQXNzdW1lcyBVcGxvYWRGaWVsZCBtYXJrdXAgc3RydWN0dXJlXG5cdFx0XHRyZXR1cm4gJCgnPGRpdj4nKS5hcHBlbmQoXG5cdFx0XHRcdCQoJzxhLz4nKS5hdHRyKHtocmVmOiB0aGlzLmRhdGEoJ3VybCcpfSkudGV4dCh0aGlzLmZpbmQoJy5uYW1lJykudGV4dCgpKVxuXHRcdFx0KS5odG1sKCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBJbnNlcnQgdXBkYXRlZCBIVE1MIGNvbnRlbnQgaW50byB0aGUgcmljaCB0ZXh0IGVkaXRvclxuXHRcdCAqL1xuXHRcdGluc2VydEhUTUw6IGZ1bmN0aW9uKGVkKSB7XG5cdFx0XHQvLyBJbnNlcnQgY29udGVudFxuXHRcdFx0ZWQucmVwbGFjZUNvbnRlbnQodGhpcy5nZXRIVE1MKCkpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgZm9ybSB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBub2RlIGluIHRoZSBlZGl0b3IuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dXBkYXRlRnJvbU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybXMgdmFsdWVzIHNldCBvbiB0aGUgZGltZW5zaW9ucyBmb3JtIGZpZWxkcyBiYXNlZCBvbiB0d28gY29uc3RyYWludHM6XG5cdFx0ICogQW4gYXNwZWN0IHJhdGlvbiwgYW5kIG1heCB3aWR0aC9oZWlnaHQgdmFsdWVzLiBXcml0ZXMgYmFjayB0byB0aGUgZmllbGQgcHJvcGVydGllcyBhcyByZXF1aXJlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgZGltZW5zaW9uIHRvIGNvbnN0cmFpbiB0aGUgb3RoZXIgdmFsdWUgYnksIGlmIGFueSAoXCJXaWR0aFwiIG9yIFwiSGVpZ2h0XCIpXG5cdFx0ICogQHBhcmFtIHtJbnR9IE9wdGlvbmFsIG1heCB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7SW50fSBPcHRpb25hbCBtYXggaGVpZ2h0XG5cdFx0ICovXG5cdFx0dXBkYXRlRGltZW5zaW9uczogZnVuY3Rpb24oY29uc3RyYWluQnksIG1heFcsIG1heEgpIHtcblx0XHRcdHZhciB3aWR0aEVsID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKSxcblx0XHRcdFx0aGVpZ2h0RWwgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKSxcblx0XHRcdFx0dyA9IHdpZHRoRWwudmFsKCksXG5cdFx0XHRcdGggPSBoZWlnaHRFbC52YWwoKSxcblx0XHRcdFx0YXNwZWN0O1xuXG5cdFx0XHQvLyBQcm9wb3J0aW9uYXRlIHVwZGF0aW5nIG9mIGhlaWdodHMsIHVzaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGlmKHcgJiYgaCkge1xuXHRcdFx0XHRpZihjb25zdHJhaW5CeSkge1xuXHRcdFx0XHRcdGFzcGVjdCA9IGhlaWdodEVsLmdldE9yaWdWYWwoKSAvIHdpZHRoRWwuZ2V0T3JpZ1ZhbCgpO1xuXHRcdFx0XHRcdC8vIFVzZXMgZmxvb3IoKSBhbmQgY2VpbCgpIHRvIGF2b2lkIGJvdGggZmllbGRzIGNvbnN0YW50bHkgbG93ZXJpbmcgZWFjaCBvdGhlcidzIHZhbHVlcyBpbiByb3VuZGluZyBzaXR1YXRpb25zXG5cdFx0XHRcdFx0aWYoY29uc3RyYWluQnkgPT0gJ1dpZHRoJykge1xuXHRcdFx0XHRcdFx0aWYobWF4VyAmJiB3ID4gbWF4VykgdyA9IG1heFc7XG5cdFx0XHRcdFx0XHRoID0gTWF0aC5mbG9vcih3ICogYXNwZWN0KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoY29uc3RyYWluQnkgPT0gJ0hlaWdodCcpIHtcblx0XHRcdFx0XHRcdGlmKG1heEggJiYgaCA+IG1heEgpIGggPSBtYXhIO1xuXHRcdFx0XHRcdFx0dyA9IE1hdGguY2VpbChoIC8gYXNwZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYobWF4VyAmJiB3ID4gbWF4VykgdyA9IG1heFc7XG5cdFx0XHRcdFx0aWYobWF4SCAmJiBoID4gbWF4SCkgaCA9IG1heEg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3aWR0aEVsLnZhbCh3KTtcblx0XHRcdFx0aGVpZ2h0RWwudmFsKGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy1odG1sZWRpdG9yZmllbGQtZmlsZS5pbWFnZScpLmVudHdpbmUoe1xuXHRcdGdldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKS52YWwoKSxcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1IZWlnaHRdJykudmFsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnc3JjJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9VVJMXScpLnZhbCgpLFxuXHRcdFx0XHQnYWx0JyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9QWx0VGV4dF0nKS52YWwoKSxcblx0XHRcdFx0J3dpZHRoJyA6IHdpZHRoID8gcGFyc2VJbnQod2lkdGgsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdoZWlnaHQnIDogaGVpZ2h0ID8gcGFyc2VJbnQoaGVpZ2h0LCAxMCkgOiBudWxsLFxuXHRcdFx0XHQndGl0bGUnIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1UaXRsZV0nKS52YWwoKSxcblx0XHRcdFx0J2NsYXNzJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q1NTQ2xhc3NdJykudmFsKCksXG5cdFx0XHRcdCdkYXRhLWZpbGVpZCcgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUZpbGVJRF0nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEV4dHJhRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnQ2FwdGlvblRleHQnOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUNhcHRpb25UZXh0XScpLnZhbCgpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Z2V0SFRNTDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBOT1AgKi9cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIExvZ2ljIHNpbWlsYXIgdG8gVGlueU1DRSAnYWR2aW1hZ2UnIHBsdWdpbiwgaW5zZXJ0QW5kQ2xvc2UoKSBtZXRob2QuXG5cdFx0ICovXG5cdFx0aW5zZXJ0SFRNTDogZnVuY3Rpb24oZWQpIHtcblx0XHRcdHZhciBmb3JtID0gdGhpcy5jbG9zZXN0KCdmb3JtJyk7XG5cdFx0XHR2YXIgbm9kZSA9IGZvcm0uZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoIWVkKSBlZCA9IGZvcm0uZ2V0RWRpdG9yKCk7XG5cblx0XHRcdC8vIEdldCB0aGUgYXR0cmlidXRlcyAmIGV4dHJhIGRhdGFcblx0XHRcdHZhciBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpLCBleHRyYURhdGEgPSB0aGlzLmdldEV4dHJhRGF0YSgpO1xuXG5cdFx0XHQvLyBGaW5kIHRoZSBlbGVtZW50IHdlIGFyZSByZXBsYWNpbmcgLSBlaXRoZXIgdGhlIGltZywgaXQncyB3cmFwcGVyIHBhcmVudCwgb3Igbm90aGluZyAoaWYgY3JlYXRpbmcpXG5cdFx0XHR2YXIgcmVwbGFjZWUgPSAobm9kZSAmJiBub2RlLmlzKCdpbWcnKSkgPyBub2RlIDogbnVsbDtcblx0XHRcdGlmIChyZXBsYWNlZSAmJiByZXBsYWNlZS5wYXJlbnQoKS5pcygnLmNhcHRpb25JbWFnZScpKSByZXBsYWNlZSA9IHJlcGxhY2VlLnBhcmVudCgpO1xuXG5cdFx0XHQvLyBGaW5kIHRoZSBpbWcgbm9kZSAtIGVpdGhlciB0aGUgZXhpc3RpbmcgaW1nIG9yIGEgbmV3IG9uZSwgYW5kIHVwZGF0ZSBpdFxuXHRcdFx0dmFyIGltZyA9IChub2RlICYmIG5vZGUuaXMoJ2ltZycpKSA/IG5vZGUgOiAkKCc8aW1nIC8+Jyk7XG5cdFx0XHRpbWcuYXR0cihhdHRycyk7XG5cblx0XHRcdC8vIEFueSBleGlzdGluZyBmaWd1cmUgb3IgY2FwdGlvbiBub2RlXG5cdFx0XHR2YXIgY29udGFpbmVyID0gaW1nLnBhcmVudCgnLmNhcHRpb25JbWFnZScpLCBjYXB0aW9uID0gY29udGFpbmVyLmZpbmQoJy5jYXB0aW9uJyk7XG5cblx0XHRcdC8vIElmIHdlJ3ZlIGdvdCBjYXB0aW9uIHRleHQsIHdlIG5lZWQgYSB3cmFwcGluZyBkaXYuY2FwdGlvbkltYWdlIGFuZCBzaWJsaW5nIHAuY2FwdGlvblxuXHRcdFx0aWYgKGV4dHJhRGF0YS5DYXB0aW9uVGV4dCkge1xuXHRcdFx0XHRpZiAoIWNvbnRhaW5lci5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSAkKCc8ZGl2PjwvZGl2PicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGFpbmVyLmF0dHIoJ2NsYXNzJywgJ2NhcHRpb25JbWFnZSAnK2F0dHJzWydjbGFzcyddKS5jc3MoJ3dpZHRoJywgYXR0cnMud2lkdGgpO1xuXG5cdFx0XHRcdGlmICghY2FwdGlvbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYXB0aW9uID0gJCgnPHAgY2xhc3M9XCJjYXB0aW9uXCI+PC9wPicpLmFwcGVuZFRvKGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYXB0aW9uLmF0dHIoJ2NsYXNzJywgJ2NhcHRpb24gJythdHRyc1snY2xhc3MnXSkudGV4dChleHRyYURhdGEuQ2FwdGlvblRleHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGZvcmdldCB0aGV5IGV4aXN0XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29udGFpbmVyID0gY2FwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50IHdlIGFyZSByZXBsYWNpbmcgdGhlIHJlcGxhY2VlIHdpdGhcblx0XHRcdHZhciByZXBsYWNlciA9IGNvbnRhaW5lciA/IGNvbnRhaW5lciA6IGltZztcblxuXHRcdFx0Ly8gSWYgd2UncmUgcmVwbGFjaW5nIHNvbWV0aGluZywgYW5kIGl0J3Mgbm90IHdpdGggaXRzZWxmLCBkbyBzb1xuXHRcdFx0aWYgKHJlcGxhY2VlICYmIHJlcGxhY2VlLm5vdChyZXBsYWNlcikubGVuZ3RoKSB7XG5cdFx0XHRcdHJlcGxhY2VlLnJlcGxhY2VXaXRoKHJlcGxhY2VyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgZWxlbWVudCwgbWFrZSBzdXJlIHRoZSBpbWcgaXMgdGhlIGZpcnN0IGNoaWxkIC0gaW1nIG1pZ2h0IGJlIHRoZVxuXHRcdFx0Ly8gcmVwbGFjZWUsIGFuZCB0aGUgd3JhcHBlciB0aGUgcmVwbGFjZXIsIGFuZCB3ZSBjYW4ndCBkbyB0aGlzIHRpbGwgYWZ0ZXIgdGhlIHJlcGxhY2UgaGFzIGhhcHBlbmVkXG5cdFx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5wcmVwZW5kKGltZyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGRvbid0IGhhdmUgYSByZXBsYWNlZSwgdGhlbiB3ZSBuZWVkIHRvIGluc2VydCB0aGUgd2hvbGUgSFRNTFxuXHRcdFx0aWYgKCFyZXBsYWNlZSkge1xuXHRcdFx0XHQvLyBPdGhlcndpc2UgaW5zZXJ0IHRoZSB3aG9sZSBIVE1MIGNvbnRlbnRcblx0XHRcdFx0ZWQucmVwYWludCgpO1xuXHRcdFx0XHRlZC5pbnNlcnRDb250ZW50KCQoJzxkaXYgLz4nKS5hcHBlbmQocmVwbGFjZXIpLmh0bWwoKSwge3NraXBfdW5kbyA6IDF9KTtcblx0XHRcdH1cblxuXHRcdFx0ZWQuYWRkVW5kbygpO1xuXHRcdFx0ZWQucmVwYWludCgpO1xuXHRcdH0sXG5cdFx0dXBkYXRlRnJvbU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9QWx0VGV4dF0nKS52YWwobm9kZS5hdHRyKCdhbHQnKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVRpdGxlXScpLnZhbChub2RlLmF0dHIoJ3RpdGxlJykpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1DU1NDbGFzc10nKS52YWwobm9kZS5hdHRyKCdjbGFzcycpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9V2lkdGhdJykudmFsKG5vZGUud2lkdGgoKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKS52YWwobm9kZS5oZWlnaHQoKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUNhcHRpb25UZXh0XScpLnZhbChub2RlLnNpYmxpbmdzKCcuY2FwdGlvbjpmaXJzdCcpLnRleHQoKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUZpbGVJRF0nKS52YWwobm9kZS5kYXRhKCdmaWxlaWQnKSk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdC8qKlxuXHQgKiBJbnNlcnQgYSBmbGFzaCBvYmplY3QgdGFnIGludG8gdGhlIGNvbnRlbnQuXG5cdCAqIFJlcXVpcmVzIHRoZSAnbWVkaWEnIHBsdWdpbiBmb3Igc2VyaWFsaXphdGlvbiBvZiB0YWdzIGludG8gPGltZz4gcGxhY2Vob2xkZXJzLlxuXHQgKi9cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy1odG1sZWRpdG9yZmllbGQtZmlsZS5mbGFzaCcpLmVudHdpbmUoe1xuXHRcdGdldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKS52YWwoKSxcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1IZWlnaHRdJykudmFsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnc3JjJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9VVJMXScpLnZhbCgpLFxuXHRcdFx0XHQnd2lkdGgnIDogd2lkdGggPyBwYXJzZUludCh3aWR0aCwgMTApIDogbnVsbCxcblx0XHRcdFx0J2hlaWdodCcgOiBoZWlnaHQgPyBwYXJzZUludChoZWlnaHQsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdkYXRhLWZpbGVpZCcgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUZpbGVJRF0nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdC8vIEVtdWxhdGUgc2VyaWFsaXphdGlvbiBmcm9tICdtZWRpYScgcGx1Z2luXG5cdFx0XHR2YXIgZWwgPSB0aW55TUNFLmFjdGl2ZUVkaXRvci5wbHVnaW5zLm1lZGlhLmRhdGFUb0ltZyh7XG5cdFx0XHRcdCd0eXBlJzogJ2ZsYXNoJyxcblx0XHRcdFx0J3dpZHRoJzogYXR0cnMud2lkdGgsXG5cdFx0XHRcdCdoZWlnaHQnOiBhdHRycy5oZWlnaHQsXG5cdFx0XHRcdCdwYXJhbXMnOiB7J3NyYyc6IGF0dHJzLnNyY30sXG5cdFx0XHRcdCd2aWRlbyc6IHsnc291cmNlcyc6IFtdfVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiAkKCc8ZGl2IC8+JykuYXBwZW5kKGVsKS5odG1sKCk7IC8vIExpdHRsZSBoYWNrIHRvIGdldCBvdXRlckhUTUwgc3RyaW5nXG5cdFx0fSxcblx0XHR1cGRhdGVGcm9tTm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0Ly8gVE9ETyBOb3QgaW1wbGVtZW50ZWRcblx0XHR9XG5cdH0pO1xuXG5cblx0LyoqXG5cdCAqIEluc2VydCBhbiBvZW1iZWQgb2JqZWN0IHRhZyBpbnRvIHRoZSBjb250ZW50LlxuXHQgKiBSZXF1aXJlcyB0aGUgJ21lZGlhJyBwbHVnaW4gZm9yIHNlcmlhbGl6YXRpb24gb2YgdGFncyBpbnRvIDxpbWc+IHBsYWNlaG9sZGVycy5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUuZW1iZWQnKS5lbnR3aW5lKHtcblx0XHRnZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB3aWR0aCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9V2lkdGhdJykudmFsKCksXG5cdFx0XHRcdGhlaWdodCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9SGVpZ2h0XScpLnZhbCgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0J3NyYycgOiB0aGlzLmZpbmQoJy50aHVtYm5haWwtcHJldmlldycpLmF0dHIoJ3NyYycpLFxuXHRcdFx0XHQnd2lkdGgnIDogd2lkdGggPyBwYXJzZUludCh3aWR0aCwgMTApIDogbnVsbCxcblx0XHRcdFx0J2hlaWdodCcgOiBoZWlnaHQgPyBwYXJzZUludChoZWlnaHQsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcycgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUNTU0NsYXNzXScpLnZhbCgpLFxuXHRcdFx0XHQnYWx0JyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9QWx0VGV4dF0nKS52YWwoKSxcblx0XHRcdFx0J3RpdGxlJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9VGl0bGVdJykudmFsKCksXG5cdFx0XHRcdCdkYXRhLWZpbGVpZCcgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUZpbGVJRF0nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEV4dHJhRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgd2lkdGggPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVdpZHRoXScpLnZhbCgpLFxuXHRcdFx0XHRoZWlnaHQgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKS52YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdCdDYXB0aW9uVGV4dCc6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q2FwdGlvblRleHRdJykudmFsKCksXG5cdFx0XHRcdCdVcmwnOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVVSTF0nKS52YWwoKSxcblx0XHRcdFx0J3RodW1ibmFpbCc6IHRoaXMuZmluZCgnLnRodW1ibmFpbC1wcmV2aWV3JykuYXR0cignc3JjJyksXG5cdFx0XHRcdCd3aWR0aCcgOiB3aWR0aCA/IHBhcnNlSW50KHdpZHRoLCAxMCkgOiBudWxsLFxuXHRcdFx0XHQnaGVpZ2h0JyA6IGhlaWdodCA/IHBhcnNlSW50KGhlaWdodCwgMTApIDogbnVsbCxcblx0XHRcdFx0J2Nzc2NsYXNzJzogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1DU1NDbGFzc10nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsLFxuXHRcdFx0XHRhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpLFxuXHRcdFx0XHRleHRyYURhdGEgPSB0aGlzLmdldEV4dHJhRGF0YSgpLFxuXHRcdFx0XHQvLyBpbWdFbCA9ICQoJzxpbWcgaWQ9XCJfc3NfdG1wX2ltZ1wiIC8+Jyk7XG5cdFx0XHRcdGltZ0VsID0gJCgnPGltZyAvPicpLmF0dHIoYXR0cnMpLmFkZENsYXNzKCdzcy1odG1sZWRpdG9yZmllbGQtZmlsZSBlbWJlZCcpO1xuXG5cdFx0XHQkLmVhY2goZXh0cmFEYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpbWdFbC5hdHRyKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZihleHRyYURhdGEuQ2FwdGlvblRleHQpIHtcblx0XHRcdFx0ZWwgPSAkKCc8ZGl2IHN0eWxlPVwid2lkdGg6ICcgKyBhdHRyc1snd2lkdGgnXSArICdweDtcIiBjbGFzcz1cImNhcHRpb25JbWFnZSAnICsgYXR0cnNbJ2NsYXNzJ10gKyAnXCI+PHAgY2xhc3M9XCJjYXB0aW9uXCI+JyArIGV4dHJhRGF0YS5DYXB0aW9uVGV4dCArICc8L3A+PC9kaXY+JykucHJlcGVuZChpbWdFbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbCA9IGltZ0VsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICQoJzxkaXYgLz4nKS5hcHBlbmQoZWwpLmh0bWwoKTsgLy8gTGl0dGxlIGhhY2sgdG8gZ2V0IG91dGVySFRNTCBzdHJpbmdcblx0XHR9LFxuXHRcdHVwZGF0ZUZyb21Ob2RlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUFsdFRleHRdJykudmFsKG5vZGUuYXR0cignYWx0JykpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1UaXRsZV0nKS52YWwobm9kZS5hdHRyKCd0aXRsZScpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9V2lkdGhdJykudmFsKG5vZGUud2lkdGgoKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKS52YWwobm9kZS5oZWlnaHQoKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVRpdGxlXScpLnZhbChub2RlLmF0dHIoJ3RpdGxlJykpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1DU1NDbGFzc10nKS52YWwobm9kZS5kYXRhKCdjc3NjbGFzcycpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9RmlsZUlEXScpLnZhbChub2RlLmRhdGEoJ2ZpbGVpZCcpKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUgLmRpbWVuc2lvbnMgOmlucHV0JykuZW50d2luZSh7XG5cdFx0T3JpZ1ZhbDogbnVsbCxcblx0XHRvbm1hdGNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHR0aGlzLnNldE9yaWdWYWwocGFyc2VJbnQodGhpcy52YWwoKSwgMTApKTtcblx0XHR9LFxuXHRcdG9udW5tYXRjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cdFx0b25mb2N1c291dDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dGhpcy5jbG9zZXN0KCcuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUnKS51cGRhdGVEaW1lbnNpb25zKHRoaXMuYXR0cignbmFtZScpKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXNlbGVjdCBpdGVtIGFuZCByZW1vdmUgdGhlICdlZGl0JyB2aWV3XG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gLnNzLXVwbG9hZGZpZWxkLWl0ZW0gLnNzLXVwbG9hZGZpZWxkLWl0ZW0tY2FuY2VsJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSwgZmlsZSA9IHRoaXMuY2xvc2VzdCgnc3MtdXBsb2FkZmllbGQtaXRlbScpO1xuXHRcdFx0Zm9ybS5maW5kKCcuc3MtZ3JpZGZpZWxkLWl0ZW1bZGF0YS1pZD0nICsgZmlsZS5kYXRhKCdpZCcpICsgJ10nKS5yZW1vdmVDbGFzcygndWktc2VsZWN0ZWQnKTtcblx0XHRcdHRoaXMuY2xvc2VzdCgnLnNzLXVwbG9hZGZpZWxkLWl0ZW0nKS5yZW1vdmUoKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCdkaXYuc3MtYXNzZXR1cGxvYWRmaWVsZCAuc3MtdXBsb2FkZmllbGQtaXRlbS1lZGl0LCBkaXYuc3MtYXNzZXR1cGxvYWRmaWVsZCAuc3MtdXBsb2FkZmllbGQtaXRlbS1uYW1lJykuZW50d2luZSh7XG5cdFx0Z2V0RWRpdEZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2VzdCgnLnNzLXVwbG9hZGZpZWxkLWl0ZW0nKS5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1lZGl0Zm9ybScpO1xuXHRcdH0sXG5cblx0XHRmcm9tRWRpdEZvcm06IHtcblx0XHRcdG9uY2hhbmdlOiBmdW5jdGlvbihlKXtcblx0XHRcdFx0dmFyIGZvcm0gPSAkKGUudGFyZ2V0KTtcblx0XHRcdFx0Zm9ybS5yZW1vdmVDbGFzcygnZWRpdGVkJyk7IC8vc28gZWRpdGVkIGNsYXNzIGlzIG9ubHkgdGhlcmUgb25jZVxuXHRcdFx0XHRmb3JtLmFkZENsYXNzKCdlZGl0ZWQnKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25jbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGVkaXRGb3JtID0gdGhpcy5nZXRFZGl0Rm9ybSgpO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UncmUgaW4gYW4gSHRtbEVkaXRvckZpZWxkIGhlcmUsIG9yIGZhbGwtYmFjayB0byBfc3VwZXIoKS4gSHRtbEVkaXRvckZpZWxkIHdpdGhcblx0XHRcdC8vIEFzc2V0VXBsb2FkRmllbGQgZG9lc24ndCB1c2UgaWZyYW1lcywgc28gbmVlZHMgaXRzIG93biB0b2dnbGVFZGl0Rm9ybSgpIGxvZ2ljXG5cdFx0XHRpZiAodGhpcy5jbG9zZXN0KCcuc3MtdXBsb2FkZmllbGQtaXRlbScpLmhhc0NsYXNzKCdzcy1odG1sZWRpdG9yZmllbGQtZmlsZScpKSB7XG5cdFx0XHRcdGVkaXRGb3JtLnBhcmVudCgnc3MtdXBsb2FkZmllbGQtaXRlbScpLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS13YXJuaW5nJyk7XG5cblx0XHRcdFx0ZWRpdEZvcm0udG9nZ2xlRWRpdEZvcm0oKTtcblxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IC8vIEF2b2lkIGEgZm9ybSBzdWJtaXRcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIEF2b2lkIGR1cGxpY2F0aW9uIGZyb20gYnV0dG9uXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N1cGVyKGUpO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnZGl2LnNzLWFzc2V0dXBsb2FkZmllbGQgLnNzLXVwbG9hZGZpZWxkLWl0ZW0tZWRpdGZvcm0nKS5lbnR3aW5lKHtcblx0XHR0b2dnbGVFZGl0Rm9ybTogZnVuY3Rpb24oYm9vbCkge1xuXHRcdFx0dmFyIGl0ZW1JbmZvID0gdGhpcy5wcmV2KCcuc3MtdXBsb2FkZmllbGQtaXRlbS1pbmZvJyksIHN0YXR1cyA9IGl0ZW1JbmZvLmZpbmQoJy5zcy11cGxvYWRmaWVsZC1pdGVtLXN0YXR1cycpO1xuXHRcdFx0dmFyIHRleHQ9XCJcIjtcblxuXHRcdFx0aWYoYm9vbCA9PT0gdHJ1ZSB8fCAoYm9vbCAhPT0gZmFsc2UgJiYgdGhpcy5oZWlnaHQoKSA9PT0gMCkpIHtcblx0XHRcdFx0dGV4dCA9IGkxOG4uX3QoJ1VwbG9hZEZpZWxkLkVkaXRpbmcnLCBcIkVkaXRpbmcgLi4uXCIpO1xuXHRcdFx0XHR0aGlzLmhlaWdodCgnYXV0bycpO1xuXHRcdFx0XHRpdGVtSW5mby5maW5kKCcudG9nZ2xlLWRldGFpbHMtaWNvbicpLmFkZENsYXNzKCdvcGVuZWQnKTtcblx0XHRcdFx0c3RhdHVzLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS1zdWNjZXNzLXRleHQnKS5yZW1vdmVDbGFzcygndWktc3RhdGUtd2FybmluZy10ZXh0Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmhlaWdodCgwKTtcblx0XHRcdFx0aXRlbUluZm8uZmluZCgnLnRvZ2dsZS1kZXRhaWxzLWljb24nKS5yZW1vdmVDbGFzcygnb3BlbmVkJyk7XG5cdFx0XHRcdGlmKCF0aGlzLmhhc0NsYXNzKCdlZGl0ZWQnKSl7XG5cdFx0XHRcdFx0dGV4dCA9IGkxOG4uX3QoJ1VwbG9hZEZpZWxkLk5PQ0hBTkdFUycsICdObyBDaGFuZ2VzJyk7XG5cdFx0XHRcdFx0c3RhdHVzLmFkZENsYXNzKCd1aS1zdGF0ZS1zdWNjZXNzLXRleHQnKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGV4dCA9IGkxOG4uX3QoJ1VwbG9hZEZpZWxkLkNIQU5HRVNTQVZFRCcsICdDaGFuZ2VzIE1hZGUnKTtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUNsYXNzKCdlZGl0ZWQnKTtcblx0XHRcdFx0XHRzdGF0dXMuYWRkQ2xhc3MoJ3VpLXN0YXRlLXN1Y2Nlc3MtdGV4dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdHN0YXR1cy5hdHRyKCd0aXRsZScsdGV4dCkudGV4dCh0ZXh0KTtcblx0XHR9XG5cdH0pO1xuXG5cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5maWVsZFtpZCQ9XCJQYXJlbnRJRF9Ib2xkZXJcIl0gLlRyZWVEcm9wZG93bkZpZWxkJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdFx0Ly8gVE9ETyBDdXN0b20gZXZlbnQgZG9lc24ndCBmaXJlIGluIElFIGlmIHJlZ2lzdGVyZWQgdGhyb3VnaCBvYmplY3QgbGl0ZXJhbFxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dGhpcy5iaW5kKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGZpbGVMaXN0ID0gc2VsZi5jbG9zZXN0KCdmb3JtJykuZmluZCgnLnNzLWdyaWRmaWVsZCcpO1xuXHRcdFx0XHRmaWxlTGlzdC5zZXRTdGF0ZSgnUGFyZW50SUQnLCBzZWxmLmdldFZhbHVlKCkpO1xuXHRcdFx0XHRmaWxlTGlzdC5yZWxvYWQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cbn0pO1xuIiwiaW1wb3J0ICQgZnJvbSAnLi9qUXVlcnknO1xuXG4kLmVudHdpbmUoJ3NzJywgZnVuY3Rpb24oJCl7XG5cdC8qKlxuXHQgKiBMaWdodHdlaWdodCB3cmFwcGVyIGFyb3VuZCBqUXVlcnkgVUkgdGFicyBmb3IgZ2VuZXJpYyB0YWIgc2V0LXVwXG5cdCAqL1xuXHQkKCcuc3MtdGFic2V0JykuZW50d2luZSh7XG5cdFx0SWdub3JlVGFiU3RhdGU6IGZhbHNlLFxuXG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcblxuXHRcdFx0Ly8gQ2FuJ3QgbmFtZSByZWRyYXcoKSBhcyBpdCBjbGFzaGVzIHdpdGggb3RoZXIgQ01TIGVudHdpbmUgY2xhc3Nlc1xuXHRcdFx0dGhpcy5yZWRyYXdUYWJzKCk7XG5cblx0XHRcdGlmIChoYXNoICE9PSAnJykge1xuXHRcdFx0XHR0aGlzLm9wZW5UYWJGcm9tVVJMKGhhc2gpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRvbnJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLmRhdGEoJ3RhYnMnKSkgdGhpcy50YWJzKCdkZXN0cm95Jyk7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRyZWRyYXdUYWJzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmV3cml0ZUhhc2hsaW5rcygpO1xuXHRcdFx0dGhpcy50YWJzKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jIG9wZW5UYWJGcm9tVVJMXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcblx0XHQgKiBAZGVzYyBBbGxvd3MgbGlua2luZyB0byBhIHNwZWNpZmljIHRhYi5cblx0XHQgKi9cblx0XHRvcGVuVGFiRnJvbVVSTDogZnVuY3Rpb24gKGhhc2gpIHtcblx0XHRcdHZhciAkdHJpZ2dlcjtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBoYXNoIHJlbGF0ZXMgdG8gYSB2YWxpZCB0YWIuXG5cdFx0XHQkLmVhY2godGhpcy5maW5kKCcuY21zLXBhbmVsLWxpbmsnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBUaGUgaGFzaCBpbiBpbiB0aGUgYnV0dG9uJ3MgaHJlZiBhbmQgdGhlcmUgaXMgZXhhY3RseSBvbmUgdGFiIHdpdGggdGhhdCBpZC5cblx0XHRcdFx0aWYgKHRoaXMuaHJlZi5pbmRleE9mKGhhc2gpICE9PSAtMSAmJiAkKGhhc2gpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdCR0cmlnZ2VyID0gJCh0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGJyZWFrIHRoZSBsb29wXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG5vIHRhYiwgaXQgbWVhbnMgdGhlIGhhc2ggaXMgaW52YWxpZCwgc28gZG8gbm90aGluZy5cblx0XHRcdGlmICgkdHJpZ2dlciA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3dpdGNoIHRvIHRoZSBjb3JyZWN0IHRhYiB3aGVuIEFKQVggbG9hZGluZyBjb21wbGV0ZXMuXG5cdFx0XHQkKHdpbmRvdykub25lKCdhamF4Q29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCR0cmlnZ2VyLmNsaWNrKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmMgcmV3cml0ZUhhc2hsaW5rc1xuXHRcdCAqIEBkZXNjIEVuc3VyZSBoYXNoIGxpbmtzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBjdXJyZW50IHBhZ2UgVVJMLCBvdGhlcndpc2UgalF1ZXJ5IGludGVycHJldHMgdGhlbSBhcyBiZWluZyBleHRlcm5hbC5cblx0XHQgKi9cblx0XHRyZXdyaXRlSGFzaGxpbmtzOiBmdW5jdGlvbigpIHtcblx0XHRcdCQodGhpcykuZmluZCgndWwgYScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghJCh0aGlzKS5hdHRyKCdocmVmJykpIHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gJCh0aGlzKS5hdHRyKCdocmVmJykubWF0Y2goLyMuKi8pO1xuXHRcdFx0XHRpZighbWF0Y2hlcykgcmV0dXJuO1xuXHRcdFx0XHQkKHRoaXMpLmF0dHIoJ2hyZWYnLCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKi8sICcnKSArIG1hdGNoZXNbMF0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiaW1wb3J0ICQgZnJvbSAnLi9qUXVlcnknO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi9pMThuJztcblxuJC5lbnR3aW5lKCdzcycsIGZ1bmN0aW9uKCQpe1xuXHQvKipcblx0ICogT24gcmVzaXplIG9mIGFueSBjbG9zZSB0aGUgb3BlbiB0cmVlZHJvcGRvd25maWVsZHNcblx0ICogYXMgd2UnbGwgbmVlZCB0byByZWRvIHdpdGggd2lkdGhzXG5cdCAqL1xuXHR2YXIgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodDtcblx0JCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS50cmVlZHJvcGRvd25maWVsZCcsIGZ1bmN0aW9uKCkge1xuXHRcdC8vIEVudHdpbmUncyAnZnJvbVdpbmRvdzo6b25yZXNpemUnIGRvZXMgbm90IHRyaWdnZXIgb24gSUU4LiBVc2Ugc3ludGhldGljIGV2ZW50LlxuXHRcdHZhciBjYiA9IGZ1bmN0aW9uKCkgeyQoJy5UcmVlRHJvcGRvd25GaWVsZCcpLmNsb3NlUGFuZWwoKTt9O1xuXG5cdFx0Ly8gV29ya2Fyb3VuZCB0byBhdm9pZCBJRTggaW5maW5pdGUgbG9vcHMgd2hlbiBlbGVtZW50cyBhcmUgcmVzaXplZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGV2ZW50IFxuXHRcdGlmKCQuYnJvd3Nlci5tc2llICYmIHBhcnNlSW50KCQuYnJvd3Nlci52ZXJzaW9uLCAxMCkgPCA5KSB7XG5cdFx0XHR2YXIgbmV3V2luZG93V2lkdGggPSAkKHdpbmRvdykud2lkdGgoKSwgbmV3V2luZG93SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXHRcdFx0aWYobmV3V2luZG93V2lkdGggIT0gd2luZG93V2lkdGggfHwgbmV3V2luZG93SGVpZ2h0ICE9IHdpbmRvd0hlaWdodCkge1xuXHRcdFx0XHR3aW5kb3dXaWR0aCA9IG5ld1dpbmRvd1dpZHRoO1xuXHRcdFx0XHR3aW5kb3dIZWlnaHQgPSBuZXdXaW5kb3dIZWlnaHQ7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNiKCk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHZhciBzdHJpbmdzID0ge1xuXHRcdCdvcGVubGluayc6IGkxOG4uX3QoJ1RyZWVEcm9wZG93bkZpZWxkLk9wZW5MaW5rJyksXG5cdFx0J2ZpZWxkVGl0bGUnOiAnKCcgKyBpMThuLl90KCdUcmVlRHJvcGRvd25GaWVsZC5GaWVsZFRpdGxlJykgKyAnKScsXG5cdFx0J3NlYXJjaEZpZWxkVGl0bGUnOiAnKCcgKyBpMThuLl90KCdUcmVlRHJvcGRvd25GaWVsZC5TZWFyY2hGaWVsZFRpdGxlJykgKyAnKSdcblx0fTtcblxuXHR2YXIgX2NsaWNrVGVzdEZuID0gZnVuY3Rpb24oZSkge1xuXHRcdC8vIElmIHRoZSBjbGljayB0YXJnZXQgaXMgbm90IGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgZmllbGQsIGNsb3NlIHRoZSBwYW5lbCBhdXRvbWF0aWNhbGx5LlxuXHRcdGlmKCEkKGUudGFyZ2V0KS5wYXJlbnRzKCcuVHJlZURyb3Bkb3duRmllbGQnKS5sZW5ndGgpICQoJy5UcmVlRHJvcGRvd25GaWVsZCcpLmNsb3NlUGFuZWwoKTtcblx0fTtcblxuXHQvKipcblx0ICogQHRvZG8gRXJyb3IgZGlzcGxheVxuXHQgKiBAdG9kbyBObyByZXN1bHRzIGRpc3BsYXkgZm9yIHNlYXJjaFxuXHQgKiBAdG9kbyBBdXRvbWF0aWMgZXhwYW5zaW9uIG9mIGFqYXggY2hpbGRyZW4gd2hlbiBtdWx0aXNlbGVjdCBpcyB0cmlnZ2VyZWRcblx0ICogQHRvZG8gQXV0b21hdGljIHBhbmVsIHBvc2l0aW9uaW5nIGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZSAodG9wL2JvdHRvbSlcblx0ICogQHRvZG8gZm9yY2VWYWx1ZVxuXHQgKiBAdG9kbyBBdXRvbWF0aWMgd2lkdGhcblx0ICogQHRvZG8gRXhwYW5kIHRpdGxlIGhlaWdodCB0byBmaXQgYWxsIGVsZW1lbnRzXG5cdCAqL1xuXHQkKCcuVHJlZURyb3Bkb3duRmllbGQnKS5lbnR3aW5lKHtcblxuXHRcdC8vIFhNTEh0dHBSZXF1ZXN0XG5cdFx0Q3VycmVudFhocjogbnVsbCxcblxuXHRcdG9uYWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuYXBwZW5kKFxuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJ0cmVlZHJvcGRvd25maWVsZC10aXRsZVwiPjwvc3Bhbj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJ0cmVlZHJvcGRvd25maWVsZC10b2dnbGUtcGFuZWwtbGlua1wiPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tdHJpYW5nbGUtMS1zXCI+PC9hPjwvZGl2PicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cInRyZWVkcm9wZG93bmZpZWxkLXBhbmVsXCI+PGRpdiBjbGFzcz1cInRyZWUtaG9sZGVyXCI+PC9kaXY+PC9kaXY+J1xuXHRcdFx0KTtcblx0XHRcblx0XHRcdHZhciBsaW5rVGl0bGUgPSBzdHJpbmdzLm9wZW5MaW5rO1xuXHRcdFx0aWYobGlua1RpdGxlKSB0aGlzLmZpbmQoXCJ0cmVlZHJvcGRvd25maWVsZC10b2dnbGUtcGFuZWwtbGluayBhXCIpLmF0dHIoJ3RpdGxlJywgbGlua1RpdGxlKTtcblx0XHRcdGlmKHRoaXMuZGF0YSgndGl0bGUnKSkgdGhpcy5zZXRUaXRsZSh0aGlzLmRhdGEoJ3RpdGxlJykpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmdldFBhbmVsKCkuaGlkZSgpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdGdldFBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbmQoJy50cmVlZHJvcGRvd25maWVsZC1wYW5lbCcpO1xuXHRcdH0sXG5cdFx0b3BlblBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGNsb3NlIGFsbCBvdGhlciBwYW5lbHNcblx0XHRcdCQoJy5UcmVlRHJvcGRvd25GaWVsZCcpLmNsb3NlUGFuZWwoKTtcblxuXHRcdFx0Ly8gTGlzdGVuIGZvciBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgZmllbGQgdG8gYXV0by1jbG9zZSBpdFxuXHRcdFx0JCgnYm9keScpLmJpbmQoJ2NsaWNrJywgX2NsaWNrVGVzdEZuKTtcblx0XHRcdFxuXHRcdFx0dmFyIHBhbmVsID0gdGhpcy5nZXRQYW5lbCgpLCB0cmVlID0gdGhpcy5maW5kKCcudHJlZS1ob2xkZXInKTtcblxuXHRcdFx0cGFuZWwuY3NzKCd3aWR0aCcsIHRoaXMud2lkdGgoKSk7XG5cdFx0XHRcblx0XHRcdHBhbmVsLnNob3coKTtcblx0XHRcdFxuXHRcdFx0Ly8gc3dhcCB0aGUgZG93biBhcnJvdyB3aXRoIGFuIHVwIGFycm93XG5cdFx0XHR2YXIgdG9nZ2xlID0gdGhpcy5maW5kKFwiLnRyZWVkcm9wZG93bmZpZWxkLXRvZ2dsZS1wYW5lbC1saW5rXCIpO1xuXHRcdFx0dG9nZ2xlLmFkZENsYXNzKCd0cmVlZHJvcGRvd25maWVsZC1vcGVuLXRyZWUnKTtcblx0XHRcdHRoaXMuYWRkQ2xhc3MoXCJ0cmVlZHJvcGRvd25maWVsZC1vcGVuLXRyZWVcIik7XG5cdFx0XHRcblx0XHRcdHRvZ2dsZS5maW5kKFwiYVwiKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoJ3VpLWljb24tdHJpYW5nbGUtMS1zJylcblx0XHRcdFx0LmFkZENsYXNzKCd1aS1pY29uLXRyaWFuZ2xlLTEtbicpO1xuXHRcdFx0XG5cdFx0XHRpZih0cmVlLmlzKCc6ZW1wdHknKSAmJiAhcGFuZWwuaGFzQ2xhc3MoJ2xvYWRpbmcnKSkge1xuXHRcdFx0XHR0aGlzLmxvYWRUcmVlKG51bGwsIHRoaXMuX3Jpc2VVcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yaXNlVXAoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50cmlnZ2VyKCdwYW5lbHNob3cnKTtcblx0XHR9LFxuXHRcdF9yaXNlVXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMsXG5cdFx0XHRcdGRyb3Bkb3duID0gdGhpcy5nZXRQYW5lbCgpLFxuXHRcdFx0XHR0b2dnbGUgPSB0aGlzLmZpbmQoXCIudHJlZWRyb3Bkb3duZmllbGQtdG9nZ2xlLXBhbmVsLWxpbmtcIiksXG5cdFx0XHRcdG9mZnNldFRvcCA9IHRvZ2dsZS5pbm5lckhlaWdodCgpLFxuXHRcdFx0XHRlbEhlaWdodCxcblx0XHRcdFx0ZWxQb3MsXG5cdFx0XHRcdGVuZE9mV2luZG93O1xuXG5cdFx0XHRpZiAodG9nZ2xlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0ZW5kT2ZXaW5kb3cgPSAoJCh3aW5kb3cpLmhlaWdodCgpICsgJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIC0gdG9nZ2xlLmlubmVySGVpZ2h0KCk7XG5cdFx0XHRcdGVsUG9zID0gdG9nZ2xlLm9mZnNldCgpLnRvcDtcblx0XHRcdFx0ZWxIZWlnaHQgPSBkcm9wZG93bi5pbm5lckhlaWdodCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIGRyb3Bkb3duIGlzIHRvbyBjbG9zZSB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLCBwb3NpdGlvbiBpdCBhYm92ZSB0aGUgJ3RyaWdnZXInXG5cdFx0XHRcdGlmIChlbFBvcyArIGVsSGVpZ2h0ID4gZW5kT2ZXaW5kb3cgJiYgZWxQb3MgLSBlbEhlaWdodCA+IDApIHtcblx0XHRcdFx0XHRjb250YWluZXIuYWRkQ2xhc3MoJ3RyZWVkcm9wZG93bmZpZWxkLXdpdGgtcmlzZScpO1xuXHRcdFx0XHRcdG9mZnNldFRvcCA9IC1kcm9wZG93bi5vdXRlckhlaWdodCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDbGFzcygndHJlZWRyb3Bkb3duZmllbGQtd2l0aC1yaXNlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRyb3Bkb3duLmNzcyh7XCJ0b3BcIjogb2Zmc2V0VG9wICsgXCJweFwifSk7XG5cdFx0fSxcblx0XHRjbG9zZVBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSgnYm9keScpLnVuYmluZCgnY2xpY2snLCBfY2xpY2tUZXN0Rm4pO1xuXG5cdFx0XHQvLyBzd2FwIHRoZSB1cCBhcnJvdyB3aXRoIGEgZG93biBhcnJvd1xuXHRcdFx0dmFyIHRvZ2dsZSA9IHRoaXMuZmluZChcIi50cmVlZHJvcGRvd25maWVsZC10b2dnbGUtcGFuZWwtbGlua1wiKTtcblx0XHRcdHRvZ2dsZS5yZW1vdmVDbGFzcygndHJlZWRyb3Bkb3duZmllbGQtb3Blbi10cmVlJyk7XG5cdFx0XHR0aGlzLnJlbW92ZUNsYXNzKCd0cmVlZHJvcGRvd25maWVsZC1vcGVuLXRyZWUgdHJlZWRyb3Bkb3duZmllbGQtd2l0aC1yaXNlJyk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0dG9nZ2xlLmZpbmQoXCJhXCIpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygndWktaWNvbi10cmlhbmdsZS0xLW4nKVxuXHRcdFx0XHQuYWRkQ2xhc3MoJ3VpLWljb24tdHJpYW5nbGUtMS1zJyk7XG5cdFx0XHRcdFxuXG5cdFx0XHR0aGlzLmdldFBhbmVsKCkuaGlkZSgpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdwYW5lbGhpZGUnKTtcblx0XHR9LFxuXHRcdHRvZ2dsZVBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXNbdGhpcy5nZXRQYW5lbCgpLmlzKCc6dmlzaWJsZScpID8gJ2Nsb3NlUGFuZWwnIDogJ29wZW5QYW5lbCddKCk7XG5cdFx0fSxcblx0XHRzZXRUaXRsZTogZnVuY3Rpb24odGl0bGUpIHtcblx0XHRcdHRpdGxlID0gdGl0bGUgfHwgdGhpcy5kYXRhKCd0aXRsZScpIHx8IHN0cmluZ3MuZmllbGRUaXRsZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5maW5kKCcudHJlZWRyb3Bkb3duZmllbGQtdGl0bGUnKS5odG1sKHRpdGxlKTtcblx0XHRcdHRoaXMuZGF0YSgndGl0bGUnLCB0aXRsZSk7IC8vIHNlcGFyYXRlIHZpZXcgZnJvbSBzdG9yYWdlIChpbXBvcnRhbnQgZm9yIHNlYXJjaCBjYW5jZWxsYXRpb24pXG5cdFx0fSxcblx0XHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcudHJlZWRyb3Bkb3duZmllbGQtdGl0bGUnKS50ZXh0KCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGl0bGUgZnJvbSB0cmVlIG5vZGUgdmFsdWVcblx0XHQgKi9cblx0XHR1cGRhdGVUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHRyZWUgPSBzZWxmLmZpbmQoJy50cmVlLWhvbGRlcicpLCB2YWwgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHR2YXIgdXBkYXRlRm4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYodmFsKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZSA9IHRyZWUuZmluZCgnKltkYXRhLWlkPVwiJyArIHZhbCArICdcIl0nKSxcblx0XHRcdFx0XHRcdHRpdGxlID0gbm9kZS5jaGlsZHJlbignYScpLmZpbmQoXCJzcGFuLmpzdHJlZV9wYWdlaWNvblwiKT9ub2RlLmNoaWxkcmVuKCdhJykuZmluZChcInNwYW4uaXRlbVwiKS5odG1sKCk6bnVsbDtcblx0XHRcdFx0XHRpZighdGl0bGUpIHRpdGxlPShub2RlLmxlbmd0aCA+IDApID8gdHJlZS5qc3RyZWUoJ2dldF90ZXh0Jywgbm9kZVswXSkgOiBudWxsO1xuXG5cdFx0XHRcdFx0aWYodGl0bGUpIHtcblx0XHRcdFx0XHRcdHNlbGYuc2V0VGl0bGUodGl0bGUpO1xuXHRcdFx0XHRcdFx0c2VsZi5kYXRhKCd0aXRsZScsIHRpdGxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYobm9kZSkgdHJlZS5qc3RyZWUoJ3NlbGVjdF9ub2RlJywgbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5zZXRUaXRsZShzZWxmLmRhdGEoJ2VtcHR5LXRpdGxlJykpO1xuXHRcdFx0XHRcdHNlbGYucmVtb3ZlRGF0YSgndGl0bGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gTG9hZCB0aGUgdHJlZSBpZiBpdHMgbm90IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0aWYoIXRyZWUuaXMoJzplbXB0eScpIHx8ICF2YWwpIHVwZGF0ZUZuKCk7XG5cdFx0XHRlbHNlIHRoaXMubG9hZFRyZWUoe2ZvcmNlVmFsdWU6IHZhbH0sIHVwZGF0ZUZuKTtcblx0XHR9LFxuXHRcdHNldFZhbHVlOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHRoaXMuZGF0YSgnbWV0YWRhdGEnLCAkLmV4dGVuZCh0aGlzLmRhdGEoJ21ldGFkYXRhJyksIHtpZDogdmFsfSkpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXQ6aGlkZGVuJykudmFsKHZhbClcblx0XHRcdFx0Ly8gVHJpZ2dlciBzeW50aGV0aWMgZXZlbnQgc28gc3Vic2NyaWJlcnMgY2FuIHdvcmthcm91bmQgdGhlIElFOCBwcm9ibGVtIHdpdGggJ2NoYW5nZScgZXZlbnRzXG5cdFx0XHRcdC8vIG5vdCBwcm9wYWdhdGluZyBvbiBoaWRkZW4gaW5wdXRzLiAnY2hhbmdlJyBpcyBzdGlsbCB0cmlnZ2VyZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmxpdHkuXG5cdFx0XHRcdC50cmlnZ2VyKCd2YWx1ZXVwZGF0ZWQnKVxuXHRcdFx0XHQudHJpZ2dlcignY2hhbmdlJyk7XG5cdFx0fSxcblx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCc6aW5wdXQ6aGlkZGVuJykudmFsKCk7XG5cdFx0fSxcblx0XHRsb2FkVHJlZTogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBwYW5lbCA9IHRoaXMuZ2V0UGFuZWwoKSwgdHJlZUhvbGRlciA9ICQocGFuZWwpLmZpbmQoJy50cmVlLWhvbGRlcicpLFxuXHRcdFx0XHRwYXJhbXMgPSAocGFyYW1zKSA/ICQuZXh0ZW5kKHt9LCB0aGlzLmdldFJlcXVlc3RQYXJhbXMoKSwgcGFyYW1zKSA6IHRoaXMuZ2V0UmVxdWVzdFBhcmFtcygpLCB4aHI7XG5cblx0XHRcdGlmKHRoaXMuZ2V0Q3VycmVudFhocigpKSB0aGlzLmdldEN1cnJlbnRYaHIoKS5hYm9ydCgpO1xuXHRcdFx0cGFuZWwuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdHhociA9ICQuYWpheCh7XG5cdFx0XHRcdHVybDogdGhpcy5kYXRhKCd1cmxUcmVlJyksXG5cdFx0XHRcdGRhdGE6IHBhcmFtcyxcblx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKHhociwgc3RhdHVzKSB7XG5cdFx0XHRcdFx0cGFuZWwucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oaHRtbCwgc3RhdHVzLCB4aHIpIHtcblx0XHRcdFx0XHR0cmVlSG9sZGVyLmh0bWwoaHRtbCk7XG5cdFx0XHRcdFx0dmFyIGZpcnN0TG9hZCA9IHRydWU7XG5cdFx0XHRcdFx0dHJlZUhvbGRlclxuXHRcdFx0XHRcdFx0LmpzdHJlZSgnZGVzdHJveScpXG5cdFx0XHRcdFx0XHQuYmluZCgnbG9hZGVkLmpzdHJlZScsIGZ1bmN0aW9uKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKSwgc2VsZWN0Tm9kZSA9IHRyZWVIb2xkZXIuZmluZCgnKltkYXRhLWlkPVwiJyArIHZhbCArICdcIl0nKSwgXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBkYXRhLmluc3QuZ2V0X3NlbGVjdGVkKCk7XG5cdFx0XHRcdFx0XHRcdGlmKHZhbCAmJiBzZWxlY3ROb2RlICE9IGN1cnJlbnROb2RlKSBkYXRhLmluc3Quc2VsZWN0X25vZGUoc2VsZWN0Tm9kZSk7XG5cdFx0XHRcdFx0XHRcdGZpcnN0TG9hZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRpZihjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkoc2VsZik7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmpzdHJlZShzZWxmLmdldFRyZWVDb25maWcoKSlcblx0XHRcdFx0XHRcdC5iaW5kKCdzZWxlY3Rfbm9kZS5qc3RyZWUnLCBmdW5jdGlvbihlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBub2RlID0gZGF0YS5yc2x0Lm9iaiwgaWQgPSAkKG5vZGUpLmRhdGEoJ2lkJyk7XG5cdFx0XHRcdFx0XHRcdGlmKCFmaXJzdExvYWQgJiYgc2VsZi5nZXRWYWx1ZSgpID09IGlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVmFsdWUgaXMgYWxyZWFkeSBzZWxlY3RlZCwgdW5zZWxlY3QgaXQgKGZvciBsYWNrIG9mIGEgYmV0dGVyIFVJIHRvIGRvIHRoaXMpXG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5kYXRhKCdtZXRhZGF0YScsIG51bGwpO1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuc2V0VGl0bGUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5zZXRWYWx1ZShudWxsKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmluc3QuZGVzZWxlY3Rfbm9kZShub2RlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLmRhdGEoJ21ldGFkYXRhJywgJC5leHRlbmQoe2lkOiBpZH0sICQobm9kZSkuZ2V0TWV0YURhdGEoKSkpO1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuc2V0VGl0bGUoZGF0YS5pbnN0LmdldF90ZXh0KG5vZGUpKTtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnNldFZhbHVlKGlkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gQXZvaWQgYXV0by1jbG9zaW5nIHBhbmVsIG9uIGZpcnN0IGxvYWRcblx0XHRcdFx0XHRcdFx0aWYoIWZpcnN0TG9hZCkgc2VsZi5jbG9zZVBhbmVsKCk7XG5cdFx0XHRcdFx0XHRcdGZpcnN0TG9hZD1mYWxzZTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c2VsZi5zZXRDdXJyZW50WGhyKG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuc2V0Q3VycmVudFhocih4aHIpO1xuXHRcdH0sXG5cdFx0Z2V0VHJlZUNvbmZpZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnY29yZSc6IHtcblx0XHRcdFx0XHQnaHRtbF90aXRsZXMnOiB0cnVlLFxuXHRcdFx0XHRcdC8vICdpbml0aWFsbHlfb3Blbic6IFsncmVjb3JkLTAnXSxcblx0XHRcdFx0XHQnYW5pbWF0aW9uJzogMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaHRtbF9kYXRhJzoge1xuXHRcdFx0XHRcdC8vIFRPRE8gSGFjayB0byBhdm9pZCBhamF4IGxvYWQgb24gaW5pdCwgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qc3RyZWUvaXNzdWVzL2RldGFpbD9pZD05MTFcblx0XHRcdFx0XHQnZGF0YSc6IHRoaXMuZ2V0UGFuZWwoKS5maW5kKCcudHJlZS1ob2xkZXInKS5odG1sKCksXG5cdFx0XHRcdFx0J2FqYXgnOiB7XG5cdFx0XHRcdFx0XHQndXJsJzogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gJC5wYXRoLnBhcnNlVXJsKHNlbGYuZGF0YSgndXJsVHJlZScpKS5ocmVmTm9TZWFyY2g7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB1cmwgKyAnLycgKyAoJChub2RlKS5kYXRhKFwiaWRcIikgPyAkKG5vZGUpLmRhdGEoXCJpZFwiKSA6IDApO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdCdkYXRhJzogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcXVlcnkgPSAkLnF1ZXJ5LmxvYWQoc2VsZi5kYXRhKCd1cmxUcmVlJykpLmtleXM7XG5cdFx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSBzZWxmLmdldFJlcXVlc3RQYXJhbXMoKTtcblx0XHRcdFx0XHRcdFx0cGFyYW1zID0gJC5leHRlbmQoe30sIHF1ZXJ5LCBwYXJhbXMsIHthamF4OiAxfSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJhbXM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQndWknOiB7XG5cdFx0XHRcdFx0XCJzZWxlY3RfbGltaXRcIiA6IDEsXG5cdFx0XHRcdFx0J2luaXRpYWxseV9zZWxlY3QnOiBbdGhpcy5nZXRQYW5lbCgpLmZpbmQoJy5jdXJyZW50JykuYXR0cignaWQnKV1cblx0XHRcdFx0fSxcblx0XHRcdFx0J3RoZW1lcyc6IHtcblx0XHRcdFx0XHQndGhlbWUnOiAnYXBwbGUnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd0eXBlcycgOiB7XG5cdFx0XHRcdFx0J3R5cGVzJyA6IHtcblx0XHRcdFx0XHRcdCdkZWZhdWx0Jzoge1xuXHRcdFx0XHRcdFx0XHQnY2hlY2tfbm9kZSc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKCAhIG5vZGUuaGFzQ2xhc3MoJ2Rpc2FibGVkJykpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQndW5jaGVja19ub2RlJzogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAoICEgbm9kZS5oYXNDbGFzcygnZGlzYWJsZWQnKSk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdCdzZWxlY3Rfbm9kZSc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKCAhIG5vZGUuaGFzQ2xhc3MoJ2Rpc2FibGVkJykpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQnZGVzZWxlY3Rfbm9kZSc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKCAhIG5vZGUuaGFzQ2xhc3MoJ2Rpc2FibGVkJykpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncGx1Z2lucyc6IFsnaHRtbF9kYXRhJywgJ3VpJywgJ3RoZW1lcycsICd0eXBlcyddXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhlIGZpZWxkIGlzIGNvbnRhaW5lZCBpbiBhIGZvcm0sIHN1Ym1pdCBhbGwgZm9ybSBwYXJhbWV0ZXJzIGJ5IGRlZmF1bHQuXG5cdFx0ICogVGhpcyBpcyB1c2VmdWwgdG8ga2VlcCBzdGF0ZSBsaWtlIGxvY2FsZSB2YWx1ZXMgd2hpY2ggYXJlIHR5cGljYWxseVxuXHRcdCAqIGVuY29kZWQgaW4gaGlkZGVuIGZpZWxkcyB0aHJvdWdoIHRoZSBmb3JtLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRSZXF1ZXN0UGFyYW1zOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkIC50cmVlLWhvbGRlciBsaScpLmVudHdpbmUoe1xuXHRcdC8qKlxuXHRcdCAqIE92ZXJsb2FkIHRvIHJldHVybiBtb3JlIGRhdGEuIFRoZSBzYW1lIGRhdGEgc2hvdWxkIGJlIHNldCBvbiBpbml0aWFsXG5cdFx0ICogdmFsdWUgdGhyb3VnaCBQSFAgYXMgd2VsbCAoc2VlIFRyZWVEcm9wZG93bkZpZWxkLT5GaWVsZCgpKS5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0TWV0YURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSB0aGlzLmF0dHIoJ2NsYXNzJykubWF0Y2goL2NsYXNzLShbXlxcc10qKS9pKTtcblx0XHRcdHZhciBrbGFzcyA9IG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogJyc7XG5cdFx0XHRyZXR1cm4ge0NsYXNzTmFtZToga2xhc3N9O1xuXHRcdH1cblx0fSk7XG5cdFxuXHQkKCcuVHJlZURyb3Bkb3duRmllbGQgKicpLmVudHdpbmUoe1xuXHRcdGdldEZpZWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudHMoJy5UcmVlRHJvcGRvd25GaWVsZDpmaXJzdCcpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQkKCcuVHJlZURyb3Bkb3duRmllbGQnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZVBhbmVsKCk7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkIC50cmVlZHJvcGRvd25maWVsZC1wYW5lbCcpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkLnNlYXJjaGFibGUnKS5lbnR3aW5lKHtcblx0XHRvbmFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0dmFyIHRpdGxlID0gaTE4bi5fdCgnVHJlZURyb3Bkb3duRmllbGQuRU5URVJUT1NFQVJDSCcpO1xuXHRcdFx0dGhpcy5maW5kKCcudHJlZWRyb3Bkb3duZmllbGQtcGFuZWwnKS5wcmVwZW5kKFxuXHRcdFx0XHQkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInNlYXJjaCB0cmVlZHJvcGRvd25maWVsZC1zZWFyY2hcIiBkYXRhLXNraXAtYXV0b2ZvY3VzPVwidHJ1ZVwiIHBsYWNlaG9sZGVyPVwiJyArIHRpdGxlICsgJ1wiIHZhbHVlPVwiXCIgLz4nKVxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdHNlYXJjaDogZnVuY3Rpb24oc3RyLCBjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vcGVuUGFuZWwoKTtcblx0XHRcdHRoaXMubG9hZFRyZWUoe3NlYXJjaDogc3RyfSwgY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0Y2FuY2VsU2VhcmNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY2xvc2VQYW5lbCgpO1xuXHRcdFx0dGhpcy5sb2FkVHJlZSgpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQkKCcuVHJlZURyb3Bkb3duRmllbGQuc2VhcmNoYWJsZSBpbnB1dC5zZWFyY2gnKS5lbnR3aW5lKHtcblx0XHRvbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBmaWVsZCA9IHRoaXMuZ2V0RmllbGQoKTtcblx0XHRcdGlmKGUua2V5Q29kZSA9PSAxMykge1xuXHRcdFx0XHQvLyB0cmlnZ2VyIHNlYXJjaCBvbiBFTlRFUiBrZXlcblx0XHRcdFx0ZmllbGQuc2VhcmNoKHRoaXMudmFsKCkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYoZS5rZXlDb2RlID09IDI3KSB7XG5cdFx0XHRcdC8vIGNhbmNlbCBzZWFyY2ggb24gRVNDIGtleVxuXHRcdFx0XHRmaWVsZC5jYW5jZWxTZWFyY2goKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkLm11bHRpcGxlJykuZW50d2luZSh7XG5cdFx0Z2V0VHJlZUNvbmZpZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2ZnID0gdGhpcy5fc3VwZXIoKTtcblx0XHRcdGNmZy5jaGVja2JveCA9IHtvdmVycmlkZV91aTogdHJ1ZSwgdHdvX3N0YXRlOiB0cnVlfTtcblx0XHRcdGNmZy5wbHVnaW5zLnB1c2goJ2NoZWNrYm94Jyk7XG5cdFx0XHRjZmcudWkuc2VsZWN0X2xpbWl0ID0gLTE7XG5cdFx0XHRyZXR1cm4gY2ZnO1xuXHRcdH0sXG5cdFx0bG9hZFRyZWU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgcGFuZWwgPSB0aGlzLmdldFBhbmVsKCksIHRyZWVIb2xkZXIgPSAkKHBhbmVsKS5maW5kKCcudHJlZS1ob2xkZXInKTtcblx0XHRcdHZhciBwYXJhbXMgPSAocGFyYW1zKSA/ICQuZXh0ZW5kKHt9LCB0aGlzLmdldFJlcXVlc3RQYXJhbXMoKSwgcGFyYW1zKSA6IHRoaXMuZ2V0UmVxdWVzdFBhcmFtcygpLCB4aHI7XG5cblx0XHRcdGlmKHRoaXMuZ2V0Q3VycmVudFhocigpKSB0aGlzLmdldEN1cnJlbnRYaHIoKS5hYm9ydCgpO1xuXHRcdFx0cGFuZWwuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdHhociA9ICQuYWpheCh7XG5cdFx0XHRcdHVybDogdGhpcy5kYXRhKCd1cmxUcmVlJyksXG5cdFx0XHRcdGRhdGE6IHBhcmFtcyxcblx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKHhociwgc3RhdHVzKSB7XG5cdFx0XHRcdFx0cGFuZWwucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oaHRtbCwgc3RhdHVzLCB4aHIpIHtcblx0XHRcdFx0XHR0cmVlSG9sZGVyLmh0bWwoaHRtbCk7XG5cdFx0XHRcdFx0dmFyIGZpcnN0TG9hZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5zZXRDdXJyZW50WGhyKG51bGwpO1xuXHRcdFx0XHRcdHRyZWVIb2xkZXJcblx0XHRcdFx0XHRcdC5qc3RyZWUoJ2Rlc3Ryb3knKVxuXHRcdFx0XHRcdFx0LmJpbmQoJ2xvYWRlZC5qc3RyZWUnLCBmdW5jdGlvbihlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdCQuZWFjaChzZWxmLmdldFZhbHVlKCksIGZ1bmN0aW9uKGksIHZhbCkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEuaW5zdC5jaGVja19ub2RlKHRyZWVIb2xkZXIuZmluZCgnKltkYXRhLWlkPScgKyB2YWwgKyAnXScpKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGZpcnN0TG9hZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRpZihjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkoc2VsZik7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmpzdHJlZShzZWxmLmdldFRyZWVDb25maWcoKSlcblx0XHRcdFx0XHRcdC5iaW5kKCd1bmNoZWNrX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlJywgZnVuY3Rpb24oZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZXMgPSBkYXRhLmluc3QuZ2V0X2NoZWNrZWQobnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHNlbGYuc2V0VmFsdWUoJC5tYXAobm9kZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICQoZWwpLmRhdGEoJ2lkJyk7XG5cdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0c2VsZi5zZXRUaXRsZSgkLm1hcChub2RlcywgZnVuY3Rpb24oZWwsIGkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5pbnN0LmdldF90ZXh0KGVsKTtcblx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHRzZWxmLmRhdGEoJ21ldGFkYXRhJywgJC5tYXAobm9kZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtpZDogJChlbCkuZGF0YSgnaWQnKSwgbWV0YWRhdGE6ICQoZWwpLmdldE1ldGFEYXRhKCl9O1xuXHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnNldEN1cnJlbnRYaHIoeGhyKTtcblx0XHR9LFxuXHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2YWwgPSB0aGlzLl9zdXBlcigpO1xuXHRcdFx0cmV0dXJuIHZhbC5zcGxpdCgvICosICovKTtcblx0XHR9LFxuXHRcdHNldFZhbHVlOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCQuaXNBcnJheSh2YWwpID8gdmFsLmpvaW4oJywnKSA6IHZhbCk7XG5cdFx0fSxcblx0XHRzZXRUaXRsZTogZnVuY3Rpb24odGl0bGUpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCQuaXNBcnJheSh0aXRsZSkgPyB0aXRsZS5qb2luKCcsICcpIDogdGl0bGUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlVGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gVE9ETyBOb3Qgc3VwcG9ydGVkIGR1ZSB0byBtdWx0aXBsZSB2YWx1ZXMvdGl0bGVzIHlldFxuXHRcdH1cblx0fSk7XG5cblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkIGlucHV0W3R5cGU9aGlkZGVuXScpLmVudHdpbmUoe1xuXHRcdG9uYWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHR0aGlzLmJpbmQoJ2NoYW5nZS5UcmVlRHJvcGRvd25GaWVsZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKHRoaXMpLmdldEZpZWxkKCkudXBkYXRlVGl0bGUoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b25yZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMudW5iaW5kKCcuVHJlZURyb3Bkb3duRmllbGQnKTtcblx0XHR9XG5cdH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMDksIFNpbHZlclN0cmlwZSBMdGQuXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuLy8gICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgPG9yZ2FuaXphdGlvbj4gbm9yIHRoZVxuLy8gICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFNpbHZlclN0cmlwZSBMdGQuICcnQVMgSVMnJyBBTkQgQU5ZXG4vLyBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4vLyBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4vLyBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBTaWx2ZXJTdHJpcGUgTHRkLiBCRSBMSUFCTEUgRk9SIEFOWVxuLy8gRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbi8vIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbi8vIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuLy8gT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4vLyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuLyoqXG4gKiBAY2xhc3MgVHJhY2tzIG9uY2hhbmdlIGV2ZW50cyBvbiBhbGwgZm9ybSBmaWVsZHMuXG4gKiBcbiAqIEB0b2RvIEltcGxlbWVudCBmb3JtIHJlc2V0IGhhbmRsaW5nXG4gKiAgXG4gKiBAbmFtZSBqUXVlcnkuY2hhbmdldHJhY2tlclxuICogQGF1dGhvciBJbmdvIFNjaG9tbWVyLCBTaWx2ZXJTdHJpcGUgTHRkLlxuICogQGxpY2Vuc2UgQlNEIExpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uKCQpIHtcblx0JC5mbi5jaGFuZ2V0cmFja2VyID0gZnVuY3Rpb24oX29wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZih0aGlzLmxlbmd0aCA+IDEpe1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKGksIGl0ZW0pIHtcblx0XHRcdFx0dGhpcy5jaGFuZ2V0cmFja2VyKF9vcHRpb25zKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZWZhdWx0cyA9IHtcblx0XHRcdGZpZWxkU2VsZWN0b3I6ICc6aW5wdXQ6bm90KDpzdWJtaXQpJyxcblx0XHRcdGlnbm9yZUZpZWxkU2VsZWN0b3I6IFwiXCIsXG5cdFx0XHRjaGFuZ2VkQ3NzQ2xhc3M6ICdjaGFuZ2VkJ1xuXHRcdH07XG5cblx0XHR2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRzLCBfb3B0aW9ucyk7XG5cblx0XHR0aGlzLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0XHRcdC8vIG9wdGlvbmFsIG1ldGFkYXRhIHBsdWdpbiBzdXBwb3J0XG5cdFx0XHRpZiAoJC5tZXRhKSBvcHRpb25zID0gJC5leHRlbmQoe30sIG9wdGlvbnMsIHRoaXMuZGF0YSgpKTtcblxuXHRcdFx0Ly8gRmxhZyBpbmRpY2F0aW5nIHRoaXMgZm9ybSB3YXMgZGlydGllZCBieSBhbiBleHRlcm5hbCBjb21wb25lbnRcblx0XHRcdHZhciBkaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgb25jaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHZhciAkZmllbGQgPSAkKGUudGFyZ2V0KTtcblx0XHRcdFx0dmFyIG9yaWdWYWwgPSAkZmllbGQuZGF0YSgnY2hhbmdldHJhY2tlci5vcmlnVmFsJyksIG5ld1ZhbDtcblxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgdmFsdWUgYmFzZWQgb24gZmllbGQgdHlwZVxuXHRcdFx0XHRpZigkZmllbGQuaXMoJzpjaGVja2JveCcpKSB7XG5cdFx0XHRcdFx0bmV3VmFsID0gJGZpZWxkLmlzKCc6Y2hlY2tlZCcpID8gMSA6IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3VmFsID0gJGZpZWxkLnZhbCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGNoYW5nZWQgc3RhdGUgYmFzZWQgb24gdmFsdWUgY29tcGFyaXNvbnNcblx0XHRcdFx0aWYob3JpZ1ZhbCA9PT0gbnVsbCB8fCBuZXdWYWwgIT0gb3JpZ1ZhbCkge1xuXHRcdFx0XHRcdCRmaWVsZC5hZGRDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGZpZWxkLnJlbW92ZUNsYXNzKG9wdGlvbnMuY2hhbmdlZENzc0NsYXNzKTtcblx0XHRcdFx0XHQvLyBVbnNldCBjaGFuZ2VkIHN0YXRlIG9uIGFsbCByYWRpbyBidXR0b25zIG9mIHRoZSBzYW1lIG5hbWVcblx0XHRcdFx0XHRpZigkZmllbGQuaXMoJzpyYWRpbycpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmZpbmQoJzpyYWRpb1tuYW1lPScgKyAkZmllbGQuYXR0cignbmFtZScpICsgJ10nKS5yZW1vdmVDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIE9ubHkgdW5zZXQgZm9ybSBzdGF0ZSBpZiBubyBvdGhlciBmaWVsZHMgYXJlIGNoYW5nZWQgYXMgd2VsbCBhbmQgdGhlIGZvcm0gaXNuJ3QgZXhwbGljaXRseSBkaXJ0eVxuXHRcdFx0XHRcdGlmKCFkaXJ0eSAmJiAhc2VsZi5nZXRGaWVsZHMoKS5maWx0ZXIoJy4nICsgb3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXR1cCBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpLCBvcmlnVmFsO1xuXHRcdFx0ZmllbGRzLmZpbHRlcignOnJhZGlvLDpjaGVja2JveCcpLmJpbmQoJ2NsaWNrLmNoYW5nZXRyYWNrZXInLCBvbmNoYW5nZSk7XG5cdFx0XHRmaWVsZHMubm90KCc6cmFkaW8sOmNoZWNrYm94JykuYmluZCgnY2hhbmdlLmNoYW5nZXRyYWNrZXInLCBvbmNoYW5nZSk7XG5cdFx0XHRmaWVsZHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoJCh0aGlzKS5pcygnOnJhZGlvLDpjaGVja2JveCcpKSB7XG5cdFx0XHRcdFx0b3JpZ1ZhbCA9IHNlbGYuZmluZCgnOmlucHV0W25hbWU9JyArICQodGhpcykuYXR0cignbmFtZScpICsgJ106Y2hlY2tlZCcpLnZhbCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9yaWdWYWwgPSAkKHRoaXMpLnZhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQodGhpcykuZGF0YSgnY2hhbmdldHJhY2tlci5vcmlnVmFsJywgb3JpZ1ZhbCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0c2VsZi5iaW5kKCdkaXJ0eS5jaGFuZ2V0cmFja2VyJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5hZGRDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5kYXRhKCdjaGFuZ2V0cmFja2VyJywgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRGaWVsZHMoKVxuXHRcdFx0XHQudW5iaW5kKCcuY2hhbmdldHJhY2tlcicpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcylcblx0XHRcdFx0LnJlbW92ZURhdGEoJ2NoYW5nZXRyYWNrZXIub3JpZ1ZhbCcpO1xuXHRcdFx0dGhpcy51bmJpbmQoJy5jaGFuZ2V0cmFja2VyJylcblx0XHRcdFx0LnJlbW92ZURhdGEoJ2NoYW5nZXRyYWNrZXInKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVzZXQgY2hhbmdlIHN0YXRlIG9mIGFsbCBmb3JtIGZpZWxkcyBhbmQgdGhlIGZvcm0gaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0RmllbGRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZXNldEZpZWxkKHRoaXMpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXNldCB0aGUgY2hhbmdlIHNpbmdsZSBmb3JtIGZpZWxkLlxuXHRcdCAqIERvZXMgbm90IHJlc2V0IHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBET01FbGVtZW50IGZpZWxkXG5cdFx0ICovXG5cdFx0dGhpcy5yZXNldEZpZWxkID0gZnVuY3Rpb24oZmllbGQpIHtcblx0XHRcdHJldHVybiAkKGZpZWxkKS5yZW1vdmVEYXRhKCdjaGFuZ2V0cmFja2VyLm9yaWdWYWwnKS5yZW1vdmVDbGFzcygnY2hhbmdlZCcpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAcmV0dXJuIGpRdWVyeSBDb2xsZWN0aW9uIG9mIGZpZWxkc1xuXHRcdCAqL1xuXHRcdHRoaXMuZ2V0RmllbGRzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKG9wdGlvbnMuZmllbGRTZWxlY3Rvcikubm90KG9wdGlvbnMuaWdub3JlRmllbGRTZWxlY3Rvcik7XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQgaW52b2tpbmcgXCJwdWJsaWNcIiBtZXRob2RzIGFzIHN0cmluZyBhcmd1bWVudHNcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGFyZ3Muc3BsaWNlKDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXNbYXJndW1lbnRzWzBdXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHRcdH1cblxuXHR9O1xufShqUXVlcnkpKTtcbiIsIi8qKlxuICogQ29va2llIHBsdWdpblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiBLbGF1cyBIYXJ0bCAoc3RpbGJ1ZXJvLmRlKVxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGFuZCBvdGhlciBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBleGFtcGxlICQuY29va2llKCd0aGVfY29va2llJywgJ3RoZV92YWx1ZScpO1xuICogQGRlc2MgU2V0IHRoZSB2YWx1ZSBvZiBhIGNvb2tpZS5cbiAqIEBleGFtcGxlICQuY29va2llKCd0aGVfY29va2llJywgJ3RoZV92YWx1ZScsIHsgZXhwaXJlczogNywgcGF0aDogJy8nLCBkb21haW46ICdqcXVlcnkuY29tJywgc2VjdXJlOiB0cnVlIH0pO1xuICogQGRlc2MgQ3JlYXRlIGEgY29va2llIHdpdGggYWxsIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGV4YW1wbGUgJC5jb29raWUoJ3RoZV9jb29raWUnLCAndGhlX3ZhbHVlJyk7XG4gKiBAZGVzYyBDcmVhdGUgYSBzZXNzaW9uIGNvb2tpZS5cbiAqIEBleGFtcGxlICQuY29va2llKCd0aGVfY29va2llJywgbnVsbCk7XG4gKiBAZGVzYyBEZWxldGUgYSBjb29raWUgYnkgcGFzc2luZyBudWxsIGFzIHZhbHVlLiBLZWVwIGluIG1pbmQgdGhhdCB5b3UgaGF2ZSB0byB1c2UgdGhlIHNhbWUgcGF0aCBhbmQgZG9tYWluXG4gKiAgICAgICB1c2VkIHdoZW4gdGhlIGNvb2tpZSB3YXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29va2llLlxuICogQHBhcmFtIFN0cmluZyB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNvb2tpZS5cbiAqIEBwYXJhbSBPYmplY3Qgb3B0aW9ucyBBbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycyB0byBwcm92aWRlIG9wdGlvbmFsIGNvb2tpZSBhdHRyaWJ1dGVzLlxuICogQG9wdGlvbiBOdW1iZXJ8RGF0ZSBleHBpcmVzIEVpdGhlciBhbiBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIGV4cGlyYXRpb24gZGF0ZSBmcm9tIG5vdyBvbiBpbiBkYXlzIG9yIGEgRGF0ZSBvYmplY3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSBuZWdhdGl2ZSB2YWx1ZSBpcyBzcGVjaWZpZWQgKGUuZy4gYSBkYXRlIGluIHRoZSBwYXN0KSwgdGhlIGNvb2tpZSB3aWxsIGJlIGRlbGV0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgc2V0IHRvIG51bGwgb3Igb21pdHRlZCwgdGhlIGNvb2tpZSB3aWxsIGJlIGEgc2Vzc2lvbiBjb29raWUgYW5kIHdpbGwgbm90IGJlIHJldGFpbmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdGhlIGJyb3dzZXIgZXhpdHMuXG4gKiBAb3B0aW9uIFN0cmluZyBwYXRoIFRoZSB2YWx1ZSBvZiB0aGUgcGF0aCBhdHJpYnV0ZSBvZiB0aGUgY29va2llIChkZWZhdWx0OiBwYXRoIG9mIHBhZ2UgdGhhdCBjcmVhdGVkIHRoZSBjb29raWUpLlxuICogQG9wdGlvbiBTdHJpbmcgZG9tYWluIFRoZSB2YWx1ZSBvZiB0aGUgZG9tYWluIGF0dHJpYnV0ZSBvZiB0aGUgY29va2llIChkZWZhdWx0OiBkb21haW4gb2YgcGFnZSB0aGF0IGNyZWF0ZWQgdGhlIGNvb2tpZSkuXG4gKiBAb3B0aW9uIEJvb2xlYW4gc2VjdXJlIElmIHRydWUsIHRoZSBzZWN1cmUgYXR0cmlidXRlIG9mIHRoZSBjb29raWUgd2lsbCBiZSBzZXQgYW5kIHRoZSBjb29raWUgdHJhbnNtaXNzaW9uIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSBhIHNlY3VyZSBwcm90b2NvbCAobGlrZSBIVFRQUykuXG4gKiBAdHlwZSB1bmRlZmluZWRcbiAqXG4gKiBAbmFtZSAkLmNvb2tpZVxuICogQGNhdCBQbHVnaW5zL0Nvb2tpZVxuICogQGF1dGhvciBLbGF1cyBIYXJ0bC9rbGF1cy5oYXJ0bEBzdGlsYnVlcm8uZGVcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYSBjb29raWUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScpO1xuICogQGRlc2MgR2V0IHRoZSB2YWx1ZSBvZiBhIGNvb2tpZS5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZS5cbiAqIEByZXR1cm4gVGhlIHZhbHVlIG9mIHRoZSBjb29raWUuXG4gKiBAdHlwZSBTdHJpbmdcbiAqXG4gKiBAbmFtZSAkLmNvb2tpZVxuICogQGNhdCBQbHVnaW5zL0Nvb2tpZVxuICogQGF1dGhvciBLbGF1cyBIYXJ0bC9rbGF1cy5oYXJ0bEBzdGlsYnVlcm8uZGVcbiAqL1xualF1ZXJ5LmNvb2tpZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJykgeyAvLyBuYW1lIGFuZCB2YWx1ZSBnaXZlbiwgc2V0IGNvb2tpZVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGpRdWVyeS5leHRlbmQoe30sIG9wdGlvbnMpOyAvLyBjbG9uZSBvYmplY3Qgc2luY2UgaXQncyB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIHRoZSBleHBpcmVkIHByb3BlcnR5IHdlcmUgY2hhbmdlZFxuICAgICAgICAgICAgb3B0aW9ucy5leHBpcmVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGlyZXMgPSAnJztcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwaXJlcyAmJiAodHlwZW9mIG9wdGlvbnMuZXhwaXJlcyA9PSAnbnVtYmVyJyB8fCBvcHRpb25zLmV4cGlyZXMudG9VVENTdHJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBpcmVzID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKG9wdGlvbnMuZXhwaXJlcyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG9wdGlvbnMuZXhwaXJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIHVzZSBleHBpcmVzIGF0dHJpYnV0ZSwgbWF4LWFnZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFXG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URSBOZWVkZWQgdG8gcGFyZW50aGVzaXplIG9wdGlvbnMucGF0aCBhbmQgb3B0aW9ucy5kb21haW5cbiAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBleHByZXNzaW9ucywgb3RoZXJ3aXNlIHRoZXkgZXZhbHVhdGUgdG8gdW5kZWZpbmVkXG4gICAgICAgIC8vIGluIHRoZSBwYWNrZWQgdmVyc2lvbiBmb3Igc29tZSByZWFzb24uLi5cbiAgICAgICAgdmFyIHBhdGggPSBvcHRpb25zLnBhdGggPyAnOyBwYXRoPScgKyAob3B0aW9ucy5wYXRoKSA6ICcnO1xuICAgICAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW4gPyAnOyBkb21haW49JyArIChvcHRpb25zLmRvbWFpbikgOiAnJztcbiAgICAgICAgdmFyIHNlY3VyZSA9IG9wdGlvbnMuc2VjdXJlID8gJzsgc2VjdXJlJyA6ICcnO1xuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBbbmFtZSwgJz0nLCBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZV0uam9pbignJyk7XG4gICAgfSBlbHNlIHsgLy8gb25seSBuYW1lIGdpdmVuLCBnZXQgY29va2llXG4gICAgICAgIHZhciBjb29raWVWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChkb2N1bWVudC5jb29raWUgJiYgZG9jdW1lbnQuY29va2llICE9ICcnKSB7XG4gICAgICAgICAgICB2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IGpRdWVyeS50cmltKGNvb2tpZXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIERvZXMgdGhpcyBjb29raWUgc3RyaW5nIGJlZ2luIHdpdGggdGhlIG5hbWUgd2Ugd2FudD9cbiAgICAgICAgICAgICAgICBpZiAoY29va2llLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCArIDEpID09IChuYW1lICsgJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tpZVZhbHVlO1xuICAgIH1cbn07IiwiLyogalF1ZXJ5LkVudHdpbmUgLSBDb3B5cmlnaHQgMjAwOS0yMDExIEhhbWlzaCBGcmllZGxhbmRlciBhbmQgU2lsdmVyU3RyaXBlLiBWZXJzaW9uIC4gKi9cblxuLyogdmVuZG9yL2pxdWVyeS5zZWxlY3Rvci9qcXVlcnkuY2xhc3MuanMgKi9cblxuLyoqXG4gKiBWZXJ5IGJhc2ljIENsYXNzIHV0aWxpdHkuIEJhc2VkIG9uIGJhc2UgYW5kIGpxdWVyeS5jbGFzcy5cbiAqIFxuICogQ2xhc3MgZGVmaW5pdGlvbjogdmFyIEZvbyA9IEJhc2UuZXh0ZW5kKHsgaW5pdDogZnVuY3Rpb24oKXsgQ29uc3RydWN0b3IgfTsgbWV0aG9kX25hbWU6IGZ1bmN0aW9uKCl7IE1ldGhvZCB9IH0pO1xuICpcbiAqIEluaGVyaXRhbmNlOiB2YXIgQmFyID0gRm9vLmV4dGVuZCh7IG1ldGhvZF9uYW1lOiBmdW5jdGlvbigpeyB0aGlzLl9zdXBlcigpOyB9IH0pO1xuICogXG4gKiBuZXctbGVzcyBDb25zdHJ1Y3RvcjogbmV3IEZvbyhhcmcpIDwtc2FtZSBhcy0+IEZvbyhhcmcpXG4gKi8gIFx0XG5cbnZhciBCYXNlO1xuXG4oZnVuY3Rpb24oKXtcblx0XG5cdHZhciBtYXJrZXIgPSB7fSwgZm5UZXN0ID0gL3h5ei8udGVzdChmdW5jdGlvbigpe3ZhciB4eXo7fSkgPyAvXFxiX3N1cGVyXFxiLyA6IC8uKi87XG5cblx0Ly8gVGhlIGJhc2UgQ2xhc3MgaW1wbGVtZW50YXRpb24gKGRvZXMgbm90aGluZylcblx0QmFzZSA9IGZ1bmN0aW9uKCl7fTtcbiBcblx0QmFzZS5hZGRNZXRob2QgPSBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3N1cGVyICYmIHRoaXMuX3N1cGVyLnByb3RvdHlwZTtcblx0XHRcblx0XHRpZiAocGFyZW50ICYmIGZuVGVzdC50ZXN0KGZ1bmMpKSB7XG5cdFx0XHR0aGlzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB0bXAgPSB0aGlzLl9zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBwYXJlbnRbbmFtZV07XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB0aGlzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG5cdH07XG5cblx0QmFzZS5hZGRNZXRob2RzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG5cdFx0XHRpZiAodHlwZW9mIHByb3BzW25hbWVdID09ICdmdW5jdGlvbicpIHRoaXMuYWRkTWV0aG9kKG5hbWUsIHByb3BzW25hbWVdKTtcblx0XHRcdGVsc2UgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHR9XG5cdH07XG5cblx0QmFzZS5zdWJjbGFzc09mID0gZnVuY3Rpb24ocGFyZW50a2xzKSB7XG5cdFx0dmFyIGtscyA9IHRoaXM7XG5cdFx0d2hpbGUgKGtscykge1xuXHRcdFx0aWYgKGtscyA9PT0gcGFyZW50a2xzKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGtscyA9IGtscy5fc3VwZXI7XG5cdFx0fVxuXHR9O1xuIFxuXHQvLyBDcmVhdGUgYSBuZXcgQ2xhc3MgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgY2xhc3Ncblx0QmFzZS5leHRlbmQgPSBmdW5jdGlvbihwcm9wcykge1xuICBcdFxuXHRcdC8vIFRoZSBkdW1teSBjbGFzcyBjb25zdHJ1Y3RvclxuXHRcdHZhciBLbHMgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhcmd1bWVudHNbMF0gPT09IG1hcmtlcikgcmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIEtscykge1xuXHRcdFx0XHRpZiAodGhpcy5pbml0KSB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgcmV0ID0gbmV3IEtscyhtYXJrZXIpOyBpZiAocmV0LmluaXQpIHJldC5pbml0LmFwcGx5KHJldCwgYXJndW1lbnRzKTsgcmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9O1xuICAgXG5cdFx0Ly8gQWRkIHRoZSBjb21tb24gY2xhc3MgdmFyaWFibGVzIGFuZCBtZXRob2RzXG5cdFx0S2xzLmNvbnN0cnVjdG9yID0gS2xzO1xuXHRcdEtscy5leHRlbmQgPSBCYXNlLmV4dGVuZDtcblx0XHRLbHMuYWRkTWV0aG9kID0gQmFzZS5hZGRNZXRob2Q7XG5cdFx0S2xzLmFkZE1ldGhvZHMgPSBCYXNlLmFkZE1ldGhvZHM7XG5cdFx0S2xzLnN1YmNsYXNzT2YgPSBCYXNlLnN1YmNsYXNzT2Y7XG5cdFx0XG5cdFx0S2xzLl9zdXBlciA9IHRoaXM7XG5cdFxuXHRcdC8vIEF0dGFjaCB0aGUgcGFyZW50IG9iamVjdCB0byB0aGUgaW5oZXJpdGFuY2UgY2hhaW5cblx0XHRLbHMucHJvdG90eXBlID0gbmV3IHRoaXMobWFya2VyKTtcblx0XHRLbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2xzO1xuXG5cdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvdmVyIG9udG8gdGhlIG5ldyBwcm90b3R5cGVcblx0XHRLbHMuYWRkTWV0aG9kcyhwcm9wcyk7XG5cdFx0XG5cdFx0cmV0dXJuIEtscztcblx0fTsgXG59KSgpOztcblxuXG4vKiB2ZW5kb3IvanF1ZXJ5LnNlbGVjdG9yL2pxdWVyeS5zZWxlY3Rvci5qcyAqL1xuXG4oZnVuY3Rpb24oJCl7XG5cblx0dmFyIHRva2VucyA9IHtcblx0XHRVTklDT0RFOiAvXFxcXFswLTlhLWZdezEsNn0oPzpcXHJcXG58WyBcXG5cXHJcXHRcXGZdKT8vLFxuXHRcdEVTQ0FQRTogLyg/OlVOSUNPREUpfFxcXFxbXlxcblxcclxcZjAtOWEtZl0vLFxuXHRcdE5PTkFTQ0lJOiAvW15cXHgwMC1cXHg3Rl0vLFxuXHRcdE5NU1RBUlQ6IC9bX2Etel18KD86Tk9OQVNDSUkpfCg/OkVTQ0FQRSkvLFxuXHRcdE5NQ0hBUjogL1tfYS16MC05LV18KD86Tk9OQVNDSUkpfCg/OkVTQ0FQRSkvLFxuXHRcdElERU5UOiAvLT8oPzpOTVNUQVJUKSg/Ok5NQ0hBUikqLyxcblx0XHRcblx0XHROTDogL1xcbnxcXHJcXG58XFxyfFxcZi8sXG5cblx0XHRTVFJJTkc6IC8oPzpTVFJJTkcxKXwoPzpTVFJJTkcyKXwoPzpTVFJJTkdCQVJFKS8sXG5cdFx0U1RSSU5HMTogL1wiKD86KD86RVNDQVBFKXxcXFxcKD86TkwpfFteXFxuXFxyXFxmXFxcIl0pKlwiLyxcblx0XHRTVFJJTkcyOiAvJyg/Oig/OkVTQ0FQRSl8XFxcXCg/Ok5MKXxbXlxcblxcclxcZlxcJ10pKicvLFxuXHRcdFNUUklOR0JBUkU6IC8oPzooPzpFU0NBUEUpfFxcXFwoPzpOTCl8W15cXG5cXHJcXGZcXF1dKSovLFxuXHRcdFxuXHRcdEZVTkNUSU9OOiAvKD86SURFTlQpXFwoXFwpLyxcblx0XHRcblx0XHRJTlRFR0VSOiAvWzAtOV0rLyxcblx0XHRcblx0XHRXSVRITjogLyhbLStdKT8oSU5URUdFUik/KG4pXFxzKig/OihbLStdKVxccyooSU5URUdFUikpPy8sXG5cdFx0V0lUSE9VVE46IC8oWy0rXSk/KElOVEVHRVIpL1xuXHR9O1xuXHRcblx0dmFyIHJ4ID0ge1xuXHRcdG5vdDogLzpub3RcXCgvLFxuXHRcdG5vdF9lbmQ6IC9cXCkvLFxuXHRcdFxuIFx0XHR0YWc6IC8oKD86SURFTlQpfFxcKikvLFxuXHRcdGlkOiAvIyhJREVOVCkvLFxuXHRcdGNsczogL1xcLihJREVOVCkvLFxuXHRcdGF0dHI6IC9cXFtcXHMqKElERU5UKVxccyooPzooW149XT89KVxccyooU1RSSU5HKVxccyopP1xcXS8sXG5cdFx0cHNldWRvX2VsOiAvKD86OihmaXJzdC1saW5lfGZpcnN0LWxldHRlcnxiZWZvcmV8YWZ0ZXIpKXwoPzo6OigoPzpGVU5DVElPTil8KD86SURFTlQpKSkvLFxuXHRcdHBzZXVkb19jbHNfbnRoOiAvOm50aC1jaGlsZFxcKFxccyooPzooPzpXSVRITil8KD86V0lUSE9VVE4pfChvZGR8ZXZlbikpXFxzKlxcKS8sXG5cdFx0cHNldWRvX2NsczogLzooSURFTlQpLyxcblxuXHRcdGNvbWI6IC9cXHMqKFxcK3x+fD4pXFxzKnxcXHMrLyxcblx0XHRjb21tYTogL1xccyosXFxzKi8sXG5cdFx0aW1wb3J0YW50OiAvXFxzKyFpbXBvcnRhbnRcXHMqJC9cblx0fTtcblxuXHQvKiBSZXBsYWNlIHBsYWNlaG9sZGVycyB3aXRoIGFjdHVhbCByZWdleCwgYW5kIG1hcmsgYWxsIGFzIGNhc2UgaW5zZW5zaXRpdmUgKi9cblx0dmFyIHRva2VuID0gL1tBLVpdW0EtWjAtOV0rLztcblx0Zm9yICh2YXIgayBpbiByeCkge1xuXHRcdHZhciBtLCBzcmMgPSByeFtrXS5zb3VyY2U7XG5cdFx0d2hpbGUgKG0gPSBzcmMubWF0Y2godG9rZW4pKSBzcmMgPSBzcmMucmVwbGFjZShtWzBdLCB0b2tlbnNbbVswXV0uc291cmNlKTtcblx0XHRyeFtrXSA9IG5ldyBSZWdFeHAoc3JjLCAnZ2knKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHN0cmluZyB0aGF0IG1hdGNoZXMgaXRzZWxmIGFnYWluc3QgcmVnZXhpaSwgYW5kIGtlZXBzIHRyYWNrIG9mIGhvdyBtdWNoIG9mIGl0c2VsZiBoYXMgYmVlbiBtYXRjaGVkXG5cdCAqL1xuXHR2YXIgQ29uc3VtYWJsZVN0cmluZyA9IEJhc2UuZXh0ZW5kKHtcblx0XHRpbml0OiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHRoaXMuc3RyID0gc3RyO1xuXHRcdFx0dGhpcy5wb3MgPSAwO1xuXHRcdH0sXG5cdFx0bWF0Y2g6IGZ1bmN0aW9uKHJ4KSB7XG5cdFx0XHR2YXIgbTtcblx0XHRcdHJ4Lmxhc3RJbmRleCA9IHRoaXMucG9zO1xuXHRcdFx0aWYgKChtID0gcnguZXhlYyh0aGlzLnN0cikpICYmIG0uaW5kZXggPT0gdGhpcy5wb3MgKSB7XG5cdFx0XHRcdHRoaXMucG9zID0gcngubGFzdEluZGV4ID8gcngubGFzdEluZGV4IDogdGhpcy5zdHIubGVuZ3RoIDtcblx0XHRcdFx0cmV0dXJuIG07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHBlZWs6IGZ1bmN0aW9uKHJ4KSB7XG5cdFx0XHR2YXIgbTtcblx0XHRcdHJ4Lmxhc3RJbmRleCA9IHRoaXMucG9zO1xuXHRcdFx0aWYgKChtID0gcnguZXhlYyh0aGlzLnN0cikpICYmIG0uaW5kZXggPT0gdGhpcy5wb3MgKSByZXR1cm4gbTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2hvd3BvczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdHIuc2xpY2UoMCx0aGlzLnBvcykrJzxIRVJFPicgKyB0aGlzLnN0ci5zbGljZSh0aGlzLnBvcyk7XG5cdFx0fSxcblx0XHRkb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBvcyA9PSB0aGlzLnN0ci5sZW5ndGg7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8qIEEgYmFzZSBjbGFzcyB0aGF0IGFsbCBTZWxlY3RvcnMgaW5oZXJpdCBvZmYgKi9cblx0dmFyIFNlbGVjdG9yQmFzZSA9IEJhc2UuZXh0ZW5kKHt9KTtcblx0XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIFNpbXBsZSBTZWxlY3RvciwgYXMgcGVyIHRoZSBDU1MzIHNlbGVjdG9yIHNwZWNcblx0ICovXG5cdHZhciBTaW1wbGVTZWxlY3RvciA9IFNlbGVjdG9yQmFzZS5leHRlbmQoe1xuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy50YWcgPSBudWxsO1xuXHRcdFx0dGhpcy5pZCA9IG51bGw7XG5cdFx0XHR0aGlzLmNsYXNzZXMgPSBbXTtcblx0XHRcdHRoaXMuYXR0cnMgPSBbXTtcblx0XHRcdHRoaXMubm90cyA9IFtdO1xuXHRcdFx0dGhpcy5wc2V1ZG9fY2xhc3NlcyA9IFtdO1xuXHRcdFx0dGhpcy5wc2V1ZG9fZWxzID0gW107XG5cdFx0fSxcblx0XHRwYXJzZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRcdHZhciBtO1xuXHRcdFx0XG5cdFx0XHQvKiBQdWxsIG91dCB0aGUgaW5pdGlhbCB0YWcgZmlyc3QsIGlmIHRoZXJlIGlzIG9uZSAqL1xuXHRcdFx0aWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC50YWcpKSB0aGlzLnRhZyA9IG1bMV07XG5cdFx0XHRcblx0XHRcdC8qIFRoZW4gZm9yIGVhY2ggc2VsZWN0aW9uIHR5cGUsIHRyeSBhbmQgZmluZCBhIG1hdGNoICovXG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChtID0gc2VsZWN0b3IubWF0Y2gocngubm90KSkge1xuXHRcdFx0XHRcdHRoaXMubm90c1t0aGlzLm5vdHMubGVuZ3RoXSA9IFNlbGVjdG9yc0dyb3VwKCkucGFyc2Uoc2VsZWN0b3IpO1xuXHRcdFx0XHRcdGlmICghKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5ub3RfZW5kKSkpIHtcblx0XHRcdFx0XHRcdHRocm93ICdJbnZhbGlkIDpub3QgdGVybSBpbiBzZWxlY3Rvcic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5pZCkpICAgICAgICAgdGhpcy5pZCA9IG1bMV07XG5cdFx0XHRcdGVsc2UgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5jbHMpKSAgICAgICAgdGhpcy5jbGFzc2VzW3RoaXMuY2xhc3Nlcy5sZW5ndGhdID0gbVsxXTtcblx0XHRcdFx0ZWxzZSBpZiAobSA9IHNlbGVjdG9yLm1hdGNoKHJ4LmF0dHIpKSAgICAgICB0aGlzLmF0dHJzW3RoaXMuYXR0cnMubGVuZ3RoXSA9IFsgbVsxXSwgbVsyXSwgbVszXSBdO1xuXHRcdFx0XHRlbHNlIGlmIChtID0gc2VsZWN0b3IubWF0Y2gocngucHNldWRvX2VsKSkgIHRoaXMucHNldWRvX2Vsc1t0aGlzLnBzZXVkb19lbHMubGVuZ3RoXSA9IG1bMV0gfHwgbVsyXTtcblx0XHRcdFx0ZWxzZSBpZiAobSA9IHNlbGVjdG9yLm1hdGNoKHJ4LnBzZXVkb19jbHNfbnRoKSkge1xuXHRcdFx0XHRcdGlmIChtWzNdKSB7XG5cdFx0XHRcdFx0XHR2YXIgYSA9IHBhcnNlSW50KChtWzFdfHwnJykrKG1bMl18fCcxJykpO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBwYXJzZUludCgobVs0XXx8JycpKyhtWzVdfHwnMCcpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgYSA9IG1bOF0gPyAyIDogMDtcblx0XHRcdFx0XHRcdHZhciBiID0gbVs4XSA/ICg0LW1bOF0ubGVuZ3RoKSA6IHBhcnNlSW50KChtWzZdfHwnJykrbVs3XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucHNldWRvX2NsYXNzZXNbdGhpcy5wc2V1ZG9fY2xhc3Nlcy5sZW5ndGhdID0gWydudGgtY2hpbGQnLCBbYSwgYl1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5wc2V1ZG9fY2xzKSkgdGhpcy5wc2V1ZG9fY2xhc3Nlc1t0aGlzLnBzZXVkb19jbGFzc2VzLmxlbmd0aF0gPSBbbVsxXV07XG5cdFx0XHRcdFxuXHRcdFx0fSB3aGlsZShtICYmICFzZWxlY3Rvci5kb25lKCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIFNlbGVjdG9yLCBhcyBwZXIgdGhlIENTUzMgc2VsZWN0b3Igc3BlY1xuXHQgKi9cblx0dmFyIFNlbGVjdG9yID0gU2VsZWN0b3JCYXNlLmV4dGVuZCh7IFxuXHRcdGluaXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLnBhcnRzID0gW107XG5cdFx0fSxcblx0XHRwYXJzZTogZnVuY3Rpb24oY29ucyl7XG5cdFx0XHR0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoXSA9IFNpbXBsZVNlbGVjdG9yKCkucGFyc2UoY29ucyk7XG5cdFx0XHRcblx0XHRcdHdoaWxlICghY29ucy5kb25lKCkgJiYgIWNvbnMucGVlayhyeC5jb21tYSkgJiYgKG0gPSBjb25zLm1hdGNoKHJ4LmNvbWIpKSkge1xuXHRcdFx0XHR0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoXSA9IG1bMV0gfHwgJyAnO1xuXHRcdFx0XHR0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoXSA9IFNpbXBsZVNlbGVjdG9yKCkucGFyc2UoY29ucyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aCA9PSAxID8gdGhpcy5wYXJ0c1swXSA6IHRoaXM7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHNlcXVlbmNlIG9mIHNlbGVjdG9ycywgYXMgcGVyIHRoZSBDU1MzIHNlbGVjdG9yIHNwZWNcblx0ICovXG5cdHZhciBTZWxlY3RvcnNHcm91cCA9IFNlbGVjdG9yQmFzZS5leHRlbmQoeyBcblx0XHRpbml0OiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5wYXJ0cyA9IFtdO1xuXHRcdH0sXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKGNvbnMpe1xuXHRcdFx0dGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aF0gPSBTZWxlY3RvcigpLnBhcnNlKGNvbnMpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoIWNvbnMuZG9uZSgpICYmIChtID0gY29ucy5tYXRjaChyeC5jb21tYSkpKSB7XG5cdFx0XHRcdHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGhdID0gU2VsZWN0b3IoKS5wYXJzZShjb25zKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucGFydHMubGVuZ3RoID09IDEgPyB0aGlzLnBhcnRzWzBdIDogdGhpcztcblx0XHR9XG5cdH0pO1xuXG5cdFxuXHQkLnNlbGVjdG9yID0gZnVuY3Rpb24ocyl7XG5cdFx0dmFyIGNvbnMgPSBDb25zdW1hYmxlU3RyaW5nKHMpO1xuXHRcdHZhciByZXMgPSBTZWxlY3RvcnNHcm91cCgpLnBhcnNlKGNvbnMpOyBcblx0XHRcblx0XHRyZXMuc2VsZWN0b3IgPSBzO1xuXHRcdFxuXHRcdGlmICghY29ucy5kb25lKCkpIHRocm93ICdDb3VsZCBub3QgcGFyc2Ugc2VsZWN0b3IgLSAnICsgY29ucy5zaG93cG9zKCkgO1xuXHRcdGVsc2UgcmV0dXJuIHJlcztcblx0fTtcblx0XG5cdCQuc2VsZWN0b3IuU2VsZWN0b3JCYXNlID0gU2VsZWN0b3JCYXNlO1xuXHQkLnNlbGVjdG9yLlNpbXBsZVNlbGVjdG9yID0gU2ltcGxlU2VsZWN0b3I7XG5cdCQuc2VsZWN0b3IuU2VsZWN0b3IgPSBTZWxlY3Rvcjtcblx0JC5zZWxlY3Rvci5TZWxlY3RvcnNHcm91cCA9IFNlbGVjdG9yc0dyb3VwO1xuXHRcbn0pKGpRdWVyeSk7XG47XG5cblxuLyogdmVuZG9yL2pxdWVyeS5zZWxlY3Rvci9qcXVlcnkuc2VsZWN0b3Iuc3BlY2lmaXR5LmpzICovXG5cbihmdW5jdGlvbigkKSB7XG5cblx0JC5zZWxlY3Rvci5TaW1wbGVTZWxlY3Rvci5hZGRNZXRob2QoJ3NwZWNpZml0eScsIGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNwZWMpIHJldHVybiB0aGlzLnNwZWM7XG5cdFx0XG5cdFx0dmFyIHNwZWMgPSBbXG5cdFx0XHR0aGlzLmlkID8gMSA6IDAsIFxuXHRcdFx0dGhpcy5jbGFzc2VzLmxlbmd0aCArIHRoaXMuYXR0cnMubGVuZ3RoICsgdGhpcy5wc2V1ZG9fY2xhc3Nlcy5sZW5ndGgsIFxuXHRcdFx0KCh0aGlzLnRhZyAmJiB0aGlzLnRhZyAhPSAnKicpID8gMSA6IDApICsgdGhpcy5wc2V1ZG9fZWxzLmxlbmd0aFxuXHRcdF07XG5cdFx0JC5lYWNoKHRoaXMubm90cywgZnVuY3Rpb24oaSxub3Qpe1xuXHRcdFx0dmFyIG5zID0gbm90LnNwZWNpZml0eSgpOyBzcGVjWzBdICs9IG5zWzBdOyBzcGVjWzFdICs9IG5zWzFdOyBzcGVjWzJdICs9IG5zWzJdOyBcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcy5zcGVjID0gc3BlYztcblx0fSk7XG5cblx0JC5zZWxlY3Rvci5TZWxlY3Rvci5hZGRNZXRob2QoJ3NwZWNpZml0eScsIGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHRoaXMuc3BlYykgcmV0dXJuIHRoaXMuc3BlYztcblx0XHRcblx0XHR2YXIgc3BlYyA9IFswLDAsMF07XG5cdFx0JC5lYWNoKHRoaXMucGFydHMsIGZ1bmN0aW9uKGkscGFydCl7XG5cdFx0XHRpZiAoaSUyKSByZXR1cm47XG5cdFx0XHR2YXIgcHMgPSBwYXJ0LnNwZWNpZml0eSgpOyBzcGVjWzBdICs9IHBzWzBdOyBzcGVjWzFdICs9IHBzWzFdOyBzcGVjWzJdICs9IHBzWzJdOyBcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcy5zcGVjID0gc3BlYztcdFxuXHR9KTtcblx0XG5cdCQuc2VsZWN0b3IuU2VsZWN0b3JzR3JvdXAuYWRkTWV0aG9kKCdzcGVjaWZpdHknLCBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLnNwZWMpIHJldHVybiB0aGlzLnNwZWM7XG5cdFx0XG5cdFx0dmFyIHNwZWMgPSBbMCwwLDBdO1xuXHRcdCQuZWFjaCh0aGlzLnBhcnRzLCBmdW5jdGlvbihpLHBhcnQpe1xuXHRcdFx0dmFyIHBzID0gcGFydC5zcGVjaWZpdHkoKTsgc3BlY1swXSArPSBwc1swXTsgc3BlY1sxXSArPSBwc1sxXTsgc3BlY1syXSArPSBwc1syXTsgXG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuc3BlYyA9IHNwZWM7XHRcblx0fSk7XG5cdFxuXHRcbn0pKGpRdWVyeSk7XG47XG5cblxuLyogdmVuZG9yL2pxdWVyeS5zZWxlY3Rvci9qcXVlcnkuc2VsZWN0b3IubWF0Y2hlcy5qcyAqL1xuXG4vKlxuVGhpcyBhdHRlbXB0cyB0byBkbyB0aGUgb3Bwb3NpdGUgb2YgU2l6emxlLlxuU2l6emxlIGlzIGdvb2QgZm9yIGZpbmRpbmcgZWxlbWVudHMgZm9yIGEgc2VsZWN0b3IsIGJ1dCBub3Qgc28gZ29vZCBmb3IgdGVsbGluZyBpZiBhbiBpbmRpdmlkdWFsIGVsZW1lbnQgbWF0Y2hlcyBhIHNlbGVjdG9yXG4qL1xuXG4oZnVuY3Rpb24oJCkge1xuXHRcblx0LyoqKiogQ0FQQUJJTElUWSBURVNUUyAqKioqL1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGRpdi5pbm5lckhUTUwgPSAnPGZvcm0gaWQ9XCJ0ZXN0XCI+PGlucHV0IG5hbWU9XCJpZFwiIHR5cGU9XCJ0ZXh0XCIvPjwvZm9ybT4nO1xuXHRcblx0Ly8gSW4gSUUgNi03LCBnZXRBdHRyaWJ1dGUgb2Z0ZW4gZG9lcyB0aGUgd3JvbmcgdGhpbmcgKHJldHVybnMgc2ltaWxhciB0byBlbC5hdHRyKSwgc28gd2UgbmVlZCB0byB1c2UgZ2V0QXR0cmlidXRlTm9kZSBvbiB0aGF0IGJyb3dzZXJcblx0dmFyIGdldEF0dHJpYnV0ZURvZGd5ID0gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdpZCcpICE9PSAndGVzdCc7XG5cdFxuXHQvLyBEb2VzIGJyb3dzZXIgc3VwcG9ydCBFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLCBFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcsIGV0Yy5cblx0dmFyIGhhc0VsZW1lbnRUcmF2ZXJzYWwgPSBkaXYuZmlyc3RFbGVtZW50Q2hpbGQgJiYgZGl2LmZpcnN0RWxlbWVudENoaWxkLnRhZ05hbWUgPT0gJ0ZPUk0nO1xuXHRcblx0Ly8gRG9lcyBicm93c2VyIHN1cHBvcnQgRWxlbWVudC5jaGlsZHJlblxuXHR2YXIgaGFzQ2hpbGRyZW4gPSBkaXYuY2hpbGRyZW4gJiYgZGl2LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT0gJ0ZPUk0nO1xuXG5cdC8qKioqIElOVFJPICoqKiovXG5cdFxuXHR2YXIgR09PRCA9IC9HT09EL2c7XG5cdHZhciBCQUQgPSAvQkFEL2c7XG5cdFxuXHR2YXIgU1RBUlRTX1dJVEhfUVVPVEVTID0gL15bJ1wiXS9nO1xuXHRcblx0dmFyIGpvaW4gPSBmdW5jdGlvbihqcykge1xuXHRcdHJldHVybiBqcy5qb2luKCdcXG4nKTtcblx0fTtcblx0XG5cdHZhciBqb2luX2NvbXBsZXggPSBmdW5jdGlvbihqcykge1xuXHRcdHZhciBjb2RlID0gbmV3IFN0cmluZyhqcy5qb2luKCdcXG4nKSk7IC8vIFN0cmluZyBvYmplY3RzIGNhbiBoYXZlIHByb3BlcnRpZXMgc2V0LiBzdHJpbmdzIGNhbid0XG5cdFx0Y29kZS5jb21wbGV4ID0gdHJ1ZTtcblx0XHRyZXR1cm4gY29kZTtcblx0fTtcblx0XG5cdC8qKioqIEFUVFJJQlVURSBBQ0NFU1NPUlMgKioqKi9cblx0XG5cdC8vIE5vdCBhbGwgYXR0cmlidXRlIG5hbWVzIGNhbiBiZSB1c2VkIGFzIGlkZW50aWZpZXJzLCBzbyB3ZSBlbmNvZGUgYW55IG5vbi1hY2NlcHRhYmxlIGNoYXJhY3RlcnMgYXMgaGV4XG5cdHZhciB2YXJGb3JBdHRyID0gZnVuY3Rpb24oYXR0cikge1xuXHRcdHJldHVybiAnXycgKyBhdHRyLnJlcGxhY2UoL15bXkEtWmEtel18W15BLVphLXowLTldL2csIGZ1bmN0aW9uKG0peyByZXR1cm4gJ18weCcgKyBtLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpICsgJ18nOyB9KTtcblx0fTtcblx0XG5cdHZhciBnZXRBdHRyO1xuXHRcblx0Ly8gR29vZCBicm93c2Vyc1xuXHRpZiAoIWdldEF0dHJpYnV0ZURvZGd5KSB7XG5cdFx0Z2V0QXR0ciA9IGZ1bmN0aW9uKGF0dHIpeyByZXR1cm4gJ3ZhciAnK3ZhckZvckF0dHIoYXR0cikrJyA9IGVsLmdldEF0dHJpYnV0ZShcIicrYXR0cisnXCIpOycgOyB9O1xuXHR9XG5cdC8vIElFIDYsIDdcblx0ZWxzZSB7XG5cdFx0Ly8gT24gSUUgNiArIDcsIGdldEF0dHJpYnV0ZSBzdGlsbCBoYXMgdG8gYmUgY2FsbGVkIHdpdGggRE9NIHByb3BlcnR5IG1pcnJvciBuYW1lLCBub3QgYXR0cmlidXRlIG5hbWUuIE1hcCBhdHRyaWJ1dGVzIHRvIHRob3NlIG5hbWVzXG5cdFx0dmFyIGdldEF0dHJJRU1hcCA9IHsgJ2NsYXNzJzogJ2NsYXNzTmFtZScsICdmb3InOiAnaHRtbEZvcicgfTtcblx0XHRcblx0XHRnZXRBdHRyID0gZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0dmFyIGllYXR0ciA9IGdldEF0dHJJRU1hcFthdHRyXSB8fCBhdHRyO1xuXHRcdFx0cmV0dXJuICd2YXIgJyt2YXJGb3JBdHRyKGF0dHIpKycgPSBlbC5nZXRBdHRyaWJ1dGUoXCInK2llYXR0cisnXCIsMikgfHwgKGVsLmdldEF0dHJpYnV0ZU5vZGUoXCInK2F0dHIrJ1wiKXx8e30pLm5vZGVWYWx1ZTsnO1xuXHRcdH07XG5cdH1cblx0XG5cdC8qKioqIEFUVFJJQlVURSBDT01QQVJJVE9SUyAqKioqL1xuXHRcblx0dmFyIGF0dHJjaGVja3MgPSB7XG5cdFx0Jy0nOiAgJyFLJyxcblx0XHQnPSc6ICAnSyAhPSBcIlZcIicsXG5cdFx0JyE9JzogJ0sgPT0gXCJWXCInLFxuXHRcdCd+PSc6ICdfV1NfSy5pbmRleE9mKFwiIFYgXCIpID09IC0xJyxcblx0XHQnXj0nOiAnIUsgfHwgSy5pbmRleE9mKFwiVlwiKSAhPSAwJyxcblx0XHQnKj0nOiAnIUsgfHwgSy5pbmRleE9mKFwiVlwiKSA9PSAtMScsXG5cdFx0JyQ9JzogJyFLIHx8IEsuc3Vic3RyKEsubGVuZ3RoLVwiVlwiLmxlbmd0aCkgIT0gXCJWXCInXG5cdH07XG5cblx0LyoqKiogU1RBVEUgVFJBQ0tFUiAqKioqL1xuXHRcblx0dmFyIFN0YXRlID0gJC5zZWxlY3Rvci5TdGF0ZSA9IEJhc2UuZXh0ZW5kKHtcblx0XHRpbml0OiBmdW5jdGlvbigpeyBcblx0XHRcdHRoaXMucmVzZXQoKTsgXG5cdFx0fSxcblx0XHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmF0dHJzID0ge307IHRoaXMud3NhdHRycyA9IHt9O1xuXHRcdH0sXG5cblx0XHRwcmV2OiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0aWYgKGhhc0VsZW1lbnRUcmF2ZXJzYWwpIHJldHVybiAnZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nJztcblx0XHRcdHJldHVybiAnd2hpbGUoKGVsID0gZWwucHJldmlvdXNTaWJsaW5nKSAmJiBlbC5ub2RlVHlwZSAhPSAxKSB7fSc7XG5cdFx0fSxcblx0XHRuZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdGlmIChoYXNFbGVtZW50VHJhdmVyc2FsKSByZXR1cm4gJ2VsID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nJztcblx0XHRcdHJldHVybiAnd2hpbGUoKGVsID0gZWwubmV4dFNpYmxpbmcpICYmIGVsLm5vZGVUeXBlICE9IDEpIHt9Jztcblx0XHR9LFxuXHRcdHByZXZMb29wOiBmdW5jdGlvbihib2R5KXtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdGlmIChoYXNFbGVtZW50VHJhdmVyc2FsKSByZXR1cm4gam9pbihbICd3aGlsZShlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpeycsIGJvZHldKTtcblx0XHRcdHJldHVybiBqb2luKFtcblx0XHRcdFx0J3doaWxlKGVsID0gZWwucHJldmlvdXNTaWJsaW5nKXsnLFxuXHRcdFx0XHRcdCdpZiAoZWwubm9kZVR5cGUgIT0gMSkgY29udGludWU7Jyxcblx0XHRcdFx0XHRib2R5XG5cdFx0XHRdKTtcblx0XHR9LFxuXHRcdHBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHRyZXR1cm4gJ2VsID0gZWwucGFyZW50Tm9kZTsnO1xuXHRcdH0sXG5cdFx0cGFyZW50TG9vcDogZnVuY3Rpb24oYm9keSkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0cmV0dXJuIGpvaW4oW1xuXHRcdFx0XHQnd2hpbGUoKGVsID0gZWwucGFyZW50Tm9kZSkgJiYgZWwubm9kZVR5cGUgPT0gMSl7Jyxcblx0XHRcdFx0XHRib2R5LFxuXHRcdFx0XHQnfSdcblx0XHRcdF0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0dXNlc19hdHRyOiBmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRpZiAodGhpcy5hdHRyc1thdHRyXSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5hdHRyc1thdHRyXSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gZ2V0QXR0cihhdHRyKTsgXG5cdFx0fSxcblx0XHR1c2VzX3dzYXR0cjogZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0aWYgKHRoaXMud3NhdHRyc1thdHRyXSkgcmV0dXJuO1xuXHRcdFx0dGhpcy53c2F0dHJzW2F0dHJdID0gdHJ1ZTtcblx0XHRcdHJldHVybiBqb2luKFt0aGlzLnVzZXNfYXR0cihhdHRyKSwgJ3ZhciBfV1NfJyt2YXJGb3JBdHRyKGF0dHIpKycgPSBcIiBcIisnK3ZhckZvckF0dHIoYXR0cikrJytcIiBcIjsnXSk7IFxuXHRcdH0sXG5cblx0XHR1c2VzX2pxdWVyeUZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuanF1ZXJ5RmlsdGVyc0FkZGVkKSByZXR1cm47XG5cdFx0XHR0aGlzLmpxdWVyeUZpbHRlcnNBZGRlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm4gJ3ZhciBfJGZpbHRlcnMgPSBqUXVlcnkuZmluZC5zZWxlY3RvcnMuZmlsdGVyczsnO1xuXHRcdH0sXG5cblx0XHRzYXZlOiBmdW5jdGlvbihsYmwpIHtcblx0XHRcdHJldHVybiAndmFyIGVsJytsYmwrJyA9IGVsOyc7XG5cdFx0fSxcblx0XHRyZXN0b3JlOiBmdW5jdGlvbihsYmwpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHJldHVybiAnZWwgPSBlbCcrbGJsKyc7Jztcblx0XHR9XG5cdH0pO1xuXHRcblx0LyoqKiogUFNFVURPLUNMQVNTIERFVEFJTFMgKioqKi9cblx0XG5cdHZhciBwc2V1ZG9jbHNjaGVja3MgPSB7XG5cdFx0J2ZpcnN0LWNoaWxkJzogam9pbihbXG5cdFx0XHQndmFyIGNlbCA9IGVsOycsXG5cdFx0XHQnd2hpbGUoY2VsID0gY2VsLnByZXZpb3VzU2libGluZyl7IGlmIChjZWwubm9kZVR5cGUgPT09IDEpIEJBRDsgfSdcblx0XHRdKSxcblx0XHQnbGFzdC1jaGlsZCc6IGpvaW4oW1xuXHRcdFx0J3ZhciBjZWwgPSBlbDsnLFxuXHRcdFx0J3doaWxlKGNlbCA9IGNlbC5uZXh0U2libGluZyl7IGlmIChjZWwubm9kZVR5cGUgPT09IDEpIEJBRDsgfSdcblx0XHRdKSxcblx0XHQnbnRoLWNoaWxkJzogZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHR2YXIgZ2V0X2kgPSBqb2luKFtcblx0XHRcdFx0J3ZhciBpID0gMSwgY2VsID0gZWw7Jyxcblx0XHRcdFx0J3doaWxlKGNlbCA9IGNlbC5wcmV2aW91c1NpYmxpbmcpeycsXG5cdFx0XHRcdFx0J2lmIChjZWwubm9kZVR5cGUgPT09IDEpIGkrKzsnLFxuXHRcdFx0XHQnfSdcblx0XHRcdF0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoYSA9PSAwKSByZXR1cm4gam9pbihbXG5cdFx0XHRcdGdldF9pLFxuXHRcdFx0XHQnaWYgKGktICcrYisnICE9IDApIEJBRDsnXG5cdFx0XHRdKTtcblx0XHRcdGVsc2UgaWYgKGIgPT0gMCAmJiBhID49IDApIHJldHVybiBqb2luKFtcblx0XHRcdFx0Z2V0X2ksXG5cdFx0XHRcdCdpZiAoaSUnK2ErJyAhPSAwIHx8IGkvJythKycgPCAwKSBCQUQ7J1xuXHRcdFx0XSk7XG5cdFx0XHRlbHNlIGlmIChiID09IDAgJiYgYSA8IDApIHJldHVybiBqb2luKFtcblx0XHRcdFx0J0JBRDsnXG5cdFx0XHRdKTtcblx0XHRcdGVsc2UgcmV0dXJuIGpvaW4oW1xuXHRcdFx0XHRnZXRfaSxcblx0XHRcdFx0J2lmICgoaS0gJytiKycpJScrYSsnICE9IDAgfHwgKGktICcrYisnKS8nK2ErJyA8IDApIEJBRDsnXG5cdFx0XHRdKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvLyBOZWVkcyB0byByZWZlbmNlIGNvbnRlbnRzIG9mIG9iamVjdCwgc28gbXVzdCBiZSBpbmplY3RlZCBhZnRlciBkZWZpbml0aW9uXG5cdHBzZXVkb2Nsc2NoZWNrc1snb25seS1jaGlsZCddID0gam9pbihbXG5cdFx0cHNldWRvY2xzY2hlY2tzWydmaXJzdC1jaGlsZCddLFxuXHRcdHBzZXVkb2Nsc2NoZWNrc1snbGFzdC1jaGlsZCddXG5cdF0pO1xuXHRcblx0LyoqKiogU2ltcGxlU2VsZWN0b3IgKioqKi9cblx0XG5cdCQuc2VsZWN0b3IuU2ltcGxlU2VsZWN0b3IuYWRkTWV0aG9kKCdjb21waWxlJywgZnVuY3Rpb24oZWwpIHtcblx0XHR2YXIganMgPSBbXTtcblx0XHRcblx0XHQvKiBDaGVjayBhZ2FpbnN0IGVsZW1lbnQgbmFtZSAqL1x0XHRcdFxuXHRcdGlmICh0aGlzLnRhZyAmJiB0aGlzLnRhZyAhPSAnKicpIHtcblx0XHRcdGpzW2pzLmxlbmd0aF0gPSAnaWYgKGVsLnRhZ05hbWUgIT0gXCInK3RoaXMudGFnLnRvVXBwZXJDYXNlKCkrJ1wiKSBCQUQ7Jztcblx0XHR9XG5cblx0XHQvKiBDaGVjayBhZ2FpbnN0IElEICovXG5cdFx0aWYgKHRoaXMuaWQpIHtcblx0XHRcdGpzW2pzLmxlbmd0aF0gPSBlbC51c2VzX2F0dHIoJ2lkJyk7XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gJ2lmIChfaWQgIT09IFwiJyt0aGlzLmlkKydcIikgQkFEOyc7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEJ1aWxkIGNsYXNzTmFtZSBjaGVja2luZyB2YXJpYWJsZSAqL1xuXHRcdGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gZWwudXNlc193c2F0dHIoJ2NsYXNzJyk7XG5cdFx0XHRcblx0XHRcdC8qIENoZWNrIGFnYWluc3QgY2xhc3MgbmFtZXMgKi9cblx0XHRcdCQuZWFjaCh0aGlzLmNsYXNzZXMsIGZ1bmN0aW9uKGksIGNscyl7XG5cdFx0XHRcdGpzW2pzLmxlbmd0aF0gPSAnaWYgKF9XU19fY2xhc3MuaW5kZXhPZihcIiAnK2NscysnIFwiKSA9PSAtMSkgQkFEOyc7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyogQ2hlY2sgYWdhaW5zdCBhdHRyaWJ1dGVzICovXG5cdFx0JC5lYWNoKHRoaXMuYXR0cnMsIGZ1bmN0aW9uKGksIGF0dHIpe1xuXHRcdFx0anNbanMubGVuZ3RoXSA9IChhdHRyWzFdID09ICd+PScpID8gZWwudXNlc193c2F0dHIoYXR0clswXSkgOiBlbC51c2VzX2F0dHIoYXR0clswXSk7XG5cdFx0XHR2YXIgY2hlY2sgPSBhdHRyY2hlY2tzWyBhdHRyWzFdIHx8ICctJyBdO1xuXHRcdFx0Y2hlY2sgPSBjaGVjay5yZXBsYWNlKCAvSy9nLCB2YXJGb3JBdHRyKGF0dHJbMF0pKS5yZXBsYWNlKCAvVi9nLCBhdHRyWzJdICYmIGF0dHJbMl0ubWF0Y2goU1RBUlRTX1dJVEhfUVVPVEVTKSA/IGF0dHJbMl0uc2xpY2UoMSwtMSkgOiBhdHRyWzJdICk7XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gJ2lmICgnK2NoZWNrKycpIEJBRDsnO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8qIENoZWNrIGFnYWluc3Qgbm90cyAqL1xuXHRcdCQuZWFjaCh0aGlzLm5vdHMsIGZ1bmN0aW9uKGksIG5vdCl7XG5cdFx0XHR2YXIgbGJsID0gKytsYmxfaWQ7XG5cdFx0XHR2YXIgZnVuYyA9IGpvaW4oW1xuXHRcdFx0XHQnbCcrbGJsKyc6eycsXG5cdFx0XHRcdFx0bm90LmNvbXBpbGUoZWwpLnJlcGxhY2UoQkFELCAnYnJlYWsgbCcrbGJsKS5yZXBsYWNlKEdPT0QsICdCQUQnKSxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEobm90IGluc3RhbmNlb2YgJC5zZWxlY3Rvci5TaW1wbGVTZWxlY3RvcikpIGZ1bmMgPSBqb2luKFtcblx0XHRcdFx0ZWwuc2F2ZShsYmwpLFxuXHRcdFx0XHRmdW5jLFxuXHRcdFx0XHRlbC5yZXN0b3JlKGxibClcblx0XHRcdF0pO1xuXHRcdFx0XHRcblx0XHRcdGpzW2pzLmxlbmd0aF0gPSBmdW5jO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8qIENoZWNrIGFnYWluc3QgcHNldWRvLWNsYXNzZXMgKi9cblx0XHQkLmVhY2godGhpcy5wc2V1ZG9fY2xhc3NlcywgZnVuY3Rpb24oaSwgcHNjbHMpe1xuXHRcdFx0dmFyIGNoZWNrID0gcHNldWRvY2xzY2hlY2tzW3BzY2xzWzBdXTtcblx0XHRcdGlmIChjaGVjaykge1xuXHRcdFx0XHRqc1tqcy5sZW5ndGhdID0gKCB0eXBlb2YgY2hlY2sgPT0gJ2Z1bmN0aW9uJyA/IGNoZWNrLmFwcGx5KHRoaXMsIHBzY2xzWzFdKSA6IGNoZWNrICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjaGVjayA9ICQuZmluZC5zZWxlY3RvcnMuZmlsdGVyc1twc2Nsc1swXV0pIHtcblx0XHRcdFx0anNbanMubGVuZ3RoXSA9IGVsLnVzZXNfanF1ZXJ5RmlsdGVycygpO1xuXHRcdFx0XHRqc1tqcy5sZW5ndGhdID0gJ2lmICghXyRmaWx0ZXJzLicrcHNjbHNbMF0rJyhlbCkpIEJBRDsnO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdGpzW2pzLmxlbmd0aF0gPSAnR09PRCc7XG5cdFx0XG5cdFx0LyogUGFzcyAqL1xuXHRcdHJldHVybiBqb2luKGpzKTtcblx0fSk7XG5cdFxuXHR2YXIgbGJsX2lkID0gMDtcblx0LyoqIFR1cm5zIGFuIGNvbXBpbGVkIGZyYWdtZW50IGludG8gdGhlIGZpcnN0IHBhcnQgb2YgYSBjb21iaW5hdGlvbiAqL1xuXHRmdW5jdGlvbiBhc19zdWJleHByKGYpIHtcblx0XHRpZiAoZi5jb21wbGV4KVxuXHRcdFx0cmV0dXJuIGpvaW4oW1xuXHRcdFx0XHQnbCcrKCsrbGJsX2lkKSsnOnsnLFxuXHRcdFx0XHRcdGYucmVwbGFjZShHT09ELCAnYnJlYWsgbCcrbGJsX2lkKSxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gZi5yZXBsYWNlKEdPT0QsICcnKTtcblx0fVxuXHRcblx0dmFyIGNvbWJpbmVzID0ge1xuXHRcdCcgJzogZnVuY3Rpb24oZWwsIGYxLCBmMikge1xuXHRcdFx0cmV0dXJuIGpvaW5fY29tcGxleChbXG5cdFx0XHRcdGYyLFxuXHRcdFx0XHQnd2hpbGUodHJ1ZSl7Jyxcblx0XHRcdFx0XHRlbC5wYXJlbnQoKSxcblx0XHRcdFx0XHQnaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkgQkFEOycsXG5cdFx0XHRcdFx0ZjEuY29tcGlsZShlbCkucmVwbGFjZShCQUQsICdjb250aW51ZScpLFxuXHRcdFx0XHQnfSdcblx0XHRcdF0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0Jz4nOiBmdW5jdGlvbihlbCwgZjEsIGYyKSB7XG5cdFx0XHRyZXR1cm4gam9pbihbXG5cdFx0XHRcdGYyLFxuXHRcdFx0XHRlbC5wYXJlbnQoKSxcblx0XHRcdFx0J2lmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIEJBRDsnLFxuXHRcdFx0XHRmMS5jb21waWxlKGVsKVxuXHRcdFx0XSk7XG5cdFx0fSxcblx0XHRcblx0XHQnfic6IGZ1bmN0aW9uKGVsLCBmMSwgZjIpIHtcblx0XHRcdHJldHVybiBqb2luX2NvbXBsZXgoW1xuXHRcdFx0XHRmMixcblx0XHRcdFx0ZWwucHJldkxvb3AoKSxcblx0XHRcdFx0XHRmMS5jb21waWxlKGVsKS5yZXBsYWNlKEJBRCwgJ2NvbnRpbnVlJyksXG5cdFx0XHRcdCd9Jyxcblx0XHRcdFx0J0JBRDsnXG5cdFx0XHRdKTtcblx0XHR9LFxuXHRcdFxuXHRcdCcrJzogZnVuY3Rpb24oZWwsIGYxLCBmMikge1xuXHRcdFx0cmV0dXJuIGpvaW4oW1xuXHRcdFx0XHRmMixcblx0XHRcdFx0ZWwucHJldigpLFxuXHRcdFx0XHQnaWYgKCFlbCkgQkFEOycsXG5cdFx0XHRcdGYxLmNvbXBpbGUoZWwpXG5cdFx0XHRdKTtcblx0XHR9XG5cdH07XG5cdFxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yLmFkZE1ldGhvZCgnY29tcGlsZScsIGZ1bmN0aW9uKGVsKSB7XG5cdFx0dmFyIGwgPSB0aGlzLnBhcnRzLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgZXhwciA9IHRoaXMucGFydHNbLS1sXS5jb21waWxlKGVsKTtcblx0XHR3aGlsZSAobCkge1xuXHRcdFx0dmFyIGNvbWJpbmF0b3IgPSB0aGlzLnBhcnRzWy0tbF07XG5cdFx0XHRleHByID0gY29tYmluZXNbY29tYmluYXRvcl0oZWwsIHRoaXMucGFydHNbLS1sXSwgYXNfc3ViZXhwcihleHByKSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBleHByO1xuXHR9KTtcblxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yc0dyb3VwLmFkZE1ldGhvZCgnY29tcGlsZScsIGZ1bmN0aW9uKGVsKSB7XG5cdFx0dmFyIGV4cHIgPSBbXSwgbGJsID0gKytsYmxfaWQ7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaT0wOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXhwcltleHByLmxlbmd0aF0gPSBqb2luKFtcblx0XHRcdFx0aSA9PSAwID8gZWwuc2F2ZShsYmwpIDogZWwucmVzdG9yZShsYmwpLCBcblx0XHRcdFx0J2wnK2xibCsnXycraSsnOnsnLFxuXHRcdFx0XHRcdHRoaXMucGFydHNbaV0uY29tcGlsZShlbCkucmVwbGFjZShCQUQsICdicmVhayBsJytsYmwrJ18nK2kpLFxuXHRcdFx0XHQnfSdcblx0XHRcdF0pO1xuXHRcdH1cblx0XHRcblx0XHRleHByW2V4cHIubGVuZ3RoXSA9ICdCQUQ7Jztcblx0XHRyZXR1cm4gam9pbihleHByKTtcblx0fSk7XG5cblx0JC5zZWxlY3Rvci5TZWxlY3RvckJhc2UuYWRkTWV0aG9kKCdtYXRjaGVzJywgZnVuY3Rpb24oZWwpe1x0XG5cdFx0dGhpcy5tYXRjaGVzID0gbmV3IEZ1bmN0aW9uKCdlbCcsIGpvaW4oWyBcblx0XHRcdCdpZiAoIWVsKSByZXR1cm4gZmFsc2U7Jyxcblx0XHRcdHRoaXMuY29tcGlsZShuZXcgU3RhdGUoKSkucmVwbGFjZShCQUQsICdyZXR1cm4gZmFsc2UnKS5yZXBsYWNlKEdPT0QsICdyZXR1cm4gdHJ1ZScpXG5cdFx0XSkpO1xuXHRcdHJldHVybiB0aGlzLm1hdGNoZXMoZWwpO1xuXHR9KTtcblx0XG59KShqUXVlcnkpO1xuXG47XG5cblxuLyogc3JjL2pxdWVyeS5zZWxlY3Rvci5hZmZlY3RlZGJ5LmpzICovXG5cbihmdW5jdGlvbigkKSB7XG5cblx0Ly8gVE9ETzpcblx0Ly8gTWFrZSBhdHRyaWJ1dGVzICYgSURzIHdvcmtcblxuXHR2YXIgRElSRUNUID0gL0RJUkVDVC9nO1xuXHR2YXIgQ09OVEVYVCA9IC9DT05URVhUL2c7XG5cdHZhciBFSVRIRVIgPSAvRElSRUNUfENPTlRFWFQvZztcblxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yQmFzZS5hZGRNZXRob2QoJ2FmZmVjdGVkQnknLCBmdW5jdGlvbihwcm9wcykge1xuXHRcdHRoaXMuYWZmZWN0ZWRCeSA9IG5ldyBGdW5jdGlvbigncHJvcHMnLCAoW1xuXHRcdFx0J3ZhciBkaXJlY3RfY2xhc3NlcywgY29udGV4dF9jbGFzc2VzLCBkaXJlY3RfYXR0cnMsIGNvbnRleHRfYXR0cnMsIHQ7Jyxcblx0XHRcdHRoaXMuQUJDX2NvbXBpbGUoKS5yZXBsYWNlKERJUkVDVCwgJ2RpcmVjdCcpLnJlcGxhY2UoQ09OVEVYVCwgJ2NvbnRleHQnKSxcblx0XHRcdCdyZXR1cm4ge2NsYXNzZXM6IHtjb250ZXh0OiBjb250ZXh0X2NsYXNzZXMsIGRpcmVjdDogZGlyZWN0X2NsYXNzZXN9LCBhdHRyczoge2NvbnRleHQ6IGNvbnRleHRfYXR0cnMsIGRpcmVjdDogZGlyZWN0X2F0dHJzfX07J1xuXHRcdF0pLmpvaW4oXCJcXG5cIikpO1xuXG5cdFx0Ly8gREVCVUc6IFByaW50IG91dCB0aGUgY29tcGlsZWQgZnVuY2l0b25cblx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLnNlbGVjdG9yLCAnJyt0aGlzLmFmZmVjdGVkQnkpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYWZmZWN0ZWRCeShwcm9wcyk7XG5cdH0pO1xuXG5cdCQuc2VsZWN0b3IuU2ltcGxlU2VsZWN0b3IuYWRkTWV0aG9kKCdBQkNfY29tcGlsZScsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0JC5lYWNoKHRoaXMuY2xhc3NlcywgZnVuY3Rpb24oaSwgY2xzKXtcblx0XHRcdHBhcnRzW3BhcnRzLmxlbmd0aF0gPSBcImlmICh0ID0gcHJvcHMuY2xhc3Nlc1snXCIrY2xzK1wiJ10pIChESVJFQ1RfY2xhc3NlcyB8fCAoRElSRUNUX2NsYXNzZXMgPSB7fSkpWydcIitjbHMrXCInXSA9IHQ7XCI7XG5cdFx0fSk7XG5cblx0XHQkLmVhY2godGhpcy5ub3RzLCBmdW5jdGlvbihpLCBub3Qpe1xuXHRcdFx0cGFydHNbcGFydHMubGVuZ3RoXSA9IG5vdC5BQkNfY29tcGlsZSgpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oXCJcXG5cIik7XG5cdH0pO1xuXG5cdCQuc2VsZWN0b3IuU2VsZWN0b3IuYWRkTWV0aG9kKCdBQkNfY29tcGlsZScsIGZ1bmN0aW9uKGFyZyl7XG5cdFx0dmFyIHBhcnRzID0gW107XG5cdFx0dmFyIGkgPSB0aGlzLnBhcnRzLmxlbmd0aC0xO1xuXG5cdFx0cGFydHNbcGFydHMubGVuZ3RoXSA9IHRoaXMucGFydHNbaV0uQUJDX2NvbXBpbGUoKTtcblx0XHR3aGlsZSAoKGkgPSBpIC0gMikgPj0gMCkgcGFydHNbcGFydHMubGVuZ3RoXSA9IHRoaXMucGFydHNbaV0uQUJDX2NvbXBpbGUoKS5yZXBsYWNlKEVJVEhFUiwgJ0NPTlRFWFQnKTtcblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xuXHR9KTtcblxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yc0dyb3VwLmFkZE1ldGhvZCgnQUJDX2NvbXBpbGUnLCBmdW5jdGlvbigpe1xuXHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0JC5lYWNoKHRoaXMucGFydHMsIGZ1bmN0aW9uKGkscGFydCl7XG5cdFx0XHRwYXJ0c1twYXJ0cy5sZW5ndGhdID0gcGFydC5BQkNfY29tcGlsZSgpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oXCJcXG5cIik7XG5cdH0pO1xuXG5cbn0pKGpRdWVyeSk7XG47XG5cblxuLyogc3JjL2pxdWVyeS5mb2N1c2lub3V0LmpzICovXG5cbihmdW5jdGlvbigkKXtcdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBmb2N1c2luIGFuZCBmb2N1c291dCBzdXBwb3J0IHRvIGJpbmQgYW5kIGxpdmUgZm9yIGJyb3dlcnMgb3RoZXIgdGhhbiBJRS4gRGVzaWduZWQgdG8gYmUgdXNhYmxlIGluIGEgZGVsZWdhdGVkIGZhc2hpb24gKGxpa2UgJC5saXZlKVxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMDcgSsO2cm4gWmFlZmZlcmVyXG5cdCAqL1xuXHRpZiAoJC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID09PSB1bmRlZmluZWQpICB7XG5cdFx0JC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gISEoJC5icm93c2VyLm1zaWUpO1xuXHR9XG5cblx0aWYgKCEkLnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgJiYgISQuZXZlbnQuc3BlY2lhbC5mb2N1c2luKSB7XG5cdFx0Ly8gRW11bGF0ZSBmb2N1c2luIGFuZCBmb2N1c291dCBieSBiaW5kaW5nIGZvY3VzIGFuZCBibHVyIGluIGNhcHR1cmluZyBtb2RlXG5cdFx0JC5lYWNoKHtmb2N1czogJ2ZvY3VzaW4nLCBibHVyOiAnZm9jdXNvdXQnfSwgZnVuY3Rpb24ob3JpZ2luYWwsIGZpeCl7XG5cdFx0XHQkLmV2ZW50LnNwZWNpYWxbZml4XSA9IHtcblx0XHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmFkZEV2ZW50TGlzdGVuZXIpIHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIob3JpZ2luYWwsICQuZXZlbnQuc3BlY2lhbFtmaXhdLmhhbmRsZXIsIHRydWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZiAoIXRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcikgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvcmlnaW5hbCwgJC5ldmVudC5zcGVjaWFsW2ZpeF0uaGFuZGxlciwgdHJ1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhhbmRsZXI6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdGFyZ3VtZW50c1swXSA9ICQuZXZlbnQuZml4KGUpO1xuXHRcdFx0XHRcdGFyZ3VtZW50c1swXS50eXBlID0gZml4O1xuXHRcdFx0XHRcdHJldHVybiAkLmV2ZW50LmhhbmRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cdFx0XG5cdChmdW5jdGlvbigpe1xuXHRcdC8vSUUgaGFzIHNvbWUgdHJvdWJsZSB3aXRoIGZvY3Vzb3V0IHdpdGggc2VsZWN0IGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uXG5cdFx0dmFyIGFjdGl2ZUZvY3VzID0gbnVsbDtcblx0XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5iaW5kKCdmb2N1c2luJywgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBlLnJlYWxUYXJnZXQgfHwgZS50YXJnZXQ7XG5cdFx0XHRcdGlmIChhY3RpdmVGb2N1cyAmJiBhY3RpdmVGb2N1cyAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0ZS50eXBlID0gJ2ZvY3Vzb3V0Jztcblx0XHRcdFx0XHQkKGFjdGl2ZUZvY3VzKS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdGUudHlwZSA9ICdmb2N1c2luJztcblx0XHRcdFx0XHRlLnRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0fVxuXHRcdFx0XHRhY3RpdmVGb2N1cyA9IHRhcmdldDtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCgnZm9jdXNvdXQnLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0YWN0aXZlRm9jdXMgPSBudWxsO1xuXHRcdFx0fSk7XG5cdH0pKCk7XG5cdFxufSkoalF1ZXJ5KTs7XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmpzICovXG5cbnRyeSB7XG5cdGNvbnNvbGUubG9nO1xufVxuY2F0Y2ggKGUpIHtcblx0d2luZG93LmNvbnNvbGUgPSB1bmRlZmluZWQ7XG59XG5cbihmdW5jdGlvbigkKSB7XG5cblx0LyogQ3JlYXRlIGEgc3ViY2xhc3Mgb2YgdGhlIGpRdWVyeSBvYmplY3QuIFRoaXMgd2FzIGludHJvZHVjZWQgaW4galF1ZXJ5IDEuNSwgYnV0IHJlbW92ZWQgYWdhaW4gaW4gMS45ICovXG5cdHZhciBzdWIgPSBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBqUXVlcnlTdWIoIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBqUXVlcnlTdWIuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCBqUXVlcnlTdWIsICQgKTtcblx0XHRqUXVlcnlTdWIuc3VwZXJjbGFzcyA9ICQ7XG5cdFx0alF1ZXJ5U3ViLmZuID0galF1ZXJ5U3ViLnByb3RvdHlwZSA9ICQoKTtcblx0XHRqUXVlcnlTdWIuZm4uY29uc3RydWN0b3IgPSBqUXVlcnlTdWI7XG5cdFx0alF1ZXJ5U3ViLmZuLmluaXQgPSBmdW5jdGlvbiBpbml0KCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRcdGlmICggY29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICYmICEoY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeVN1YikgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBqUXVlcnlTdWIoIGNvbnRleHQgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpRdWVyeS5mbi5pbml0LmNhbGwoIHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5U3ViICk7XG5cdFx0fTtcblx0XHRqUXVlcnlTdWIuZm4uaW5pdC5wcm90b3R5cGUgPSBqUXVlcnlTdWIuZm47XG5cdFx0dmFyIHJvb3RqUXVlcnlTdWIgPSBqUXVlcnlTdWIoZG9jdW1lbnQpO1xuXHRcdHJldHVybiBqUXVlcnlTdWI7XG5cdH07XG5cblx0dmFyIG5hbWVzcGFjZXMgPSB7fTtcblxuXHQkLmVudHdpbmUgPSBmdW5jdGlvbigpIHtcblx0XHQkLmZuLmVudHdpbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIGNvdXBsZSBvZiB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgYWNjZXNzaW5nIHRoZSBzdG9yZSBvdXRzaWRlIG9mIHRoaXMgY2xvc3VyZSwgYW5kIGZvciBtYWtpbmcgdGhpbmdzXG5cdCAqIG9wZXJhdGUgaW4gYSBsaXR0bGUgbW9yZSBlYXN5LXRvLXRlc3QgbWFubmVyXG5cdCAqL1xuXHQkLmV4dGVuZCgkLmVudHdpbmUsIHtcblx0XHQvKipcblx0XHQgKiBHZXQgYWxsIHRoZSBuYW1lc3BhY2VzLiBVc2VmdWwgZm9yIGludHJvc3BlY3Rpb24/IEludGVybmFsIGludGVyZmFjZSBvZiBOYW1lc3BhY2Ugbm90IGd1YXJhbnRlZWQgY29uc2lzdGFudFxuXHRcdCAqL1xuXHRcdG5hbWVzcGFjZXM6IG5hbWVzcGFjZXMsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGFsbCBlbnR3aW5lIHJ1bGVzXG5cdFx0ICovXG5cdFx0Y2xlYXJfYWxsX3J1bGVzOiBmdW5jdGlvbigpIHsgXG5cdFx0XHQvLyBSZW1vdmUgcHJveHkgZnVuY3Rpb25zXG5cdFx0XHRmb3IgKHZhciBrIGluICQuZm4pIHsgaWYgKCQuZm5ba10uaXNlbnR3aW5lbWV0aG9kKSBkZWxldGUgJC5mbltrXTsgfVxuXHRcdFx0Ly8gUmVtb3ZlIGJvdW5kIGV2ZW50cyAtIFRPRE86IE1ha2UgdGhpcyBwbHVnZ2FibGUsIHNvIHRoaXMgY29kZSBjYW4gYmUgbW92ZWQgdG8ganF1ZXJ5LmVudHdpbmUuZXZlbnRzLmpzXG5cdFx0XHQkKGRvY3VtZW50KS51bmJpbmQoJy5lbnR3aW5lJyk7XG5cdFx0XHQkKHdpbmRvdykudW5iaW5kKCcuZW50d2luZScpO1xuXHRcdFx0Ly8gUmVtb3ZlIG5hbWVzcGFjZXMsIGFuZCBzdGFydCBvdmVyIGFnYWluXG5cdFx0XHRmb3IgKHZhciBrIGluIG5hbWVzcGFjZXMpIGRlbGV0ZSBuYW1lc3BhY2VzW2tdO1xuXHRcdFx0Zm9yICh2YXIgayBpbiAkLmVudHdpbmUuY2FwdHVyZV9iaW5kaW5ncykgZGVsZXRlICQuZW50d2luZS5jYXB0dXJlX2JpbmRpbmdzW2tdO1xuXHRcdH0sXG5cdFx0XG5cdFx0V0FSTl9MRVZFTF9OT05FOiAwLFxuXHRcdFdBUk5fTEVWRUxfSU1QT1JUQU5UOiAxLFxuXHRcdFdBUk5fTEVWRUxfQkVTVFBSQUNUSVNFOiAyLFxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBXYXJuaW5nIGxldmVsLiBTZXQgdG8gYSBoaWdoZXIgbGV2ZWwgdG8gZ2V0IHdhcm5pbmdzIGR1bXBlZCB0byBjb25zb2xlLlxuXHRcdCAqL1xuXHRcdHdhcm5pbmdMZXZlbDogMCxcblx0XHRcblx0XHQvKiogVXRpbGl0eSB0byBvcHRpb25hbGx5IGRpc3BsYXkgd2FybmluZyBtZXNzYWdlcyBkZXBlbmRpbmcgb24gbGV2ZWwgKi9cblx0XHR3YXJuOiBmdW5jdGlvbihtZXNzYWdlLCBsZXZlbCkge1xuXHRcdFx0aWYgKGxldmVsIDw9ICQuZW50d2luZS53YXJuaW5nTGV2ZWwgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHsgXG5cdFx0XHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcblx0XHRcdFx0aWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdHdhcm5fZXhjZXB0aW9uOiBmdW5jdGlvbih3aGVyZSwgLyogb3B0aW9uYWw6ICovIG9uLCBlKSB7XG5cdFx0XHRpZiAoJC5lbnR3aW5lLldBUk5fTEVWRUxfSU1QT1JUQU5UIDw9ICQuZW50d2luZS53YXJuaW5nTGV2ZWwgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikgeyBlID0gb247IG9uID0gbnVsbDsgfVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9uKSBjb25zb2xlLndhcm4oJ1VuY2F1Z2h0IGV4Y2VwdGlvbicsZSwnaW4nLHdoZXJlLCdvbicsb24pO1xuXHRcdFx0XHRlbHNlICAgIGNvbnNvbGUud2FybignVW5jYXVnaHQgZXhjZXB0aW9uJyxlLCdpbicsd2hlcmUpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGUuc3RhY2spIGNvbnNvbGUud2FybihcIlN0YWNrIFRyYWNlOlxcblwiICsgZS5zdGFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0XG5cblx0LyoqIFN0b3JlcyBhIGNvdW50IG9mIGRlZmluaXRpb25zLCBzbyB0aGF0IHdlIGNhbiBzb3J0IGlkZW50aWNhbCBzZWxlY3RvcnMgYnkgZGVmaW5pdGlvbiBvcmRlciAqL1xuXHR2YXIgcnVsZWNvdW50ID0gMDtcblx0XG5cdHZhciBSdWxlID0gQmFzZS5leHRlbmQoe1xuXHRcdGluaXQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBuYW1lKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLnNwZWNpZml0eSA9IHNlbGVjdG9yLnNwZWNpZml0eSgpO1xuXHRcdFx0dGhpcy5pbXBvcnRhbnQgPSAwO1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMucnVsZWNvdW50ID0gcnVsZWNvdW50Kys7XG5cdFx0fVxuXHR9KTtcblx0XG5cdFJ1bGUuY29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHR2YXIgYXMgPSBhLnNwZWNpZml0eSwgYnMgPSBiLnNwZWNpZml0eTtcblx0XHRcblx0XHRyZXR1cm4gKGEuaW1wb3J0YW50IC0gYi5pbXBvcnRhbnQpIHx8XG5cdFx0ICAgICAgIChhc1swXSAtIGJzWzBdKSB8fFxuXHRcdCAgICAgICAoYXNbMV0gLSBic1sxXSkgfHxcblx0XHQgICAgICAgKGFzWzJdIC0gYnNbMl0pIHx8XG5cdFx0ICAgICAgIChhLnJ1bGVjb3VudCAtIGIucnVsZWNvdW50KSA7XG5cdH07XG5cblx0JC5lbnR3aW5lLlJ1bGVMaXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcblx0XHRsaXN0LmFkZFJ1bGUgPSBmdW5jdGlvbihzZWxlY3RvciwgbmFtZSl7IFxuXHRcdFx0dmFyIHJ1bGUgPSBSdWxlKHNlbGVjdG9yLCBuYW1lKTtcblx0XHRcdFxuXHRcdFx0bGlzdFtsaXN0Lmxlbmd0aF0gPSBydWxlOyBcblx0XHRcdGxpc3Quc29ydChSdWxlLmNvbXBhcmUpOyBcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJ1bGU7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbGlzdDtcblx0fTtcblxuXHR2YXIgaGFuZGxlcnMgPSBbXTtcblx0XG5cdC8qKlxuXHQgKiBBIE5hbWVzcGFjZSBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYWRkaW5nIGVudHdpbmUgbWV0aG9kcyB0byBhIG5hbWVzcGFjZSAoaW5jbHVkaW5nIHRoZSBfbnVsbF8gbmFtZXNwYWNlKVxuXHQgKi9cblx0JC5lbnR3aW5lLk5hbWVzcGFjZSA9IEJhc2UuZXh0ZW5kKHtcblx0XHRpbml0OiBmdW5jdGlvbihuYW1lKXtcblx0XHRcdGlmIChuYW1lICYmICFuYW1lLm1hdGNoKC9eW0EtWmEtejAtOS5dKyQvKSkgJC5lbnR3aW5lLndhcm4oJ0VudHdpbmUgbmFtZXNwYWNlICcrbmFtZSsnIGlzIG5vdCBmb3JtYXR0ZWQgYXMgcGVyaW9kIHNlcGVyYXRlZCBpZGVudGlmaWVycycsICQuZW50d2luZS5XQVJOX0xFVkVMX0JFU1RQUkFDVElTRSk7XG5cdFx0XHRuYW1lID0gbmFtZSB8fCAnX19iYXNlJztcblx0XHRcdFxuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMuc3RvcmUgPSB7fTtcblx0XHRcdFxuXHRcdFx0bmFtZXNwYWNlc1tuYW1lXSA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdGlmIChuYW1lID09IFwiX19iYXNlXCIpIHtcblx0XHRcdFx0dGhpcy5pbmplY3RlZSA9ICQuZm47XG5cdFx0XHRcdHRoaXMuJCA9ICQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gV2UncmUgaW4gYSBuYW1lc3BhY2UsIHNvIHdlIGJ1aWxkIGEgQ2xhc3MgdGhhdCBzdWJjbGFzc2VzIHRoZSBqUXVlcnkgT2JqZWN0IENsYXNzIHRvIGluamVjdCBuYW1lc3BhY2UgZnVuY3Rpb25zIGludG9cblx0XHRcdFx0dGhpcy4kID0gJC5zdWIgPyAkLnN1YigpIDogc3ViKCk7XG5cdFx0XHRcdC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBzdWIoKSAtIHN1YmNsYXNzIG11c3Qgc2hhcmUgY2FjaGUgd2l0aCByb290IG9yIGRhdGEgd29uJ3QgZ2V0IGNsZWFyZWQgYnkgY2xlYW5EYXRhXG5cdFx0XHRcdHRoaXMuJC5jYWNoZSA9ICQuY2FjaGU7XG5cblx0XHRcdFx0dGhpcy5pbmplY3RlZSA9IHRoaXMuJC5wcm90b3R5cGU7XG5cblx0XHRcdFx0Ly8gV2Ugb3ZlcnJpZGUgZW50d2luZSB0byBpbmplY3QgdGhlIG5hbWUgb2YgdGhpcyBuYW1lc3BhY2Ugd2hlbiBkZWZpbmluZyBibG9ja3MgaW5zaWRlIHRoaXMgbmFtZXNwYWNlXG5cdFx0XHRcdHZhciBlbnR3aW5lX3dyYXBwZXIgPSB0aGlzLmluamVjdGVlLmVudHdpbmUgPSBmdW5jdGlvbihzcGFjZW5hbWUpIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIXNwYWNlbmFtZSB8fCB0eXBlb2Ygc3BhY2VuYW1lICE9ICdzdHJpbmcnKSB7IGFyZ3MgPSAkLm1ha2VBcnJheShhcmdzKTsgYXJncy51bnNoaWZ0KG5hbWUpOyB9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoc3BhY2VuYW1lLmNoYXJBdCgwKSAhPSAnLicpIGFyZ3NbMF0gPSBuYW1lKycuJytzcGFjZW5hbWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuICQuZm4uZW50d2luZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuJC5lbnR3aW5lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZW50d2luZV93cmFwcGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tpXSwgYnVpbGRlcjtcblxuXHRcdFx0XHRcdC8vIEluamVjdCBqUXVlcnkgb2JqZWN0IG1ldGhvZCBvdmVycmlkZXNcblx0XHRcdFx0XHRpZiAoYnVpbGRlciA9IGhhbmRsZXIubmFtZXNwYWNlTWV0aG9kT3ZlcnJpZGVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3ZlcnJpZGVzID0gYnVpbGRlcih0aGlzKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGsgaW4gb3ZlcnJpZGVzKSB0aGlzLmluamVjdGVlW2tdID0gb3ZlcnJpZGVzW2tdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJbmplY3QgJC5lbnR3aW5lIGZ1bmN0aW9uIG92ZXJyaWRlc1xuXHRcdFx0XHRcdGlmIChidWlsZGVyID0gaGFuZGxlci5uYW1lc3BhY2VTdGF0aWNPdmVycmlkZXMpIHtcblx0XHRcdFx0XHRcdHZhciBvdmVycmlkZXMgPSBidWlsZGVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBvdmVycmlkZXMpIHRoaXMuJC5lbnR3aW5lW2tdID0gb3ZlcnJpZGVzW2tdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZG9lcyBzZWxlY3RvciBtYXRjaGluZyBhZ2FpbnN0IHRoZSBmdW5jdGlvbiBsaXN0IGZvciBhIGZ1bmN0aW9uIG5hbWVcblx0XHQgKiBVc2VkIGJ5IHByb3h5IGZvciBhbGwgY2FsbHMsIGFuZCBieSBjdG9yUHJveHkgdG8gaGFuZGxlIF9zdXBlciBjYWxsc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZnVuY3Rpb24gYXMgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGZ1bmNwcm9wIC0gdGhlIHByb3BlcnR5IG9uIHRoZSBSdWxlIG9iamVjdCB0aGF0IGdpdmVzIHRoZSBhY3R1YWwgZnVuY3Rpb24gdG8gY2FsbFxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGJhc2VmdW5jIC0gdGhlIG5vbi1lbnR3aW5lIGZ1bmN0aW9uIHRvIHVzZSBhcyB0aGUgY2F0Y2gtYWxsIGZ1bmN0aW9uIGF0IHRoZSBib3R0b20gb2YgdGhlIHN0YWNrXG5cdFx0ICovXG5cdFx0b25lOiBmdW5jdGlvbihuYW1lLCBmdW5jcHJvcCwgYmFzZWZ1bmMpIHtcblx0XHRcdHZhciBuYW1lc3BhY2UgPSB0aGlzO1xuXHRcdFx0dmFyIGZ1bmNzID0gdGhpcy5zdG9yZVtuYW1lXTtcblx0XHRcdFxuXHRcdFx0dmFyIG9uZSA9IGZ1bmN0aW9uKGVsLCBhcmdzLCBpKXtcblx0XHRcdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkgaSA9IGZ1bmNzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChmdW5jc1tpXS5zZWxlY3Rvci5tYXRjaGVzKGVsKSkge1xuXHRcdFx0XHRcdFx0dmFyIHJldCwgdG1wX2kgPSBlbC5pLCB0bXBfZiA9IGVsLmY7XG5cdFx0XHRcdFx0XHRlbC5pID0gaTsgZWwuZiA9IG9uZTtcblx0XHRcdFx0XHRcdHRyeSB7IHJldCA9IGZ1bmNzW2ldW2Z1bmNwcm9wXS5hcHBseShuYW1lc3BhY2UuJChlbCksIGFyZ3MpOyB9XG5cdFx0XHRcdFx0XHRmaW5hbGx5IHsgZWwuaSA9IHRtcF9pOyBlbC5mID0gdG1wX2Y7IH1cblx0XHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgZW50d2luZS1kZWZpbmVkIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXMgYSBub24tZW50d2luZSBmdW5jdGlvbiB0byB1c2UgYXMgYSBiYXNlLCB0cnkgdGhhdFxuXHRcdFx0XHRpZiAoYmFzZWZ1bmMpIHJldHVybiBiYXNlZnVuYy5hcHBseShuYW1lc3BhY2UuJChlbCksIGFyZ3MpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG9uZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgcHJveHkgaXMgYSBmdW5jdGlvbiBhdHRhY2hlZCB0byBhIGNhbGxhYmxlIG9iamVjdCAoZWl0aGVyIHRoZSBiYXNlIGpRdWVyeS5mbiBvciBhIHN1YnNwYWNlIG9iamVjdCkgd2hpY2ggaGFuZGxlc1xuXHRcdCAqIGZpbmRpbmcgYW5kIGNhbGxpbmcgdGhlIGNvcnJlY3QgZnVuY3Rpb24gZm9yIGVhY2ggbWVtYmVyIG9mIHRoZSBjdXJyZW50IGpRdWVyeSBjb250ZXh0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBhcyBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBiYXNlZnVuYyAtIHRoZSBub24tZW50d2luZSBmdW5jdGlvbiB0byB1c2UgYXMgdGhlIGNhdGNoLWFsbCBmdW5jdGlvbiBhdCB0aGUgYm90dG9tIG9mIHRoZSBzdGFja1xuXHRcdCAqL1xuXHRcdGJ1aWxkX3Byb3h5OiBmdW5jdGlvbihuYW1lLCBiYXNlZnVuYykge1xuXHRcdFx0dmFyIG9uZSA9IHRoaXMub25lKG5hbWUsICdmdW5jJywgYmFzZWZ1bmMpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJ4eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcnYsIGN0eCA9ICQodGhpcyk7IFxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGkgPSBjdHgubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSBydiA9IG9uZShjdHhbaV0sIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHJldHVybiBydjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBwcnh5O1xuXHRcdH0sXG5cdFx0XG5cdFx0YmluZF9wcm94eTogZnVuY3Rpb24oc2VsZWN0b3IsIG5hbWUsIGZ1bmMpIHtcblx0XHRcdHZhciBydWxlbGlzdCA9IHRoaXMuc3RvcmVbbmFtZV0gfHwgKHRoaXMuc3RvcmVbbmFtZV0gPSAkLmVudHdpbmUuUnVsZUxpc3QoKSk7XG5cdFx0XHRcblx0XHRcdHZhciBydWxlID0gcnVsZWxpc3QuYWRkUnVsZShzZWxlY3RvciwgbmFtZSk7IHJ1bGUuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcblx0XHRcdGlmICghdGhpcy5pbmplY3RlZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCAhdGhpcy5pbmplY3RlZVtuYW1lXS5pc2VudHdpbmVtZXRob2QpIHtcblx0XHRcdFx0dGhpcy5pbmplY3RlZVtuYW1lXSA9IHRoaXMuYnVpbGRfcHJveHkobmFtZSwgdGhpcy5pbmplY3RlZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMuaW5qZWN0ZWVbbmFtZV0gOiBudWxsKTtcblx0XHRcdFx0dGhpcy5pbmplY3RlZVtuYW1lXS5pc2VudHdpbmVtZXRob2QgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuaW5qZWN0ZWVbbmFtZV0uaXNlbnR3aW5lbWV0aG9kKSB7XG5cdFx0XHRcdCQuZW50d2luZS53YXJuKCdXYXJuaW5nOiBFbnR3aW5lIGZ1bmN0aW9uICcrbmFtZSsnIGNsYXNoZXMgd2l0aCByZWd1bGFyIGpRdWVyeSBmdW5jdGlvbiAtIGVudHdpbmUgZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGFibGUgZGlyZWN0bHkgb24galF1ZXJ5IG9iamVjdCcsICQuZW50d2luZS5XQVJOX0xFVkVMX0lNUE9SVEFOVCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHRhZGQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBkYXRhKSB7XG5cdFx0XHQvLyBGb3IgZXZlcnkgaXRlbSBpbiB0aGUgaGFzaCwgdHJ5IGV2ZXIgbWV0aG9kIGhhbmRsZXIsIHVudGlsIG9uZSByZXR1cm5zIHRydWVcblx0XHRcdGZvciAodmFyIGsgaW4gZGF0YSkge1xuXHRcdFx0XHR2YXIgdiA9IGRhdGFba107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGhhbmRsZXJzW2ldLmJpbmQgJiYgaGFuZGxlcnNbaV0uYmluZC5jYWxsKHRoaXMsIHNlbGVjdG9yLCBrLCB2KSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdGhhczogZnVuY3Rpb24oY3R4LCBuYW1lKSB7XG5cdFx0XHR2YXIgcnVsZWxpc3QgPSB0aGlzLnN0b3JlW25hbWVdO1xuXHRcdFx0aWYgKCFydWxlbGlzdCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHQvKiBXZSBnbyBmb3J3YXJkIHRoaXMgdGltZSwgc2luY2UgbG93IHNwZWNpZml0eSBpcyBsaWtlbHkgdG8ga25vY2sgb3V0IGEgYnVuY2ggb2YgZWxlbWVudHMgcXVpY2tseSAqL1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAgOyBpIDwgcnVsZWxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3R4ID0gY3R4Lm5vdChydWxlbGlzdFtpXS5zZWxlY3Rvcik7XG5cdFx0XHRcdGlmICghY3R4Lmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8qKlxuXHQgKiBBIGhhbmRsZXIgaXMgc29tZSBqYXZhc2NyaXB0IGNvZGUgdGhhdCBhZGRzIHN1cHBvcnQgZm9yIHNvbWUgdGltZSBvZiBrZXkgLyB2YWx1ZSBwYWlyIHBhc3NlZCBpbiB0aGUgaGFzaCB0byB0aGUgTmFtZXNwYWNlIGFkZCBtZXRob2QuXG5cdCAqIFRoZSBkZWZhdWx0IGhhbmRsZXJzIHByb3ZpZGVkIChhbmQgaW5jbHVkZWQgYnkgZGVmYXVsdCkgYXJlIGV2ZW50LCBjdG9yIGFuZCBwcm9wZXJ0aWVzXG5cdCAqL1xuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZEhhbmRsZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGggJiYgaGFuZGxlcnNbaV0ub3JkZXIgPCBoYW5kbGVyLm9yZGVyOyBpKyspIHsgLyogUGFzcyAqLyB9XG5cdFx0aGFuZGxlcnMuc3BsaWNlKGksIDAsIGhhbmRsZXIpO1xuXHR9O1xuXHRcblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyKHtcblx0XHRvcmRlcjogNTAsXG5cdFx0XG5cdFx0YmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIGssIHYpe1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbih2KSkge1xuXHRcdFx0XHR0aGlzLmJpbmRfcHJveHkoc2VsZWN0b3IsIGssIHYpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdCQuZXh0ZW5kKCQuZm4sIHtcblx0XHQvKipcblx0XHQgKiBNYWluIGVudHdpbmUgZnVuY3Rpb24uIFVzZWQgZm9yIG5ldyBkZWZpbml0aW9ucywgY2FsbGluZyBpbnRvIGEgbmFtZXNwYWNlIChvciBmb3JjaW5nIHRoZSBiYXNlIG5hbWVzcGFjZSkgYW5kIGVudGVyaW5nIGEgdXNpbmcgYmxvY2tcblx0XHQgKiBcblx0XHQgKi9cblx0XHRlbnR3aW5lOiBmdW5jdGlvbihzcGFjZW5hbWUpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdC8qIERvbid0IGFjdHVhbGx5IHdvcmsgb3V0IHNlbGVjdG9yIHVudGlsIHdlIHRyeSBhbmQgZGVmaW5lIHNvbWV0aGluZyBvbiBpdCAtIHdlIG1pZ2h0IGJlIG9wZW5pbmcgYSBuYW1lc3BhY2Ugb24gYW4gZnVuY3Rpb24tdHJhdmVyZXNlZCBvYmplY3Rcblx0XHRcdCAgIHdoaWNoIGhhdmUgbm9uLXN0YW5kYXJkIHNlbGVjdG9ycyBsaWtlIC5wYXJlbnRzKC5mb28pLnNsaWNlKDAsMSkgKi9cblx0XHRcdHZhciBzZWxlY3RvciA9IG51bGw7ICBcblx0XHRcblx0XHRcdC8qIEJ5IGRlZmF1bHQgd2Ugb3BlcmF0b3Igb24gdGhlIGJhc2UgbmFtZXNwYWNlICovXG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gbmFtZXNwYWNlcy5fX2Jhc2UgfHwgJC5lbnR3aW5lLk5hbWVzcGFjZSgpO1xuXHRcdFx0XG5cdFx0XHQvKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHRoZW4gaXQncyB0aGUgbmFtZSBvZiBhIG5hbWVzcGFjZS4gTG9vayBpdCB1cCAqL1xuXHRcdFx0aWYgKHR5cGVvZiBzcGFjZW5hbWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKHNwYWNlbmFtZS5jaGFyQXQoJzAnKSA9PSAnLicpIHNwYWNlbmFtZSA9IHNwYWNlbmFtZS5zdWJzdHIoMSk7XG5cdFx0XHRcdGlmIChzcGFjZW5hbWUpIG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbc3BhY2VuYW1lXSB8fCAkLmVudHdpbmUuTmFtZXNwYWNlKHNwYWNlbmFtZSk7XG5cdFx0XHRcdGk9MTtcblx0XHRcdH1cblx0XHRcblx0XHRcdC8qIEFsbCByZW1haW5pbmcgYXJndW1lbnRzIHNob3VsZCBlaXRoZXIgYmUgdXNpbmcgYmxvY2tzIG9yIGRlZmluaXRpb24gaGFzaHMgKi9cblx0XHRcdHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgcmVzID0gYXJndW1lbnRzW2krK107XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiBpdCdzIGEgZnVuY3Rpb24sIGNhbGwgaXQgLSBlaXRoZXIgaXQncyBhIHVzaW5nIGJsb2NrIG9yIGl0J3MgYSBuYW1lc3BhY2VkIGVudHdpbmUgZGVmaW5pdGlvblxuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHJlcykpIHtcblx0XHRcdFx0XHRpZiAocmVzLmxlbmd0aCAhPSAxKSAkLmVudHdpbmUud2FybignRnVuY3Rpb24gYmxvY2sgaW5zaWRlIGVudHdpbmUgZGVmaW5pdGlvbiBkb2VzIG5vdCB0YWtlICQgYXJndW1lbnQgcHJvcGVybHknLCAkLmVudHdpbmUuV0FSTl9MRVZFTF9JTVBPUlRBTlQpO1xuXHRcdFx0XHRcdHJlcyA9IHJlcy5jYWxsKG5hbWVzcGFjZS4kKHRoaXMpLCBuYW1lc3BhY2UuJCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBlbnR3aW5lIGRlZmluaXRpb24gaGFzaCwgaW5qZWN0IGl0IGludG8gbmFtZXNwYWNlXG5cdFx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0XHRpZiAoc2VsZWN0b3IgPT09IG51bGwpIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/ICQuc2VsZWN0b3IodGhpcy5zZWxlY3RvcikgOiBmYWxzZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoc2VsZWN0b3IpIG5hbWVzcGFjZS5hZGQoc2VsZWN0b3IsIHJlcyk7XG5cdFx0XHRcdFx0ZWxzZSAkLmVudHdpbmUud2FybignRW50d2luZSBibG9jayBnaXZlbiB0byBlbnR3aW5lIGNhbGwgd2l0aG91dCBzZWxlY3Rvci4gTWFrZSBzdXJlIHlvdSBjYWxsICQoc2VsZWN0b3IpLmVudHdpbmUgd2hlbiBkZWZpbmluZyBibG9ja3MnLCAkLmVudHdpbmUuV0FSTl9MRVZFTF9JTVBPUlRBTlQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvKiBGaW5hbGx5LCByZXR1cm4gdGhlIGpRdWVyeSBvYmplY3QgJ3RoaXMnIHJlZmVycyB0bywgd3JhcHBlZCBpbiB0aGUgbmV3IG5hbWVzcGFjZSAqL1xuXHRcdFx0cmV0dXJuIG5hbWVzcGFjZS4kKHRoaXMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIENhbGxzIHRoZSBuZXh0IG1vc3Qgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBlbnR3aW5lIG1ldGhvZFxuXHRcdCAqL1xuXHRcdF9zdXBlcjogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBydiwgaSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzWzBdO1xuXHRcdFx0XHRydiA9IGVsLmYoZWwsIGFyZ3VtZW50cywgZWwuaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXHR9KTtcblx0XG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHNyYy9kb21ldmVudHMvanF1ZXJ5LmVudHdpbmUuZG9tZXZlbnRzLmFkZHJlbS5qcyAqL1xuXG4oZnVuY3Rpb24oJCl7XG5cblx0Ly8gR2V0cyBhbGwgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIGEgcGFydGljdWxhciBlbGVtZW50cywgc3RvcmVzIGl0IGluIGFuIGFycmF5XG5cdGZ1bmN0aW9uIGdldEVsZW1lbnRzKHN0b3JlLCBvcmlnaW5hbCkge1xuXHRcdHZhciBub2RlLCBpID0gc3RvcmUubGVuZ3RoLCBuZXh0ID0gb3JpZ2luYWwuZmlyc3RDaGlsZDtcblxuXHRcdHdoaWxlICgobm9kZSA9IG5leHQpKSB7XG5cdFx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgc3RvcmVbaSsrXSA9IG5vZGU7XG5cdFx0XHRuZXh0ID0gbm9kZS5maXJzdENoaWxkIHx8IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHR3aGlsZSAoIW5leHQgJiYgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpICYmIG5vZGUgIT09IG9yaWdpbmFsKSBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblxuXHQvLyBUaGlzIG1pZ2h0IGJlIGZhc3Rlcj8gT3Igc2xvd2VyPyBAdG9kbzogYmVuY2htYXJrLlxuXHRmdW5jdGlvbiBnZXRFbGVtZW50c0FsdChzdG9yZSwgbm9kZSkge1xuXHRcdGlmIChub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG5cdFx0XHR2YXIgZWxzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLCBsZW4gPSBlbHMubGVuZ3RoLCBpID0gMCwgaiA9IHN0b3JlLmxlbmd0aDtcblx0XHRcdGZvcig7IGkgPCBsZW47IGkrKywgaisrKSB7XG5cdFx0XHRcdHN0b3JlW2pdID0gZWxzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChub2RlLmNoaWxkTm9kZXMpIHtcblx0XHRcdHZhciBlbHMgPSBub2RlLmNoaWxkTm9kZXMsIGxlbiA9IGVscy5sZW5ndGgsIGkgPSAwO1xuXHRcdFx0Zm9yKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGdldEVsZW1lbnRzKHN0b3JlLCBlbHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBkb250VHJpZ2dlciA9IGZhbHNlO1xuXG5cdHZhciBwYXRjaERvbU1hbmlwQ2FsbGJhY2sgPSBmdW5jdGlvbihvcmlnaW5hbCkge1xuXHRcdHZhciBwYXRjaGVkID0gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgYWRkZWQgPSBbXTtcblxuXHRcdFx0aWYgKCFkb250VHJpZ2dlcikge1xuXHRcdFx0XHRpZiAoZWxlbS5ub2RlVHlwZSA9PSAxKSBhZGRlZFthZGRlZC5sZW5ndGhdID0gZWxlbTtcblx0XHRcdFx0Z2V0RWxlbWVudHMoYWRkZWQsIGVsZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcnYgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRpZiAoIWRvbnRUcmlnZ2VyICYmIGFkZGVkLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCdFbnR3aW5lRWxlbWVudHNBZGRlZCcpO1xuXHRcdFx0XHRldmVudC50YXJnZXRzID0gYWRkZWQ7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblx0XHRwYXRjaGVkLnBhdGNoZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHBhdGNoZWQ7XG5cdH1cblxuXHR2YXIgdmVyc2lvbiA9ICQucHJvdG90eXBlLmpxdWVyeS5zcGxpdCgnLicpO1xuXHR2YXIgY2FsbGJhY2tJZHggPSAodmVyc2lvblswXSA+IDEgfHwgdmVyc2lvblsxXSA+PSAxMCA/IDEgOiAyKTtcblxuXHQvLyBNb25rZXkgcGF0Y2ggJC5mbi5kb21NYW5pcCB0byBjYXRjaCBhbGwgcmVndWxhciBqUXVlcnkgYWRkIGVsZW1lbnQgY2FsbHNcblx0dmFyIF9kb21NYW5pcCA9ICQucHJvdG90eXBlLmRvbU1hbmlwO1xuXHQkLnByb3RvdHlwZS5kb21NYW5pcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghYXJndW1lbnRzW2NhbGxiYWNrSWR4XS5wYXRjaGVkKSBhcmd1bWVudHNbY2FsbGJhY2tJZHhdID0gcGF0Y2hEb21NYW5pcENhbGxiYWNrKGFyZ3VtZW50c1tjYWxsYmFja0lkeF0pO1xuXHRcdHJldHVybiBfZG9tTWFuaXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXG5cdC8vIE1vbmtleSBwYXRjaCAkLmZuLmh0bWwgdG8gY2F0Y2ggd2hlbiBqUXVlcnkgc2V0cyBpbm5lckhUTUwgZGlyZWN0bHlcblx0dmFyIF9odG1sID0gJC5wcm90b3R5cGUuaHRtbDtcblx0JC5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBfaHRtbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0ZG9udFRyaWdnZXIgPSB0cnVlO1xuXHRcdHZhciByZXMgPSBfaHRtbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdGRvbnRUcmlnZ2VyID0gZmFsc2U7XG5cblx0XHR2YXIgYWRkZWQgPSBbXTtcblxuXHRcdHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKyApIGdldEVsZW1lbnRzKGFkZGVkLCB0aGlzW2ldKTtcblxuXHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ0VudHdpbmVFbGVtZW50c0FkZGVkJyk7XG5cdFx0ZXZlbnQudGFyZ2V0cyA9IGFkZGVkO1xuXHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKGV2ZW50KTtcblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvLyBJZiB0aGlzIGlzIHRydWUsIHdlJ3ZlIGNoYW5nZWQgc29tZXRoaW5nIHRvIGNhbGwgY2xlYW5EYXRhIHNvIHRoYXQgd2UgY2FuIGNhdGNoIHRoZSBlbGVtZW50cywgYnV0IHdlIGRvbid0XG5cdC8vIHdhbnQgdG8gY2FsbCB0aGUgdW5kZXJseWluZyBvcmlnaW5hbCAkLmNsZWFuRGF0YVxuXHR2YXIgc3VwcmVzc0FjdHVhbENsZWFuID0gZmFsc2U7XG5cblx0Ly8gTW9ua2V5IHBhdGNoICQuY2xlYW5EYXRhIHRvIGNhdGNoIGVsZW1lbnQgcmVtb3ZhbFxuXHR2YXIgX2NsZWFuRGF0YSA9ICQuY2xlYW5EYXRhO1xuXHQkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHQvLyBCeSBkZWZhdWx0IHdlIGNhbiBhc3N1bWUgYWxsIGVsZW1lbnRzIHBhc3NlZCBhcmUgbGVnaXRpbWF0ZWx5IGJlaW5nIHJlbW92ZWVkXG5cdFx0dmFyIHJlbW92ZWQgPSBlbGVtcztcblxuXHRcdC8vIEV4Y2VwdCBpZiB3ZSdyZSBzdXByZXNzaW5nIGFjdHVhbCBjbGVhbiAtIHdlIG1pZ2h0IGJlIGJlaW5nIGNhbGxlZCBieSBqUXVlcnkgXCJiZWluZyBjYXJlZnVsXCIgYWJvdXQgZGV0YWNoaW5nIG5vZGVzXG5cdFx0Ly8gYmVmb3JlIGF0dGFjaGluZyB0aGVtLiBTbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVzZSBub2RlcyBjdXJyZW50bHkgYXJlIGluIGEgZG9jdW1lbnRcblx0XHRpZiAoc3VwcmVzc0FjdHVhbENsZWFuKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aCwgcmVtb3ZlZCA9IFtdLCByaSA9IDA7XG5cdFx0XHRmb3IoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIG5vZGUgPSBlbGVtc1tpXSwgY3VycmVudCA9IG5vZGU7XG5cdFx0XHRcdHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnQubm9kZVR5cGUgPT0gOSkgeyByZW1vdmVkW3JpKytdID0gbm9kZTsgYnJlYWs7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCkge1xuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCgnRW50d2luZUVsZW1lbnRzUmVtb3ZlZCcpO1xuXHRcdFx0ZXZlbnQudGFyZ2V0cyA9IHJlbW92ZWQ7XG5cdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihldmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFzdXByZXNzQWN0dWFsQ2xlYW4pIF9jbGVhbkRhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXG5cdC8vIE1vbmtleSBwYXRjaCAkLmZuLnJlbW92ZSB0byBjYXRjaCB3aGVuIHdlJ3JlIGp1c3QgZGV0YWNoaW5nIChrZWVwZGF0YSA9PSAxKSAtXG5cdC8vIHRoaXMgZG9lc24ndCBjYWxsIGNsZWFuRGF0YSBidXQgc3RpbGwgbmVlZHMgdG8gdHJpZ2dlciBldmVudFxuXHR2YXIgX3JlbW92ZSA9ICQucHJvdG90eXBlLnJlbW92ZTtcblx0JC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGtlZXBkYXRhKSB7XG5cdFx0c3VwcmVzc0FjdHVhbENsZWFuID0ga2VlcGRhdGE7XG5cdFx0dmFyIHJ2ID0gX3JlbW92ZS5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRzdXByZXNzQWN0dWFsQ2xlYW4gPSBmYWxzZTtcblx0XHRyZXR1cm4gcnY7XG5cdH1cblxuXHQvLyBBbmQgb24gRE9NIHJlYWR5LCB0cmlnZ2VyIGFkZGluZyBvbmNlXG5cdCQoZnVuY3Rpb24oKXtcblx0XHR2YXIgYWRkZWQgPSBbXTsgZ2V0RWxlbWVudHMoYWRkZWQsIGRvY3VtZW50KTtcblxuXHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ0VudHdpbmVFbGVtZW50c0FkZGVkJyk7XG5cdFx0ZXZlbnQudGFyZ2V0cyA9IGFkZGVkO1xuXHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKGV2ZW50KTtcblx0fSk7XG5cblxufSkoalF1ZXJ5KTs7XG5cblxuLyogc3JjL2RvbWV2ZW50cy9qcXVlcnkuZW50d2luZS5kb21ldmVudHMubWF5YmVjaGFuZ2VkLmpzICovXG5cbihmdW5jdGlvbigkKXtcblxuXHQvKiogVXRpbGl0eSBmdW5jdGlvbiB0byBtb25rZXktcGF0Y2ggYSBqUXVlcnkgbWV0aG9kICovXG5cdHZhciBtb25rZXkgPSBmdW5jdGlvbiggLyogbWV0aG9kLCBtZXRob2QsIC4uLi4sIHBhdGNoICovKXtcblx0XHR2YXIgbWV0aG9kcyA9ICQubWFrZUFycmF5KGFyZ3VtZW50cyk7XG5cdFx0dmFyIHBhdGNoID0gbWV0aG9kcy5wb3AoKTtcblxuXHRcdCQuZWFjaChtZXRob2RzLCBmdW5jdGlvbihpLCBtZXRob2Qpe1xuXHRcdFx0dmFyIG9sZCA9ICQuZm5bbWV0aG9kXTtcblxuXHRcdFx0JC5mblttZXRob2RdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcywgYXJncyA9ICQubWFrZUFycmF5KGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0dmFyIHJ2ID0gb2xkLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdFx0XHRwYXRjaC5hcHBseShzZWxmLCBhcmdzKTtcblx0XHRcdFx0cmV0dXJuIHJ2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqIFdoYXQgdG8gY2FsbCB0byBydW4gYSBmdW5jdGlvbiAnc29vbicuIE5vcm1hbGx5IHNldFRpbWVvdXQsIGJ1dCBmb3Igc3luY3Jvbm91cyBtb2RlIHdlIG92ZXJyaWRlIHNvIHNvb24gPT09IG5vdyAqL1xuXHR2YXIgcnVuU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXHRcblx0LyoqIFRoZSB0aW1lciBoYW5kbGUgZm9yIHRoZSBhc3luY3Jvbm91cyBtYXRjaGluZyBjYWxsICovXG5cdHZhciBDaGFuZ2VEZXRhaWxzID0gQmFzZS5leHRlbmQoe1xuXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdsb2JhbCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hdHRycyA9IHt9O1xuXHRcdFx0dGhpcy5jbGFzc2VzID0ge307XG5cdFx0fSxcblxuXHRcdC8qKiBGaXJlIHRoZSBjaGFuZ2UgZXZlbnQuIE9ubHkgZmlyZXMgb24gdGhlIGRvY3VtZW50IG5vZGUsIHNvIGJpbmQgdG8gdGhhdCAqL1xuXHRcdHRyaWdnZXJFdmVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB3ZSdyZSBub3QgdGhlIGFjdGl2ZSBjaGFuZ2VzIGluc3RhbmNlIGFueSBtb3JlLCBkb24ndCB0cmlnZ2VyXG5cdFx0XHRpZiAoY2hhbmdlcyAhPSB0aGlzKSByZXR1cm47XG5cblx0XHRcdC8vIENhbmNlbCBhbnkgcGVuZGluZyB0aW1lb3V0IChpZiB3ZSdyZSBkaXJlY3RseSBjYWxsZWQgaW4gdGhlIG1lYW4gdGltZSlcblx0XHRcdGlmICh0aGlzLmNoZWNrX2lkKSBjbGVhclRpbWVvdXQodGhpcy5jaGVja19pZCk7XG5cblx0XHRcdC8vIFJlc2V0IHRoZSBnbG9iYWwgY2hhbmdlcyBvYmplY3QgdG8gYmUgYSBuZXcgaW5zdGFuY2UgKGRvIGJlZm9yZSB0cmlnZ2VyLCBpbiBjYXNlIHRyaWdnZXIgZmlyZXMgY2hhbmdlcyBpdHNlbGYpXG5cdFx0XHRjaGFuZ2VzID0gbmV3IENoYW5nZURldGFpbHMoKTtcblxuXHRcdFx0Ly8gRmlyZSBldmVudFxuXHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJFbnR3aW5lU3VidHJlZU1heWJlQ2hhbmdlZFwiLCBbdGhpc10pO1xuXHRcdH0sXG5cblx0XHRjaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5jaGVja19pZCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuY2hlY2tfaWQgPSBydW5Tb29uKGZ1bmN0aW9uKCl7IHNlbGYuY2hlY2tfaWQgPSBudWxsOyBzZWxmLnRyaWdnZXJFdmVudCgpOyB9LCAxMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFkZEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5nbG9iYWwpIHJldHVybiB0aGlzOyAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZsYWdnZWQgYXMgYSBnbG9iYWwgY2hhbmdlLCBqdXN0IHNraXBcblxuXHRcdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xuXHRcdFx0dGhpcy5jaGFuZ2VkKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0YWRkU3VidHJlZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQWxsKCk7XG5cdFx0fSxcblxuXHRcdC8qIEZvciBub3cgd2UgZG9uJ3QgZG8gdGhpcy4gSXQncyBleHBlbnNpdmUsIGFuZCBqcXVlcnkuZW50d2luZS5jdG9ycyBkb2Vzbid0IHVzZSB0aGlzIGluZm9ybWF0aW9uIGFueXdheSAqL1xuXHRcdGFkZFN1YnRyZWVGdXR1cmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmICh0aGlzLmdsb2JhbCkgcmV0dXJuIHRoaXM7IC8vIElmIHdlJ3ZlIGFscmVhZHkgZmxhZ2dlZCBhcyBhIGdsb2JhbCBjaGFuZ2UsIGp1c3Qgc2tpcFxuXG5cdFx0XHR0aGlzLnN1YnRyZWUgPSB0aGlzLnN1YnRyZWUgPyB0aGlzLnN1YnRyZWUuYWRkKG5vZGUpIDogJChub2RlKTtcblx0XHRcdHRoaXMuY2hhbmdlZCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGFkZEF0dHI6IGZ1bmN0aW9uKGF0dHIsIG5vZGUpIHtcblx0XHRcdGlmICh0aGlzLmdsb2JhbCkgcmV0dXJuIHRoaXM7XG5cblx0XHRcdHRoaXMuYXR0cnNbYXR0cl0gPSAoYXR0ciBpbiB0aGlzLmF0dHJzKSA/IHRoaXMuYXR0cnNbYXR0cl0uYWRkKG5vZGUpIDogJChub2RlKTtcblx0XHRcdHRoaXMuY2hhbmdlZCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGFkZENsYXNzOiBmdW5jdGlvbihrbGFzcywgbm9kZSkge1xuXHRcdFx0aWYgKHRoaXMuZ2xvYmFsKSByZXR1cm4gdGhpcztcblxuXHRcdFx0dGhpcy5jbGFzc2VzW2tsYXNzXSA9IChrbGFzcyBpbiB0aGlzLmNsYXNzZXMpID8gdGhpcy5jbGFzc2VzW2tsYXNzXS5hZGQobm9kZSkgOiAkKG5vZGUpO1xuXHRcdFx0dGhpcy5jaGFuZ2VkKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0pO1xuXG5cdHZhciBjaGFuZ2VzID0gbmV3IENoYW5nZURldGFpbHMoKTtcblxuXHQvLyBFbGVtZW50IGFkZCBldmVudHMgdHJpZ2dlciBtYXliZWNoYW5nZWQgZXZlbnRzXG5cblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZUVsZW1lbnRzQWRkZWQnLCBmdW5jdGlvbihlKXsgY2hhbmdlcy5hZGRTdWJ0cmVlKGUudGFyZ2V0cyk7IH0pO1xuXG5cdC8vIEVsZW1lbnQgcmVtb3ZlIGV2ZW50cyB0cmlnZ2VyIG1heWJlY2hhbmdlZCBldmVudHMsIGJ1dCB3ZSBoYXZlIHRvIHdhaXQgdW50aWwgYWZ0ZXIgdGhlIG5vZGVzIGFyZSBhY3R1YWxseSByZW1vdmVkXG5cdC8vIChFbnR3aW5lRWxlbWVudHNSZW1vdmVkIGZpcmVzIF9qdXN0IGJlZm9yZV8gdGhlIGVsZW1lbnRzIGFyZSByZW1vdmVkIHNvIHRoZSBkYXRhIHN0aWxsIGV4aXN0cyksIGVzcGVjaWFsbHkgaW4gc3luY3Jvbm91cyBtb2RlXG5cblx0dmFyIHJlbW92ZWQgPSBudWxsO1xuXHQkKGRvY3VtZW50KS5iaW5kKCdFbnR3aW5lRWxlbWVudHNSZW1vdmVkJywgZnVuY3Rpb24oZSl7IHJlbW92ZWQgPSBlLnRhcmdldHM7IH0pO1xuXG5cdG1vbmtleSgncmVtb3ZlJywgJ2h0bWwnLCAnZW1wdHknLCBmdW5jdGlvbigpe1xuXHRcdHZhciBzdWJ0cmVlID0gcmVtb3ZlZDsgcmVtb3ZlZCA9IG51bGw7XG5cdFx0aWYgKHN1YnRyZWUpIGNoYW5nZXMuYWRkU3VidHJlZShzdWJ0cmVlKTtcblx0fSk7XG5cblx0Ly8gV2UgYWxzbyBuZWVkIHRvIGtub3cgd2hlbiBhbiBhdHRyaWJ1dGUsIGNsYXNzLCBldGMgY2hhbmdlcy4gUGF0Y2ggdGhlIHJlbGV2YW50IGpRdWVyeSBtZXRob2RzIGhlcmVcblxuXHRtb25rZXkoJ3JlbW92ZUF0dHInLCBmdW5jdGlvbihhdHRyKXtcblx0XHRjaGFuZ2VzLmFkZEF0dHIoYXR0ciwgdGhpcyk7XG5cdH0pO1xuXG5cdG1vbmtleSgnYWRkQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCBmdW5jdGlvbihrbGFzcyl7XG5cdFx0aWYgKHR5cGVvZiBrbGFzcyA9PSAnc3RyaW5nJykgY2hhbmdlcy5hZGRDbGFzcyhrbGFzcywgdGhpcyk7XG5cdH0pO1xuXG5cdG1vbmtleSgnYXR0cicsIGZ1bmN0aW9uKGEsIGIpe1xuXHRcdGlmIChiICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGEgPT0gJ3N0cmluZycpIGNoYW5nZXMuYWRkQXR0cihhLCB0aGlzKTtcblx0XHRlbHNlIGlmICh0eXBlb2YgYSAhPSAnc3RyaW5nJykgeyBmb3IgKHZhciBrIGluIGEpIGNoYW5nZXMuYWRkQXR0cihrLCB0aGlzKTsgfVxuXHR9KTtcblxuXHQvLyBBZGQgc29tZSB1c2VmdWxsIGFjY2Vzc29ycyB0byAkLmVudHdpbmVcblxuXHQkLmV4dGVuZCgkLmVudHdpbmUsIHtcblx0XHQvKipcblx0XHQgKiBNYWtlIG9ubWF0Y2ggYW5kIG9udW5tYXRjaCB3b3JrIGluIHN5bmNocm9ub3VzIG1vZGUgLSB0aGF0IGlzLCBuZXcgZWxlbWVudHMgd2lsbCBiZSBkZXRlY3RlZCBpbW1lZGlhdGVseSBhZnRlclxuXHRcdCAqIHRoZSBET00gbWFuaXB1bGF0aW9uIHRoYXQgbWFkZSB0aGVtIG1hdGNoLiBUaGlzIGlzIG9ubHkgcmVhbGx5IHVzZWZ1bCBmb3IgZHVyaW5nIHRlc3RpbmcsIHNpbmNlIGl0J3MgcHJldHR5IHNsb3dcblx0XHQgKiAob3RoZXJ3aXNlIHdlJ2QgbWFrZSBpdCB0aGUgZGVmYXVsdCkuXG5cdFx0ICovXG5cdFx0c3luY2hyb25vdXNfbW9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoY2hhbmdlcyAmJiBjaGFuZ2VzLmNoZWNrX2lkKSBjbGVhclRpbWVvdXQoY2hhbmdlcy5jaGVja19pZCk7XG5cdFx0XHRjaGFuZ2VzID0gbmV3IENoYW5nZURldGFpbHMoKTtcblxuXHRcdFx0cnVuU29vbiA9IGZ1bmN0aW9uKGZ1bmMsIGRlbGF5KXsgZnVuYy5jYWxsKHRoaXMpOyByZXR1cm4gbnVsbDsgfTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBvbm1hdGNoIGFuZCBvbnVubWF0Y2ggbm93IC0gdXNlZnVsbCBmb3IgYWZ0ZXIgRE9NIG1hbmlwdWxhdGlvbiBieSBtZXRob2RzIG90aGVyIHRoYW4gdGhyb3VnaCBqUXVlcnkuXG5cdFx0ICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgb24gZG9jdW1lbnQucmVhZHlcblx0XHQgKi9cblx0XHR0cmlnZ2VyTWF0Y2hpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2hhbmdlcy5hZGRBbGwoKTtcblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpOztcblxuXG4vKiBzcmMvanF1ZXJ5LmVudHdpbmUuZXZlbnRzLmpzICovXG5cbihmdW5jdGlvbigkKSB7XHRcblxuXHQvKiogVGFrZW4gZnJvbSBqUXVlcnkgMS41LjIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICovXG5cdGlmICgkLnN1cHBvcnQuY2hhbmdlQnViYmxlcyA9PSB1bmRlZmluZWQpIHtcblx0XHQkLnN1cHBvcnQuY2hhbmdlQnViYmxlcyA9IHRydWU7XG5cblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGV2ZW50TmFtZSA9IFwib25jaGFuZ2VcIjtcblxuXHRcdGlmIChlbC5hdHRhY2hFdmVudCkge1xuXHRcdFx0dmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBlbCk7XG5cdFx0XHRpZiAoIWlzU3VwcG9ydGVkKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZShldmVudE5hbWUsIFwicmV0dXJuO1wiKTtcblx0XHRcdFx0aXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxbZXZlbnROYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuXHRcdFx0fVxuXG5cdFx0XHQkLnN1cHBvcnQuY2hhbmdlQnViYmxlcyA9IGlzU3VwcG9ydGVkO1xuXHRcdH1cblx0fVxuXG5cdC8qIFJldHVybiB0cnVlIGlmIG5vZGUgYiBpcyB0aGUgc2FtZSBhcywgb3IgaXMgYSBkZXNjZW5kYW50IG9mLCBub2RlIGEgKi9cblx0aWYgKGRvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG5cdFx0dmFyIGlzX29yX2NvbnRhaW5zID0gZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgJiYgYiAmJiAoYSA9PSBiIHx8ICEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAxNikpO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0dmFyIGlzX29yX2NvbnRhaW5zID0gZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgJiYgYiAmJiAoYSA9PSBiIHx8IChhLmNvbnRhaW5zID8gYS5jb250YWlucyhiKSA6IHRydWUpKTtcblx0XHR9O1xuXHR9XG5cblx0LyogQWRkIHRoZSBtZXRob2RzIHRvIGhhbmRsZSBldmVudCBiaW5kaW5nIHRvIHRoZSBOYW1lc3BhY2UgY2xhc3MgKi9cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRNZXRob2RzKHtcblx0XHRidWlsZF9ldmVudF9wcm94eTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIG9uZSA9IHRoaXMub25lKG5hbWUsICdmdW5jJyk7XG5cdFx0XHRcblx0XHRcdHZhciBwcnh5ID0gZnVuY3Rpb24oZSwgZGF0YSkge1xuXHRcdFx0XHQvLyBGb3IgZXZlbnRzIHRoYXQgZG8gbm90IGJ1YmJsZSB3ZSBtYW51YWxseSB0cmlnZ2VyIGRlbGVnYXRpb24gKHNlZSBkZWxlZ2F0ZV9zdWJtaXQgYmVsb3cpIFxuXHRcdFx0XHQvLyBJZiB0aGlzIGV2ZW50IGlzIGEgbWFudWFsIHRyaWdnZXIsIHRoZSBldmVudCB3ZSBhY3R1YWxseSB3YW50IHRvIGJ1YmJsZSBpcyBhdHRhY2hlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBwYXNzZWQgZXZlbnRcblx0XHRcdFx0ZSA9IGUuZGVsZWdhdGVkRXZlbnQgfHwgZTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBlbCA9IGUudGFyZ2V0O1xuXHRcdFx0XHR3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgPT0gMSAmJiAhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IG9uZShlbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRpZiAocmV0ICE9PSB1bmRlZmluZWQpIGUucmVzdWx0ID0gcmV0O1xuXHRcdFx0XHRcdGlmIChyZXQgPT09IGZhbHNlKSB7IGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHByeHk7XG5cdFx0fSxcblx0XHRcblx0XHRidWlsZF9tb3VzZWVudGVybGVhdmVfcHJveHk6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBvbmUgPSB0aGlzLm9uZShuYW1lLCAnZnVuYycpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJ4eSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dmFyIGVsID0gZS50YXJnZXQ7XG5cdFx0XHRcdHZhciByZWwgPSBlLnJlbGF0ZWRUYXJnZXQ7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgPT0gMSAmJiAhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG5cdFx0XHRcdFx0LyogV2Uga25vdyBlbCBjb250YWluZWQgdGFyZ2V0LiBJZiBpdCBhbHNvIGNvbnRhaW5zIHJlbGF0ZWRUYXJnZXQgdGhlbiB3ZSBkaWRuJ3QgbW91c2VlbnRlciAvIGxlYXZlLiBXaGF0J3MgbW9yZSwgZXZlcnkgYW5jZXN0b3Igd2lsbCBhbHNvXG5cdFx0XHRcdFx0Y29udGFuIGVsIGFuZCByZWwsIGFuZCBzbyB3ZSBjYW4ganVzdCBzdG9wIGJ1YmJsaW5nICovXG5cdFx0XHRcdFx0aWYgKGlzX29yX2NvbnRhaW5zKGVsLCByZWwpKSBicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgcmV0ID0gb25lKGVsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdGlmIChyZXQgIT09IHVuZGVmaW5lZCkgZS5yZXN1bHQgPSByZXQ7XG5cdFx0XHRcdFx0aWYgKHJldCA9PT0gZmFsc2UpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcHJ4eTtcblx0XHR9LFxuXHRcdFxuXHRcdGJ1aWxkX2NoYW5nZV9wcm94eTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIG9uZSA9IHRoaXMub25lKG5hbWUsICdmdW5jJyk7XG5cblx0XHRcdC8qXG5cdFx0XHRUaGlzIGNoYW5nZSBidWJibGUgZW11bGF0aW9uIGNvZGUgaXMgdGFrZW4gbW9zdGx5IGZyb20galF1ZXJ5IDEuNiAtIHVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgZWFzaWx5IHJldXNlIGFueSBvZlxuXHRcdFx0aXQgd2l0aG91dCBkdXBsaWNhdGlvbiwgc28gd2UnbGwgaGF2ZSB0byByZS1taWdyYXRlIGFueSBidWdmaXhlc1xuXHRcdFx0Ki9cblxuXHRcdFx0Ly8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBpdGVtLiBJc24ndCBzdXBwb3NlZCB0byBiZSBpbnRlcnByZXRhYmxlLCBqdXN0IHN0YWJsZSBmb3Igc29tZSB2YWx1ZSwgYW5kIGRpZmZlcmVudFxuXHRcdFx0Ly8gb25jZSB0aGUgdmFsdWUgY2hhbmdlc1xuXHRcdFx0dmFyIGdldFZhbCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IGVsZW0udHlwZSwgdmFsID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuXHRcdFx0XHRcdHZhbCA9IGVsZW0uY2hlY2tlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlID09PSBcInNlbGVjdC1tdWx0aXBsZVwiKSB7XG5cdFx0XHRcdFx0dmFsID0gXCJcIjtcblx0XHRcdFx0XHRpZiAoZWxlbS5zZWxlY3RlZEluZGV4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoZWxlbS5vcHRpb25zLCBmdW5jdGlvbihlbGVtKXsgcmV0dXJuIGVsZW0uc2VsZWN0ZWQ7IH0pLmpvaW4oXCItXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJzZWxlY3RcIikpIHtcblx0XHRcdFx0XHR2YWwgPSBlbGVtLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGVzdCBpZiBhIG5vZGUgbmFtZSBpcyBhIGZvcm0gaW5wdXRcblx0XHRcdHZhciByZm9ybUVsZW1zID0gL14oPzp0ZXh0YXJlYXxpbnB1dHxzZWxlY3QpJC9pO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGlzIGV2ZW50IGlzIGEgY2hhbmdlLCBhbmQgYnViYmxlIHRoZSBjaGFuZ2UgZXZlbnQgaWYgaXQgaXNcblx0XHRcdHZhciB0ZXN0Q2hhbmdlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0LCBkYXRhLCB2YWw7XG5cblx0XHRcdFx0aWYgKCFyZm9ybUVsZW1zLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHwgZWxlbS5yZWFkT25seSkgcmV0dXJuO1xuXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YShlbGVtLCBcIl9lbnR3aW5lX2NoYW5nZV9kYXRhXCIpO1xuXHRcdFx0XHR2YWwgPSBnZXRWYWwoZWxlbSk7XG5cblx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgZGF0YSB3aWxsIGJlIGFsc28gcmV0cmlldmVkIGJ5IGJlZm9yZWFjdGl2YXRlXG5cdFx0XHRcdGlmIChlLnR5cGUgIT09IFwiZm9jdXNvdXRcIiB8fCBlbGVtLnR5cGUgIT09IFwicmFkaW9cIikge1xuXHRcdFx0XHRcdGpRdWVyeS5kYXRhKGVsZW0sIFwiX2VudHdpbmVfY2hhbmdlX2RhdGFcIiwgdmFsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBkYXRhKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKGRhdGEgIT0gbnVsbCB8fCB2YWwpIHtcblx0XHRcdFx0XHRlLnR5cGUgPSBcImNoYW5nZVwiO1xuXG5cdFx0XHRcdFx0d2hpbGUgKGVsZW0gJiYgZWxlbS5ub2RlVHlwZSA9PSAxICYmICFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcblx0XHRcdFx0XHRcdHZhciByZXQgPSBvbmUoZWxlbSwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGlmIChyZXQgIT09IHVuZGVmaW5lZCkgZS5yZXN1bHQgPSByZXQ7XG5cdFx0XHRcdFx0XHRpZiAocmV0ID09PSBmYWxzZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cblxuXHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIFRoZSBhY3R1YWwgcHJveHkgLSByZXNwb25kcyB0byBzZXZlcmFsIGV2ZW50cywgc29tZSBvZiB3aGljaCB0cmlnZXIgYSBjaGFuZ2UgY2hlY2ssIHNvbWVcblx0XHRcdC8vIG9mIHdoaWNoIGp1c3Qgc3RvcmUgdGhlIHZhbHVlIGZvciBmdXR1cmUgY2hhbmdlIGNoZWNrc1xuXHRcdFx0dmFyIHByeHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IGUudHlwZSwgZWxlbSA9IGUudGFyZ2V0LCB0eXBlID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSA/IGVsZW0udHlwZSA6IFwiXCI7XG5cblx0XHRcdFx0c3dpdGNoIChldmVudCkge1xuXHRcdFx0XHRcdGNhc2UgJ2ZvY3Vzb3V0Jzpcblx0XHRcdFx0XHRjYXNlICdiZWZvcmVkZWFjdGl2YXRlJzpcblx0XHRcdFx0XHRcdHRlc3RDaGFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY2xpY2snOlxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHRcdFx0XHR0ZXN0Q2hhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdC8vIENoYW5nZSBoYXMgdG8gYmUgY2FsbGVkIGJlZm9yZSBzdWJtaXRcblx0XHRcdFx0XHQvLyBLZXlkb3duIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBrZXlwcmVzcywgd2hpY2ggaXMgdXNlZCBpbiBzdWJtaXQtZXZlbnQgZGVsZWdhdGlvblxuXHRcdFx0XHRcdGNhc2UgJ2tleWRvd24nOlxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHQoZS5rZXlDb2RlID09PSAxMyAmJiAhalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRleHRhcmVhXCIgKSApIHx8XG5cdFx0XHRcdFx0XHRcdChlLmtleUNvZGUgPT09IDMyICYmICh0eXBlID09PSBcImNoZWNrYm94XCIgfHwgdHlwZSA9PT0gXCJyYWRpb1wiKSkgfHxcblx0XHRcdFx0XHRcdFx0dHlwZSA9PT0gXCJzZWxlY3QtbXVsdGlwbGVcIlxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHRlc3RDaGFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gQmVmb3JlYWN0aXZhdGUgaGFwcGVucyBhbHNvIGJlZm9yZSB0aGUgcHJldmlvdXMgZWxlbWVudCBpcyBibHVycmVkXG5cdFx0XHRcdFx0Ly8gd2l0aCB0aGlzIGV2ZW50IHlvdSBjYW4ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBidXQgeW91IGNhbiBzdG9yZVxuXHRcdFx0XHRcdC8vIGluZm9ybWF0aW9uXG5cdFx0XHRcdFx0Y2FzZSAnZm9jdXNpbic6XG5cdFx0XHRcdFx0Y2FzZSAnYmVmb3JlYWN0aXZhdGUnOlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW0sIFwiX2VudHdpbmVfY2hhbmdlX2RhdGFcIiwgZ2V0VmFsKGVsZW0pICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJ4eTtcblx0XHR9LFxuXHRcdFxuXHRcdGJpbmRfZXZlbnQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBuYW1lLCBmdW5jLCBldmVudCkge1xuXHRcdFx0dmFyIGZ1bmNzID0gdGhpcy5zdG9yZVtuYW1lXSB8fCAodGhpcy5zdG9yZVtuYW1lXSA9ICQuZW50d2luZS5SdWxlTGlzdCgpKSA7XG5cdFx0XHR2YXIgcHJveGllcyA9IGZ1bmNzLnByb3hpZXMgfHwgKGZ1bmNzLnByb3hpZXMgPSB7fSk7XG5cdFx0XHRcblx0XHRcdHZhciBydWxlID0gZnVuY3MuYWRkUnVsZShzZWxlY3RvciwgbmFtZSk7IHJ1bGUuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcblx0XHRcdGlmICghcHJveGllc1tuYW1lXSkge1xuXHRcdFx0XHRzd2l0Y2ggKG5hbWUpIHtcblx0XHRcdFx0XHRjYXNlICdvbm1vdXNlZW50ZXInOlxuXHRcdFx0XHRcdFx0cHJveGllc1tuYW1lXSA9IHRoaXMuYnVpbGRfbW91c2VlbnRlcmxlYXZlX3Byb3h5KG5hbWUpO1xuXHRcdFx0XHRcdFx0ZXZlbnQgPSAnbW91c2VvdmVyJztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ29ubW91c2VsZWF2ZSc6XG5cdFx0XHRcdFx0XHRwcm94aWVzW25hbWVdID0gdGhpcy5idWlsZF9tb3VzZWVudGVybGVhdmVfcHJveHkobmFtZSk7XG5cdFx0XHRcdFx0XHRldmVudCA9ICdtb3VzZW91dCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdvbmNoYW5nZSc6XG5cdFx0XHRcdFx0XHRpZiAoISQuc3VwcG9ydC5jaGFuZ2VCdWJibGVzKSB7XG5cdFx0XHRcdFx0XHRcdHByb3hpZXNbbmFtZV0gPSB0aGlzLmJ1aWxkX2NoYW5nZV9wcm94eShuYW1lKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSAnY2xpY2sga2V5ZG93biBmb2N1c2luIGZvY3Vzb3V0IGJlZm9yZWFjdGl2YXRlIGJlZm9yZWRlYWN0aXZhdGUnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnb25zdWJtaXQnOlxuXHRcdFx0XHRcdFx0ZXZlbnQgPSAnZGVsZWdhdGVkU3VibWl0Jztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ29uZm9jdXMnOlxuXHRcdFx0XHRcdGNhc2UgJ29uYmx1cic6XG5cdFx0XHRcdFx0XHQkLmVudHdpbmUud2FybignRXZlbnQgJytldmVudCsnIG5vdCBzdXBwb3J0ZWQgLSB1c2luZyBmb2N1c2luIC8gZm9jdXNvdXQgaW5zdGVhZCcsICQuZW50d2luZS5XQVJOX0xFVkVMX0lNUE9SVEFOVCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIG5vbmUgb2YgdGhlIHNwZWNpYWwgaGFuZGxlcnMgY3JlYXRlZCBhIHByb3h5LCB1c2UgdGhlIGdlbmVyaWMgcHJveHlcblx0XHRcdFx0aWYgKCFwcm94aWVzW25hbWVdKSBwcm94aWVzW25hbWVdID0gdGhpcy5idWlsZF9ldmVudF9wcm94eShuYW1lKTtcblxuXHRcdFx0XHQkKGRvY3VtZW50KS5iaW5kKGV2ZW50LnJlcGxhY2UoLyhcXHMrfCQpL2csICcuZW50d2luZSQxJyksIHByb3hpZXNbbmFtZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdFxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZEhhbmRsZXIoe1xuXHRcdG9yZGVyOiA0MCxcblx0XHRcblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgaywgdil7XG5cdFx0XHR2YXIgbWF0Y2gsIGV2ZW50O1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbih2KSAmJiAobWF0Y2ggPSBrLm1hdGNoKC9eb24oLiopLykpKSB7XG5cdFx0XHRcdGV2ZW50ID0gbWF0Y2hbMV07XG5cdFx0XHRcdHRoaXMuYmluZF9ldmVudChzZWxlY3RvciwgaywgdiwgZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRcblx0Ly8gRmluZCBhbGwgZm9ybXMgYW5kIGJpbmQgb25zdWJtaXQgdG8gdHJpZ2dlciBvbiB0aGUgZG9jdW1lbnQgdG9vLiBcblx0Ly8gVGhpcyBpcyB0aGUgb25seSBldmVudCB0aGF0IGNhbid0IGJlIGdyYWJiZWQgdmlhIGRlbGVnYXRpb25cblx0XG5cdHZhciBkZWxlZ2F0ZV9zdWJtaXQgPSBmdW5jdGlvbihlLCBkYXRhKXtcblx0XHR2YXIgZGVsZWdhdGlvbkV2ZW50ID0gJC5FdmVudCgnZGVsZWdhdGVkU3VibWl0Jyk7IGRlbGVnYXRpb25FdmVudC5kZWxlZ2F0ZWRFdmVudCA9IGU7XG5cdFx0cmV0dXJuICQoZG9jdW1lbnQpLnRyaWdnZXIoZGVsZWdhdGlvbkV2ZW50LCBkYXRhKTsgXG5cdH07XG5cblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZUVsZW1lbnRzQWRkZWQnLCBmdW5jdGlvbihlKXtcblx0XHR2YXIgZm9ybXMgPSAkKGUudGFyZ2V0cykuZmlsdGVyKCdmb3JtJyk7XG5cdFx0aWYgKCFmb3Jtcy5sZW5ndGgpIHJldHVybjtcblxuXHRcdGZvcm1zLmJpbmQoJ3N1Ym1pdC5lbnR3aW5lX2RlbGVnYXRlX3N1Ym1pdCcsIGRlbGVnYXRlX3N1Ym1pdCk7XG5cdH0pO1xuXG59KShqUXVlcnkpO1xuXHQ7XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmV2ZW50Y2FwdHVyZS5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkTWV0aG9kcyh7XG5cdFx0YmluZF9jYXB0dXJlOiBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnQsIG5hbWUsIGNhcHR1cmUpIHtcblx0XHRcdHZhciBzdG9yZSAgPSB0aGlzLmNhcHR1cmVzIHx8ICh0aGlzLmNhcHR1cmVzID0ge30pO1xuXHRcdFx0dmFyIHJ1bGVsaXN0cyA9IHN0b3JlW2V2ZW50XSB8fCAoc3RvcmVbZXZlbnRdID0ge30pO1xuXHRcdFx0dmFyIHJ1bGVsaXN0ID0gcnVsZWxpc3RzW25hbWVdIHx8IChydWxlbGlzdHNbbmFtZV0gPSAkLmVudHdpbmUuUnVsZUxpc3QoKSk7XG5cblx0XHRcdHZhciBydWxlID0gcnVsZWxpc3QuYWRkUnVsZShzZWxlY3RvciwgZXZlbnQpO1xuXHRcdFx0cnVsZS5oYW5kbGVyID0gbmFtZTtcblxuXHRcdFx0dGhpcy5iaW5kX3Byb3h5KHNlbGVjdG9yLCBuYW1lLCBjYXB0dXJlKTtcblx0XHR9XG5cdH0pO1xuXG5cdHZhciBiaW5kaW5ncyA9ICQuZW50d2luZS5jYXB0dXJlX2JpbmRpbmdzID0ge307XG5cblx0dmFyIGV2ZW50X3Byb3h5ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSwgY2FwdHVyZWxpc3RzLCBmb3JldmVudCwgY2FwdHVyZWxpc3QsIHJ1bGUsIGhhbmRsZXIsIHNlbDtcblxuXHRcdFx0Zm9yICh2YXIgayBpbiAkLmVudHdpbmUubmFtZXNwYWNlcykge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSAkLmVudHdpbmUubmFtZXNwYWNlc1trXTtcblx0XHRcdFx0Y2FwdHVyZWxpc3RzID0gbmFtZXNwYWNlLmNhcHR1cmVzO1xuXG5cdFx0XHRcdGlmIChjYXB0dXJlbGlzdHMgJiYgKGZvcmV2ZW50ID0gY2FwdHVyZWxpc3RzW2V2ZW50XSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIGZvcmV2ZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgY2FwdHVyZWxpc3QgPSBmb3JldmVudFtrXTtcblx0XHRcdFx0XHRcdHZhciB0cmlnZ2VyZWQgPSBuYW1lc3BhY2UuJChbXSk7XG5cblx0XHRcdFx0XHRcdC8vIFN0ZXBwaW5nIHRocm91Z2ggZWFjaCBzZWxlY3RvciBmcm9tIG1vc3QgdG8gbGVhc3Qgc3BlY2lmaWNcblx0XHRcdFx0XHRcdHZhciBqID0gY2FwdHVyZWxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0XHRydWxlID0gY2FwdHVyZWxpc3Rbal07XG5cdFx0XHRcdFx0XHRcdGhhbmRsZXIgPSBydWxlLmhhbmRsZXI7XG5cdFx0XHRcdFx0XHRcdHNlbCA9IHJ1bGUuc2VsZWN0b3Iuc2VsZWN0b3I7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1hdGNoaW5nID0gbmFtZXNwYWNlLiQoc2VsKS5ub3QodHJpZ2dlcmVkKTtcblx0XHRcdFx0XHRcdFx0bWF0Y2hpbmdbaGFuZGxlcl0uYXBwbHkobWF0Y2hpbmcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0XHRcdFx0dHJpZ2dlcmVkID0gdHJpZ2dlcmVkLmFkZChtYXRjaGluZyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBzZWxlY3Rvcl9wcm94eSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBoYW5kbGVyLCBpbmNsdWRlY2hpbGRyZW4pIHtcblx0XHR2YXIgbWF0Y2hlciA9ICQuc2VsZWN0b3Ioc2VsZWN0b3IpO1xuXHRcdHJldHVybiBmdW5jdGlvbihlKXtcblx0XHRcdGlmIChtYXRjaGVyLm1hdGNoZXMoZS50YXJnZXQpKSByZXR1cm4gaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgZG9jdW1lbnRfcHJveHkgPSBmdW5jdGlvbihzZWxlY3RvciwgaGFuZGxlciwgaW5jbHVkZWNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKGUudGFyZ2V0ID09PSBkb2N1bWVudCkgcmV0dXJuIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHdpbmRvd19wcm94eSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBoYW5kbGVyLCBpbmNsdWRlY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZSl7XG5cdFx0XHRpZiAoZS50YXJnZXQgPT09IHdpbmRvdykgcmV0dXJuIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHByb3BlcnR5X3Byb3h5ID0gZnVuY3Rpb24ocHJvcGVydHksIGhhbmRsZXIsIGluY2x1ZGVjaGlsZHJlbikge1xuXHRcdHZhciBtYXRjaGVyO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyIG1hdGNoID0gdGhpc1snZ2V0Jytwcm9wZXJ0eV0oKTtcblxuXHRcdFx0aWYgKHR5cGVvZihtYXRjaCkgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSAobWF0Y2hlciAmJiBtYXRjaCA9PSBtYXRjaGVyLnNlbGVjdG9yKSA/IG1hdGNoZXIgOiAkLnNlbGVjdG9yKG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXIubWF0Y2hlcyhlLnRhcmdldCkpIHJldHVybiBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCQuaW5BcnJheShlLnRhcmdldCwgbWF0Y2gpICE9PSAtMSkgcmV0dXJuIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyKHtcblx0XHRvcmRlcjogMTAsXG5cblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgaywgdikge1xuXHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0aWYgKCQuaXNQbGFpbk9iamVjdCh2KSAmJiAobWF0Y2ggPSBrLm1hdGNoKC9eZnJvbVxccyooLiopLykpKSB7XG5cdFx0XHRcdHZhciBmcm9tID0gbWF0Y2hbMV07XG5cdFx0XHRcdHZhciBwcm94eUdlbjtcblxuXHRcdFx0XHRpZiAoZnJvbS5tYXRjaCgvW15cXHddLykpIHByb3h5R2VuID0gc2VsZWN0b3JfcHJveHk7XG5cdFx0XHRcdGVsc2UgaWYgKGZyb20gPT0gJ1dpbmRvdycgfHwgZnJvbSA9PSAnd2luZG93JykgcHJveHlHZW4gPSB3aW5kb3dfcHJveHk7XG5cdFx0XHRcdGVsc2UgaWYgKGZyb20gPT0gJ0RvY3VtZW50JyB8fCBmcm9tID09ICdkb2N1bWVudCcpIHByb3h5R2VuID0gZG9jdW1lbnRfcHJveHk7XG5cdFx0XHRcdGVsc2UgcHJveHlHZW4gPSBwcm9wZXJ0eV9wcm94eTtcblxuXHRcdFx0XHRmb3IgKHZhciBvbmV2ZW50IGluIHYpIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlciA9IHZbb25ldmVudF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBvbmV2ZW50Lm1hdGNoKC9eb24oLiopLyk7XG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gbWF0Y2hbMV07XG5cblx0XHRcdFx0XHR0aGlzLmJpbmRfY2FwdHVyZShzZWxlY3RvciwgZXZlbnQsIGsgKyAnXycgKyBldmVudCwgcHJveHlHZW4oZnJvbSwgaGFuZGxlcikpO1xuXG5cdFx0XHRcdFx0aWYgKCFiaW5kaW5nc1tldmVudF0pIHtcblx0XHRcdFx0XHRcdHZhciBuYW1lc3BhY2VkID0gZXZlbnQucmVwbGFjZSgvKFxccyt8JCkvZywgJy5lbnR3aW5lJDEnKTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzW2V2ZW50XSA9IGV2ZW50X3Byb3h5KGV2ZW50KTtcblxuXHRcdFx0XHRcdFx0JChwcm94eUdlbiA9PSB3aW5kb3dfcHJveHkgPyB3aW5kb3cgOiBkb2N1bWVudCkuYmluZChuYW1lc3BhY2VkLCBiaW5kaW5nc1tldmVudF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG47XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmN0b3JzLmpzICovXG5cbihmdW5jdGlvbigkKSB7XHRcblxuXHQvKiBBZGQgdGhlIG1ldGhvZHMgdG8gaGFuZGxlIGNvbnN0cnVjdG9yICYgZGVzdHJ1Y3RvciBiaW5kaW5nIHRvIHRoZSBOYW1lc3BhY2UgY2xhc3MgKi9cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRNZXRob2RzKHtcblx0XHRiaW5kX2NvbmRlc2M6IGZ1bmN0aW9uKHNlbGVjdG9yLCBuYW1lLCBmdW5jKSB7XG5cdFx0XHR2YXIgY3RvcnMgPSB0aGlzLnN0b3JlLmN0b3JzIHx8ICh0aGlzLnN0b3JlLmN0b3JzID0gJC5lbnR3aW5lLlJ1bGVMaXN0KCkpIDtcblx0XHRcdFxuXHRcdFx0dmFyIHJ1bGU7XG5cdFx0XHRmb3IgKHZhciBpID0gMCA7IGkgPCBjdG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoY3RvcnNbaV0uc2VsZWN0b3Iuc2VsZWN0b3IgPT0gc2VsZWN0b3Iuc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRydWxlID0gY3RvcnNbaV07IGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXJ1bGUpIHtcblx0XHRcdFx0cnVsZSA9IGN0b3JzLmFkZFJ1bGUoc2VsZWN0b3IsICdjdG9ycycpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRydWxlW25hbWVdID0gZnVuYztcblx0XHRcdFxuXHRcdFx0aWYgKCFjdG9yc1tuYW1lKydwcm94eSddKSB7XG5cdFx0XHRcdHZhciBvbmUgPSB0aGlzLm9uZSgnY3RvcnMnLCBuYW1lKTtcblx0XHRcdFx0dmFyIG5hbWVzcGFjZSA9IHRoaXM7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgcHJveHkgPSBmdW5jdGlvbihlbHMsIGksIGZ1bmMpIHtcblx0XHRcdFx0XHR2YXIgaiA9IGVscy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0dmFyIGVsID0gZWxzW2pdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgdG1wX2kgPSBlbC5pLCB0bXBfZiA9IGVsLmY7XG5cdFx0XHRcdFx0XHRlbC5pID0gaTsgZWwuZiA9IG9uZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dHJ5ICAgICAgeyBmdW5jLmNhbGwobmFtZXNwYWNlLiQoZWwpKTsgfVxuXHRcdFx0XHRcdFx0Y2F0Y2goZSkgeyAkLmVudHdpbmUud2Fybl9leGNlcHRpb24obmFtZSwgZWwsIGUpOyB9IFxuXHRcdFx0XHRcdFx0ZmluYWxseSAgeyBlbC5pID0gdG1wX2k7IGVsLmYgPSB0bXBfZjsgfVx0XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjdG9yc1tuYW1lKydwcm94eSddID0gcHJveHk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0XG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkSGFuZGxlcih7XG5cdFx0b3JkZXI6IDMwLFxuXHRcdFxuXHRcdGJpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrLCB2KSB7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHYpICYmIChrID09ICdvbm1hdGNoJyB8fCBrID09ICdvbnVubWF0Y2gnKSkge1xuXHRcdFx0XHQvLyBXaGVuIHdlIGFkZCBuZXcgbWF0Y2hlcnMgd2UgbmVlZCB0byB0cmlnZ2VyIGEgZnVsbCBnbG9iYWwgcmVjYWxjIG9uY2UsIHJlZ2FyZGxlc3Mgb2YgdGhlIERPTSBjaGFuZ2VzIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudFxuXHRcdFx0XHR0aGlzLm1hdGNoZXJzRGlydHkgPSB0cnVlO1xuXG5cdFx0XHRcdHRoaXMuYmluZF9jb25kZXNjKHNlbGVjdG9yLCBrLCB2KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogRmluZHMgYWxsIHRoZSBlbGVtZW50cyB0aGF0IG5vdyBtYXRjaCBhIGRpZmZlcmVudCBydWxlIChvciBoYXZlIGJlZW4gcmVtb3ZlZCkgYW5kIGNhbGwgb25tYXRjaCBvbiBvbnVubWF0Y2ggYXMgYXBwcm9wcmlhdGVcblx0ICogXG5cdCAqIEJlY2F1c2UgdGhpcyBoYXMgdG8gc2NhbiB0aGUgRE9NLCBhbmQgaXMgdGhlcmVmb3JlIGZhaXJseSBzbG93LCB0aGlzIGlzIG5vcm1hbGx5IHRyaWdnZXJlZCBvZmYgYSBzaG9ydCB0aW1lb3V0LCBzbyB0aGF0XG5cdCAqIGEgc2VyaWVzIG9mIERPTSBtYW5pcHVsYXRpb25zIHdpbGwgb25seSB0cmlnZ2VyIHRoaXMgb25jZS5cblx0ICogXG5cdCAqIFRoZSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoYXQgdGhpbmdzIGxpa2U6XG5cdCAqICAgJCgnI2ZvbycpLmFkZENsYXNzKCd0YWJzJyk7ICQoJyNmb28nKS50YWJGdW5jdGlvbkJhcigpO1xuXHQgKiB3b24ndCB3b3JrLlxuXHQgKi9cblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZVN1YnRyZWVNYXliZUNoYW5nZWQnLCBmdW5jdGlvbihlLCBjaGFuZ2VzKXtcblx0XHQvLyB2YXIgc3RhcnQgPSAobmV3IERhdGUpLmdldFRpbWUoKTtcblxuXHRcdC8vIEZvciBldmVyeSBuYW1lc3BhY2Vcblx0XHRmb3IgKHZhciBrIGluICQuZW50d2luZS5uYW1lc3BhY2VzKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gJC5lbnR3aW5lLm5hbWVzcGFjZXNba107XG5cblx0XHRcdC8vIFRoYXQgaGFzIGNvbnN0cnVjdG9ycyBvciBkZXN0cnVjdG9yc1xuXHRcdFx0dmFyIGN0b3JzID0gbmFtZXNwYWNlLnN0b3JlLmN0b3JzO1xuXHRcdFx0aWYgKGN0b3JzKSB7XG5cdFx0XHRcblx0XHRcdFx0Ly8gS2VlcCBhIHJlY29yZCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgbWF0Y2hlZCBzb21lIHByZXZpb3VzIG1vcmUgc3BlY2lmaWMgcnVsZS5cblx0XHRcdFx0Ly8gTm90IHRoYXQgd2UgX2Rvbid0XyBhY3R1YWxseSBkbyB0aGF0IHVudGlsIHRoaXMgaXMgbmVlZGVkLiBJZiBtYXRjaGVkIGlzIG51bGwsIGl0J3Mgbm90IGJlZW4gY2FsY3VsYXRlZCB5ZXQuXG5cdFx0XHRcdC8vIFdlIGFsc28ga2VlcCB0cmFjayBvZiBhbnkgZWxlbWVudHMgdGhhdCBoYXZlIG5ld2x5IGJlZW4gdGFrZW4gb3IgcmVsZWFzZWQgYnkgYSBzcGVjaWZpYyBydWxlXG5cdFx0XHRcdHZhciBtYXRjaGVkID0gbnVsbCwgdGFrZW4gPSAkKFtdKSwgcmVsZWFzZWQgPSAkKFtdKTtcblxuXHRcdFx0XHQvLyBVcGRhdGVzIG1hdGNoZWQgdG8gY29udGFpbiBhbGwgdGhlIHByZXZpb3VzbHkgbWF0Y2hlZCBlbGVtZW50cyBhcyBpZiB3ZSdkIGJlZW4ga2VlcGluZyB0cmFjayBhbGwgYWxvbmdcblx0XHRcdFx0dmFyIGNhbGNtYXRjaGVkID0gZnVuY3Rpb24oail7XG5cdFx0XHRcdFx0aWYgKG1hdGNoZWQgIT09IG51bGwpIHJldHVybjtcblx0XHRcdFx0XHRtYXRjaGVkID0gJChbXSk7XG5cblx0XHRcdFx0XHR2YXIgY2FjaGUsIGsgPSBjdG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCgtLWspID4gaikge1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlID0gY3RvcnNba10uY2FjaGUpIG1hdGNoZWQgPSBtYXRjaGVkLmFkZChjYWNoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU29tZSBkZWNsYXJlZCB2YXJpYWJsZXMgdXNlZCBpbiB0aGUgbG9vcFxuXHRcdFx0XHR2YXIgYWRkLCByZW0sIHJlcywgcnVsZSwgc2VsLCBjdG9yLCBkdG9yLCBmdWxsO1xuXG5cdFx0XHRcdC8vIFN0ZXBwaW5nIHRocm91Z2ggZWFjaCBzZWxlY3RvciBmcm9tIG1vc3QgdG8gbGVhc3Qgc3BlY2lmaWNcblx0XHRcdFx0dmFyIGogPSBjdG9ycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHQvLyBCdWlsZCBzb21lIHF1aWNrLWFjY2VzcyB2YXJpYWJsZXNcblx0XHRcdFx0XHRydWxlID0gY3RvcnNbal07XG5cdFx0XHRcdFx0c2VsID0gcnVsZS5zZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdFx0XHRjdG9yID0gcnVsZS5vbm1hdGNoOyBcblx0XHRcdFx0XHRkdG9yID0gcnVsZS5vbnVubWF0Y2g7XG5cblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0UnVsZS5jYWNoZSBtaWdodCBiZSBzdGFsZSBvciBmcmVzaC4gSXQnbGwgYmUgc3RhbGUgaWZcblx0XHRcdFx0XHQgICAtIHNvbWUgbW9yZSBzcGVjaWZpYyBzZWxlY3RvciBub3cgaGFzIHNvbWUgb2YgcnVsZS5jYWNoZSBpbiBpdFxuXHRcdFx0XHRcdFx0LSBzb21lIGNoYW5nZSBoYXMgaGFwcGVuZWQgdGhhdCBtZWFucyBuZXcgZWxlbWVudHMgbWF0Y2ggdGhpcyBzZWxlY3RvciBub3dcblx0XHRcdFx0XHRcdC0gc29tZSBjaGFuZ2UgaGFzIGhhcHBlbmVkIHRoYXQgbWVhbnMgZWxlbWVudHMgbm8gbG9uZ2VyIG1hdGNoIHRoaXMgc2VsZWN0b3JcblxuXHRcdFx0XHRcdFx0VGhlIGZpcnN0IHdlIGNhbiBqdXN0IGNvbXBhcmUgcnVsZXMuY2FjaGUgd2l0aCBtYXRjaGVkLCByZW1vdmluZyBhbnl0aGluZyB0aGF0J3MgdGhlcmUgYWxyZWFkeS5cblx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIFwiZWxlbWVudHMgdGhhdCBtYXRjaCB0aGlzIHNlbGVjdG9yIGFuZCBubyBtb3JlIHNwZWNpZmljIHNlbGVjdG9yIHdpdGggYW4gb25tYXRjaCBydWxlXCIgdG8gbnVsbC5cblx0XHRcdFx0XHQvLyBTdGF5aW5nIG51bGwgbWVhbnMgdGhpcyBzZWxlY3RvciBpcyBmcmVzaC5cblx0XHRcdFx0XHRyZXMgPSBudWxsO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBnZXRzIGNoYW5nZWQgdG8gdHJ1ZSwgaXQncyB0b28gaGFyZCB0byBkbyBhIGRlbHRhIHVwZGF0ZSwgc28gZG8gYSBmdWxsIHVwZGF0ZVxuXHRcdFx0XHRcdGZ1bGwgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmIChuYW1lc3BhY2UubWF0Y2hlcnNEaXJ0eSB8fCBjaGFuZ2VzLmdsb2JhbCkge1xuXHRcdFx0XHRcdFx0Ly8gRm9yIG5vdywganVzdCBmYWxsIGJhY2sgdG8gb2xkIHZlcnNpb24uIFdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgY2hhbmdlZC5TdWJ0cmVlLmZpbmQoJyonKS5hbmRTZWxmKCkuZmlsdGVyKHNlbCksIGJ1dCB0aGF0J3MgX3dheV8gc2xvd2VyIG9uIG1vZGVybiBicm93c2VycyB0aGFuIHRoZSBiZWxvd1xuXHRcdFx0XHRcdFx0ZnVsbCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgZGVhbCB3aXRoIGF0dHJpYnV0ZXMgeWV0LCBzbyBhbnkgYXR0cmlidXRlIGNoYW5nZSBtZWFucyB3ZSBuZWVkIHRvIGRvIGEgZnVsbCByZWNhbGNcblx0XHRcdFx0XHRcdGZvciAodmFyIGsgaW4gY2hhbmdlcy5hdHRycykge1x0ZnVsbCA9IHRydWU7IGJyZWFrOyB9XG5cblx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHQgSWYgYSBjbGFzcyBjaGFuZ2VzLCBidXQgaXQgaXNuJ3QgbGlzdGVkIGluIG91ciBzZWxlY3Rvciwgd2UgZG9uJ3QgY2FyZSAtIHRoZSBjaGFuZ2UgY291bGRuJ3QgYWZmZWN0IHdoZXRoZXIgb3Igbm90IGFueSBlbGVtZW50IG1hdGNoZXNcblxuXHRcdFx0XHRcdFx0IElmIGl0IGlzIGxpc3RlZCBvbiBvdXIgc2VsZWN0b3Jcblx0XHRcdFx0XHRcdFx0LSBJZiBpdCBpcyBvbiB0aGUgZGlyZWN0IG1hdGNoIHBhcnQsIGl0IGNvdWxkIGhhdmUgYWRkZWQgb3IgcmVtb3ZlZCB0aGUgbm9kZSBpdCBjaGFuZ2VkIG9uXG5cdFx0XHRcdFx0XHRcdC0gSWYgaXQgaXMgb24gdGhlIGNvbnRleHQgcGFydCwgaXQgY291bGQgaGF2ZSBhZGRlZCBvciByZW1vdmVkIGFueSBub2RlIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluY2x1ZGVkIG9yIGV4Y2x1ZGVkIGJlY2F1c2Ugb2YgYSBtYXRjaCBvciBmYWlsdXJlIHRvIG1hdGNoIHdpdGggdGhlIGNvbnRleHQgcmVxdWlyZWQgb24gdGhhdCBub2RlXG5cdFx0XHRcdFx0XHRcdC0gTk9URTogSXQgbWlnaHQgYmUgb24gX2JvdGhfXG5cdFx0XHRcdFx0XHQgKi9cblxuXHRcdFx0XHRcdFx0dmFyIG1ldGhvZCA9IHJ1bGUuc2VsZWN0b3IuYWZmZWN0ZWRCeShjaGFuZ2VzKTtcblxuXHRcdFx0XHRcdFx0aWYgKG1ldGhvZC5jbGFzc2VzLmNvbnRleHQpIHtcblx0XHRcdFx0XHRcdFx0ZnVsbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBtZXRob2QuY2xhc3Nlcy5kaXJlY3QpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxjbWF0Y2hlZChqKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVjaGVjayA9IGNoYW5nZXMuY2xhc3Nlc1trXS5ub3QobWF0Y2hlZCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocmVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMgPSBydWxlLmNhY2hlID8gcnVsZS5jYWNoZS5ub3QodGFrZW4pLmFkZChyZWxlYXNlZC5maWx0ZXIoc2VsKSkgOiAkKFtdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRyZXMgPSByZXMubm90KHJlY2hlY2spLmFkZChyZWNoZWNrLmZpbHRlcihzZWwpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChmdWxsKSB7XG5cdFx0XHRcdFx0XHRjYWxjbWF0Y2hlZChqKTtcblx0XHRcdFx0XHRcdHJlcyA9ICQoc2VsKS5ub3QobWF0Y2hlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCFyZXMpIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2Ugd2VyZW4ndCBzdGFsZSBiZWNhdXNlIG9mIGFueSBjaGFuZ2VzIHRvIHRoZSBET00gdGhhdCBhZmZlY3RlZCB0aGlzIHNlbGVjdG9yLCBidXQgbW9yZSBzcGVjaWZpY1xuXHRcdFx0XHRcdFx0XHQvLyBvbm1hdGNoZXMgbWlnaHQgaGF2ZSBjYXVzZWQgc3RhbGUtbmVzc1xuXG5cdFx0XHRcdFx0XHRcdC8vIERvIGFueSBvZiB0aGUgcHJldmlvdXMgcmVsZWFzZWQgZWxlbWVudHMgbWF0Y2ggdGhpcyBzZWxlY3Rvcj9cblx0XHRcdFx0XHRcdFx0YWRkID0gcmVsZWFzZWQubGVuZ3RoICYmIHJlbGVhc2VkLmZpbHRlcihzZWwpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChhZGQgJiYgYWRkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFllcywgc28gd2UncmUgc3RhbGUgYXMgd2UgbmVlZCB0byBpbmNsdWRlIHRoZW0uIEZpbHRlciBmb3IgYW55IHBvc3NpYmxlIHRha2VuIHZhbHVlIGF0IHRoZSBzYW1lIHRpbWVcblx0XHRcdFx0XHRcdFx0XHRyZXMgPSBydWxlLmNhY2hlID8gcnVsZS5jYWNoZS5ub3QodGFrZW4pLmFkZChhZGQpIDogYWRkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIERvIHdlIHRoaW5rIHdlIG93biBhbnkgb2YgdGhlIGVsZW1lbnRzIG5vdyB0YWtlbiBieSBtb3JlIHNwZWNpZmljIHJ1bGVzP1xuXHRcdFx0XHRcdFx0XHRcdHJlbSA9IHRha2VuLmxlbmd0aCAmJiBydWxlLmNhY2hlICYmIHJ1bGUuY2FjaGUuZmlsdGVyKHRha2VuKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChyZW0gJiYgcmVtLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gWWVzLCBzbyB3ZSdyZSBzdGFsZSBhcyB3ZSBuZWVkIHRvIGV4Y2x1ZGUgdGhlbS5cblx0XHRcdFx0XHRcdFx0XHRcdHJlcyA9IHJ1bGUuY2FjaGUubm90KHJlbSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVzIHdpbGwgYmUgbnVsbCBpZiB3ZSBrbm93IHdlIGFyZSBmcmVzaCAobm8gZnVsbCBuZWVkZWQsIHNlbGVjdG9yIG5vdCBhZmZlY3RlZEJ5IGNoYW5nZXMpXG5cdFx0XHRcdFx0aWYgKHJlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIHRyYWNraW5nIG1hdGNoZWQsIGFkZCBvdXJzZWx2ZXNcblx0XHRcdFx0XHRcdGlmIChtYXRjaGVkICYmIHJ1bGUuY2FjaGUpIG1hdGNoZWQgPSBtYXRjaGVkLmFkZChydWxlLmNhY2hlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGlzIHNlbGVjdG9yIGhhcyBhIGxpc3Qgb2YgZWxlbWVudHMgaXQgbWF0Y2hlZCBhZ2FpbnN0IGxhc3QgdGltZVxuXHRcdFx0XHRcdFx0aWYgKHJ1bGUuY2FjaGUpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRmluZCB0aGUgb25lcyB0aGF0IGFyZSBleHRyYSB0aGlzIHRpbWVcblx0XHRcdFx0XHRcdFx0YWRkID0gcmVzLm5vdChydWxlLmNhY2hlKTtcblx0XHRcdFx0XHRcdFx0cmVtID0gcnVsZS5jYWNoZS5ub3QocmVzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhZGQgPSByZXM7IHJlbSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYWRkICYmIGFkZC5sZW5ndGgpIHx8IChyZW0gJiYgcmVtLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJlbSAmJiByZW0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVsZWFzZWQgPSByZWxlYXNlZC5hZGQocmVtKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChkdG9yICYmICFydWxlLm9udW5tYXRjaFJ1bm5pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bGUub251bm1hdGNoUnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdG9ycy5vbnVubWF0Y2hwcm94eShyZW0sIGosIGR0b3IpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cnVsZS5vbnVubWF0Y2hSdW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCB0aGUgY29uc3RydWN0b3Igb24gdGhlIG5ld2x5IG1hdGNoZWQgb25lc1xuXHRcdFx0XHRcdFx0XHRpZiAoYWRkICYmIGFkZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHR0YWtlbiA9IHRha2VuLmFkZChhZGQpO1xuXHRcdFx0XHRcdFx0XHRcdHJlbGVhc2VkID0gcmVsZWFzZWQubm90KGFkZCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoY3RvciAmJiAhcnVsZS5vbm1hdGNoUnVubmluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cnVsZS5vbm1hdGNoUnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdG9ycy5vbm1hdGNocHJveHkoYWRkLCBqLCBjdG9yKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bGUub25tYXRjaFJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIHRyYWNraW5nIG1hdGNoZWQsIGFkZCBvdXJzZWx2ZXNcblx0XHRcdFx0XHRcdGlmIChtYXRjaGVkKSBtYXRjaGVkID0gbWF0Y2hlZC5hZGQocmVzKTtcblxuXHRcdFx0XHRcdFx0Ly8gQW5kIHJlbWVtYmVyIHRoaXMgbGlzdCBvZiBtYXRjaGluZyBlbGVtZW50cyBhZ2FpbiB0aGlzIHNlbGVjdG9yLCBzbyBuZXh0IG1hdGNoaW5nIHdlIGNhbiBmaW5kIHRoZSB1bm1hdGNoZWQgb25lc1xuXHRcdFx0XHRcdFx0cnVsZS5jYWNoZSA9IHJlcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuYW1lc3BhY2UubWF0Y2hlcnNEaXJ0eSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNvbnNvbGUubG9nKChuZXcgRGF0ZSkuZ2V0VGltZSgpIC0gc3RhcnQpO1xuXHR9KTtcblx0XG5cbn0pKGpRdWVyeSk7XG47XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmFkZHJlbS5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkTWV0aG9kcyh7XG5cdFx0YnVpbGRfYWRkcmVtX3Byb3h5OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgb25lID0gdGhpcy5vbmUobmFtZSwgJ2Z1bmMnKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBydiwgaSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHJ2ID0gb25lKHRoaXNbaV0sIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0cmV0dXJuIHJ2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvbmUodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0YmluZF9hZGRyZW1fcHJveHk6IGZ1bmN0aW9uKHNlbGVjdG9yLCBuYW1lLCBmdW5jKSB7XG5cdFx0XHR2YXIgcnVsZWxpc3QgPSB0aGlzLnN0b3JlW25hbWVdIHx8ICh0aGlzLnN0b3JlW25hbWVdID0gJC5lbnR3aW5lLlJ1bGVMaXN0KCkpO1xuXG5cdFx0XHR2YXIgcnVsZSA9IHJ1bGVsaXN0LmFkZFJ1bGUoc2VsZWN0b3IsIG5hbWUpOyBydWxlLmZ1bmMgPSBmdW5jO1xuXG5cdFx0XHRpZiAoIXRoaXMuaW5qZWN0ZWUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0dGhpcy5pbmplY3RlZVtuYW1lXSA9IHRoaXMuYnVpbGRfYWRkcmVtX3Byb3h5KG5hbWUpO1xuXHRcdFx0XHR0aGlzLmluamVjdGVlW25hbWVdLmlzZW50d2luZW1ldGhvZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZEhhbmRsZXIoe1xuXHRcdG9yZGVyOiAzMCxcblxuXHRcdGJpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrLCB2KSB7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHYpICYmIChrID09ICdvbmFkZCcgfHwgayA9PSAnb25yZW1vdmUnKSkge1xuXHRcdFx0XHR0aGlzLmJpbmRfYWRkcmVtX3Byb3h5KHNlbGVjdG9yLCBrLCB2KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQkKGRvY3VtZW50KS5iaW5kKCdFbnR3aW5lRWxlbWVudHNBZGRlZCcsIGZ1bmN0aW9uKGUpe1xuXHRcdC8vIEZvciBldmVyeSBuYW1lc3BhY2Vcblx0XHRmb3IgKHZhciBrIGluICQuZW50d2luZS5uYW1lc3BhY2VzKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gJC5lbnR3aW5lLm5hbWVzcGFjZXNba107XG5cdFx0XHRpZiAobmFtZXNwYWNlLmluamVjdGVlLm9uYWRkKSBuYW1lc3BhY2UuaW5qZWN0ZWUub25hZGQuY2FsbChlLnRhcmdldHMpO1xuXHRcdH1cblx0fSk7XG5cblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZUVsZW1lbnRzUmVtb3ZlZCcsIGZ1bmN0aW9uKGUpe1xuXHRcdGZvciAodmFyIGsgaW4gJC5lbnR3aW5lLm5hbWVzcGFjZXMpIHtcblx0XHRcdHZhciBuYW1lc3BhY2UgPSAkLmVudHdpbmUubmFtZXNwYWNlc1trXTtcblx0XHRcdGlmIChuYW1lc3BhY2UuaW5qZWN0ZWUub25yZW1vdmUpIG5hbWVzcGFjZS5pbmplY3RlZS5vbnJlbW92ZS5jYWxsKGUudGFyZ2V0cyk7XG5cdFx0fVxuXHR9KTtcblxuXG5cblxufSkoalF1ZXJ5KTtcbjtcblxuXG4vKiBzcmMvanF1ZXJ5LmVudHdpbmUucHJvcGVydGllcy5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1x0XG5cblx0dmFyIGVudHdpbmVfcHJlcGVuZCA9ICdfX2VudHdpbmUhJztcblx0XG5cdHZhciBnZXRFbnR3aW5lRGF0YSA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2UsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGVsLmRhdGEoZW50d2luZV9wcmVwZW5kICsgbmFtZXNwYWNlICsgJyEnICsgcHJvcGVydHkpO1xuXHR9O1xuXHRcblx0dmFyIHNldEVudHdpbmVEYXRhID0gZnVuY3Rpb24oZWwsIG5hbWVzcGFjZSwgcHJvcGVydHksIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGVsLmRhdGEoZW50d2luZV9wcmVwZW5kICsgbmFtZXNwYWNlICsgJyEnICsgcHJvcGVydHksIHZhbHVlKTtcblx0fTtcblx0XG5cdHZhciBnZXRFbnR3aW5lRGF0YUFzSGFzaCA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2UpIHtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdHZhciBpZCA9IGpRdWVyeS5kYXRhKGVsWzBdKTtcblx0XHRcblx0XHR2YXIgbWF0Y2hzdHIgPSBlbnR3aW5lX3ByZXBlbmQgKyBuYW1lc3BhY2UgKyAnISc7XG5cdFx0dmFyIG1hdGNobGVuID0gbWF0Y2hzdHIubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBjYWNoZSA9IGpRdWVyeS5jYWNoZVtpZF07XG5cdFx0Zm9yICh2YXIgayBpbiBjYWNoZSkge1xuXHRcdFx0aWYgKGsuc3Vic3RyKDAsbWF0Y2hsZW4pID09IG1hdGNoc3RyKSBoYXNoW2suc3Vic3RyKG1hdGNobGVuKV0gPSBjYWNoZVtrXTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGhhc2g7XG5cdH07XG5cdFxuXHR2YXIgc2V0RW50d2luZURhdGFGcm9tSGFzaCA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2UsIGhhc2gpIHtcblx0XHRmb3IgKHZhciBrIGluIGhhc2gpIHNldEVudHdpbmVEYXRhKG5hbWVzcGFjZSwgaywgaGFzaFtrXSk7XG5cdH07XG5cblx0dmFyIGVudHdpbmVEYXRhID0gZnVuY3Rpb24oZWwsIG5hbWVzcGFjZSwgYXJncykge1xuXHRcdHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdFx0cmV0dXJuIGdldEVudHdpbmVEYXRhQXNIYXNoKGVsLCBuYW1lc3BhY2UpO1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gPT0gJ3N0cmluZycpIHJldHVybiBnZXRFbnR3aW5lRGF0YShlbCwgbmFtZXNwYWNlLCBhcmdzWzBdKTtcblx0XHRcdFx0ZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0RW50d2luZURhdGFGcm9tSGFzaChlbCwgbmFtZXNwYWNlLCBhcmdzWzBdKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzZXRFbnR3aW5lRGF0YShlbCwgbmFtZXNwYWNlLCBhcmdzWzBdLCBhcmdzWzFdKTtcblx0XHR9XG5cdH07XG4gXG5cdCQuZXh0ZW5kKCQuZm4sIHtcblx0XHRlbnR3aW5lRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZW50d2luZURhdGEodGhpcywgJ19fYmFzZScsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkSGFuZGxlcih7XG5cdFx0b3JkZXI6IDYwLFxuXHRcdFxuXHRcdGJpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrLCB2KSB7XG5cdFx0XHRpZiAoay5jaGFyQXQoMCkgIT0gay5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSkgJC5lbnR3aW5lLndhcm4oJ0VudHdpbmUgcHJvcGVydHkgJytrKycgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyJywgJC5lbnR3aW5lLldBUk5fTEVWRUxfQkVTVFBSQUNUSVNFKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG5cblx0XHRcdHZhciBnZXR0ZXJOYW1lID0gJ2dldCcraztcblx0XHRcdHZhciBzZXR0ZXJOYW1lID0gJ3NldCcraztcblxuXHRcdFx0dGhpcy5iaW5kX3Byb3h5KHNlbGVjdG9yLCBnZXR0ZXJOYW1lLCBmdW5jdGlvbigpIHsgdmFyIHIgPSB0aGlzLmVudHdpbmVEYXRhKGspOyByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gdiA6IHI7IH0pO1xuXHRcdFx0dGhpcy5iaW5kX3Byb3h5KHNlbGVjdG9yLCBzZXR0ZXJOYW1lLCBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZW50d2luZURhdGEoaywgdik7IH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBHZXQgdGhlIGdldCBhbmQgc2V0IHByb3hpZXMgd2UganVzdCBjcmVhdGVkXG5cdFx0XHRcblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLmluamVjdGVlW2dldHRlck5hbWVdO1xuXHRcdFx0dmFyIHNldHRlciA9IHRoaXMuaW5qZWN0ZWVbc2V0dGVyTmFtZV07XG5cdFx0XHRcblx0XHRcdC8vIEFuZCBiaW5kIGluIHRoZSBqUXVlcnktc3R5bGUgYWNjZXNzb3Jcblx0XHRcdFxuXHRcdFx0dGhpcy5iaW5kX3Byb3h5KHNlbGVjdG9yLCBrLCBmdW5jdGlvbih2KXsgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID09IDEgPyBzZXR0ZXIgOiBnZXR0ZXIpLmNhbGwodGhpcywgdikgOyB9KTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRcblx0XHRuYW1lc3BhY2VNZXRob2RPdmVycmlkZXM6IGZ1bmN0aW9uKG5hbWVzcGFjZSl7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnR3aW5lRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVudHdpbmVEYXRhKHRoaXMsIG5hbWVzcGFjZS5uYW1lLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSk7XG5cdFxufSkoalF1ZXJ5KTtcbjtcblxuXG4vKiBzcmMvanF1ZXJ5LmVudHdpbmUubGVnYWN5LmpzICovXG5cbihmdW5jdGlvbigkKSB7XHRcblx0XG5cdC8vIEFkZHMgYmFjayBjb25jcmV0ZSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHQkLmNvbmNyZXRlID0gJC5lbnR3aW5lO1xuXHQkLmZuLmNvbmNyZXRlID0gJC5mbi5lbnR3aW5lO1xuXHQkLmZuLmNvbmNyZXRlRGF0YSA9ICQuZm4uZW50d2luZURhdGE7XG5cdFxuXHQvLyBVc2UgYWRkSGFuZGxlciB0byBoYWNrIGluIHRoZSBuYW1lc3BhY2UuJC5jb25jcmV0ZSBlcXVpdmlsZW50IHRvIHRoZSBuYW1lc3BhY2UuJC5lbnR3aW5lIG5hbWVzcGFjZS1pbmplY3Rpb25cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyKHtcblx0XHRvcmRlcjogMTAwLFxuXHRcdGJpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrLCB2KSB7IHJldHVybiBmYWxzZTsgfSxcblx0XG5cdFx0bmFtZXNwYWNlTWV0aG9kT3ZlcnJpZGVzOiBmdW5jdGlvbihuYW1lc3BhY2Upe1xuXHRcdFx0bmFtZXNwYWNlLiQuY29uY3JldGUgPSBuYW1lc3BhY2UuJC5lbnR3aW5lO1xuXHRcdFx0bmFtZXNwYWNlLmluamVjdGVlLmNvbmNyZXRlID0gbmFtZXNwYWNlLmluamVjdGVlLmVudHdpbmU7XG5cdFx0XHRuYW1lc3BhY2UuaW5qZWN0ZWUuY29uY3JldGVEYXRhID0gbmFtZXNwYWNlLmluamVjdGVlLmVudHdpbmVEYXRhO1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG47XG5cbiIsIi8qIVxuICogalF1ZXJ5IEZvcm0gUGx1Z2luXG4gKiB2ZXJzaW9uOiAyLjk2ICgxNi1GRUItMjAxMilcbiAqIEByZXF1aXJlcyBqUXVlcnkgdjEuMy4yIG9yIGxhdGVyXG4gKlxuICogRXhhbXBsZXMgYW5kIGRvY3VtZW50YXRpb24gYXQ6IGh0dHA6Ly9tYWxzdXAuY29tL2pxdWVyeS9mb3JtL1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKlx0aHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXHRodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqL1xuOyhmdW5jdGlvbigkKSB7XG5cbi8qXG5cdFVzYWdlIE5vdGU6XG5cdC0tLS0tLS0tLS0tXG5cdERvIG5vdCB1c2UgYm90aCBhamF4U3VibWl0IGFuZCBhamF4Rm9ybSBvbiB0aGUgc2FtZSBmb3JtLiAgVGhlc2Vcblx0ZnVuY3Rpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuICBVc2UgYWpheFN1Ym1pdCBpZiB5b3Ugd2FudFxuXHR0byBiaW5kIHlvdXIgb3duIHN1Ym1pdCBoYW5kbGVyIHRvIHRoZSBmb3JtLiAgRm9yIGV4YW1wbGUsXG5cblx0JChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0JCgnI215Rm9ybScpLmJpbmQoJ3N1Ym1pdCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgLy8gPC0tIGltcG9ydGFudFxuXHRcdFx0JCh0aGlzKS5hamF4U3VibWl0KHtcblx0XHRcdFx0dGFyZ2V0OiAnI291dHB1dCdcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRVc2UgYWpheEZvcm0gd2hlbiB5b3Ugd2FudCB0aGUgcGx1Z2luIHRvIG1hbmFnZSBhbGwgdGhlIGV2ZW50IGJpbmRpbmdcblx0Zm9yIHlvdS4gIEZvciBleGFtcGxlLFxuXG5cdCQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCQoJyNteUZvcm0nKS5hamF4Rm9ybSh7XG5cdFx0XHR0YXJnZXQ6ICcjb3V0cHV0J1xuXHRcdH0pO1xuXHR9KTtcblx0XG5cdFlvdSBjYW4gYWxzbyB1c2UgYWpheEZvcm0gd2l0aCBkZWxlZ2F0aW9uIChyZXF1aXJlcyBqUXVlcnkgdjEuNyspLCBzbyB0aGVcblx0Zm9ybSBkb2VzIG5vdCBoYXZlIHRvIGV4aXN0IHdoZW4geW91IGludm9rZSBhamF4Rm9ybTpcblxuXHQkKCcjbXlGb3JtJykuYWpheEZvcm0oe1xuXHRcdGRlbGVnYXRpb246IHRydWUsXG5cdFx0dGFyZ2V0OiAnI291dHB1dCdcblx0fSk7XG5cdFxuXHRXaGVuIHVzaW5nIGFqYXhGb3JtLCB0aGUgYWpheFN1Ym1pdCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgZm9yIHlvdVxuXHRhdCB0aGUgYXBwcm9wcmlhdGUgdGltZS5cbiovXG5cbi8qKlxuICogYWpheFN1Ym1pdCgpIHByb3ZpZGVzIGEgbWVjaGFuaXNtIGZvciBpbW1lZGlhdGVseSBzdWJtaXR0aW5nXG4gKiBhbiBIVE1MIGZvcm0gdXNpbmcgQUpBWC5cbiAqL1xuJC5mbi5hamF4U3VibWl0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBmYXN0IGZhaWwgaWYgbm90aGluZyBzZWxlY3RlZCAoaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC8yNzUyKVxuXHRpZiAoIXRoaXMubGVuZ3RoKSB7XG5cdFx0bG9nKCdhamF4U3VibWl0OiBza2lwcGluZyBzdWJtaXQgcHJvY2VzcyAtIG5vIGVsZW1lbnQgc2VsZWN0ZWQnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRcblx0dmFyIG1ldGhvZCwgYWN0aW9uLCB1cmwsICRmb3JtID0gdGhpcztcblxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdG9wdGlvbnMgPSB7IHN1Y2Nlc3M6IG9wdGlvbnMgfTtcblx0fVxuXG5cdG1ldGhvZCA9IHRoaXMuYXR0cignbWV0aG9kJyk7XG5cdGFjdGlvbiA9IHRoaXMuYXR0cignYWN0aW9uJyk7XG5cdHVybCA9ICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykgPyAkLnRyaW0oYWN0aW9uKSA6ICcnO1xuXHR1cmwgPSB1cmwgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG5cdGlmICh1cmwpIHtcblx0XHQvLyBjbGVhbiB1cmwgKGRvbid0IGluY2x1ZGUgaGFzaCB2YXVlKVxuXHRcdHVybCA9ICh1cmwubWF0Y2goL14oW14jXSspLyl8fFtdKVsxXTtcblx0fVxuXG5cdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7XG5cdFx0dXJsOiAgdXJsLFxuXHRcdHN1Y2Nlc3M6ICQuYWpheFNldHRpbmdzLnN1Y2Nlc3MsXG5cdFx0dHlwZTogbWV0aG9kIHx8ICdHRVQnLFxuXHRcdGlmcmFtZVNyYzogL15odHRwcy9pLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJycpID8gJ2phdmFzY3JpcHQ6ZmFsc2UnIDogJ2Fib3V0OmJsYW5rJ1xuXHR9LCBvcHRpb25zKTtcblxuXHQvLyBob29rIGZvciBtYW5pcHVsYXRpbmcgdGhlIGZvcm0gZGF0YSBiZWZvcmUgaXQgaXMgZXh0cmFjdGVkO1xuXHQvLyBjb252ZW5pZW50IGZvciB1c2Ugd2l0aCByaWNoIGVkaXRvcnMgbGlrZSB0aW55TUNFIG9yIEZDS0VkaXRvclxuXHR2YXIgdmV0byA9IHt9O1xuXHR0aGlzLnRyaWdnZXIoJ2Zvcm0tcHJlLXNlcmlhbGl6ZScsIFt0aGlzLCBvcHRpb25zLCB2ZXRvXSk7XG5cdGlmICh2ZXRvLnZldG8pIHtcblx0XHRsb2coJ2FqYXhTdWJtaXQ6IHN1Ym1pdCB2ZXRvZWQgdmlhIGZvcm0tcHJlLXNlcmlhbGl6ZSB0cmlnZ2VyJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBwcm92aWRlIG9wcG9ydHVuaXR5IHRvIGFsdGVyIGZvcm0gZGF0YSBiZWZvcmUgaXQgaXMgc2VyaWFsaXplZFxuXHRpZiAob3B0aW9ucy5iZWZvcmVTZXJpYWxpemUgJiYgb3B0aW9ucy5iZWZvcmVTZXJpYWxpemUodGhpcywgb3B0aW9ucykgPT09IGZhbHNlKSB7XG5cdFx0bG9nKCdhamF4U3VibWl0OiBzdWJtaXQgYWJvcnRlZCB2aWEgYmVmb3JlU2VyaWFsaXplIGNhbGxiYWNrJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR2YXIgdHJhZGl0aW9uYWwgPSBvcHRpb25zLnRyYWRpdGlvbmFsO1xuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSAkLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXHRcblx0dmFyIHF4LG4sdixhID0gdGhpcy5mb3JtVG9BcnJheShvcHRpb25zLnNlbWFudGljKTtcblx0aWYgKG9wdGlvbnMuZGF0YSkge1xuXHRcdG9wdGlvbnMuZXh0cmFEYXRhID0gb3B0aW9ucy5kYXRhO1xuXHRcdHF4ID0gJC5wYXJhbShvcHRpb25zLmRhdGEsIHRyYWRpdGlvbmFsKTtcblx0fVxuXG5cdC8vIGdpdmUgcHJlLXN1Ym1pdCBjYWxsYmFjayBhbiBvcHBvcnR1bml0eSB0byBhYm9ydCB0aGUgc3VibWl0XG5cdGlmIChvcHRpb25zLmJlZm9yZVN1Ym1pdCAmJiBvcHRpb25zLmJlZm9yZVN1Ym1pdChhLCB0aGlzLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcblx0XHRsb2coJ2FqYXhTdWJtaXQ6IHN1Ym1pdCBhYm9ydGVkIHZpYSBiZWZvcmVTdWJtaXQgY2FsbGJhY2snKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGZpcmUgdmV0b2FibGUgJ3ZhbGlkYXRlJyBldmVudFxuXHR0aGlzLnRyaWdnZXIoJ2Zvcm0tc3VibWl0LXZhbGlkYXRlJywgW2EsIHRoaXMsIG9wdGlvbnMsIHZldG9dKTtcblx0aWYgKHZldG8udmV0bykge1xuXHRcdGxvZygnYWpheFN1Ym1pdDogc3VibWl0IHZldG9lZCB2aWEgZm9ybS1zdWJtaXQtdmFsaWRhdGUgdHJpZ2dlcicpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dmFyIHEgPSAkLnBhcmFtKGEsIHRyYWRpdGlvbmFsKTtcblx0aWYgKHF4KSB7XG5cdFx0cSA9ICggcSA/IChxICsgJyYnICsgcXgpIDogcXggKTtcblx0fVx0XG5cdGlmIChvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSA9PSAnR0VUJykge1xuXHRcdG9wdGlvbnMudXJsICs9IChvcHRpb25zLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxO1xuXHRcdG9wdGlvbnMuZGF0YSA9IG51bGw7ICAvLyBkYXRhIGlzIG51bGwgZm9yICdnZXQnXG5cdH1cblx0ZWxzZSB7XG5cdFx0b3B0aW9ucy5kYXRhID0gcTsgLy8gZGF0YSBpcyB0aGUgcXVlcnkgc3RyaW5nIGZvciAncG9zdCdcblx0fVxuXG5cdHZhciBjYWxsYmFja3MgPSBbXTtcblx0aWYgKG9wdGlvbnMucmVzZXRGb3JtKSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oKSB7ICRmb3JtLnJlc2V0Rm9ybSgpOyB9KTtcblx0fVxuXHRpZiAob3B0aW9ucy5jbGVhckZvcm0pIHtcblx0XHRjYWxsYmFja3MucHVzaChmdW5jdGlvbigpIHsgJGZvcm0uY2xlYXJGb3JtKG9wdGlvbnMuaW5jbHVkZUhpZGRlbik7IH0pO1xuXHR9XG5cblx0Ly8gcGVyZm9ybSBhIGxvYWQgb24gdGhlIHRhcmdldCBvbmx5IGlmIGRhdGFUeXBlIGlzIG5vdCBwcm92aWRlZFxuXHRpZiAoIW9wdGlvbnMuZGF0YVR5cGUgJiYgb3B0aW9ucy50YXJnZXQpIHtcblx0XHR2YXIgb2xkU3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBmdW5jdGlvbigpe307XG5cdFx0Y2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dmFyIGZuID0gb3B0aW9ucy5yZXBsYWNlVGFyZ2V0ID8gJ3JlcGxhY2VXaXRoJyA6ICdodG1sJztcblx0XHRcdCQob3B0aW9ucy50YXJnZXQpW2ZuXShkYXRhKS5lYWNoKG9sZFN1Y2Nlc3MsIGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cdH1cblx0ZWxzZSBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2gob3B0aW9ucy5zdWNjZXNzKTtcblx0fVxuXG5cdG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgeGhyKSB7IC8vIGpRdWVyeSAxLjQrIHBhc3NlcyB4aHIgYXMgM3JkIGFyZ1xuXHRcdHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IG9wdGlvbnM7XHQvLyBqUXVlcnkgMS40KyBzdXBwb3J0cyBzY29wZSBjb250ZXh0IFxuXHRcdGZvciAodmFyIGk9MCwgbWF4PWNhbGxiYWNrcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0Y2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhociB8fCAkZm9ybSwgJGZvcm1dKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gYXJlIHRoZXJlIGZpbGVzIHRvIHVwbG9hZD9cblx0dmFyIGZpbGVJbnB1dHMgPSAkKCdpbnB1dDpmaWxlOmVuYWJsZWRbdmFsdWVdJywgdGhpcyk7IC8vIFt2YWx1ZV0gKGlzc3VlICMxMTMpXG5cdHZhciBoYXNGaWxlSW5wdXRzID0gZmlsZUlucHV0cy5sZW5ndGggPiAwO1xuXHR2YXIgbXAgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG5cdHZhciBtdWx0aXBhcnQgPSAoJGZvcm0uYXR0cignZW5jdHlwZScpID09IG1wIHx8ICRmb3JtLmF0dHIoJ2VuY29kaW5nJykgPT0gbXApO1xuXG5cdHZhciBmaWxlQVBJID0gISEoaGFzRmlsZUlucHV0cyAmJiBmaWxlSW5wdXRzLmdldCgwKS5maWxlcyAmJiB3aW5kb3cuRm9ybURhdGEpO1xuXHRsb2coXCJmaWxlQVBJIDpcIiArIGZpbGVBUEkpO1xuXHR2YXIgc2hvdWxkVXNlRnJhbWUgPSAoaGFzRmlsZUlucHV0cyB8fCBtdWx0aXBhcnQpICYmICFmaWxlQVBJO1xuXG5cdC8vIG9wdGlvbnMuaWZyYW1lIGFsbG93cyB1c2VyIHRvIGZvcmNlIGlmcmFtZSBtb2RlXG5cdC8vIDA2LU5PVi0wOTogbm93IGRlZmF1bHRpbmcgdG8gaWZyYW1lIG1vZGUgaWYgZmlsZSBpbnB1dCBpcyBkZXRlY3RlZFxuXHRpZiAob3B0aW9ucy5pZnJhbWUgIT09IGZhbHNlICYmIChvcHRpb25zLmlmcmFtZSB8fCBzaG91bGRVc2VGcmFtZSkpIHtcblx0XHQvLyBoYWNrIHRvIGZpeCBTYWZhcmkgaGFuZyAodGhhbmtzIHRvIFRpbSBNb2xlbmRpamsgZm9yIHRoaXMpXG5cdFx0Ly8gc2VlOiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2dyb3VwL2pxdWVyeS1kZXYvYnJvd3NlX3RocmVhZC90aHJlYWQvMzYzOTViN2FiNTEwZGQ1ZFxuXHRcdGlmIChvcHRpb25zLmNsb3NlS2VlcEFsaXZlKSB7XG5cdFx0XHQkLmdldChvcHRpb25zLmNsb3NlS2VlcEFsaXZlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZmlsZVVwbG9hZElmcmFtZShhKTtcblx0XHRcdH0pO1xuXHRcdH1cbiAgXHRcdGVsc2Uge1xuXHRcdFx0ZmlsZVVwbG9hZElmcmFtZShhKTtcbiAgXHRcdH1cblx0fVxuXHRlbHNlIGlmICgoaGFzRmlsZUlucHV0cyB8fCBtdWx0aXBhcnQpICYmIGZpbGVBUEkpIHtcblx0XHRvcHRpb25zLnByb2dyZXNzID0gb3B0aW9ucy5wcm9ncmVzcyB8fCAkLm5vb3A7XG5cdFx0ZmlsZVVwbG9hZFhocihhKTtcblx0fVxuXHRlbHNlIHtcblx0XHQkLmFqYXgob3B0aW9ucyk7XG5cdH1cblxuXHQgLy8gZmlyZSAnbm90aWZ5JyBldmVudFxuXHQgdGhpcy50cmlnZ2VyKCdmb3JtLXN1Ym1pdC1ub3RpZnknLCBbdGhpcywgb3B0aW9uc10pO1xuXHQgcmV0dXJuIHRoaXM7XG5cblx0IC8vIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZmlsZSB1cGxvYWRzIChiaWcgaGF0IHRpcCB0byBmcmFuY29pczJtZXR6KVxuXHRmdW5jdGlvbiBmaWxlVXBsb2FkWGhyKGEpIHtcblx0XHR2YXIgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuXHRcdGZvciAodmFyIGk9MDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhW2ldLnR5cGUgPT0gJ2ZpbGUnKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGZvcm1kYXRhLmFwcGVuZChhW2ldLm5hbWUsIGFbaV0udmFsdWUpO1xuXHRcdH1cblxuXHRcdCRmb3JtLmZpbmQoJ2lucHV0OmZpbGU6ZW5hYmxlZCcpLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdHZhciBuYW1lID0gJCh0aGlzKS5hdHRyKCduYW1lJyksIGZpbGVzID0gdGhpcy5maWxlcztcblx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdGZvcm1kYXRhLmFwcGVuZChuYW1lLCBmaWxlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAob3B0aW9ucy5leHRyYURhdGEpIHtcblx0XHRcdGZvciAodmFyIGsgaW4gb3B0aW9ucy5leHRyYURhdGEpXG5cdFx0XHRcdGZvcm1kYXRhLmFwcGVuZChrLCBvcHRpb25zLmV4dHJhRGF0YVtrXSlcblx0XHR9XG5cblx0XHRvcHRpb25zLmRhdGEgPSBudWxsO1xuXG5cdFx0dmFyIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5hamF4U2V0dGluZ3MsIG9wdGlvbnMsIHtcblx0XHRcdGNvbnRlbnRUeXBlOiBmYWxzZSxcblx0XHRcdHByb2Nlc3NEYXRhOiBmYWxzZSxcblx0XHRcdGNhY2hlOiBmYWxzZSxcblx0XHRcdHR5cGU6ICdQT1NUJ1xuXHRcdH0pO1xuXG4gICAgICAvL3MuY29udGV4dCA9IHMuY29udGV4dCB8fCBzO1xuXG4gICAgICBzLmRhdGEgPSBudWxsO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBzLmJlZm9yZVNlbmQ7XG4gICAgICBzLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIsIG8pIHtcbiAgICAgICAgICBvLmRhdGEgPSBmb3JtZGF0YTtcbiAgICAgICAgICBpZih4aHIudXBsb2FkKSB7IC8vIHVuZm9ydHVuYXRlbHksIGpRdWVyeSBkb2Vzbid0IGV4cG9zZSB0aGlzIHByb3AgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEwMTkwKVxuICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgby5wcm9ncmVzcyhldmVudC5wb3NpdGlvbiwgZXZlbnQudG90YWwpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihiZWZvcmVTZW5kKVxuICAgICAgICAgICAgICBiZWZvcmVTZW5kLmNhbGwobywgeGhyLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICAkLmFqYXgocyk7XG4gICB9XG5cblx0Ly8gcHJpdmF0ZSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgZmlsZSB1cGxvYWRzIChoYXQgdGlwIHRvIFlBSE9PISlcblx0ZnVuY3Rpb24gZmlsZVVwbG9hZElmcmFtZShhKSB7XG5cdFx0dmFyIGZvcm0gPSAkZm9ybVswXSwgZWwsIGksIHMsIGcsIGlkLCAkaW8sIGlvLCB4aHIsIHN1YiwgbiwgdGltZWRPdXQsIHRpbWVvdXRIYW5kbGU7XG5cdFx0dmFyIHVzZVByb3AgPSAhISQuZm4ucHJvcDtcblxuXHRcdGlmIChhKSB7XG5cdFx0XHRpZiAoIHVzZVByb3AgKSB7XG5cdFx0XHRcdC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IHNlcmlhbGl6ZWQgaW5wdXQgaXMgc3RpbGwgZW5hYmxlZFxuXHRcdFx0XHRmb3IgKGk9MDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRlbCA9ICQoZm9ybVthW2ldLm5hbWVdKTtcblx0XHRcdFx0XHRlbC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpPTA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZWwgPSAkKGZvcm1bYVtpXS5uYW1lXSk7XG5cdFx0XHRcdFx0ZWwucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoJCgnOmlucHV0W25hbWU9c3VibWl0XSw6aW5wdXRbaWQ9c3VibWl0XScsIGZvcm0pLmxlbmd0aCkge1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gaW5wdXQgd2l0aCBhIG5hbWUgb3IgaWQgb2YgJ3N1Ym1pdCcgdGhlbiB3ZSB3b24ndCBiZVxuXHRcdFx0Ly8gYWJsZSB0byBpbnZva2UgdGhlIHN1Ym1pdCBmbiBvbiB0aGUgZm9ybSAoYXQgbGVhc3Qgbm90IHgtYnJvd3Nlcilcblx0XHRcdGFsZXJ0KCdFcnJvcjogRm9ybSBlbGVtZW50cyBtdXN0IG5vdCBoYXZlIG5hbWUgb3IgaWQgb2YgXCJzdWJtaXRcIi4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkLmFqYXhTZXR0aW5ncywgb3B0aW9ucyk7XG5cdFx0cy5jb250ZXh0ID0gcy5jb250ZXh0IHx8IHM7XG5cdFx0aWQgPSAnanFGb3JtSU8nICsgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0XHRpZiAocy5pZnJhbWVUYXJnZXQpIHtcblx0XHRcdCRpbyA9ICQocy5pZnJhbWVUYXJnZXQpO1xuXHRcdFx0biA9ICRpby5hdHRyKCduYW1lJyk7XG5cdFx0XHRpZiAobiA9PSBudWxsKVxuXHRcdFx0IFx0JGlvLmF0dHIoJ25hbWUnLCBpZCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGlkID0gbjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQkaW8gPSAkKCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCIgc3JjPVwiJysgcy5pZnJhbWVTcmMgKydcIiAvPicpO1xuXHRcdFx0JGlvLmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6ICctMTAwMHB4JywgbGVmdDogJy0xMDAwcHgnIH0pO1xuXHRcdH1cblx0XHRpbyA9ICRpb1swXTtcblxuXG5cdFx0eGhyID0geyAvLyBtb2NrIG9iamVjdFxuXHRcdFx0YWJvcnRlZDogMCxcblx0XHRcdHJlc3BvbnNlVGV4dDogbnVsbCxcblx0XHRcdHJlc3BvbnNlWE1MOiBudWxsLFxuXHRcdFx0c3RhdHVzOiAwLFxuXHRcdFx0c3RhdHVzVGV4dDogJ24vYScsXG5cdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oKSB7fSxcblx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oc3RhdHVzKSB7XG5cdFx0XHRcdHZhciBlID0gKHN0YXR1cyA9PT0gJ3RpbWVvdXQnID8gJ3RpbWVvdXQnIDogJ2Fib3J0ZWQnKTtcblx0XHRcdFx0bG9nKCdhYm9ydGluZyB1cGxvYWQuLi4gJyArIGUpO1xuXHRcdFx0XHR0aGlzLmFib3J0ZWQgPSAxO1xuXHRcdFx0XHQkaW8uYXR0cignc3JjJywgcy5pZnJhbWVTcmMpOyAvLyBhYm9ydCBvcCBpbiBwcm9ncmVzc1xuXHRcdFx0XHR4aHIuZXJyb3IgPSBlO1xuXHRcdFx0XHRzLmVycm9yICYmIHMuZXJyb3IuY2FsbChzLmNvbnRleHQsIHhociwgZSwgc3RhdHVzKTtcblx0XHRcdFx0ZyAmJiAkLmV2ZW50LnRyaWdnZXIoXCJhamF4RXJyb3JcIiwgW3hociwgcywgZV0pO1xuXHRcdFx0XHRzLmNvbXBsZXRlICYmIHMuY29tcGxldGUuY2FsbChzLmNvbnRleHQsIHhociwgZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGcgPSBzLmdsb2JhbDtcblx0XHQvLyB0cmlnZ2VyIGFqYXggZ2xvYmFsIGV2ZW50cyBzbyB0aGF0IGFjdGl2aXR5L2Jsb2NrIGluZGljYXRvcnMgd29yayBsaWtlIG5vcm1hbFxuXHRcdGlmIChnICYmICEgJC5hY3RpdmUrKykge1xuXHRcdFx0JC5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuXHRcdH1cblx0XHRpZiAoZykge1xuXHRcdFx0JC5ldmVudC50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW3hociwgc10pO1xuXHRcdH1cblxuXHRcdGlmIChzLmJlZm9yZVNlbmQgJiYgcy5iZWZvcmVTZW5kLmNhbGwocy5jb250ZXh0LCB4aHIsIHMpID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKHMuZ2xvYmFsKSB7XG5cdFx0XHRcdCQuYWN0aXZlLS07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh4aHIuYWJvcnRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGFkZCBzdWJtaXR0aW5nIGVsZW1lbnQgdG8gZGF0YSBpZiB3ZSBrbm93IGl0XG5cdFx0c3ViID0gZm9ybS5jbGs7XG5cdFx0aWYgKHN1Yikge1xuXHRcdFx0biA9IHN1Yi5uYW1lO1xuXHRcdFx0aWYgKG4gJiYgIXN1Yi5kaXNhYmxlZCkge1xuXHRcdFx0XHRzLmV4dHJhRGF0YSA9IHMuZXh0cmFEYXRhIHx8IHt9O1xuXHRcdFx0XHRzLmV4dHJhRGF0YVtuXSA9IHN1Yi52YWx1ZTtcblx0XHRcdFx0aWYgKHN1Yi50eXBlID09IFwiaW1hZ2VcIikge1xuXHRcdFx0XHRcdHMuZXh0cmFEYXRhW24rJy54J10gPSBmb3JtLmNsa194O1xuXHRcdFx0XHRcdHMuZXh0cmFEYXRhW24rJy55J10gPSBmb3JtLmNsa195O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBDTElFTlRfVElNRU9VVF9BQk9SVCA9IDE7XG5cdFx0dmFyIFNFUlZFUl9BQk9SVCA9IDI7XG5cblx0XHRmdW5jdGlvbiBnZXREb2MoZnJhbWUpIHtcblx0XHRcdHZhciBkb2MgPSBmcmFtZS5jb250ZW50V2luZG93ID8gZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCA6IGZyYW1lLmNvbnRlbnREb2N1bWVudCA/IGZyYW1lLmNvbnRlbnREb2N1bWVudCA6IGZyYW1lLmRvY3VtZW50O1xuXHRcdFx0cmV0dXJuIGRvYztcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUmFpbHMgQ1NSRiBoYWNrICh0aGFua3MgdG8gWXZhbiBCYXJ0aGVsZW15KVxuXHRcdHZhciBjc3JmX3Rva2VuID0gJCgnbWV0YVtuYW1lPWNzcmYtdG9rZW5dJykuYXR0cignY29udGVudCcpO1xuXHRcdHZhciBjc3JmX3BhcmFtID0gJCgnbWV0YVtuYW1lPWNzcmYtcGFyYW1dJykuYXR0cignY29udGVudCcpO1xuXHRcdGlmIChjc3JmX3BhcmFtICYmIGNzcmZfdG9rZW4pIHtcblx0XHRcdHMuZXh0cmFEYXRhID0gcy5leHRyYURhdGEgfHwge307XG5cdFx0XHRzLmV4dHJhRGF0YVtjc3JmX3BhcmFtXSA9IGNzcmZfdG9rZW47XG5cdFx0fVxuXG5cdFx0Ly8gdGFrZSBhIGJyZWF0aCBzbyB0aGF0IHBlbmRpbmcgcmVwYWludHMgZ2V0IHNvbWUgY3B1IHRpbWUgYmVmb3JlIHRoZSB1cGxvYWQgc3RhcnRzXG5cdFx0ZnVuY3Rpb24gZG9TdWJtaXQoKSB7XG5cdFx0XHQvLyBtYWtlIHN1cmUgZm9ybSBhdHRycyBhcmUgc2V0XG5cdFx0XHR2YXIgdCA9ICRmb3JtLmF0dHIoJ3RhcmdldCcpLCBhID0gJGZvcm0uYXR0cignYWN0aW9uJyk7XG5cblx0XHRcdC8vIHVwZGF0ZSBmb3JtIGF0dHJzIGluIElFIGZyaWVuZGx5IHdheVxuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsaWQpO1xuXHRcdFx0aWYgKCFtZXRob2QpIHtcblx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsICdQT1NUJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYSAhPSBzLnVybCkge1xuXHRcdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgcy51cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZSBib3JrcyBpbiBzb21lIGNhc2VzIHdoZW4gc2V0dGluZyBlbmNvZGluZ1xuXHRcdFx0aWYgKCEgcy5za2lwRW5jb2RpbmdPdmVycmlkZSAmJiAoIW1ldGhvZCB8fCAvcG9zdC9pLnRlc3QobWV0aG9kKSkpIHtcblx0XHRcdFx0JGZvcm0uYXR0cih7XG5cdFx0XHRcdFx0ZW5jb2Rpbmc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcblx0XHRcdFx0XHRlbmN0eXBlOiAgJ211bHRpcGFydC9mb3JtLWRhdGEnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdXBwb3J0IHRpbW91dFxuXHRcdFx0aWYgKHMudGltZW91dCkge1xuXHRcdFx0XHR0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGltZWRPdXQgPSB0cnVlOyBjYihDTElFTlRfVElNRU9VVF9BQk9SVCk7IH0sIHMudGltZW91dCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGxvb2sgZm9yIHNlcnZlciBhYm9ydHNcblx0XHRcdGZ1bmN0aW9uIGNoZWNrU3RhdGUoKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0YXRlID0gZ2V0RG9jKGlvKS5yZWFkeVN0YXRlO1xuXHRcdFx0XHRcdGxvZygnc3RhdGUgPSAnICsgc3RhdGUpO1xuXHRcdFx0XHRcdGlmIChzdGF0ZS50b0xvd2VyQ2FzZSgpID09ICd1bmluaXRpYWxpemVkJylcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoY2hlY2tTdGF0ZSw1MCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2goZSkge1xuXHRcdFx0XHRcdGxvZygnU2VydmVyIGFib3J0OiAnICwgZSwgJyAoJywgZS5uYW1lLCAnKScpO1xuXHRcdFx0XHRcdGNiKFNFUlZFUl9BQk9SVCk7XG5cdFx0XHRcdFx0dGltZW91dEhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG5cdFx0XHRcdFx0dGltZW91dEhhbmRsZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgXCJleHRyYVwiIGRhdGEgdG8gZm9ybSBpZiBwcm92aWRlZCBpbiBvcHRpb25zXG5cdFx0XHR2YXIgZXh0cmFJbnB1dHMgPSBbXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChzLmV4dHJhRGF0YSkge1xuXHRcdFx0XHRcdGZvciAodmFyIG4gaW4gcy5leHRyYURhdGEpIHtcblx0XHRcdFx0XHRcdGV4dHJhSW5wdXRzLnB1c2goXG5cdFx0XHRcdFx0XHRcdCQoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIicrbisnXCI+JykuYXR0cigndmFsdWUnLHMuZXh0cmFEYXRhW25dKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhmb3JtKVswXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFzLmlmcmFtZVRhcmdldCkge1xuXHRcdFx0XHRcdC8vIGFkZCBpZnJhbWUgdG8gZG9jIGFuZCBzdWJtaXQgdGhlIGZvcm1cblx0XHRcdFx0XHQkaW8uYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdFx0XHRpby5hdHRhY2hFdmVudCA/IGlvLmF0dGFjaEV2ZW50KCdvbmxvYWQnLCBjYikgOiBpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRUaW1lb3V0KGNoZWNrU3RhdGUsMTUpO1xuXHRcdFx0XHRmb3JtLnN1Ym1pdCgpO1xuXHRcdFx0fVxuXHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdC8vIHJlc2V0IGF0dHJzIGFuZCByZW1vdmUgXCJleHRyYVwiIGlucHV0IGVsZW1lbnRzXG5cdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdhY3Rpb24nLGEpO1xuXHRcdFx0XHRpZih0KSB7XG5cdFx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRmb3JtLnJlbW92ZUF0dHIoJ3RhcmdldCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoZXh0cmFJbnB1dHMpLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzLmZvcmNlU3luYykge1xuXHRcdFx0ZG9TdWJtaXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KGRvU3VibWl0LCAxMCk7IC8vIHRoaXMgbGV0cyBkb20gdXBkYXRlcyByZW5kZXJcblx0XHR9XG5cblx0XHR2YXIgZGF0YSwgZG9jLCBkb21DaGVja0NvdW50ID0gNTAsIGNhbGxiYWNrUHJvY2Vzc2VkO1xuXG5cdFx0ZnVuY3Rpb24gY2IoZSkge1xuXHRcdFx0aWYgKHhoci5hYm9ydGVkIHx8IGNhbGxiYWNrUHJvY2Vzc2VkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRvYyA9IGdldERvYyhpbyk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaChleCkge1xuXHRcdFx0XHRsb2coJ2Nhbm5vdCBhY2Nlc3MgcmVzcG9uc2UgZG9jdW1lbnQ6ICcsIGV4KTtcblx0XHRcdFx0ZSA9IFNFUlZFUl9BQk9SVDtcblx0XHRcdH1cblx0XHRcdGlmIChlID09PSBDTElFTlRfVElNRU9VVF9BQk9SVCAmJiB4aHIpIHtcblx0XHRcdFx0eGhyLmFib3J0KCd0aW1lb3V0Jyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGUgPT0gU0VSVkVSX0FCT1JUICYmIHhocikge1xuXHRcdFx0XHR4aHIuYWJvcnQoJ3NlcnZlciBhYm9ydCcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9jIHx8IGRvYy5sb2NhdGlvbi5ocmVmID09IHMuaWZyYW1lU3JjKSB7XG5cdFx0XHRcdC8vIHJlc3BvbnNlIG5vdCByZWNlaXZlZCB5ZXRcblx0XHRcdFx0aWYgKCF0aW1lZE91dClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpby5kZXRhY2hFdmVudCA/IGlvLmRldGFjaEV2ZW50KCdvbmxvYWQnLCBjYikgOiBpby5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcblxuXHRcdFx0dmFyIHN0YXR1cyA9ICdzdWNjZXNzJywgZXJyTXNnO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRpbWVkT3V0KSB7XG5cdFx0XHRcdFx0dGhyb3cgJ3RpbWVvdXQnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGlzWG1sID0gcy5kYXRhVHlwZSA9PSAneG1sJyB8fCBkb2MuWE1MRG9jdW1lbnQgfHwgJC5pc1hNTERvYyhkb2MpO1xuXHRcdFx0XHRsb2coJ2lzWG1sPScraXNYbWwpO1xuXHRcdFx0XHRpZiAoIWlzWG1sICYmIHdpbmRvdy5vcGVyYSAmJiAoZG9jLmJvZHkgPT0gbnVsbCB8fCBkb2MuYm9keS5pbm5lckhUTUwgPT0gJycpKSB7XG5cdFx0XHRcdFx0aWYgKC0tZG9tQ2hlY2tDb3VudCkge1xuXHRcdFx0XHRcdFx0Ly8gaW4gc29tZSBicm93c2VycyAoT3BlcmEpIHRoZSBpZnJhbWUgRE9NIGlzIG5vdCBhbHdheXMgdHJhdmVyc2FibGUgd2hlblxuXHRcdFx0XHRcdFx0Ly8gdGhlIG9ubG9hZCBjYWxsYmFjayBmaXJlcywgc28gd2UgbG9vcCBhIGJpdCB0byBhY2NvbW1vZGF0ZVxuXHRcdFx0XHRcdFx0bG9nKCdyZXF1ZWluZyBvbkxvYWQgY2FsbGJhY2ssIERPTSBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGNiLCAyNTApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBsZXQgdGhpcyBmYWxsIHRocm91Z2ggYmVjYXVzZSBzZXJ2ZXIgcmVzcG9uc2UgY291bGQgYmUgYW4gZW1wdHkgZG9jdW1lbnRcblx0XHRcdFx0XHQvL2xvZygnQ291bGQgbm90IGFjY2VzcyBpZnJhbWUgRE9NIGFmdGVyIG11dGlwbGUgdHJpZXMuJyk7XG5cdFx0XHRcdFx0Ly90aHJvdyAnRE9NRXhjZXB0aW9uOiBub3QgYXZhaWxhYmxlJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vbG9nKCdyZXNwb25zZSBkZXRlY3RlZCcpO1xuXHRcdFx0XHR2YXIgZG9jUm9vdCA9IGRvYy5ib2R5ID8gZG9jLmJvZHkgOiBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHR4aHIucmVzcG9uc2VUZXh0ID0gZG9jUm9vdCA/IGRvY1Jvb3QuaW5uZXJIVE1MIDogbnVsbDtcblx0XHRcdFx0eGhyLnJlc3BvbnNlWE1MID0gZG9jLlhNTERvY3VtZW50ID8gZG9jLlhNTERvY3VtZW50IDogZG9jO1xuXHRcdFx0XHRpZiAoaXNYbWwpXG5cdFx0XHRcdFx0cy5kYXRhVHlwZSA9ICd4bWwnO1xuXHRcdFx0XHR4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpe1xuXHRcdFx0XHRcdHZhciBoZWFkZXJzID0geydjb250ZW50LXR5cGUnOiBzLmRhdGFUeXBlfTtcblx0XHRcdFx0XHRyZXR1cm4gaGVhZGVyc1toZWFkZXJdO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBzdXBwb3J0IGZvciBYSFIgJ3N0YXR1cycgJiAnc3RhdHVzVGV4dCcgZW11bGF0aW9uIDpcblx0XHRcdFx0aWYgKGRvY1Jvb3QpIHtcblx0XHRcdFx0XHR4aHIuc3RhdHVzID0gTnVtYmVyKCBkb2NSb290LmdldEF0dHJpYnV0ZSgnc3RhdHVzJykgKSB8fCB4aHIuc3RhdHVzO1xuXHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0ID0gZG9jUm9vdC5nZXRBdHRyaWJ1dGUoJ3N0YXR1c1RleHQnKSB8fCB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkdCA9IChzLmRhdGFUeXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc2NyID0gLyhqc29ufHNjcmlwdHx0ZXh0KS8udGVzdChkdCk7XG5cdFx0XHRcdGlmIChzY3IgfHwgcy50ZXh0YXJlYSkge1xuXHRcdFx0XHRcdC8vIHNlZSBpZiB1c2VyIGVtYmVkZGVkIHJlc3BvbnNlIGluIHRleHRhcmVhXG5cdFx0XHRcdFx0dmFyIHRhID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0YXJlYScpWzBdO1xuXHRcdFx0XHRcdGlmICh0YSkge1xuXHRcdFx0XHRcdFx0eGhyLnJlc3BvbnNlVGV4dCA9IHRhLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gc3VwcG9ydCBmb3IgWEhSICdzdGF0dXMnICYgJ3N0YXR1c1RleHQnIGVtdWxhdGlvbiA6XG5cdFx0XHRcdFx0XHR4aHIuc3RhdHVzID0gTnVtYmVyKCB0YS5nZXRBdHRyaWJ1dGUoJ3N0YXR1cycpICkgfHwgeGhyLnN0YXR1cztcblx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0ID0gdGEuZ2V0QXR0cmlidXRlKCdzdGF0dXNUZXh0JykgfHwgeGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHNjcikge1xuXHRcdFx0XHRcdFx0Ly8gYWNjb3VudCBmb3IgYnJvd3NlcnMgaW5qZWN0aW5nIHByZSBhcm91bmQganNvbiByZXNwb25zZVxuXHRcdFx0XHRcdFx0dmFyIHByZSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJlJylbMF07XG5cdFx0XHRcdFx0XHR2YXIgYiA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuXHRcdFx0XHRcdFx0aWYgKHByZSkge1xuXHRcdFx0XHRcdFx0XHR4aHIucmVzcG9uc2VUZXh0ID0gcHJlLnRleHRDb250ZW50ID8gcHJlLnRleHRDb250ZW50IDogcHJlLmlubmVyVGV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGIpIHtcblx0XHRcdFx0XHRcdFx0eGhyLnJlc3BvbnNlVGV4dCA9IGIudGV4dENvbnRlbnQgPyBiLnRleHRDb250ZW50IDogYi5pbm5lclRleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGR0ID09ICd4bWwnICYmICF4aHIucmVzcG9uc2VYTUwgJiYgeGhyLnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0eGhyLnJlc3BvbnNlWE1MID0gdG9YbWwoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRhdGEgPSBodHRwRGF0YSh4aHIsIGR0LCBzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHN0YXR1cyA9ICdwYXJzZXJlcnJvcic7XG5cdFx0XHRcdFx0eGhyLmVycm9yID0gZXJyTXNnID0gKGUgfHwgc3RhdHVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0bG9nKCdlcnJvciBjYXVnaHQ6ICcsZSk7XG5cdFx0XHRcdHN0YXR1cyA9ICdlcnJvcic7XG5cdFx0XHRcdHhoci5lcnJvciA9IGVyck1zZyA9IChlIHx8IHN0YXR1cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh4aHIuYWJvcnRlZCkge1xuXHRcdFx0XHRsb2coJ3VwbG9hZCBhYm9ydGVkJyk7XG5cdFx0XHRcdHN0YXR1cyA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh4aHIuc3RhdHVzKSB7IC8vIHdlJ3ZlIHNldCB4aHIuc3RhdHVzXG5cdFx0XHRcdHN0YXR1cyA9ICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwIHx8IHhoci5zdGF0dXMgPT09IDMwNCkgPyAnc3VjY2VzcycgOiAnZXJyb3InO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBvcmRlcmluZyBvZiB0aGVzZSBjYWxsYmFja3MvdHJpZ2dlcnMgaXMgb2RkLCBidXQgdGhhdCdzIGhvdyAkLmFqYXggZG9lcyBpdFxuXHRcdFx0aWYgKHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG5cdFx0XHRcdHMuc3VjY2VzcyAmJiBzLnN1Y2Nlc3MuY2FsbChzLmNvbnRleHQsIGRhdGEsICdzdWNjZXNzJywgeGhyKTtcblx0XHRcdFx0ZyAmJiAkLmV2ZW50LnRyaWdnZXIoXCJhamF4U3VjY2Vzc1wiLCBbeGhyLCBzXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzdGF0dXMpIHtcblx0XHRcdFx0aWYgKGVyck1zZyA9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZXJyTXNnID0geGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdHMuZXJyb3IgJiYgcy5lcnJvci5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMsIGVyck1zZyk7XG5cdFx0XHRcdGcgJiYgJC5ldmVudC50cmlnZ2VyKFwiYWpheEVycm9yXCIsIFt4aHIsIHMsIGVyck1zZ10pO1xuXHRcdFx0fVxuXG5cdFx0XHRnICYmICQuZXZlbnQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbeGhyLCBzXSk7XG5cblx0XHRcdGlmIChnICYmICEgLS0kLmFjdGl2ZSkge1xuXHRcdFx0XHQkLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdH1cblxuXHRcdFx0cy5jb21wbGV0ZSAmJiBzLmNvbXBsZXRlLmNhbGwocy5jb250ZXh0LCB4aHIsIHN0YXR1cyk7XG5cblx0XHRcdGNhbGxiYWNrUHJvY2Vzc2VkID0gdHJ1ZTtcblx0XHRcdGlmIChzLnRpbWVvdXQpXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcblxuXHRcdFx0Ly8gY2xlYW4gdXBcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghcy5pZnJhbWVUYXJnZXQpXG5cdFx0XHRcdFx0JGlvLnJlbW92ZSgpO1xuXHRcdFx0XHR4aHIucmVzcG9uc2VYTUwgPSBudWxsO1xuXHRcdFx0fSwgMTAwKTtcblx0XHR9XG5cblx0XHR2YXIgdG9YbWwgPSAkLnBhcnNlWE1MIHx8IGZ1bmN0aW9uKHMsIGRvYykgeyAvLyB1c2UgcGFyc2VYTUwgaWYgYXZhaWxhYmxlIChqUXVlcnkgMS41Kylcblx0XHRcdGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuXHRcdFx0XHRkb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuXHRcdFx0XHRkb2MuYXN5bmMgPSAnZmFsc2UnO1xuXHRcdFx0XHRkb2MubG9hZFhNTChzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkb2MgPSAobmV3IERPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcocywgJ3RleHQveG1sJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50ICYmIGRvYy5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT0gJ3BhcnNlcmVycm9yJykgPyBkb2MgOiBudWxsO1xuXHRcdH07XG5cdFx0dmFyIHBhcnNlSlNPTiA9ICQucGFyc2VKU09OIHx8IGZ1bmN0aW9uKHMpIHtcblx0XHRcdHJldHVybiB3aW5kb3dbJ2V2YWwnXSgnKCcgKyBzICsgJyknKTtcblx0XHR9O1xuXG5cdFx0dmFyIGh0dHBEYXRhID0gZnVuY3Rpb24oIHhociwgdHlwZSwgcyApIHsgLy8gbW9zdGx5IGxpZnRlZCBmcm9tIGpxMS40LjRcblxuXHRcdFx0dmFyIGN0ID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSB8fCAnJyxcblx0XHRcdFx0eG1sID0gdHlwZSA9PT0gJ3htbCcgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZigneG1sJykgPj0gMCxcblx0XHRcdFx0ZGF0YSA9IHhtbCA/IHhoci5yZXNwb25zZVhNTCA6IHhoci5yZXNwb25zZVRleHQ7XG5cblx0XHRcdGlmICh4bWwgJiYgZGF0YS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09ICdwYXJzZXJlcnJvcicpIHtcblx0XHRcdFx0JC5lcnJvciAmJiAkLmVycm9yKCdwYXJzZXJlcnJvcicpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHMgJiYgcy5kYXRhRmlsdGVyKSB7XG5cdFx0XHRcdGRhdGEgPSBzLmRhdGFGaWx0ZXIoZGF0YSwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnanNvbicgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZignanNvbicpID49IDApIHtcblx0XHRcdFx0XHRkYXRhID0gcGFyc2VKU09OKGRhdGEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwic2NyaXB0XCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZihcImphdmFzY3JpcHRcIikgPj0gMCkge1xuXHRcdFx0XHRcdCQuZ2xvYmFsRXZhbChkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblx0fVxufTtcblxuLyoqXG4gKiBhamF4Rm9ybSgpIHByb3ZpZGVzIGEgbWVjaGFuaXNtIGZvciBmdWxseSBhdXRvbWF0aW5nIGZvcm0gc3VibWlzc2lvbi5cbiAqXG4gKiBUaGUgYWR2YW50YWdlcyBvZiB1c2luZyB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIGFqYXhTdWJtaXQoKSBhcmU6XG4gKlxuICogMTogVGhpcyBtZXRob2Qgd2lsbCBpbmNsdWRlIGNvb3JkaW5hdGVzIGZvciA8aW5wdXQgdHlwZT1cImltYWdlXCIgLz4gZWxlbWVudHMgKGlmIHRoZSBlbGVtZW50XG4gKlx0aXMgdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0pLlxuICogMi4gVGhpcyBtZXRob2Qgd2lsbCBpbmNsdWRlIHRoZSBzdWJtaXQgZWxlbWVudCdzIG5hbWUvdmFsdWUgZGF0YSAoZm9yIHRoZSBlbGVtZW50IHRoYXQgd2FzXG4gKlx0dXNlZCB0byBzdWJtaXQgdGhlIGZvcm0pLlxuICogMy4gVGhpcyBtZXRob2QgYmluZHMgdGhlIHN1Ym1pdCgpIG1ldGhvZCB0byB0aGUgZm9ybSBmb3IgeW91LlxuICpcbiAqIFRoZSBvcHRpb25zIGFyZ3VtZW50IGZvciBhamF4Rm9ybSB3b3JrcyBleGFjdGx5IGFzIGl0IGRvZXMgZm9yIGFqYXhTdWJtaXQuICBhamF4Rm9ybSBtZXJlbHlcbiAqIHBhc3NlcyB0aGUgb3B0aW9ucyBhcmd1bWVudCBhbG9uZyBhZnRlciBwcm9wZXJseSBiaW5kaW5nIGV2ZW50cyBmb3Igc3VibWl0IGVsZW1lbnRzIGFuZFxuICogdGhlIGZvcm0gaXRzZWxmLlxuICovXG4kLmZuLmFqYXhGb3JtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5kZWxlZ2F0aW9uID0gb3B0aW9ucy5kZWxlZ2F0aW9uICYmICQuaXNGdW5jdGlvbigkLmZuLm9uKTtcblx0XG5cdC8vIGluIGpRdWVyeSAxLjMrIHdlIGNhbiBmaXggbWlzdGFrZXMgd2l0aCB0aGUgcmVhZHkgc3RhdGVcblx0aWYgKCFvcHRpb25zLmRlbGVnYXRpb24gJiYgdGhpcy5sZW5ndGggPT09IDApIHtcblx0XHR2YXIgbyA9IHsgczogdGhpcy5zZWxlY3RvciwgYzogdGhpcy5jb250ZXh0IH07XG5cdFx0aWYgKCEkLmlzUmVhZHkgJiYgby5zKSB7XG5cdFx0XHRsb2coJ0RPTSBub3QgcmVhZHksIHF1ZXVpbmcgYWpheEZvcm0nKTtcblx0XHRcdCQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoby5zLG8uYykuYWpheEZvcm0ob3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHQvLyBpcyB5b3VyIERPTSByZWFkeT8gIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVHV0b3JpYWxzOkludHJvZHVjaW5nXyQoZG9jdW1lbnQpLnJlYWR5KClcblx0XHRsb2coJ3Rlcm1pbmF0aW5nOyB6ZXJvIGVsZW1lbnRzIGZvdW5kIGJ5IHNlbGVjdG9yJyArICgkLmlzUmVhZHkgPyAnJyA6ICcgKERPTSBub3QgcmVhZHkpJykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmRlbGVnYXRpb24gKSB7XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5vZmYoJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGRvQWpheFN1Ym1pdClcblx0XHRcdC5vZmYoJ2NsaWNrLmZvcm0tcGx1Z2luJywgdGhpcy5zZWxlY3RvciwgY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KVxuXHRcdFx0Lm9uKCdzdWJtaXQuZm9ybS1wbHVnaW4nLCB0aGlzLnNlbGVjdG9yLCBvcHRpb25zLCBkb0FqYXhTdWJtaXQpXG5cdFx0XHQub24oJ2NsaWNrLmZvcm0tcGx1Z2luJywgdGhpcy5zZWxlY3Rvciwgb3B0aW9ucywgY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJldHVybiB0aGlzLmFqYXhGb3JtVW5iaW5kKClcblx0XHQuYmluZCgnc3VibWl0LmZvcm0tcGx1Z2luJywgb3B0aW9ucywgZG9BamF4U3VibWl0KVxuXHRcdC5iaW5kKCdjbGljay5mb3JtLXBsdWdpbicsIG9wdGlvbnMsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudCk7XG59O1xuXG4vLyBwcml2YXRlIGV2ZW50IGhhbmRsZXJzXHRcbmZ1bmN0aW9uIGRvQWpheFN1Ym1pdChlKSB7XG5cdHZhciBvcHRpb25zID0gZS5kYXRhO1xuXHRpZiAoIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHsgLy8gaWYgZXZlbnQgaGFzIGJlZW4gY2FuY2VsZWQsIGRvbid0IHByb2NlZWRcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0JCh0aGlzKS5hamF4U3VibWl0KG9wdGlvbnMpO1xuXHR9XG59XG5cdFxuZnVuY3Rpb24gY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KGUpIHtcblx0dmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuXHR2YXIgJGVsID0gJCh0YXJnZXQpO1xuXHRpZiAoISgkZWwuaXMoXCI6c3VibWl0LGlucHV0OmltYWdlXCIpKSkge1xuXHRcdC8vIGlzIHRoaXMgYSBjaGlsZCBlbGVtZW50IG9mIHRoZSBzdWJtaXQgZWw/ICAoZXg6IGEgc3BhbiB3aXRoaW4gYSBidXR0b24pXG5cdFx0dmFyIHQgPSAkZWwuY2xvc2VzdCgnOnN1Ym1pdCcpO1xuXHRcdGlmICh0Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRhcmdldCA9IHRbMF07XG5cdH1cblx0dmFyIGZvcm0gPSB0aGlzO1xuXHRmb3JtLmNsayA9IHRhcmdldDtcblx0aWYgKHRhcmdldC50eXBlID09ICdpbWFnZScpIHtcblx0XHRpZiAoZS5vZmZzZXRYICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9ybS5jbGtfeCA9IGUub2Zmc2V0WDtcblx0XHRcdGZvcm0uY2xrX3kgPSBlLm9mZnNldFk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgJC5mbi5vZmZzZXQgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIG9mZnNldCA9ICRlbC5vZmZzZXQoKTtcblx0XHRcdGZvcm0uY2xrX3ggPSBlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQ7XG5cdFx0XHRmb3JtLmNsa195ID0gZS5wYWdlWSAtIG9mZnNldC50b3A7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvcm0uY2xrX3ggPSBlLnBhZ2VYIC0gdGFyZ2V0Lm9mZnNldExlZnQ7XG5cdFx0XHRmb3JtLmNsa195ID0gZS5wYWdlWSAtIHRhcmdldC5vZmZzZXRUb3A7XG5cdFx0fVxuXHR9XG5cdC8vIGNsZWFyIGZvcm0gdmFyc1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmb3JtLmNsayA9IGZvcm0uY2xrX3ggPSBmb3JtLmNsa195ID0gbnVsbDsgfSwgMTAwKTtcbn07XG5cblxuLy8gYWpheEZvcm1VbmJpbmQgdW5iaW5kcyB0aGUgZXZlbnQgaGFuZGxlcnMgdGhhdCB3ZXJlIGJvdW5kIGJ5IGFqYXhGb3JtXG4kLmZuLmFqYXhGb3JtVW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnVuYmluZCgnc3VibWl0LmZvcm0tcGx1Z2luIGNsaWNrLmZvcm0tcGx1Z2luJyk7XG59O1xuXG4vKipcbiAqIGZvcm1Ub0FycmF5KCkgZ2F0aGVycyBmb3JtIGVsZW1lbnQgZGF0YSBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBjYW5cbiAqIGJlIHBhc3NlZCB0byBhbnkgb2YgdGhlIGZvbGxvd2luZyBhamF4IGZ1bmN0aW9uczogJC5nZXQsICQucG9zdCwgb3IgbG9hZC5cbiAqIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgYm90aCBhICduYW1lJyBhbmQgJ3ZhbHVlJyBwcm9wZXJ0eS4gIEFuIGV4YW1wbGUgb2ZcbiAqIGFuIGFycmF5IGZvciBhIHNpbXBsZSBsb2dpbiBmb3JtIG1pZ2h0IGJlOlxuICpcbiAqIFsgeyBuYW1lOiAndXNlcm5hbWUnLCB2YWx1ZTogJ2pyZXNpZycgfSwgeyBuYW1lOiAncGFzc3dvcmQnLCB2YWx1ZTogJ3NlY3JldCcgfSBdXG4gKlxuICogSXQgaXMgdGhpcyBhcnJheSB0aGF0IGlzIHBhc3NlZCB0byBwcmUtc3VibWl0IGNhbGxiYWNrIGZ1bmN0aW9ucyBwcm92aWRlZCB0byB0aGVcbiAqIGFqYXhTdWJtaXQoKSBhbmQgYWpheEZvcm0oKSBtZXRob2RzLlxuICovXG4kLmZuLmZvcm1Ub0FycmF5ID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcblx0dmFyIGEgPSBbXTtcblx0aWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblxuXHR2YXIgZm9ybSA9IHRoaXNbMF07XG5cdHZhciBlbHMgPSBzZW1hbnRpYyA/IGZvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSA6IGZvcm0uZWxlbWVudHM7XG5cdGlmICghZWxzKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblxuXHR2YXIgaSxqLG4sdixlbCxtYXgsam1heDtcblx0Zm9yKGk9MCwgbWF4PWVscy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdGVsID0gZWxzW2ldO1xuXHRcdG4gPSBlbC5uYW1lO1xuXHRcdGlmICghbikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbWFudGljICYmIGZvcm0uY2xrICYmIGVsLnR5cGUgPT0gXCJpbWFnZVwiKSB7XG5cdFx0XHQvLyBoYW5kbGUgaW1hZ2UgaW5wdXRzIG9uIHRoZSBmbHkgd2hlbiBzZW1hbnRpYyA9PSB0cnVlXG5cdFx0XHRpZighZWwuZGlzYWJsZWQgJiYgZm9ybS5jbGsgPT0gZWwpIHtcblx0XHRcdFx0YS5wdXNoKHtuYW1lOiBuLCB2YWx1ZTogJChlbCkudmFsKCksIHR5cGU6IGVsLnR5cGUgfSk7XG5cdFx0XHRcdGEucHVzaCh7bmFtZTogbisnLngnLCB2YWx1ZTogZm9ybS5jbGtfeH0sIHtuYW1lOiBuKycueScsIHZhbHVlOiBmb3JtLmNsa195fSk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2ID0gJC5maWVsZFZhbHVlKGVsLCB0cnVlKTtcblx0XHRpZiAodiAmJiB2LmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0XHRmb3Ioaj0wLCBqbWF4PXYubGVuZ3RoOyBqIDwgam1heDsgaisrKSB7XG5cdFx0XHRcdGEucHVzaCh7bmFtZTogbiwgdmFsdWU6IHZbal19KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodiAhPT0gbnVsbCAmJiB0eXBlb2YgdiAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0YS5wdXNoKHtuYW1lOiBuLCB2YWx1ZTogdiwgdHlwZTogZWwudHlwZX0pO1xuXHRcdH1cblx0fVxuXG5cdGlmICghc2VtYW50aWMgJiYgZm9ybS5jbGspIHtcblx0XHQvLyBpbnB1dCB0eXBlPT0naW1hZ2UnIGFyZSBub3QgZm91bmQgaW4gZWxlbWVudHMgYXJyYXkhIGhhbmRsZSBpdCBoZXJlXG5cdFx0dmFyICRpbnB1dCA9ICQoZm9ybS5jbGspLCBpbnB1dCA9ICRpbnB1dFswXTtcblx0XHRuID0gaW5wdXQubmFtZTtcblx0XHRpZiAobiAmJiAhaW5wdXQuZGlzYWJsZWQgJiYgaW5wdXQudHlwZSA9PSAnaW1hZ2UnKSB7XG5cdFx0XHRhLnB1c2goe25hbWU6IG4sIHZhbHVlOiAkaW5wdXQudmFsKCl9KTtcblx0XHRcdGEucHVzaCh7bmFtZTogbisnLngnLCB2YWx1ZTogZm9ybS5jbGtfeH0sIHtuYW1lOiBuKycueScsIHZhbHVlOiBmb3JtLmNsa195fSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIGZvcm0gZGF0YSBpbnRvIGEgJ3N1Ym1pdHRhYmxlJyBzdHJpbmcuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgc3RyaW5nXG4gKiBpbiB0aGUgZm9ybWF0OiBuYW1lMT12YWx1ZTEmYW1wO25hbWUyPXZhbHVlMlxuICovXG4kLmZuLmZvcm1TZXJpYWxpemUgPSBmdW5jdGlvbihzZW1hbnRpYykge1xuXHQvL2hhbmQgb2ZmIHRvIGpRdWVyeS5wYXJhbSBmb3IgcHJvcGVyIGVuY29kaW5nXG5cdHJldHVybiAkLnBhcmFtKHRoaXMuZm9ybVRvQXJyYXkoc2VtYW50aWMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplcyBhbGwgZmllbGQgZWxlbWVudHMgaW4gdGhlIGpRdWVyeSBvYmplY3QgaW50byBhIHF1ZXJ5IHN0cmluZy5cbiAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQ6IG5hbWUxPXZhbHVlMSZhbXA7bmFtZTI9dmFsdWUyXG4gKi9cbiQuZm4uZmllbGRTZXJpYWxpemUgPSBmdW5jdGlvbihzdWNjZXNzZnVsKSB7XG5cdHZhciBhID0gW107XG5cdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR2YXIgbiA9IHRoaXMubmFtZTtcblx0XHRpZiAoIW4pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHYgPSAkLmZpZWxkVmFsdWUodGhpcywgc3VjY2Vzc2Z1bCk7XG5cdFx0aWYgKHYgJiYgdi5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wLG1heD12Lmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdGEucHVzaCh7bmFtZTogbiwgdmFsdWU6IHZbaV19KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodiAhPT0gbnVsbCAmJiB0eXBlb2YgdiAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0YS5wdXNoKHtuYW1lOiB0aGlzLm5hbWUsIHZhbHVlOiB2fSk7XG5cdFx0fVxuXHR9KTtcblx0Ly9oYW5kIG9mZiB0byBqUXVlcnkucGFyYW0gZm9yIHByb3BlciBlbmNvZGluZ1xuXHRyZXR1cm4gJC5wYXJhbShhKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUocykgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LiAgRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAqXG4gKiAgPGZvcm0+PGZpZWxkc2V0PlxuICpcdCAgPGlucHV0IG5hbWU9XCJBXCIgdHlwZT1cInRleHRcIiAvPlxuICpcdCAgPGlucHV0IG5hbWU9XCJBXCIgdHlwZT1cInRleHRcIiAvPlxuICpcdCAgPGlucHV0IG5hbWU9XCJCXCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJCMVwiIC8+XG4gKlx0ICA8aW5wdXQgbmFtZT1cIkJcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIkIyXCIvPlxuICpcdCAgPGlucHV0IG5hbWU9XCJDXCIgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJDMVwiIC8+XG4gKlx0ICA8aW5wdXQgbmFtZT1cIkNcIiB0eXBlPVwicmFkaW9cIiB2YWx1ZT1cIkMyXCIgLz5cbiAqICA8L2ZpZWxkc2V0PjwvZm9ybT5cbiAqXG4gKiAgdmFyIHYgPSAkKCc6dGV4dCcpLmZpZWxkVmFsdWUoKTtcbiAqICAvLyBpZiBubyB2YWx1ZXMgYXJlIGVudGVyZWQgaW50byB0aGUgdGV4dCBpbnB1dHNcbiAqICB2ID09IFsnJywnJ11cbiAqICAvLyBpZiB2YWx1ZXMgZW50ZXJlZCBpbnRvIHRoZSB0ZXh0IGlucHV0cyBhcmUgJ2ZvbycgYW5kICdiYXInXG4gKiAgdiA9PSBbJ2ZvbycsJ2JhciddXG4gKlxuICogIHZhciB2ID0gJCgnOmNoZWNrYm94JykuZmllbGRWYWx1ZSgpO1xuICogIC8vIGlmIG5laXRoZXIgY2hlY2tib3ggaXMgY2hlY2tlZFxuICogIHYgPT09IHVuZGVmaW5lZFxuICogIC8vIGlmIGJvdGggY2hlY2tib3hlcyBhcmUgY2hlY2tlZFxuICogIHYgPT0gWydCMScsICdCMiddXG4gKlxuICogIHZhciB2ID0gJCgnOnJhZGlvJykuZmllbGRWYWx1ZSgpO1xuICogIC8vIGlmIG5laXRoZXIgcmFkaW8gaXMgY2hlY2tlZFxuICogIHYgPT09IHVuZGVmaW5lZFxuICogIC8vIGlmIGZpcnN0IHJhZGlvIGlzIGNoZWNrZWRcbiAqICB2ID09IFsnQzEnXVxuICpcbiAqIFRoZSBzdWNjZXNzZnVsIGFyZ3VtZW50IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBmaWVsZCBlbGVtZW50IG11c3QgYmUgJ3N1Y2Nlc3NmdWwnXG4gKiAocGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0L2ludGVyYWN0L2Zvcm1zLmh0bWwjc3VjY2Vzc2Z1bC1jb250cm9scykuXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgc3VjY2Vzc2Z1bCBhcmd1bWVudCBpcyB0cnVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSB0aGUgdmFsdWUocylcbiAqIGZvciBlYWNoIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgKmFsd2F5cyogcmV0dXJucyBhbiBhcnJheS4gIElmIG5vIHZhbGlkIHZhbHVlIGNhbiBiZSBkZXRlcm1pbmVkIHRoZVxuICpcdGFycmF5IHdpbGwgYmUgZW1wdHksIG90aGVyd2lzZSBpdCB3aWxsIGNvbnRhaW4gb25lIG9yIG1vcmUgdmFsdWVzLlxuICovXG4kLmZuLmZpZWxkVmFsdWUgPSBmdW5jdGlvbihzdWNjZXNzZnVsKSB7XG5cdGZvciAodmFyIHZhbD1bXSwgaT0wLCBtYXg9dGhpcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdHZhciBlbCA9IHRoaXNbaV07XG5cdFx0dmFyIHYgPSAkLmZpZWxkVmFsdWUoZWwsIHN1Y2Nlc3NmdWwpO1xuXHRcdGlmICh2ID09PSBudWxsIHx8IHR5cGVvZiB2ID09ICd1bmRlZmluZWQnIHx8ICh2LmNvbnN0cnVjdG9yID09IEFycmF5ICYmICF2Lmxlbmd0aCkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHR2LmNvbnN0cnVjdG9yID09IEFycmF5ID8gJC5tZXJnZSh2YWwsIHYpIDogdmFsLnB1c2godik7XG5cdH1cblx0cmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKi9cbiQuZmllbGRWYWx1ZSA9IGZ1bmN0aW9uKGVsLCBzdWNjZXNzZnVsKSB7XG5cdHZhciBuID0gZWwubmFtZSwgdCA9IGVsLnR5cGUsIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0aWYgKHN1Y2Nlc3NmdWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHN1Y2Nlc3NmdWwgPSB0cnVlO1xuXHR9XG5cblx0aWYgKHN1Y2Nlc3NmdWwgJiYgKCFuIHx8IGVsLmRpc2FibGVkIHx8IHQgPT0gJ3Jlc2V0JyB8fCB0ID09ICdidXR0b24nIHx8XG5cdFx0KHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpICYmICFlbC5jaGVja2VkIHx8XG5cdFx0KHQgPT0gJ3N1Ym1pdCcgfHwgdCA9PSAnaW1hZ2UnKSAmJiBlbC5mb3JtICYmIGVsLmZvcm0uY2xrICE9IGVsIHx8XG5cdFx0dGFnID09ICdzZWxlY3QnICYmIGVsLnNlbGVjdGVkSW5kZXggPT0gLTEpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICh0YWcgPT0gJ3NlbGVjdCcpIHtcblx0XHR2YXIgaW5kZXggPSBlbC5zZWxlY3RlZEluZGV4O1xuXHRcdGlmIChpbmRleCA8IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgYSA9IFtdLCBvcHMgPSBlbC5vcHRpb25zO1xuXHRcdHZhciBvbmUgPSAodCA9PSAnc2VsZWN0LW9uZScpO1xuXHRcdHZhciBtYXggPSAob25lID8gaW5kZXgrMSA6IG9wcy5sZW5ndGgpO1xuXHRcdGZvcih2YXIgaT0ob25lID8gaW5kZXggOiAwKTsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHR2YXIgb3AgPSBvcHNbaV07XG5cdFx0XHRpZiAob3Auc2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIHYgPSBvcC52YWx1ZTtcblx0XHRcdFx0aWYgKCF2KSB7IC8vIGV4dHJhIHBhaW4gZm9yIElFLi4uXG5cdFx0XHRcdFx0diA9IChvcC5hdHRyaWJ1dGVzICYmIG9wLmF0dHJpYnV0ZXNbJ3ZhbHVlJ10gJiYgIShvcC5hdHRyaWJ1dGVzWyd2YWx1ZSddLnNwZWNpZmllZCkpID8gb3AudGV4dCA6IG9wLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvbmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnB1c2godik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9XG5cdHJldHVybiAkKGVsKS52YWwoKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBmb3JtIGRhdGEuICBUYWtlcyB0aGUgZm9sbG93aW5nIGFjdGlvbnMgb24gdGhlIGZvcm0ncyBpbnB1dCBmaWVsZHM6XG4gKiAgLSBpbnB1dCB0ZXh0IGZpZWxkcyB3aWxsIGhhdmUgdGhlaXIgJ3ZhbHVlJyBwcm9wZXJ0eSBzZXQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICogIC0gc2VsZWN0IGVsZW1lbnRzIHdpbGwgaGF2ZSB0aGVpciAnc2VsZWN0ZWRJbmRleCcgcHJvcGVydHkgc2V0IHRvIC0xXG4gKiAgLSBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzIHdpbGwgaGF2ZSB0aGVpciAnY2hlY2tlZCcgcHJvcGVydHkgc2V0IHRvIGZhbHNlXG4gKiAgLSBpbnB1dHMgb2YgdHlwZSBzdWJtaXQsIGJ1dHRvbiwgcmVzZXQsIGFuZCBoaWRkZW4gd2lsbCAqbm90KiBiZSBlZmZlY3RlZFxuICogIC0gYnV0dG9uIGVsZW1lbnRzIHdpbGwgKm5vdCogYmUgZWZmZWN0ZWRcbiAqL1xuJC5mbi5jbGVhckZvcm0gPSBmdW5jdGlvbihpbmNsdWRlSGlkZGVuKSB7XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0JCgnaW5wdXQsc2VsZWN0LHRleHRhcmVhJywgdGhpcykuY2xlYXJGaWVsZHMoaW5jbHVkZUhpZGRlbik7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHNlbGVjdGVkIGZvcm0gZWxlbWVudHMuXG4gKi9cbiQuZm4uY2xlYXJGaWVsZHMgPSAkLmZuLmNsZWFySW5wdXRzID0gZnVuY3Rpb24oaW5jbHVkZUhpZGRlbikge1xuXHR2YXIgcmUgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZW1haWx8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaTsgLy8gJ2hpZGRlbicgaXMgbm90IGluIHRoaXMgbGlzdFxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ID0gdGhpcy50eXBlLCB0YWcgPSB0aGlzLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAocmUudGVzdCh0KSB8fCB0YWcgPT0gJ3RleHRhcmVhJyB8fCAoaW5jbHVkZUhpZGRlbiAmJiAvaGlkZGVuLy50ZXN0KHQpKSApIHtcblx0XHRcdHRoaXMudmFsdWUgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAodCA9PSAnY2hlY2tib3gnIHx8IHQgPT0gJ3JhZGlvJykge1xuXHRcdFx0dGhpcy5jaGVja2VkID0gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRhZyA9PSAnc2VsZWN0Jykge1xuXHRcdFx0dGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBmb3JtIGRhdGEuICBDYXVzZXMgYWxsIGZvcm0gZWxlbWVudHMgdG8gYmUgcmVzZXQgdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWUuXG4gKi9cbiQuZm4ucmVzZXRGb3JtID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0Ly8gZ3VhcmQgYWdhaW5zdCBhbiBpbnB1dCB3aXRoIHRoZSBuYW1lIG9mICdyZXNldCdcblx0XHQvLyBub3RlIHRoYXQgSUUgcmVwb3J0cyB0aGUgcmVzZXQgZnVuY3Rpb24gYXMgYW4gJ29iamVjdCdcblx0XHRpZiAodHlwZW9mIHRoaXMucmVzZXQgPT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHRoaXMucmVzZXQgPT0gJ29iamVjdCcgJiYgIXRoaXMucmVzZXQubm9kZVR5cGUpKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBhbnkgbWF0Y2hpbmcgZWxlbWVudHMuXG4gKi9cbiQuZm4uZW5hYmxlID0gZnVuY3Rpb24oYikge1xuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0YiA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRpc2FibGVkID0gIWI7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDaGVja3MvdW5jaGVja3MgYW55IG1hdGNoaW5nIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucyBhbmRcbiAqIHNlbGVjdHMvZGVzZWxlY3RzIGFuZCBtYXRjaGluZyBvcHRpb24gZWxlbWVudHMuXG4gKi9cbiQuZm4uc2VsZWN0ZWQgPSBmdW5jdGlvbihzZWxlY3QpIHtcblx0aWYgKHNlbGVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0ID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ID0gdGhpcy50eXBlO1xuXHRcdGlmICh0ID09ICdjaGVja2JveCcgfHwgdCA9PSAncmFkaW8nKSB7XG5cdFx0XHR0aGlzLmNoZWNrZWQgPSBzZWxlY3Q7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdvcHRpb24nKSB7XG5cdFx0XHR2YXIgJHNlbCA9ICQodGhpcykucGFyZW50KCdzZWxlY3QnKTtcblx0XHRcdGlmIChzZWxlY3QgJiYgJHNlbFswXSAmJiAkc2VsWzBdLnR5cGUgPT0gJ3NlbGVjdC1vbmUnKSB7XG5cdFx0XHRcdC8vIGRlc2VsZWN0IGFsbCBvdGhlciBvcHRpb25zXG5cdFx0XHRcdCRzZWwuZmluZCgnb3B0aW9uJykuc2VsZWN0ZWQoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZWxlY3RlZCA9IHNlbGVjdDtcblx0XHR9XG5cdH0pO1xufTtcblxuLy8gZXhwb3NlIGRlYnVnIHZhclxuJC5mbi5hamF4U3VibWl0LmRlYnVnID0gZmFsc2U7XG5cbi8vIGhlbHBlciBmbiBmb3IgY29uc29sZSBsb2dnaW5nXG5mdW5jdGlvbiBsb2coKSB7XG5cdGlmICghJC5mbi5hamF4U3VibWl0LmRlYnVnKSBcblx0XHRyZXR1cm47XG5cdHZhciBtc2cgPSAnW2pxdWVyeS5mb3JtXSAnICsgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsJycpO1xuXHRpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKSB7XG5cdFx0d2luZG93LmNvbnNvbGUubG9nKG1zZyk7XG5cdH1cblx0ZWxzZSBpZiAod2luZG93Lm9wZXJhICYmIHdpbmRvdy5vcGVyYS5wb3N0RXJyb3IpIHtcblx0XHR3aW5kb3cub3BlcmEucG9zdEVycm9yKG1zZyk7XG5cdH1cbn07XG5cbn0pKGpRdWVyeSk7IiwiLyoqXG4gKiBPbi1kZW1hbmQgSmF2YVNjcmlwdCBoYW5kbGVyXG4gKlxuICogQmFzZWQgb24gaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9maWxlcy9pc3N1ZXMvanF1ZXJ5Lm9uZGVtYW5kLmpzXy50eHRcbiAqIGFuZCBoZWF2aWx5IG1vZGlmaWVkIHRvIGludGVncmF0ZSB3aXRoIFNpbHZlclN0cmlwZSBhbmQgcHJvdG90eXBlLmpzLlxuICogQWRkcyBjYXBhYmlsaXRpZXMgZm9yIGN1c3RvbSBYLUluY2x1ZGUtQ1NTIGFuZCBYLUluY2x1ZGUtSlMgSFRUUCBoZWFkZXJzXG4gKiB0byByZXF1ZXN0IGxvYWRpbmcgb2YgZXh0ZXJuYWxzIGFsb25nc2lkZSBhbiBhamF4IHJlc3BvbnNlLlxuICpcbiAqIFJlcXVpcmVzIGpRdWVyeSAxLjUgKCQuRGVmZXJyZWQgc3VwcG9ydClcbiAqXG4gKiBDQVVUSU9OOiBSZWxpZXMgb24gY3VzdG9taXphdGlvbiBvZiB0aGUgJ2JlZm9yZVNlbmQnIGNhbGxiYWNrIGluIGpRdWVyeS5hamF4U2V0dXAoKVxuICpcbiAqIEBhdXRob3IgSW5nbyBTY2hvbW1lciAoaW5nbyBhdCBzaWx2ZXJzdHJpcGUgZG90IGNvbSlcbiAqIEBhdXRob3IgU2FtIE1pbm5lZSAoc2FtIGF0IHNpbHZlcnN0cmlwZSBkb3QgY29tKVxuICovXG4oZnVuY3Rpb24oJCl7XG5cblx0dmFyIGRlY29kZVBhdGggPSBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyUyQy9nLCcsJykucmVwbGFjZSgvXFwmYW1wOy9nLCAnJicpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcblx0fTtcblxuXHQkLmV4dGVuZCh7XG5cblx0XHQvLyBsb2FkZWQgZmlsZXMgbGlzdCAtIHRvIHByb3RlY3QgYWdhaW5zdCBsb2FkaW5nIGV4aXN0ZWQgZmlsZSBhZ2FpbiAgKGJ5IFBHQSlcblx0XHRfb25kZW1hbmRfbG9hZGVkX2xpc3QgOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBDU1Mgb3IgSlMgc2NyaXB0IGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkXG5cdFx0ICovXG5cdFx0aXNJdGVtTG9hZGVkIDogZnVuY3Rpb24oc2NyaXB0VXJsKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHNyYztcblx0XHRcdGlmKHRoaXMuX29uZGVtYW5kX2xvYWRlZF9saXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX29uZGVtYW5kX2xvYWRlZF9saXN0ID0ge307XG5cdFx0XHRcdCQoJ3NjcmlwdCcpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c3JjID0gJCh0aGlzKS5hdHRyKCdzcmMnKTtcblx0XHRcdFx0XHRpZihzcmMpIHNlbGYuX29uZGVtYW5kX2xvYWRlZF9saXN0W3NyY10gPSAxO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0JCgnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzcmMgPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcblx0XHRcdFx0XHRpZihzcmMpIHNlbGYuX29uZGVtYW5kX2xvYWRlZF9saXN0W3NyY10gPSAxO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fb25kZW1hbmRfbG9hZGVkX2xpc3RbZGVjb2RlUGF0aChzY3JpcHRVcmwpXSAhPT0gdW5kZWZpbmVkKTtcblx0XHR9LFxuXG5cdFx0cmVxdWlyZUNzcyA6IGZ1bmN0aW9uKHN0eWxlVXJsLCBtZWRpYSl7XG5cdFx0XHRpZighbWVkaWEpIG1lZGlhID0gJ2FsbCc7XG5cblx0XHRcdC8vIERvbid0IGRvdWJsZSB1cCBvbiBsb2FkaW5nIHNjcmlwdHNcblx0XHRcdGlmKCQuaXNJdGVtTG9hZGVkKHN0eWxlVXJsKSkgcmV0dXJuO1xuXG5cdFx0XHRpZihkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KXtcblx0XHRcdFx0dmFyIHNzID0gZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldChzdHlsZVVybCk7XG5cdFx0XHRcdHNzLm1lZGlhID0gbWVkaWE7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0XHRcdFx0JChzdHlsZVRhZykuYXR0cih7XG5cdFx0XHRcdFx0aHJlZlx0OiBzdHlsZVVybCxcblx0XHRcdFx0XHR0eXBlXHQ6ICd0ZXh0L2NzcycsXG5cdFx0XHRcdFx0bWVkaWEgXHQ6IG1lZGlhLFxuXHRcdFx0XHRcdHJlbFx0XHQ6ICdzdHlsZXNoZWV0J1xuXHRcdFx0XHR9KS5hcHBlbmRUbygkKCdoZWFkJykuZ2V0KDApKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fb25kZW1hbmRfbG9hZGVkX2xpc3Rbc3R5bGVVcmxdID0gMTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcm9jZXNzIHRoZSBYLUluY2x1ZGUtQ1NTIGFuZCBYLUluY2x1ZGUtSlMgaGVhZGVycyBwcm92aWRlZCBieSB0aGUgUmVxdWlyZW1lbnRzIGNsYXNzXG5cdFx0ICovXG5cdFx0cHJvY2Vzc09uRGVtYW5kSGVhZGVyczogZnVuY3Rpb24oeG1sLCBzdGF0dXMsIHhocikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBwcm9jZXNzRGZkID0gbmV3ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0Ly8gQ1NTXG5cdFx0XHRpZih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUluY2x1ZGUtQ1NTJykpIHtcblx0XHRcdFx0dmFyIGNzc0luY2x1ZGVzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUluY2x1ZGUtQ1NTJykuc3BsaXQoJywnKTtcblx0XHRcdFx0Zm9yKHZhciBpPTA7aTxjc3NJbmNsdWRlcy5sZW5ndGg7aSsrKSB7XG5cdFx0XHRcdFx0Ly8gU3ludGF4OiBcIlVSTDojIzptZWRpYVwiXG5cdFx0XHRcdFx0aWYoY3NzSW5jbHVkZXNbaV0ubWF0Y2goL14oLiopOiMjOiguKikkLykpIHtcblx0XHRcdFx0XHRcdCQucmVxdWlyZUNzcyhkZWNvZGVQYXRoKFJlZ0V4cC4kMSksIFJlZ0V4cC4kMik7XG5cdFx0XHRcdFx0Ly8gU3ludGF4OiBcIlVSTFwiXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCQucmVxdWlyZUNzcyhkZWNvZGVQYXRoKGNzc0luY2x1ZGVzW2ldKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEphdmFTY3JpcHRcblx0XHRcdHZhciBuZXdKc0luY2x1ZGVzID0gW107XG5cdFx0XHRpZih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUluY2x1ZGUtSlMnKSkge1xuXHRcdFx0XHR2YXIganNJbmNsdWRlcyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1JbmNsdWRlLUpTJykuc3BsaXQoJywnKTtcblx0XHRcdFx0Zm9yKHZhciBpPTA7aTxqc0luY2x1ZGVzLmxlbmd0aDtpKyspIHtcblx0XHRcdFx0XHR2YXIganNJbmNsdWRlUGF0aCA9IGRlY29kZVBhdGgoanNJbmNsdWRlc1tpXSk7XG5cdFx0XHRcdFx0aWYoISQuaXNJdGVtTG9hZGVkKGpzSW5jbHVkZVBhdGgpKSB7XG5cdFx0XHRcdFx0XHRuZXdKc0luY2x1ZGVzLnB1c2goanNJbmNsdWRlUGF0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIG1ha2UgYW4gYXJyYXkgb2YgdGhlIGluY2x1ZGVzIHRoYXQgYXJlIGFjdHVhbGx5IG5ldywgYW5kIGF0dGFjaCB0aGUgY2FsbGJhY2sgdG8gdGhlIGxhc3Qgb25lXG5cdFx0XHQvLyBUaGV5IGFyZSBwbGFjZWQgaW4gYSBxdWV1ZSBhbmQgd2lsbCBiZSBpbmNsdWRlZCBpbiBvcmRlci4gIFRoaXMgbWVhbnMgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbFxuXHRcdFx0Ly8gYmUgYWJsZSB0byBleGVjdXRlIHNjcmlwdCBpbiB0aGUgbmV3IGluY2x1ZGVzIChzdWNoIGFzIGEgbGl2ZXF1ZXJ5IHVwZGF0ZSlcblx0XHRcdHZhciBnZXRTY3JpcHRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihuZXdKc0luY2x1ZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBuZXdKc0luY2x1ZGUgPSBuZXdKc0luY2x1ZGVzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0Ly8gZW11bGF0ZXMgZ2V0U2NyaXB0KCkgd2l0aCBhZGR0bC4gc2V0dGluZ1xuXHRcdFx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdFx0XHRkYXRhVHlwZTogJ3NjcmlwdCcsXG5cdFx0XHRcdFx0XHR1cmw6IG5ld0pzSW5jbHVkZSxcblx0XHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLl9vbmRlbWFuZF9sb2FkZWRfbGlzdFtuZXdKc0luY2x1ZGVdID0gMTtcblx0XHRcdFx0XHRcdFx0Z2V0U2NyaXB0UXVldWUoKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjYWNoZTogZmFsc2UsXG5cdFx0XHRcdFx0XHQvLyBqUXVlcnkgc2VlbXMgdG8gb3ZlcnJpZGUgdGhlIFhIUiBvYmplY3RzIGlmIHVzZWQgaW4gYXN5bmMgbW9kZVxuXHRcdFx0XHRcdFx0YXN5bmM6IGZhbHNlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvY2Vzc0RmZC5yZXNvbHZlKHhtbCwgc3RhdHVzLCB4aHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG5ld0pzSW5jbHVkZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGdldFNjcmlwdFF1ZXVlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiB0aGVyZSBhcmVuJ3QgYW55IG5ldyBpbmNsdWRlcywgdGhlbiB3ZSBjYW4ganVzdCBjYWxsIHRoZSBjYWxsYmFja3Mgb3Vyc2VsdmVzXG5cdFx0XHRcdHByb2Nlc3NEZmQucmVzb2x2ZSh4bWwsIHN0YXR1cywgeGhyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NEZmQucHJvbWlzZSgpO1xuXHRcdH1cblxuXHR9KTtcblxuXHQkLmFqYXhTZXR1cCh7XG5cdFx0Ly8gYmVmb3JlU2VuZCBpcyB0aGUgb25seSBwbGFjZSB0byBhY2Nlc3MgdGhlIFhIUiBvYmplY3QgYmVmb3JlIHN1Y2Nlc3MgaGFuZGxlcnMgYXJlIGFkZGVkXG5cdFx0YmVmb3JlU2VuZDogZnVuY3Rpb24oanFYSFIsIHMpIHtcblx0XHRcdC8vIEF2b2lkIHJlY3Vyc2lvbiBpbiBhamF4IGNhbGxiYWNrcyBjYXVzZWQgYnkgZ2V0U2NyaXB0KCksIGJ5IG5vdCBwYXJzaW5nXG5cdFx0XHQvLyBvbmRlbWFuZCBoZWFkZXJzIGZvciAnc2NyaXB0JyBkYXRhdHlwZXNcblx0XHRcdGlmKHMuZGF0YVR5cGUgPT0gJ3NjcmlwdCcpIHJldHVybjtcblxuXHRcdFx0dmFyIGRmZCA9IG5ldyAkLkRlZmVycmVkKCk7XG5cblx0XHRcdC8vIFJlZ2lzdGVyIG91ciBvd24gc3VjY2VzcyBoYW5kbGVyIChhc3N1bWVzIG5vIGhhbmRsZXJzIGFyZSBhbHJlYWR5IHJlZ2lzdGVyZWQpXG5cdFx0XHQvLyAnc3VjY2VzcycgaXMgYW4gYWxpYXMgZm9yICdkb25lJywgd2hpY2ggaXMgZXhlY3V0ZWQgYnkgdGhlIGJ1aWx0LWluIGRlZmVycmVkIGluc3RhbmNlIGluICQuYWpheCgpXG5cdFx0XHRqcVhIUi5zdWNjZXNzKGZ1bmN0aW9uKHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpYSFIpIHtcblx0XHRcdFx0JC5wcm9jZXNzT25EZW1hbmRIZWFkZXJzKHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpYSFIpLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGZkLnJlc29sdmVXaXRoKHMuY29udGV4dCB8fCB0aGlzLCBbc3VjY2Vzcywgc3RhdHVzVGV4dCwgalhIUl0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZXJvdXRlIGFsbCBleHRlcm5hbCBzdWNjZXNzIGhhbmxkZXJzIHRocm91Z2ggb3VyIG93biBkZWZlcnJlZC5cblx0XHRcdC8vIE5vdCBvdmVybG9hZGluZyBmYWlsKCkgYXMgbm8gZXZlbnQgY2FuIGNhdXNlIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHRvIGZhaWwuXG5cdFx0XHRqcVhIUi5zdWNjZXNzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0ZGZkLmRvbmUoY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblxufSkoalF1ZXJ5KTtcbiIsIi8qKlxuICogalF1ZXJ5LnF1ZXJ5IC0gUXVlcnkgU3RyaW5nIE1vZGlmaWNhdGlvbiBhbmQgQ3JlYXRpb24gZm9yIGpRdWVyeVxuICogV3JpdHRlbiBieSBCbGFpciBNaXRjaGVsbW9yZSAoYmxhaXIgRE9UIG1pdGNoZWxtb3JlIEFUIGdtYWlsIERPVCBjb20pXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgV1RGUEwgKGh0dHA6Ly9zYW0uem95Lm9yZy93dGZwbC8pLlxuICogRGF0ZTogMjAwOS84LzEzXG4gKlxuICogQGF1dGhvciBCbGFpciBNaXRjaGVsbW9yZVxuICogQHZlcnNpb24gMi4xLjdcbiAqXG4gKiovXG5uZXcgZnVuY3Rpb24oc2V0dGluZ3MpIHsgXG4gIC8vIFZhcmlvdXMgU2V0dGluZ3NcbiAgdmFyICRzZXBhcmF0b3IgPSBzZXR0aW5ncy5zZXBhcmF0b3IgfHwgJyYnO1xuICB2YXIgJHNwYWNlcyA9IHNldHRpbmdzLnNwYWNlcyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIHZhciAkc3VmZml4ID0gc2V0dGluZ3Muc3VmZml4ID09PSBmYWxzZSA/ICcnIDogJ1tdJztcbiAgdmFyICRwcmVmaXggPSBzZXR0aW5ncy5wcmVmaXggPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICB2YXIgJGhhc2ggPSAkcHJlZml4ID8gc2V0dGluZ3MuaGFzaCA9PT0gdHJ1ZSA/IFwiI1wiIDogXCI/XCIgOiBcIlwiO1xuICB2YXIgJG51bWJlcnMgPSBzZXR0aW5ncy5udW1iZXJzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgXG4gIGpRdWVyeS5xdWVyeSA9IG5ldyBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXMgPSBmdW5jdGlvbihvLCB0KSB7XG4gICAgICByZXR1cm4gbyAhPSB1bmRlZmluZWQgJiYgbyAhPT0gbnVsbCAmJiAoISF0ID8gby5jb25zdHJ1Y3RvciA9PSB0IDogdHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgbSwgcnggPSAvXFxbKFteW10qKVxcXS9nLCBtYXRjaCA9IC9eKFteW10rKShcXFsuKlxcXSk/JC8uZXhlYyhwYXRoKSwgYmFzZSA9IG1hdGNoWzFdLCB0b2tlbnMgPSBbXTtcbiAgICAgIHdoaWxlIChtID0gcnguZXhlYyhtYXRjaFsyXSkpIHRva2Vucy5wdXNoKG1bMV0pO1xuICAgICAgcmV0dXJuIFtiYXNlLCB0b2tlbnNdO1xuICAgIH07XG4gICAgdmFyIHNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdG9rZW5zLCB2YWx1ZSkge1xuICAgICAgdmFyIG8sIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCAhPSAnb2JqZWN0JykgdGFyZ2V0ID0gbnVsbDtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xuICAgICAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0gW107XG4gICAgICAgIGlmIChpcyh0YXJnZXQsIEFycmF5KSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKHRva2Vucy5sZW5ndGggPT0gMCA/IHZhbHVlIDogc2V0KG51bGwsIHRva2Vucy5zbGljZSgwKSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpcyh0YXJnZXQsIE9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKHRhcmdldFtpKytdICE9IG51bGwpO1xuICAgICAgICAgIHRhcmdldFstLWldID0gdG9rZW5zLmxlbmd0aCA9PSAwID8gdmFsdWUgOiBzZXQodGFyZ2V0W2ldLCB0b2tlbnMuc2xpY2UoMCksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICB0YXJnZXQucHVzaCh0b2tlbnMubGVuZ3RoID09IDAgPyB2YWx1ZSA6IHNldChudWxsLCB0b2tlbnMuc2xpY2UoMCksIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW4gJiYgdG9rZW4ubWF0Y2goL15cXHMqWzAtOV0rXFxzKiQvKSkge1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0gW107XG4gICAgICAgIHRhcmdldFtpbmRleF0gPSB0b2tlbnMubGVuZ3RoID09IDAgPyB2YWx1ZSA6IHNldCh0YXJnZXRbaW5kZXhdLCB0b2tlbnMuc2xpY2UoMCksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdG9rZW4ucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgXCJcIik7XG4gICAgICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSB7fTtcbiAgICAgICAgaWYgKGlzKHRhcmdldCwgQXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGVtcFtpXSA9IHRhcmdldFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0ID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbaW5kZXhdID0gdG9rZW5zLmxlbmd0aCA9PSAwID8gdmFsdWUgOiBzZXQodGFyZ2V0W2luZGV4XSwgdG9rZW5zLnNsaWNlKDApLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIHF1ZXJ5T2JqZWN0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi5rZXlzID0ge307XG4gICAgICBcbiAgICAgIGlmIChhLnF1ZXJ5T2JqZWN0KSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKGEuZ2V0KCksIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgc2VsZi5TRVQoa2V5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHEgPSBcIlwiICsgdGhpcztcbiAgICAgICAgICBxID0gcS5yZXBsYWNlKC9eWz8jXS8sJycpOyAvLyByZW1vdmUgYW55IGxlYWRpbmcgPyB8fCAjXG4gICAgICAgICAgcSA9IHEucmVwbGFjZSgvWzsmXSQvLCcnKTsgLy8gcmVtb3ZlIGFueSB0cmFpbGluZyAmIHx8IDtcbiAgICAgICAgICBpZiAoJHNwYWNlcykgcSA9IHEucmVwbGFjZSgvWytdL2csJyAnKTsgLy8gcmVwbGFjZSArJ3Mgd2l0aCBzcGFjZXNcbiAgICAgICAgICBcbiAgICAgICAgICBqUXVlcnkuZWFjaChxLnNwbGl0KC9bJjtdLyksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc3BsaXQoJz0nKVswXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5zcGxpdCgnPScpWzFdIHx8IFwiXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoJG51bWJlcnMpIHtcbiAgICAgICAgICAgICAgaWYgKC9eWystXT9bMC05XStcXC5bMC05XSokLy50ZXN0KHZhbCkpIC8vIHNpbXBsZSBmbG9hdCByZWdleFxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoL15bKy1dP1swLTldKyQvLnRlc3QodmFsKSkgLy8gc2ltcGxlIGludCByZWdleFxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YWwgPSAoIXZhbCAmJiB2YWwgIT09IDApID8gdHJ1ZSA6IHZhbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gZmFsc2UgJiYgdmFsICE9PSB0cnVlICYmIHR5cGVvZiB2YWwgIT0gJ251bWJlcicpXG4gICAgICAgICAgICAgIHZhbCA9IHZhbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2VsZi5TRVQoa2V5LCB2YWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgcXVlcnlPYmplY3QucHJvdG90eXBlID0ge1xuICAgICAgcXVlcnlPYmplY3Q6IHRydWUsXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSwgdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gaXModmFsdWUsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIEdFVDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICghaXMoa2V5KSkgcmV0dXJuIHRoaXMua2V5cztcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlKGtleSksIGJhc2UgPSBwYXJzZWRbMF0sIHRva2VucyA9IHBhcnNlZFsxXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMua2V5c1tiYXNlXTtcbiAgICAgICAgd2hpbGUgKHRhcmdldCAhPSBudWxsICYmIHRva2Vucy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFt0b2tlbnMuc2hpZnQoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT0gJ251bWJlcicgPyB0YXJnZXQgOiB0YXJnZXQgfHwgXCJcIjtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5HRVQoa2V5KTtcbiAgICAgICAgaWYgKGlzKHRhcmdldCwgT2JqZWN0KSlcbiAgICAgICAgICByZXR1cm4galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgdGFyZ2V0KTtcbiAgICAgICAgZWxzZSBpZiAoaXModGFyZ2V0LCBBcnJheSkpXG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5zbGljZSgwKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0sXG4gICAgICBTRVQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICFpcyh2YWwpID8gbnVsbCA6IHZhbDtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlKGtleSksIGJhc2UgPSBwYXJzZWRbMF0sIHRva2VucyA9IHBhcnNlZFsxXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMua2V5c1tiYXNlXTtcbiAgICAgICAgdGhpcy5rZXlzW2Jhc2VdID0gc2V0KHRhcmdldCwgdG9rZW5zLnNsaWNlKDApLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSgpLlNFVChrZXksIHZhbCk7XG4gICAgICB9LFxuICAgICAgUkVNT1ZFOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuU0VUKGtleSwgbnVsbCkuQ09NUEFDVCgpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5SRU1PVkUoa2V5KTtcbiAgICAgIH0sXG4gICAgICBFTVBUWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgalF1ZXJ5LmVhY2goc2VsZi5rZXlzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGYua2V5c1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9LFxuICAgICAgbG9hZDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciBoYXNoID0gdXJsLnJlcGxhY2UoL14uKj9bI10oLis/KSg/OlxcPy4rKT8kLywgXCIkMVwiKTtcbiAgICAgICAgdmFyIHNlYXJjaCA9IHVybC5yZXBsYWNlKC9eLio/Wz9dKC4rPykoPzojLispPyQvLCBcIiQxXCIpO1xuICAgICAgICByZXR1cm4gbmV3IHF1ZXJ5T2JqZWN0KHVybC5sZW5ndGggPT0gc2VhcmNoLmxlbmd0aCA/ICcnIDogc2VhcmNoLCB1cmwubGVuZ3RoID09IGhhc2gubGVuZ3RoID8gJycgOiBoYXNoKTtcbiAgICAgIH0sXG4gICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5FTVBUWSgpO1xuICAgICAgfSxcbiAgICAgIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHF1ZXJ5T2JqZWN0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIENPTVBBQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBidWlsZChvcmlnKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHR5cGVvZiBvcmlnID09IFwib2JqZWN0XCIgPyBpcyhvcmlnLCBBcnJheSkgPyBbXSA6IHt9IDogb3JpZztcbiAgICAgICAgICBpZiAodHlwZW9mIG9yaWcgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZChvLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChpcyhvLCBBcnJheSkpXG4gICAgICAgICAgICAgICAgby5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgalF1ZXJ5LmVhY2gob3JpZywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGFkZChvYmosIGtleSwgYnVpbGQodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5cyA9IGJ1aWxkKHRoaXMua2V5cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNvbXBhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCkuQ09NUEFDVCgpO1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBxdWVyeVN0cmluZyA9IFtdLCBjaHVua3MgPSBbXSwgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICBzdHIgPSBzdHIgKyBcIlwiO1xuICAgICAgICAgIGlmICgkc3BhY2VzKSBzdHIgPSBzdHIucmVwbGFjZSgvIC9nLCBcIitcIik7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYWRkRmllbGRzID0gZnVuY3Rpb24oYXJyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFpcyh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgdmFyIG8gPSBbZW5jb2RlKGtleSldO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgby5wdXNoKFwiPVwiKTtcbiAgICAgICAgICAgIG8ucHVzaChlbmNvZGUodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyLnB1c2goby5qb2luKFwiXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJ1aWxkID0gZnVuY3Rpb24ob2JqLCBiYXNlKSB7XG4gICAgICAgICAgdmFyIG5ld0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICFiYXNlIHx8IGJhc2UgPT0gXCJcIiA/IFtrZXldLmpvaW4oXCJcIikgOiBbYmFzZSwgXCJbXCIsIGtleSwgXCJdXCJdLmpvaW4oXCJcIik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIFxuICAgICAgICAgICAgICBidWlsZCh2YWx1ZSwgbmV3S2V5KGtleSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBhZGRGaWVsZHMoY2h1bmtzLCBuZXdLZXkoa2V5KSwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYnVpbGQodGhpcy5rZXlzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjaHVua3MubGVuZ3RoID4gMCkgcXVlcnlTdHJpbmcucHVzaCgkaGFzaCk7XG4gICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goY2h1bmtzLmpvaW4oJHNlcGFyYXRvcikpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gbmV3IHF1ZXJ5T2JqZWN0KGxvY2F0aW9uLnNlYXJjaCwgbG9jYXRpb24uaGFzaCk7XG4gIH07XG59KGpRdWVyeS5xdWVyeSB8fCB7fSk7IC8vIFBhc3MgaW4galF1ZXJ5LnF1ZXJ5IGFzIHNldHRpbmdzIG9iamVjdCIsIi8qISBqUXVlcnkgVUkgLSB2MS45LjIgLSAyMDEyLTExLTIzXG4qIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiogSW5jbHVkZXM6IGpxdWVyeS51aS5jb3JlLmpzLCBqcXVlcnkudWkud2lkZ2V0LmpzLCBqcXVlcnkudWkubW91c2UuanMsIGpxdWVyeS51aS5wb3NpdGlvbi5qcywganF1ZXJ5LnVpLmFjY29yZGlvbi5qcywganF1ZXJ5LnVpLmF1dG9jb21wbGV0ZS5qcywganF1ZXJ5LnVpLmJ1dHRvbi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXIuanMsIGpxdWVyeS51aS5kaWFsb2cuanMsIGpxdWVyeS51aS5kcmFnZ2FibGUuanMsIGpxdWVyeS51aS5kcm9wcGFibGUuanMsIGpxdWVyeS51aS5lZmZlY3QuanMsIGpxdWVyeS51aS5lZmZlY3QtYmxpbmQuanMsIGpxdWVyeS51aS5lZmZlY3QtYm91bmNlLmpzLCBqcXVlcnkudWkuZWZmZWN0LWNsaXAuanMsIGpxdWVyeS51aS5lZmZlY3QtZHJvcC5qcywganF1ZXJ5LnVpLmVmZmVjdC1leHBsb2RlLmpzLCBqcXVlcnkudWkuZWZmZWN0LWZhZGUuanMsIGpxdWVyeS51aS5lZmZlY3QtZm9sZC5qcywganF1ZXJ5LnVpLmVmZmVjdC1oaWdobGlnaHQuanMsIGpxdWVyeS51aS5lZmZlY3QtcHVsc2F0ZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1zY2FsZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1zaGFrZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1zbGlkZS5qcywganF1ZXJ5LnVpLmVmZmVjdC10cmFuc2Zlci5qcywganF1ZXJ5LnVpLm1lbnUuanMsIGpxdWVyeS51aS5wcm9ncmVzc2Jhci5qcywganF1ZXJ5LnVpLnJlc2l6YWJsZS5qcywganF1ZXJ5LnVpLnNlbGVjdGFibGUuanMsIGpxdWVyeS51aS5zbGlkZXIuanMsIGpxdWVyeS51aS5zb3J0YWJsZS5qcywganF1ZXJ5LnVpLnNwaW5uZXIuanMsIGpxdWVyeS51aS50YWJzLmpzLCBqcXVlcnkudWkudG9vbHRpcC5qc1xuKiBDb3B5cmlnaHQgKGMpIDIwMTIgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyBMaWNlbnNlZCBNSVQgKi9cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1dWlkID0gMCxcblx0cnVuaXF1ZUlkID0gL151aS1pZC1cXGQrJC87XG5cbi8vIHByZXZlbnQgZHVwbGljYXRlIGxvYWRpbmdcbi8vIHRoaXMgaXMgb25seSBhIHByb2JsZW0gYmVjYXVzZSB3ZSBwcm94eSBleGlzdGluZyBmdW5jdGlvbnNcbi8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRvdWJsZSBwcm94eSB0aGVtXG4kLnVpID0gJC51aSB8fCB7fTtcbmlmICggJC51aS52ZXJzaW9uICkge1xuXHRyZXR1cm47XG59XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblxuXHRrZXlDb2RlOiB7XG5cdFx0QkFDS1NQQUNFOiA4LFxuXHRcdENPTU1BOiAxODgsXG5cdFx0REVMRVRFOiA0Nixcblx0XHRET1dOOiA0MCxcblx0XHRFTkQ6IDM1LFxuXHRcdEVOVEVSOiAxMyxcblx0XHRFU0NBUEU6IDI3LFxuXHRcdEhPTUU6IDM2LFxuXHRcdExFRlQ6IDM3LFxuXHRcdE5VTVBBRF9BREQ6IDEwNyxcblx0XHROVU1QQURfREVDSU1BTDogMTEwLFxuXHRcdE5VTVBBRF9ESVZJREU6IDExMSxcblx0XHROVU1QQURfRU5URVI6IDEwOCxcblx0XHROVU1QQURfTVVMVElQTFk6IDEwNixcblx0XHROVU1QQURfU1VCVFJBQ1Q6IDEwOSxcblx0XHRQQUdFX0RPV046IDM0LFxuXHRcdFBBR0VfVVA6IDMzLFxuXHRcdFBFUklPRDogMTkwLFxuXHRcdFJJR0hUOiAzOSxcblx0XHRTUEFDRTogMzIsXG5cdFx0VEFCOiA5LFxuXHRcdFVQOiAzOFxuXHR9XG59KTtcblxuLy8gcGx1Z2luc1xuJC5mbi5leHRlbmQoe1xuXHRfZm9jdXM6ICQuZm4uZm9jdXMsXG5cdGZvY3VzOiBmdW5jdGlvbiggZGVsYXksIGZuICkge1xuXHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCggZWxlbSApLmZvY3VzKCk7XG5cdFx0XHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIGRlbGF5ICk7XG5cdFx0XHR9KSA6XG5cdFx0XHR0aGlzLl9mb2N1cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH0sXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcygncG9zaXRpb24nKSkpIHx8ICgvYWJzb2x1dGUvKS50ZXN0KHRoaXMuY3NzKCdwb3NpdGlvbicpKSkge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8ocmVsYXRpdmV8YWJzb2x1dGV8Zml4ZWQpLykudGVzdCgkLmNzcyh0aGlzLCdwb3NpdGlvbicpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsJ292ZXJmbG93JykrJC5jc3ModGhpcywnb3ZlcmZsb3cteScpKyQuY3NzKHRoaXMsJ292ZXJmbG93LXgnKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLCdvdmVyZmxvdycpKyQuY3NzKHRoaXMsJ292ZXJmbG93LXknKSskLmNzcyh0aGlzLCdvdmVyZmxvdy14JykpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKCdwb3NpdGlvbicpKSB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xuXHR9LFxuXG5cdHpJbmRleDogZnVuY3Rpb24oIHpJbmRleCApIHtcblx0XHRpZiAoIHpJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCBcInpJbmRleFwiLCB6SW5kZXggKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzWyAwIF0gKSwgcG9zaXRpb24sIHZhbHVlO1xuXHRcdFx0d2hpbGUgKCBlbGVtLmxlbmd0aCAmJiBlbGVtWyAwIF0gIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHQvLyBJZ25vcmUgei1pbmRleCBpZiBwb3NpdGlvbiBpcyBzZXQgdG8gYSB2YWx1ZSB3aGVyZSB6LWluZGV4IGlzIGlnbm9yZWQgYnkgdGhlIGJyb3dzZXJcblx0XHRcdFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0XHRcdC8vIFdlYktpdCBhbHdheXMgcmV0dXJucyBhdXRvIGlmIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWRcblx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0Ly8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcblx0XHRcdFx0XHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcblx0XHRcdFx0XHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxuXHRcdFx0XHRcdC8vIDxkaXYgc3R5bGU9XCJ6LWluZGV4OiAtMTA7XCI+PGRpdiBzdHlsZT1cInotaW5kZXg6IDA7XCI+PC9kaXY+PC9kaXY+XG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUludCggZWxlbS5jc3MoIFwiekluZGV4XCIgKSwgMTAgKTtcblx0XHRcdFx0XHRpZiAoICFpc05hTiggdmFsdWUgKSAmJiB2YWx1ZSAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbSA9IGVsZW0ucGFyZW50KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0dW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGlzLmlkICkge1xuXHRcdFx0XHR0aGlzLmlkID0gXCJ1aS1pZC1cIiArICgrK3V1aWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBydW5pcXVlSWQudGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJpZFwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBzZWxlY3RvcnNcbmZ1bmN0aW9uIGZvY3VzYWJsZSggZWxlbWVudCwgaXNUYWJJbmRleE5vdE5hTiApIHtcblx0dmFyIG1hcCwgbWFwTmFtZSwgaW1nLFxuXHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoIFwiYXJlYVwiID09PSBub2RlTmFtZSApIHtcblx0XHRtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0bWFwTmFtZSA9IG1hcC5uYW1lO1xuXHRcdGlmICggIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtYXBcIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aW1nID0gJCggXCJpbWdbdXNlbWFwPSNcIiArIG1hcE5hbWUgKyBcIl1cIiApWzBdO1xuXHRcdHJldHVybiAhIWltZyAmJiB2aXNpYmxlKCBpbWcgKTtcblx0fVxuXHRyZXR1cm4gKCAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3QoIG5vZGVOYW1lICkgP1xuXHRcdCFlbGVtZW50LmRpc2FibGVkIDpcblx0XHRcImFcIiA9PT0gbm9kZU5hbWUgP1xuXHRcdFx0ZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOlxuXHRcdFx0aXNUYWJJbmRleE5vdE5hTikgJiZcblx0XHQvLyB0aGUgZWxlbWVudCBhbmQgYWxsIG9mIGl0cyBhbmNlc3RvcnMgbXVzdCBiZSB2aXNpYmxlXG5cdFx0dmlzaWJsZSggZWxlbWVudCApO1xufVxuXG5mdW5jdGlvbiB2aXNpYmxlKCBlbGVtZW50ICkge1xuXHRyZXR1cm4gJC5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbWVudCApICYmXG5cdFx0ISQoIGVsZW1lbnQgKS5wYXJlbnRzKCkuYW5kU2VsZigpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLmNzcyggdGhpcywgXCJ2aXNpYmlsaXR5XCIgKSA9PT0gXCJoaWRkZW5cIjtcblx0XHR9KS5sZW5ndGg7XG59XG5cbiQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiggZGF0YU5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZGF0YU5hbWUgKTtcblx0XHRcdH07XG5cdFx0fSkgOlxuXHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBtYXRjaFsgMyBdICk7XG5cdFx0fSxcblxuXHRmb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHJldHVybiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc05hTiggJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSApICk7XG5cdH0sXG5cblx0dGFiYmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB0YWJJbmRleCA9ICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICksXG5cdFx0XHRpc1RhYkluZGV4TmFOID0gaXNOYU4oIHRhYkluZGV4ICk7XG5cdFx0cmV0dXJuICggaXNUYWJJbmRleE5hTiB8fCB0YWJJbmRleCA+PSAwICkgJiYgZm9jdXNhYmxlKCBlbGVtZW50LCAhaXNUYWJJbmRleE5hTiApO1xuXHR9XG59KTtcblxuLy8gc3VwcG9ydFxuJChmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdGRpdiA9IGJvZHkuYXBwZW5kQ2hpbGQoIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdC8vIGFjY2VzcyBvZmZzZXRIZWlnaHQgYmVmb3JlIHNldHRpbmcgdGhlIHN0eWxlIHRvIHByZXZlbnQgYSBsYXlvdXQgYnVnXG5cdC8vIGluIElFIDkgd2hpY2ggY2F1c2VzIHRoZSBlbGVtZW50IHRvIGNvbnRpbnVlIHRvIHRha2UgdXAgc3BhY2UgZXZlblxuXHQvLyBhZnRlciBpdCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSAoIzgwMjYpXG5cdGRpdi5vZmZzZXRIZWlnaHQ7XG5cblx0JC5leHRlbmQoIGRpdi5zdHlsZSwge1xuXHRcdG1pbkhlaWdodDogXCIxMDBweFwiLFxuXHRcdGhlaWdodDogXCJhdXRvXCIsXG5cdFx0cGFkZGluZzogMCxcblx0XHRib3JkZXJXaWR0aDogMFxuXHR9KTtcblxuXHQkLnN1cHBvcnQubWluSGVpZ2h0ID0gZGl2Lm9mZnNldEhlaWdodCA9PT0gMTAwO1xuXHQkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBkaXY7XG5cblx0Ly8gc2V0IGRpc3BsYXkgdG8gbm9uZSB0byBhdm9pZCBhIGxheW91dCBidWcgaW4gSUVcblx0Ly8gaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC80MDE0XG5cdGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciB1YU1hdGNoID0gL21zaWUgKFtcXHcuXSspLy5leGVjKCBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblx0JC51aS5pZSA9IHVhTWF0Y2gubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlO1xuXHQkLnVpLmllNiA9IHBhcnNlRmxvYXQoIHVhTWF0Y2hbIDEgXSwgMTAgKSA9PT0gNjtcbn0pKCk7XG5cbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiAgVXNlIHRoZSBwcm94eSBwYXR0ZXJuIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnRhaW5zOiAkLmNvbnRhaW5zLFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fSxcblxuXHQvLyB0aGVzZSBhcmUgb2RkIGZ1bmN0aW9ucywgZml4IHRoZSBBUEkgb3IgbW92ZSBpbnRvIGluZGl2aWR1YWwgcGx1Z2luc1xuXHRpc092ZXJBeGlzOiBmdW5jdGlvbiggeCwgcmVmZXJlbmNlLCBzaXplICkge1xuXHRcdC8vRGV0ZXJtaW5lcyB3aGVuIHggY29vcmRpbmF0ZSBpcyBvdmVyIFwiYlwiIGVsZW1lbnQgYXhpc1xuXHRcdHJldHVybiAoIHggPiByZWZlcmVuY2UgKSAmJiAoIHggPCAoIHJlZmVyZW5jZSArIHNpemUgKSApO1xuXHR9LFxuXHRpc092ZXI6IGZ1bmN0aW9uKCB5LCB4LCB0b3AsIGxlZnQsIGhlaWdodCwgd2lkdGggKSB7XG5cdFx0Ly9EZXRlcm1pbmVzIHdoZW4geCwgeSBjb29yZGluYXRlcyBpcyBvdmVyIFwiYlwiIGVsZW1lbnRcblx0XHRyZXR1cm4gJC51aS5pc092ZXJBeGlzKCB5LCB0b3AsIGhlaWdodCApICYmICQudWkuaXNPdmVyQXhpcyggeCwgbGVmdCwgd2lkdGggKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblxuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHRmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFwiLVwiICsgbmFtZTtcblxuXHRpZiAoICFwcm90b3R5cGUgKSB7XG5cdFx0cHJvdG90eXBlID0gYmFzZTtcblx0XHRiYXNlID0gJC5XaWRnZXQ7XG5cdH1cblxuXHQvLyBjcmVhdGUgc2VsZWN0b3IgZm9yIHBsdWdpblxuXHQkLmV4cHJbIFwiOlwiIF1bIGZ1bGxOYW1lLnRvTG93ZXJDYXNlKCkgXSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZnVsbE5hbWUgKTtcblx0fTtcblxuXHQkWyBuYW1lc3BhY2UgXSA9ICRbIG5hbWVzcGFjZSBdIHx8IHt9O1xuXHRleGlzdGluZ0NvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXTtcblx0Y29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cdC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblx0XHQvLyBjb3B5IHRoZSBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhlIHByb3RvdHlwZSBpbiBjYXNlIHdlIG5lZWQgdG9cblx0XHQvLyByZWRlZmluZSB0aGUgd2lkZ2V0IGxhdGVyXG5cdFx0X3Byb3RvOiAkLmV4dGVuZCgge30sIHByb3RvdHlwZSApLFxuXHRcdC8vIHRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9KTtcblxuXHRiYXNlUHJvdG90eXBlID0gbmV3IGJhc2UoKTtcblx0Ly8gd2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggJC5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cHJvdG90eXBlWyBwcm9wIF0gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfc3VwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdFx0X19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseSxcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9zdXBlckFwcGx5O1xuXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9fc3VwZXJBcHBseTtcblxuXHRcdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdH0pKCk7XG5cdFx0fVxuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCA6IG5hbWVcblx0fSwgcHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0Ly8gVE9ETyByZW1vdmUgd2lkZ2V0QmFzZUNsYXNzLCBzZWUgIzgxNTVcblx0XHR3aWRnZXRCYXNlQ2xhc3M6IGZ1bGxOYW1lLFxuXHRcdHdpZGdldEZ1bGxOYW1lOiBmdWxsTmFtZVxuXHR9KTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIHJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3RvciwgY2hpbGQuX3Byb3RvICk7XG5cdFx0fSk7XG5cdFx0Ly8gcmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdGlucHV0SW5kZXggPSAwLFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdGtleSxcblx0XHR2YWx1ZTtcblx0Zm9yICggOyBpbnB1dEluZGV4IDwgaW5wdXRMZW5ndGg7IGlucHV0SW5kZXgrKyApIHtcblx0XHRmb3IgKCBrZXkgaW4gaW5wdXRbIGlucHV0SW5kZXggXSApIHtcblx0XHRcdHZhbHVlID0gaW5wdXRbIGlucHV0SW5kZXggXVsga2V5IF07XG5cdFx0XHRpZiAoIGlucHV0WyBpbnB1dEluZGV4IF0uaGFzT3duUHJvcGVydHkoIGtleSApICYmIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cdFx0XHRcdC8vIENvcHkgZXZlcnl0aGluZyBlbHNlIGJ5IHJlZmVyZW5jZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuJC53aWRnZXQuYnJpZGdlID0gZnVuY3Rpb24oIG5hbWUsIG9iamVjdCApIHtcblx0dmFyIGZ1bGxOYW1lID0gb2JqZWN0LnByb3RvdHlwZS53aWRnZXRGdWxsTmFtZSB8fCBuYW1lO1xuXHQkLmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgaXNNZXRob2RDYWxsID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIsXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0XHRyZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHQvLyBhbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRvcHRpb25zID0gIWlzTWV0aG9kQ2FsbCAmJiBhcmdzLmxlbmd0aCA/XG5cdFx0XHQkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdChhcmdzKSApIDpcblx0XHRcdG9wdGlvbnM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlLFxuXHRcdFx0XHRcdGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArIFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcImF0dGVtcHRlZCB0byBjYWxsIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIGluc3RhbmNlW29wdGlvbnNdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICsgXCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUucHVzaFN0YWNrKCBtZXRob2RWYWx1ZS5nZXQoKSApIDpcblx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApLl9pbml0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cdF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdGVsZW1lbnQgPSAkKCBlbGVtZW50IHx8IHRoaXMuZGVmYXVsdEVsZW1lbnQgfHwgdGhpcyApWyAwIF07XG5cdFx0dGhpcy5lbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdHRoaXMudXVpZCA9IHV1aWQrKztcblx0XHR0aGlzLmV2ZW50TmFtZXNwYWNlID0gXCIuXCIgKyB0aGlzLndpZGdldE5hbWUgKyB0aGlzLnV1aWQ7XG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQvLyAxLjkgQkMgZm9yICM3ODEwXG5cdFx0XHQvLyBUT0RPIHJlbW92ZSBkdWFsIHN0b3JhZ2Vcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXROYW1lLCB0aGlzICk7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kb2N1bWVudCA9ICQoIGVsZW1lbnQuc3R5bGUgP1xuXHRcdFx0XHQvLyBlbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbMF0uZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2N1bWVudFswXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jcmVhdGUoKTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblx0X2dldENyZWF0ZU9wdGlvbnM6ICQubm9vcCxcblx0X2dldENyZWF0ZUV2ZW50RGF0YTogJC5ub29wLFxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdC8vIHdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQvLyAxLjkgQkMgZm9yICM3ODEwXG5cdFx0XHQvLyBUT0RPIHJlbW92ZSBkdWFsIHN0b3JhZ2Vcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldE5hbWUgKVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKVxuXHRcdFx0Ly8gc3VwcG9ydDoganF1ZXJ5IDwxLjYuM1xuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxM1xuXHRcdFx0LnJlbW92ZURhdGEoICQuY2FtZWxDYXNlKCB0aGlzLndpZGdldEZ1bGxOYW1lICkgKTtcblx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZCBcIiArXG5cdFx0XHRcdFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXG5cdFx0Ly8gY2xlYW4gdXAgZXZlbnRzIGFuZCBzdGF0ZXNcblx0XHR0aGlzLmJpbmRpbmdzLnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApO1xuXHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdH0sXG5cdF9kZXN0cm95OiAkLm5vb3AsXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHR9LFxuXG5cdG9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBrZXksXG5cdFx0XHRwYXJ0cyxcblx0XHRcdGN1ck9wdGlvbixcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHQvLyBkb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHQvLyBoYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbigga2V5LCBvcHRpb25zWyBrZXkgXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZCB1aS1zdGF0ZS1kaXNhYmxlZFwiLCAhIXZhbHVlIClcblx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHR9LFxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHRydWUgKTtcblx0fSxcblxuXHRfb246IGZ1bmN0aW9uKCBzdXBwcmVzc0Rpc2FibGVkQ2hlY2ssIGVsZW1lbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBkZWxlZ2F0ZUVsZW1lbnQsXG5cdFx0XHRpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBubyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhY2NlcHQgc2VsZWN0b3JzLCBET00gZWxlbWVudHNcblx0XHRcdGVsZW1lbnQgPSBkZWxlZ2F0ZUVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5hZGQoIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQkLmVhY2goIGhhbmRsZXJzLCBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRcdC8vIGFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdFx0JCggdGhpcyApLmhhc0NsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKSApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSB0aGUgZ3VpZCBzbyBkaXJlY3QgdW5iaW5kaW5nIHdvcmtzXG5cdFx0XHRpZiAoIHR5cGVvZiBoYW5kbGVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRoYW5kbGVyUHJveHkuZ3VpZCA9IGhhbmRsZXIuZ3VpZCA9XG5cdFx0XHRcdFx0aGFuZGxlci5ndWlkIHx8IGhhbmRsZXJQcm94eS5ndWlkIHx8ICQuZ3VpZCsrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWF0Y2ggPSBldmVudC5tYXRjaCggL14oXFx3KylcXHMqKC4qKSQvICksXG5cdFx0XHRcdGV2ZW50TmFtZSA9IG1hdGNoWzFdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2UsXG5cdFx0XHRcdHNlbGVjdG9yID0gbWF0Y2hbMl07XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQuZGVsZWdhdGUoIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5iaW5kKCBldmVudE5hbWUsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBcIlwiKS5zcGxpdCggXCIgXCIgKS5qb2luKCB0aGlzLmV2ZW50TmFtZXNwYWNlICsgXCIgXCIgKSArIHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC51bmJpbmQoIGV2ZW50TmFtZSApLnVuZGVsZWdhdGUoIGV2ZW50TmFtZSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnLFxuXHRcdFx0Y2FsbGJhY2sgPSB0aGlzLm9wdGlvbnNbIHR5cGUgXTtcblxuXHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdGV2ZW50ID0gJC5FdmVudCggZXZlbnQgKTtcblx0XHRldmVudC50eXBlID0gKCB0eXBlID09PSB0aGlzLndpZGdldEV2ZW50UHJlZml4ID9cblx0XHRcdHR5cGUgOlxuXHRcdFx0dGhpcy53aWRnZXRFdmVudFByZWZpeCArIHR5cGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdC8vIHRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WzBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHR2YXIgaGFzT3B0aW9ucyxcblx0XHRcdGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRcdG1ldGhvZCA6XG5cdFx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRcdG9wdGlvbnMuZWZmZWN0IHx8IGRlZmF1bHRFZmZlY3Q7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXHRcdGlmICggb3B0aW9ucy5kZWxheSApIHtcblx0XHRcdGVsZW1lbnQuZGVsYXkoIG9wdGlvbnMuZGVsYXkgKTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSB8fCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgJiYgJC5lZmZlY3RzWyBlZmZlY3ROYW1lIF0gKSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gREVQUkVDQVRFRFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZS5fZ2V0Q3JlYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAkLm1ldGFkYXRhICYmICQubWV0YWRhdGEuZ2V0KCB0aGlzLmVsZW1lbnRbMF0gKVsgdGhpcy53aWRnZXROYW1lIF07XG5cdH07XG59XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgbW91c2VIYW5kbGVkID0gZmFsc2U7XG4kKCBkb2N1bWVudCApLm1vdXNldXAoIGZ1bmN0aW9uKCBlICkge1xuXHRtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbn0pO1xuXG4kLndpZGdldChcInVpLm1vdXNlXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2FuY2VsOiAnaW5wdXQsdGV4dGFyZWEsYnV0dG9uLHNlbGVjdCxvcHRpb24nLFxuXHRcdGRpc3RhbmNlOiAxLFxuXHRcdGRlbGF5OiAwXG5cdH0sXG5cdF9tb3VzZUluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmJpbmQoJ21vdXNlZG93bi4nK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoJ2NsaWNrLicrdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgJy5wcmV2ZW50Q2xpY2tFdmVudCcpKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgJy5wcmV2ZW50Q2xpY2tFdmVudCcpO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUT0RPOiBtYWtlIHN1cmUgZGVzdHJveWluZyBvbmUgaW5zdGFuY2Ugb2YgbW91c2UgZG9lc24ndCBtZXNzIHdpdGhcblx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXG5cdF9tb3VzZURlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC51bmJpbmQoJy4nK3RoaXMud2lkZ2V0TmFtZSk7XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApIHtcblx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdC51bmJpbmQoJ21vdXNlbW92ZS4nK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHRcdC51bmJpbmQoJ21vdXNldXAuJyt0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG5cdFx0aWYoIG1vdXNlSGFuZGxlZCApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQodGhpcy5fbW91c2VTdGFydGVkICYmIHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblxuXHRcdHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidG5Jc0xlZnQgPSAoZXZlbnQud2hpY2ggPT09IDEpLFxuXHRcdFx0Ly8gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBJRSA4IHdpdGhcblx0XHRcdC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXG5cdFx0XHRlbElzQ2FuY2VsID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aCA6IGZhbHNlKTtcblx0XHRpZiAoIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoZXZlbnQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICghdGhpcy5tb3VzZURlbGF5TWV0KSB7XG5cdFx0XHR0aGlzLl9tb3VzZURlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9ICh0aGlzLl9tb3VzZVN0YXJ0KGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXG5cdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArICcucHJldmVudENsaWNrRXZlbnQnKSkge1xuXHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgJy5wcmV2ZW50Q2xpY2tFdmVudCcpO1xuXHRcdH1cblxuXHRcdC8vIHRoZXNlIGRlbGVnYXRlcyBhcmUgcmVxdWlyZWQgdG8ga2VlcCBjb250ZXh0XG5cdFx0dGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlTW92ZShldmVudCk7XG5cdFx0fTtcblx0XHR0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH07XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5iaW5kKCdtb3VzZW1vdmUuJyt0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LmJpbmQoJ21vdXNldXAuJyt0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0bW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VNb3ZlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIElFIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIGhhcHBlbmVkIHdoZW4gbW91c2Ugd2FzIG91dCBvZiB3aW5kb3dcblx0XHRpZiAoJC51aS5pZSAmJiAhKGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA5KSAmJiAhZXZlbnQuYnV0dG9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbW91c2VVcChldmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50KTtcblx0XHRcdHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZURpc3RhbmNlTWV0KGV2ZW50KSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KGV2ZW50KSkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID1cblx0XHRcdFx0KHRoaXMuX21vdXNlU3RhcnQodGhpcy5fbW91c2VEb3duRXZlbnQsIGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0KHRoaXMuX21vdXNlU3RhcnRlZCA/IHRoaXMuX21vdXNlRHJhZyhldmVudCkgOiB0aGlzLl9tb3VzZVVwKGV2ZW50KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICF0aGlzLl9tb3VzZVN0YXJ0ZWQ7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC51bmJpbmQoJ21vdXNlbW92ZS4nK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHQudW5iaW5kKCdtb3VzZXVwLicrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXG5cdFx0aWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XG5cblx0XHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHQkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyAnLnByZXZlbnRDbGlja0V2ZW50JywgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlU3RvcChldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZURpc3RhbmNlTWV0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiAoTWF0aC5tYXgoXG5cdFx0XHRcdE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VYIC0gZXZlbnQucGFnZVgpLFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWSAtIGV2ZW50LnBhZ2VZKVxuXHRcdFx0KSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2Vcblx0XHQpO1xuXHR9LFxuXG5cdF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlRGVsYXlNZXQ7XG5cdH0sXG5cblx0Ly8gVGhlc2UgYXJlIHBsYWNlaG9sZGVyIG1ldGhvZHMsIHRvIGJlIG92ZXJyaWRlbiBieSBleHRlbmRpbmcgcGx1Z2luXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbihldmVudCkge30sXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50KSB7fSxcblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHt9LFxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCkgeyByZXR1cm4gdHJ1ZTsgfVxufSk7XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC51aSA9ICQudWkgfHwge307XG5cbnZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCxcblx0bWF4ID0gTWF0aC5tYXgsXG5cdGFicyA9IE1hdGguYWJzLFxuXHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdHJob3Jpem9udGFsID0gL2xlZnR8Y2VudGVyfHJpZ2h0Lyxcblx0cnZlcnRpY2FsID0gL3RvcHxjZW50ZXJ8Ym90dG9tLyxcblx0cm9mZnNldCA9IC9bXFwrXFwtXVxcZCslPy8sXG5cdHJwb3NpdGlvbiA9IC9eXFx3Ky8sXG5cdHJwZXJjZW50ID0gLyUkLyxcblx0X3Bvc2l0aW9uID0gJC5mbi5wb3NpdGlvbjtcblxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyggb2Zmc2V0cywgd2lkdGgsIGhlaWdodCApIHtcblx0cmV0dXJuIFtcblx0XHRwYXJzZUludCggb2Zmc2V0c1sgMCBdLCAxMCApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAwIF0gKSA/IHdpZHRoIC8gMTAwIDogMSApLFxuXHRcdHBhcnNlSW50KCBvZmZzZXRzWyAxIF0sIDEwICkgKiAoIHJwZXJjZW50LnRlc3QoIG9mZnNldHNbIDEgXSApID8gaGVpZ2h0IC8gMTAwIDogMSApXG5cdF07XG59XG5mdW5jdGlvbiBwYXJzZUNzcyggZWxlbWVudCwgcHJvcGVydHkgKSB7XG5cdHJldHVybiBwYXJzZUludCggJC5jc3MoIGVsZW1lbnQsIHByb3BlcnR5ICksIDEwICkgfHwgMDtcbn1cblxuJC5wb3NpdGlvbiA9IHtcblx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdFx0dmFyIHcxLCB3Mixcblx0XHRcdGRpdiA9ICQoIFwiPGRpdiBzdHlsZT0nZGlzcGxheTpibG9jazt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OmhpZGRlbjsnPjxkaXYgc3R5bGU9J2hlaWdodDoxMDBweDt3aWR0aDphdXRvOyc+PC9kaXY+PC9kaXY+XCIgKSxcblx0XHRcdGlubmVyRGl2ID0gZGl2LmNoaWxkcmVuKClbMF07XG5cblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggZGl2ICk7XG5cdFx0dzEgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblx0XHRkaXYuY3NzKCBcIm92ZXJmbG93XCIsIFwic2Nyb2xsXCIgKTtcblxuXHRcdHcyID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cblx0XHRpZiAoIHcxID09PSB3MiApIHtcblx0XHRcdHcyID0gZGl2WzBdLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdGRpdi5yZW1vdmUoKTtcblxuXHRcdHJldHVybiAoY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3MSAtIHcyKTtcblx0fSxcblx0Z2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oIHdpdGhpbiApIHtcblx0XHR2YXIgb3ZlcmZsb3dYID0gd2l0aGluLmlzV2luZG93ID8gXCJcIiA6IHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy14XCIgKSxcblx0XHRcdG92ZXJmbG93WSA9IHdpdGhpbi5pc1dpbmRvdyA/IFwiXCIgOiB3aXRoaW4uZWxlbWVudC5jc3MoIFwib3ZlcmZsb3cteVwiICksXG5cdFx0XHRoYXNPdmVyZmxvd1ggPSBvdmVyZmxvd1ggPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1ggPT09IFwiYXV0b1wiICYmIHdpdGhpbi53aWR0aCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbFdpZHRoICksXG5cdFx0XHRoYXNPdmVyZmxvd1kgPSBvdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1kgPT09IFwiYXV0b1wiICYmIHdpdGhpbi5oZWlnaHQgPCB3aXRoaW4uZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6IGhhc092ZXJmbG93WSA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcblx0XHR9O1xuXHR9LFxuXHRnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgd2l0aGluRWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgd2luZG93ICksXG5cdFx0XHRpc1dpbmRvdyA9ICQuaXNXaW5kb3coIHdpdGhpbkVsZW1lbnRbMF0gKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdG9mZnNldDogd2l0aGluRWxlbWVudC5vZmZzZXQoKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuXHRcdFx0c2Nyb2xsTGVmdDogd2l0aGluRWxlbWVudC5zY3JvbGxMZWZ0KCksXG5cdFx0XHRzY3JvbGxUb3A6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHR3aWR0aDogaXNXaW5kb3cgPyB3aXRoaW5FbGVtZW50LndpZHRoKCkgOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogaXNXaW5kb3cgPyB3aXRoaW5FbGVtZW50LmhlaWdodCgpIDogd2l0aGluRWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fVxufTtcblxuJC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoICFvcHRpb25zIHx8ICFvcHRpb25zLm9mICkge1xuXHRcdHJldHVybiBfcG9zaXRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0Ly8gbWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xuXHRvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIGF0T2Zmc2V0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRPZmZzZXQsIGJhc2VQb3NpdGlvbixcblx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLm9mICksXG5cdFx0d2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKCBvcHRpb25zLndpdGhpbiApLFxuXHRcdHNjcm9sbEluZm8gPSAkLnBvc2l0aW9uLmdldFNjcm9sbEluZm8oIHdpdGhpbiApLFxuXHRcdHRhcmdldEVsZW0gPSB0YXJnZXRbMF0sXG5cdFx0Y29sbGlzaW9uID0gKCBvcHRpb25zLmNvbGxpc2lvbiB8fCBcImZsaXBcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdG9mZnNldHMgPSB7fTtcblxuXHRpZiAoIHRhcmdldEVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0dGFyZ2V0V2lkdGggPSB0YXJnZXQud2lkdGgoKTtcblx0XHR0YXJnZXRIZWlnaHQgPSB0YXJnZXQuaGVpZ2h0KCk7XG5cdFx0dGFyZ2V0T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0fSBlbHNlIGlmICggJC5pc1dpbmRvdyggdGFyZ2V0RWxlbSApICkge1xuXHRcdHRhcmdldFdpZHRoID0gdGFyZ2V0LndpZHRoKCk7XG5cdFx0dGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0LmhlaWdodCgpO1xuXHRcdHRhcmdldE9mZnNldCA9IHsgdG9wOiB0YXJnZXQuc2Nyb2xsVG9wKCksIGxlZnQ6IHRhcmdldC5zY3JvbGxMZWZ0KCkgfTtcblx0fSBlbHNlIGlmICggdGFyZ2V0RWxlbS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHQvLyBmb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xuXHRcdG9wdGlvbnMuYXQgPSBcImxlZnQgdG9wXCI7XG5cdFx0dGFyZ2V0V2lkdGggPSB0YXJnZXRIZWlnaHQgPSAwO1xuXHRcdHRhcmdldE9mZnNldCA9IHsgdG9wOiB0YXJnZXRFbGVtLnBhZ2VZLCBsZWZ0OiB0YXJnZXRFbGVtLnBhZ2VYIH07XG5cdH0gZWxzZSB7XG5cdFx0dGFyZ2V0V2lkdGggPSB0YXJnZXQub3V0ZXJXaWR0aCgpO1xuXHRcdHRhcmdldEhlaWdodCA9IHRhcmdldC5vdXRlckhlaWdodCgpO1xuXHRcdHRhcmdldE9mZnNldCA9IHRhcmdldC5vZmZzZXQoKTtcblx0fVxuXHQvLyBjbG9uZSB0byByZXVzZSBvcmlnaW5hbCB0YXJnZXRPZmZzZXQgbGF0ZXJcblx0YmFzZVBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCB0YXJnZXRPZmZzZXQgKTtcblxuXHQvLyBmb3JjZSBteSBhbmQgYXQgdG8gaGF2ZSB2YWxpZCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbnNcblx0Ly8gaWYgYSB2YWx1ZSBpcyBtaXNzaW5nIG9yIGludmFsaWQsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGNlbnRlclxuXHQkLmVhY2goIFsgXCJteVwiLCBcImF0XCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9ICggb3B0aW9uc1sgdGhpcyBdIHx8IFwiXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRcdGhvcml6b250YWxPZmZzZXQsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldDtcblxuXHRcdGlmICggcG9zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyByZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0pO1xuXG5cdC8vIG5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xsaXNpb25Qb3NpdGlvbiwgdXNpbmcsXG5cdFx0XHRlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0ZWxlbVdpZHRoID0gZWxlbS5vdXRlcldpZHRoKCksXG5cdFx0XHRlbGVtSGVpZ2h0ID0gZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdFx0bWFyZ2luTGVmdCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0bWFyZ2luVG9wID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luVG9wXCIgKSxcblx0XHRcdGNvbGxpc2lvbldpZHRoID0gZWxlbVdpZHRoICsgbWFyZ2luTGVmdCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblJpZ2h0XCIgKSArIHNjcm9sbEluZm8ud2lkdGgsXG5cdFx0XHRjb2xsaXNpb25IZWlnaHQgPSBlbGVtSGVpZ2h0ICsgbWFyZ2luVG9wICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luQm90dG9tXCIgKSArIHNjcm9sbEluZm8uaGVpZ2h0LFxuXHRcdFx0cG9zaXRpb24gPSAkLmV4dGVuZCgge30sIGJhc2VQb3NpdGlvbiApLFxuXHRcdFx0bXlPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLm15LCBlbGVtLm91dGVyV2lkdGgoKSwgZWxlbS5vdXRlckhlaWdodCgpICk7XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJyaWdodFwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGg7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGggLyAyO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXRbIDAgXTtcblx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXRbIDEgXTtcblxuXHRcdC8vIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBmcmFjdGlvbnMsIHRoZW4gcm91bmQgZm9yIGNvbnNpc3RlbnQgcmVzdWx0c1xuXHRcdGlmICggISQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0ID0gcm91bmQoIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdHBvc2l0aW9uLnRvcCA9IHJvdW5kKCBwb3NpdGlvbi50b3AgKTtcblx0XHR9XG5cblx0XHRjb2xsaXNpb25Qb3NpdGlvbiA9IHtcblx0XHRcdG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG5cdFx0XHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxuXHRcdH07XG5cblx0XHQkLmVhY2goIFsgXCJsZWZ0XCIsIFwidG9wXCIgXSwgZnVuY3Rpb24oIGksIGRpciApIHtcblx0XHRcdGlmICggJC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXSApIHtcblx0XHRcdFx0JC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXVsgZGlyIF0oIHBvc2l0aW9uLCB7XG5cdFx0XHRcdFx0dGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGVsZW1XaWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdGVsZW1IZWlnaHQ6IGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0Y29sbGlzaW9uUG9zaXRpb246IGNvbGxpc2lvblBvc2l0aW9uLFxuXHRcdFx0XHRcdGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcblx0XHRcdFx0XHRjb2xsaXNpb25IZWlnaHQ6IGNvbGxpc2lvbkhlaWdodCxcblx0XHRcdFx0XHRvZmZzZXQ6IFsgYXRPZmZzZXRbIDAgXSArIG15T2Zmc2V0WyAwIF0sIGF0T2Zmc2V0IFsgMSBdICsgbXlPZmZzZXRbIDEgXSBdLFxuXHRcdFx0XHRcdG15OiBvcHRpb25zLm15LFxuXHRcdFx0XHRcdGF0OiBvcHRpb25zLmF0LFxuXHRcdFx0XHRcdHdpdGhpbjogd2l0aGluLFxuXHRcdFx0XHRcdGVsZW0gOiBlbGVtXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCAkLmZuLmJnaWZyYW1lICkge1xuXHRcdFx0ZWxlbS5iZ2lmcmFtZSgpO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy51c2luZyApIHtcblx0XHRcdC8vIGFkZHMgZmVlZGJhY2sgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHVzaW5nIGNhbGxiYWNrLCBpZiBwcmVzZW50XG5cdFx0XHR1c2luZyA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCAtIHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgdGFyZ2V0V2lkdGggLSBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0dG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyB0YXJnZXRIZWlnaHQgLSBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGZlZWRiYWNrID0ge1xuXHRcdFx0XHRcdFx0dGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGVmdDogdGFyZ2V0T2Zmc2V0LmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHRhcmdldEhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbSxcblx0XHRcdFx0XHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbUhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IHJpZ2h0IDwgMCA/IFwibGVmdFwiIDogbGVmdCA+IDAgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdFx0dmVydGljYWw6IGJvdHRvbSA8IDAgPyBcInRvcFwiIDogdG9wID4gMCA/IFwiYm90dG9tXCIgOiBcIm1pZGRsZVwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCB0YXJnZXRXaWR0aCA8IGVsZW1XaWR0aCAmJiBhYnMoIGxlZnQgKyByaWdodCApIDwgdGFyZ2V0V2lkdGggKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaG9yaXpvbnRhbCA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyggdG9wICsgYm90dG9tICkgPCB0YXJnZXRIZWlnaHQgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2sudmVydGljYWwgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF4KCBhYnMoIGxlZnQgKSwgYWJzKCByaWdodCApICkgPiBtYXgoIGFicyggdG9wICksIGFicyggYm90dG9tICkgKSApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcImhvcml6b250YWxcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcInZlcnRpY2FsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCB0aGlzLCBwcm9wcywgZmVlZGJhY2sgKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZWxlbS5vZmZzZXQoICQuZXh0ZW5kKCBwb3NpdGlvbiwgeyB1c2luZzogdXNpbmcgfSApICk7XG5cdH0pO1xufTtcblxuJC51aS5wb3NpdGlvbiA9IHtcblx0Zml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0b3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zTGVmdCxcblx0XHRcdFx0b3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdC8vIGVsZW1lbnQgaXMgd2lkZXIgdGhhbiB3aXRoaW5cblx0XHRcdGlmICggZGF0YS5jb2xsaXNpb25XaWR0aCA+IG91dGVyV2lkdGggKSB7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIGxlZnQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IDAgJiYgb3ZlclJpZ2h0IDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdCAtIG5ld092ZXJSaWdodDtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciByaWdodCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3RoIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggb3ZlckxlZnQgPiBvdmVyUmlnaHQgKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0ICsgb3V0ZXJXaWR0aCAtIGRhdGEuY29sbGlzaW9uV2lkdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQvLyB0b28gZmFyIGxlZnQgLT4gYWxpZ24gd2l0aCBsZWZ0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJMZWZ0ID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdDtcblx0XHRcdC8vIHRvbyBmYXIgcmlnaHQgLT4gYWxpZ24gd2l0aCByaWdodCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDtcblx0XHRcdC8vIGFkanVzdCBiYXNlZCBvbiBwb3NpdGlvbiBhbmQgbWFyZ2luXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gbWF4KCBwb3NpdGlvbi5sZWZ0IC0gY29sbGlzaW9uUG9zTGVmdCwgcG9zaXRpb24ubGVmdCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQgPSBkYXRhLndpdGhpbi5oZWlnaHQsXG5cdFx0XHRcdGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxuXHRcdFx0XHRvdmVyVG9wID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zVG9wLFxuXHRcdFx0XHRvdmVyQm90dG9tID0gY29sbGlzaW9uUG9zVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlckJvdHRvbTtcblxuXHRcdFx0Ly8gZWxlbWVudCBpcyB0YWxsZXIgdGhhbiB3aXRoaW5cblx0XHRcdGlmICggZGF0YS5jb2xsaXNpb25IZWlnaHQgPiBvdXRlckhlaWdodCApIHtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgdG9wIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJUb3AgPiAwICYmIG92ZXJCb3R0b20gPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgb3ZlclRvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG92ZXJUb3AgLSBuZXdPdmVyQm90dG9tO1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdHRvbSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgJiYgb3ZlclRvcCA8PSAwICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3RoIHRvcCBhbmQgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggb3ZlclRvcCA+IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQgKyBvdXRlckhlaWdodCAtIGRhdGEuY29sbGlzaW9uSGVpZ2h0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQvLyB0b28gZmFyIHVwIC0+IGFsaWduIHdpdGggdG9wXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyVG9wID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24udG9wICs9IG92ZXJUb3A7XG5cdFx0XHQvLyB0b28gZmFyIGRvd24gLT4gYWxpZ24gd2l0aCBib3R0b20gZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCAtPSBvdmVyQm90dG9tO1xuXHRcdFx0Ly8gYWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCA9IG1heCggcG9zaXRpb24udG9wIC0gY29sbGlzaW9uUG9zVG9wLCBwb3NpdGlvbi50b3AgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXA6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQubGVmdCArIHdpdGhpbi5zY3JvbGxMZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IGNvbGxpc2lvblBvc0xlZnQgLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRteU9mZnNldCA9IGRhdGEubXlbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLmF0WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAwIF0sXG5cdFx0XHRcdG5ld092ZXJSaWdodCxcblx0XHRcdFx0bmV3T3ZlckxlZnQ7XG5cblx0XHRcdGlmICggb3ZlckxlZnQgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJSaWdodCA8IDAgfHwgbmV3T3ZlclJpZ2h0IDwgYWJzKCBvdmVyTGVmdCApICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRMZWZ0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJMZWZ0ID4gMCB8fCBhYnMoIG5ld092ZXJMZWZ0ICkgPCBvdmVyUmlnaHQgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC50b3AgKyB3aXRoaW4uc2Nyb2xsVG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IHdpdGhpbi5oZWlnaHQsXG5cdFx0XHRcdG9mZnNldFRvcCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSBjb2xsaXNpb25Qb3NUb3AgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHR0b3AgPSBkYXRhLm15WyAxIF0gPT09IFwidG9wXCIsXG5cdFx0XHRcdG15T2Zmc2V0ID0gdG9wID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLm15WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMSBdID09PSBcInRvcFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAxIF0sXG5cdFx0XHRcdG5ld092ZXJUb3AsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cdFx0XHRpZiAoIG92ZXJUb3AgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggKCBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0KSA+IG92ZXJUb3AgJiYgKCBuZXdPdmVyQm90dG9tIDwgMCB8fCBuZXdPdmVyQm90dG9tIDwgYWJzKCBvdmVyVG9wICkgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyVG9wID0gcG9zaXRpb24udG9wIC0gIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldFRvcDtcblx0XHRcdFx0aWYgKCAoIHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQpID4gb3ZlckJvdHRvbSAmJiAoIG5ld092ZXJUb3AgPiAwIHx8IGFicyggbmV3T3ZlclRvcCApIDwgb3ZlckJvdHRvbSApICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwZml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBmcmFjdGlvbiBzdXBwb3J0IHRlc3RcbihmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXN0RWxlbWVudCwgdGVzdEVsZW1lbnRQYXJlbnQsIHRlc3RFbGVtZW50U3R5bGUsIG9mZnNldExlZnQsIGksXG5cdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF0sXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vQ3JlYXRlIGEgXCJmYWtlIGJvZHlcIiBmb3IgdGVzdGluZyBiYXNlZCBvbiBtZXRob2QgdXNlZCBpbiBqUXVlcnkuc3VwcG9ydFxuXHR0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGJvZHkgPyBcImRpdlwiIDogXCJib2R5XCIgKTtcblx0dGVzdEVsZW1lbnRTdHlsZSA9IHtcblx0XHR2aXNpYmlsaXR5OiBcImhpZGRlblwiLFxuXHRcdHdpZHRoOiAwLFxuXHRcdGhlaWdodDogMCxcblx0XHRib3JkZXI6IDAsXG5cdFx0bWFyZ2luOiAwLFxuXHRcdGJhY2tncm91bmQ6IFwibm9uZVwiXG5cdH07XG5cdGlmICggYm9keSApIHtcblx0XHQkLmV4dGVuZCggdGVzdEVsZW1lbnRTdHlsZSwge1xuXHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdGxlZnQ6IFwiLTEwMDBweFwiLFxuXHRcdFx0dG9wOiBcIi0xMDAwcHhcIlxuXHRcdH0pO1xuXHR9XG5cdGZvciAoIGkgaW4gdGVzdEVsZW1lbnRTdHlsZSApIHtcblx0XHR0ZXN0RWxlbWVudC5zdHlsZVsgaSBdID0gdGVzdEVsZW1lbnRTdHlsZVsgaSBdO1xuXHR9XG5cdHRlc3RFbGVtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblx0dGVzdEVsZW1lbnRQYXJlbnQgPSBib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0dGVzdEVsZW1lbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKCB0ZXN0RWxlbWVudCwgdGVzdEVsZW1lbnRQYXJlbnQuZmlyc3RDaGlsZCApO1xuXG5cdGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDEwLjc0MzIyMjJweDtcIjtcblxuXHRvZmZzZXRMZWZ0ID0gJCggZGl2ICkub2Zmc2V0KCkubGVmdDtcblx0JC5zdXBwb3J0Lm9mZnNldEZyYWN0aW9ucyA9IG9mZnNldExlZnQgPiAxMCAmJiBvZmZzZXRMZWZ0IDwgMTE7XG5cblx0dGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcblx0dGVzdEVsZW1lbnRQYXJlbnQucmVtb3ZlQ2hpbGQoIHRlc3RFbGVtZW50ICk7XG59KSgpO1xuXG4vLyBERVBSRUNBVEVEXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblx0Ly8gb2Zmc2V0IG9wdGlvblxuXHQoZnVuY3Rpb24oICQgKSB7XG5cdFx0dmFyIF9wb3NpdGlvbiA9ICQuZm4ucG9zaXRpb247XG5cdFx0JC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCAhb3B0aW9ucyB8fCAhb3B0aW9ucy5vZmZzZXQgKSB7XG5cdFx0XHRcdHJldHVybiBfcG9zaXRpb24uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LnNwbGl0KCBcIiBcIiApLFxuXHRcdFx0XHRhdCA9IG9wdGlvbnMuYXQuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRpZiAoIG9mZnNldC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdG9mZnNldFsgMSBdID0gb2Zmc2V0WyAwIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIC9eXFxkLy50ZXN0KCBvZmZzZXRbIDAgXSApICkge1xuXHRcdFx0XHRvZmZzZXRbIDAgXSA9IFwiK1wiICsgb2Zmc2V0WyAwIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIC9eXFxkLy50ZXN0KCBvZmZzZXRbIDEgXSApICkge1xuXHRcdFx0XHRvZmZzZXRbIDEgXSA9IFwiK1wiICsgb2Zmc2V0WyAxIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGF0Lmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0aWYgKCAvbGVmdHxjZW50ZXJ8cmlnaHQvLnRlc3QoIGF0WyAwIF0gKSApIHtcblx0XHRcdFx0XHRhdFsgMSBdID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdFsgMSBdID0gYXRbIDAgXTtcblx0XHRcdFx0XHRhdFsgMCBdID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9wb3NpdGlvbi5jYWxsKCB0aGlzLCAkLmV4dGVuZCggb3B0aW9ucywge1xuXHRcdFx0XHRhdDogYXRbIDAgXSArIG9mZnNldFsgMCBdICsgXCIgXCIgKyBhdFsgMSBdICsgb2Zmc2V0WyAxIF0sXG5cdFx0XHRcdG9mZnNldDogdW5kZWZpbmVkXG5cdFx0XHR9ICkgKTtcblx0XHR9O1xuXHR9KCBqUXVlcnkgKSApO1xufVxuXG59KCBqUXVlcnkgKSApO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1aWQgPSAwLFxuXHRoaWRlUHJvcHMgPSB7fSxcblx0c2hvd1Byb3BzID0ge307XG5cbmhpZGVQcm9wcy5oZWlnaHQgPSBoaWRlUHJvcHMucGFkZGluZ1RvcCA9IGhpZGVQcm9wcy5wYWRkaW5nQm90dG9tID1cblx0aGlkZVByb3BzLmJvcmRlclRvcFdpZHRoID0gaGlkZVByb3BzLmJvcmRlckJvdHRvbVdpZHRoID0gXCJoaWRlXCI7XG5zaG93UHJvcHMuaGVpZ2h0ID0gc2hvd1Byb3BzLnBhZGRpbmdUb3AgPSBzaG93UHJvcHMucGFkZGluZ0JvdHRvbSA9XG5cdHNob3dQcm9wcy5ib3JkZXJUb3BXaWR0aCA9IHNob3dQcm9wcy5ib3JkZXJCb3R0b21XaWR0aCA9IFwic2hvd1wiO1xuXG4kLndpZGdldCggXCJ1aS5hY2NvcmRpb25cIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhY3RpdmU6IDAsXG5cdFx0YW5pbWF0ZToge30sXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVhZGVyOiBcIj4gbGkgPiA6Zmlyc3QtY2hpbGQsPiA6bm90KGxpKTpldmVuXCIsXG5cdFx0aGVpZ2h0U3R5bGU6IFwiYXV0b1wiLFxuXHRcdGljb25zOiB7XG5cdFx0XHRhY3RpdmVIZWFkZXI6IFwidWktaWNvbi10cmlhbmdsZS0xLXNcIixcblx0XHRcdGhlYWRlcjogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtZVwiXG5cdFx0fSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUFjdGl2YXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFjY29yZGlvbklkID0gdGhpcy5hY2NvcmRpb25JZCA9IFwidWktYWNjb3JkaW9uLVwiICtcblx0XHRcdFx0KHRoaXMuZWxlbWVudC5hdHRyKCBcImlkXCIgKSB8fCArK3VpZCksXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5wcmV2U2hvdyA9IHRoaXMucHJldkhpZGUgPSAkKCk7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0XCIgKTtcblxuXHRcdHRoaXMuaGVhZGVycyA9IHRoaXMuZWxlbWVudC5maW5kKCBvcHRpb25zLmhlYWRlciApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWhlYWRlciB1aS1oZWxwZXItcmVzZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgKTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMuaGVhZGVycyApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdGhpcy5oZWFkZXJzICk7XG5cblx0XHR0aGlzLmhlYWRlcnMubmV4dCgpXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWNvbnRlbnQgdWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIiApXG5cdFx0XHQuaGlkZSgpO1xuXG5cdFx0Ly8gZG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlIC8gbnVsbFxuXHRcdGlmICggIW9wdGlvbnMuY29sbGFwc2libGUgJiYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSB8fCBvcHRpb25zLmFjdGl2ZSA9PSBudWxsKSApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gMDtcblx0XHR9XG5cdFx0Ly8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlc1xuXHRcdGlmICggb3B0aW9ucy5hY3RpdmUgPCAwICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgKz0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBvcHRpb25zLmFjdGl2ZSApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLWNvcm5lci1hbGwgdWktY29ybmVyLXRvcFwiICk7XG5cdFx0dGhpcy5hY3RpdmUubmV4dCgpXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXCIgKVxuXHRcdFx0LnNob3coKTtcblxuXHRcdHRoaXMuX2NyZWF0ZUljb25zKCk7XG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0XHQvLyBBUklBXG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwicm9sZVwiLCBcInRhYmxpc3RcIiApO1xuXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFiXCIgKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHZhciBoZWFkZXIgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0aGVhZGVySWQgPSBoZWFkZXIuYXR0ciggXCJpZFwiICksXG5cdFx0XHRcdFx0cGFuZWwgPSBoZWFkZXIubmV4dCgpLFxuXHRcdFx0XHRcdHBhbmVsSWQgPSBwYW5lbC5hdHRyKCBcImlkXCIgKTtcblx0XHRcdFx0aWYgKCAhaGVhZGVySWQgKSB7XG5cdFx0XHRcdFx0aGVhZGVySWQgPSBhY2NvcmRpb25JZCArIFwiLWhlYWRlci1cIiArIGk7XG5cdFx0XHRcdFx0aGVhZGVyLmF0dHIoIFwiaWRcIiwgaGVhZGVySWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFwYW5lbElkICkge1xuXHRcdFx0XHRcdHBhbmVsSWQgPSBhY2NvcmRpb25JZCArIFwiLXBhbmVsLVwiICsgaTtcblx0XHRcdFx0XHRwYW5lbC5hdHRyKCBcImlkXCIsIHBhbmVsSWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoZWFkZXIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIsIHBhbmVsSWQgKTtcblx0XHRcdFx0cGFuZWwuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaGVhZGVySWQgKTtcblx0XHRcdH0pXG5cdFx0XHQubmV4dCgpXG5cdFx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJwYW5lbFwiICk7XG5cblx0XHR0aGlzLmhlYWRlcnNcblx0XHRcdC5ub3QoIHRoaXMuYWN0aXZlIClcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9KVxuXHRcdFx0Lm5leHQoKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5oaWRlKCk7XG5cblx0XHQvLyBtYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGhlYWRlciBpcyBpbiB0aGUgdGFiIG9yZGVyXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5oZWFkZXJzLmVxKCAwICkuYXR0ciggXCJ0YWJJbmRleFwiLCAwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYWN0aXZlLmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdHRhYkluZGV4OiAwXG5cdFx0XHR9KVxuXHRcdFx0Lm5leHQoKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiXG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX29uKCB0aGlzLmhlYWRlcnMsIHsga2V5ZG93bjogXCJfa2V5ZG93blwiIH0pO1xuXHRcdHRoaXMuX29uKCB0aGlzLmhlYWRlcnMubmV4dCgpLCB7IGtleWRvd246IFwiX3BhbmVsS2V5RG93blwiIH0pO1xuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCBvcHRpb25zLmV2ZW50ICk7XG5cdH0sXG5cblx0X2dldENyZWF0ZUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlYWRlcjogdGhpcy5hY3RpdmUsXG5cdFx0XHRjb250ZW50OiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5hY3RpdmUubmV4dCgpXG5cdFx0fTtcblx0fSxcblxuXHRfY3JlYXRlSWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpY29ucyA9IHRoaXMub3B0aW9ucy5pY29ucztcblx0XHRpZiAoIGljb25zICkge1xuXHRcdFx0JCggXCI8c3Bhbj5cIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24taGVhZGVyLWljb24gdWktaWNvbiBcIiArIGljb25zLmhlYWRlciApXG5cdFx0XHRcdC5wcmVwZW5kVG8oIHRoaXMuaGVhZGVycyApO1xuXHRcdFx0dGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBpY29ucy5oZWFkZXIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGljb25zLmFjdGl2ZUhlYWRlciApO1xuXHRcdFx0dGhpcy5oZWFkZXJzLmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1pY29uc1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95SWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1pY29uc1wiIClcblx0XHRcdC5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKVxuXHRcdFx0XHQucmVtb3ZlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb250ZW50cztcblxuXHRcdC8vIGNsZWFuIHVwIG1haW4gZWxlbWVudFxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBoZWFkZXJzXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktYWNjb3JkaW9uLWhlYWRlciB1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZSB1aS1oZWxwZXItcmVzZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCB1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAvXnVpLWFjY29yZGlvbi8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cblx0XHQvLyBjbGVhbiB1cCBjb250ZW50IHBhbmVsc1xuXHRcdGNvbnRlbnRzID0gdGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0LmNzcyggXCJkaXNwbGF5XCIsIFwiXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZXhwYW5kZWRcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1oZWxwZXItcmVzZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbSB1aS1hY2NvcmRpb24tY29udGVudCB1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAvXnVpLWFjY29yZGlvbi8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0Y29udGVudHMuY3NzKCBcImhlaWdodFwiLCBcIlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImFjdGl2ZVwiICkge1xuXHRcdFx0Ly8gX2FjdGl2YXRlKCkgd2lsbCBoYW5kbGUgaW52YWxpZCB2YWx1ZXMgYW5kIHVwZGF0ZSB0aGlzLm9wdGlvbnNcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImV2ZW50XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudCApIHtcblx0XHRcdFx0dGhpcy5fb2ZmKCB0aGlzLmhlYWRlcnMsIHRoaXMub3B0aW9ucy5ldmVudCApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0dXBFdmVudHMoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIHNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgJiYgIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJpY29uc1wiICkge1xuXHRcdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLl9jcmVhdGVJY29ucygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vICM1MzMyIC0gb3BhY2l0eSBkb2Vzbid0IGNhc2NhZGUgdG8gcG9zaXRpb25lZCBlbGVtZW50cyBpbiBJRVxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBkaXNhYmxlZCBjbGFzcyB0byB0aGUgaGVhZGVycyBhbmQgcGFuZWxzXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMuaGVhZGVycy5hZGQoIHRoaXMuaGVhZGVycy5uZXh0KCkgKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfa2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGUsXG5cdFx0XHRsZW5ndGggPSB0aGlzLmhlYWRlcnMubGVuZ3RoLFxuXHRcdFx0Y3VycmVudEluZGV4ID0gdGhpcy5oZWFkZXJzLmluZGV4KCBldmVudC50YXJnZXQgKSxcblx0XHRcdHRvRm9jdXMgPSBmYWxzZTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIGtleUNvZGUuUklHSFQ6XG5cdFx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgKCBjdXJyZW50SW5kZXggKyAxICkgJSBsZW5ndGggXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuTEVGVDpcblx0XHRcdGNhc2Uga2V5Q29kZS5VUDpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgKCBjdXJyZW50SW5kZXggLSAxICsgbGVuZ3RoICkgJSBsZW5ndGggXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuU1BBQ0U6XG5cdFx0XHRjYXNlIGtleUNvZGUuRU5URVI6XG5cdFx0XHRcdHRoaXMuX2V2ZW50SGFuZGxlciggZXZlbnQgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuSE9NRTpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgMCBdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2Uga2V5Q29kZS5FTkQ6XG5cdFx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbIGxlbmd0aCAtIDEgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKCB0b0ZvY3VzICkge1xuXHRcdFx0JCggZXZlbnQudGFyZ2V0ICkuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdFx0JCggdG9Gb2N1cyApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdFx0dG9Gb2N1cy5mb2N1cygpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblx0X3BhbmVsS2V5RG93biA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCAmJiBldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnByZXYoKS5mb2N1cygpO1xuXHRcdH1cblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF4SGVpZ2h0LCBvdmVyZmxvdyxcblx0XHRcdGhlaWdodFN0eWxlID0gdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudCgpO1xuXG5cblx0XHRpZiAoIGhlaWdodFN0eWxlID09PSBcImZpbGxcIiApIHtcblx0XHRcdC8vIElFIDYgdHJlYXRzIGhlaWdodCBsaWtlIG1pbkhlaWdodCwgc28gd2UgbmVlZCB0byB0dXJuIG9mZiBvdmVyZmxvd1xuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gZ2V0IGEgcmVsaWFibGUgaGVpZ2h0XG5cdFx0XHQvLyB3ZSB1c2UgdGhlIG1pbkhlaWdodCBzdXBwb3J0IHRlc3QgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBvbmx5XG5cdFx0XHQvLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgbWluSGVpZ2h0IHdpbGwgdHJlYXQgaGVpZ2h0IGFzIG1pbkhlaWdodFxuXHRcdFx0aWYgKCAhJC5zdXBwb3J0Lm1pbkhlaWdodCApIHtcblx0XHRcdFx0b3ZlcmZsb3cgPSBwYXJlbnQuY3NzKCBcIm92ZXJmbG93XCIgKTtcblx0XHRcdFx0cGFyZW50LmNzcyggXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKTtcblx0XHRcdH1cblx0XHRcdG1heEhlaWdodCA9IHBhcmVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5zaWJsaW5ncyggXCI6dmlzaWJsZVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heEhlaWdodCAtPSBlbGVtLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblx0XHRcdGlmICggb3ZlcmZsb3cgKSB7XG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiwgb3ZlcmZsb3cgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5oZWFkZXJzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1heEhlaWdodCAtPSAkKCB0aGlzICkub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmhlYWRlcnMubmV4dCgpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5oZWlnaHQoIE1hdGgubWF4KCAwLCBtYXhIZWlnaHQgLVxuXHRcdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKCBcIm92ZXJmbG93XCIsIFwiYXV0b1wiICk7XG5cdFx0fSBlbHNlIGlmICggaGVpZ2h0U3R5bGUgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0bWF4SGVpZ2h0ID0gMDtcblx0XHRcdHRoaXMuaGVhZGVycy5uZXh0KClcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWF4SGVpZ2h0ID0gTWF0aC5tYXgoIG1heEhlaWdodCwgJCggdGhpcyApLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApLmhlaWdodCgpICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5oZWlnaHQoIG1heEhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggaW5kZXggKVsgMCBdO1xuXG5cdFx0Ly8gdHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlID09PSB0aGlzLmFjdGl2ZVsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHRyeWluZyB0byBjb2xsYXBzZSwgc2ltdWxhdGUgYSBjbGljayBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBoZWFkZXJcblx0XHRhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5hY3RpdmVbIDAgXTtcblxuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcih7XG5cdFx0XHR0YXJnZXQ6IGFjdGl2ZSxcblx0XHRcdGN1cnJlbnRUYXJnZXQ6IGFjdGl2ZSxcblx0XHRcdHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0XHR9KTtcblx0fSxcblxuXHRfZmluZEFjdGl2ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwibnVtYmVyXCIgPyB0aGlzLmhlYWRlcnMuZXEoIHNlbGVjdG9yICkgOiAkKCk7XG5cdH0sXG5cblx0X3NldHVwRXZlbnRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHt9O1xuXHRcdGlmICggIWV2ZW50ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQkLmVhY2goIGV2ZW50LnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGluZGV4LCBldmVudE5hbWUgKSB7XG5cdFx0XHRldmVudHNbIGV2ZW50TmFtZSBdID0gXCJfZXZlbnRIYW5kbGVyXCI7XG5cdFx0fSk7XG5cdFx0dGhpcy5fb24oIHRoaXMuaGVhZGVycywgZXZlbnRzICk7XG5cdH0sXG5cblx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmUsXG5cdFx0XHRjbGlja2VkID0gJCggZXZlbnQuY3VycmVudFRhcmdldCApLFxuXHRcdFx0Y2xpY2tlZElzQWN0aXZlID0gY2xpY2tlZFsgMCBdID09PSBhY3RpdmVbIDAgXSxcblx0XHRcdGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcblx0XHRcdHRvU2hvdyA9IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLm5leHQoKSxcblx0XHRcdHRvSGlkZSA9IGFjdGl2ZS5uZXh0KCksXG5cdFx0XHRldmVudERhdGEgPSB7XG5cdFx0XHRcdG9sZEhlYWRlcjogYWN0aXZlLFxuXHRcdFx0XHRvbGRQYW5lbDogdG9IaWRlLFxuXHRcdFx0XHRuZXdIZWFkZXI6IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLFxuXHRcdFx0XHRuZXdQYW5lbDogdG9TaG93XG5cdFx0XHR9O1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmIChcblx0XHRcdFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxuXHRcdFx0XHQoIGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSApIHx8XG5cdFx0XHRcdC8vIGFsbG93IGNhbmNlbGluZyBhY3RpdmF0aW9uXG5cdFx0XHRcdCggdGhpcy5fdHJpZ2dlciggXCJiZWZvcmVBY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICkgPT09IGZhbHNlICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5hY3RpdmUgPSBjb2xsYXBzaW5nID8gZmFsc2UgOiB0aGlzLmhlYWRlcnMuaW5kZXgoIGNsaWNrZWQgKTtcblxuXHRcdC8vIHdoZW4gdGhlIGNhbGwgdG8gLl90b2dnbGUoKSBjb21lcyBhZnRlciB0aGUgY2xhc3MgY2hhbmdlc1xuXHRcdC8vIGl0IGNhdXNlcyBhIHZlcnkgb2RkIGJ1ZyBpbiBJRSA4IChzZWUgIzY3MjApXG5cdFx0dGhpcy5hY3RpdmUgPSBjbGlja2VkSXNBY3RpdmUgPyAkKCkgOiBjbGlja2VkO1xuXHRcdHRoaXMuX3RvZ2dsZSggZXZlbnREYXRhICk7XG5cblx0XHQvLyBzd2l0Y2ggY2xhc3Nlc1xuXHRcdC8vIGNvcm5lciBjbGFzc2VzIG9uIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBoZWFkZXIgc3RheSBhZnRlciB0aGUgYW5pbWF0aW9uXG5cdFx0YWN0aXZlLnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0aWYgKCBvcHRpb25zLmljb25zICkge1xuXHRcdFx0YWN0aXZlLmNoaWxkcmVuKCBcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggb3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIG9wdGlvbnMuaWNvbnMuaGVhZGVyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhY2xpY2tlZElzQWN0aXZlICkge1xuXHRcdFx0Y2xpY2tlZFxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIgKTtcblx0XHRcdGlmICggb3B0aW9ucy5pY29ucyApIHtcblx0XHRcdFx0Y2xpY2tlZC5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggb3B0aW9ucy5pY29ucy5oZWFkZXIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggb3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Y2xpY2tlZFxuXHRcdFx0XHQubmV4dCgpXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmVcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgdG9TaG93ID0gZGF0YS5uZXdQYW5lbCxcblx0XHRcdHRvSGlkZSA9IHRoaXMucHJldlNob3cubGVuZ3RoID8gdGhpcy5wcmV2U2hvdyA6IGRhdGEub2xkUGFuZWw7XG5cblx0XHQvLyBoYW5kbGUgYWN0aXZhdGluZyBhIHBhbmVsIGR1cmluZyB0aGUgYW5pbWF0aW9uIGZvciBhbm90aGVyIGFjdGl2YXRpb25cblx0XHR0aGlzLnByZXZTaG93LmFkZCggdGhpcy5wcmV2SGlkZSApLnN0b3AoIHRydWUsIHRydWUgKTtcblx0XHR0aGlzLnByZXZTaG93ID0gdG9TaG93O1xuXHRcdHRoaXMucHJldkhpZGUgPSB0b0hpZGU7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hbmltYXRlICkge1xuXHRcdFx0dGhpcy5fYW5pbWF0ZSggdG9TaG93LCB0b0hpZGUsIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9IaWRlLmhpZGUoKTtcblx0XHRcdHRvU2hvdy5zaG93KCk7XG5cdFx0XHR0aGlzLl90b2dnbGVDb21wbGV0ZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdHRvSGlkZS5hdHRyKHtcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0fSk7XG5cdFx0dG9IaWRlLnByZXYoKS5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0Ly8gaWYgd2UncmUgc3dpdGNoaW5nIHBhbmVscywgcmVtb3ZlIHRoZSBvbGQgaGVhZGVyIGZyb20gdGhlIHRhYiBvcmRlclxuXHRcdC8vIGlmIHdlJ3JlIG9wZW5pbmcgZnJvbSBjb2xsYXBzZWQgc3RhdGUsIHJlbW92ZSB0aGUgcHJldmlvdXMgaGVhZGVyIGZyb20gdGhlIHRhYiBvcmRlclxuXHRcdC8vIGlmIHdlJ3JlIGNvbGxhcHNpbmcsIHRoZW4ga2VlcCB0aGUgY29sbGFwc2luZyBoZWFkZXIgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiB0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0dG9IaWRlLnByZXYoKS5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fSBlbHNlIGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMuaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICkgPT09IDA7XG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3dcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5wcmV2KClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0XHR9KTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24oIHRvU2hvdywgdG9IaWRlLCBkYXRhICkge1xuXHRcdHZhciB0b3RhbCwgZWFzaW5nLCBkdXJhdGlvbixcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0YWRqdXN0ID0gMCxcblx0XHRcdGRvd24gPSB0b1Nob3cubGVuZ3RoICYmXG5cdFx0XHRcdCggIXRvSGlkZS5sZW5ndGggfHwgKCB0b1Nob3cuaW5kZXgoKSA8IHRvSGlkZS5pbmRleCgpICkgKSxcblx0XHRcdGFuaW1hdGUgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZSB8fCB7fSxcblx0XHRcdG9wdGlvbnMgPSBkb3duICYmIGFuaW1hdGUuZG93biB8fCBhbmltYXRlLFxuXHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5fdG9nZ2xlQ29tcGxldGUoIGRhdGEgKTtcblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZWFzaW5nID0gb3B0aW9ucztcblx0XHR9XG5cdFx0Ly8gZmFsbCBiYWNrIGZyb20gb3B0aW9ucyB0byBhbmltYXRpb24gaW4gY2FzZSBvZiBwYXJ0aWFsIGRvd24gc2V0dGluZ3Ncblx0XHRlYXNpbmcgPSBlYXNpbmcgfHwgb3B0aW9ucy5lYXNpbmcgfHwgYW5pbWF0ZS5lYXNpbmc7XG5cdFx0ZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBvcHRpb25zLmR1cmF0aW9uIHx8IGFuaW1hdGUuZHVyYXRpb247XG5cblx0XHRpZiAoICF0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRvU2hvdy5hbmltYXRlKCBzaG93UHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlICk7XG5cdFx0fVxuXHRcdGlmICggIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdG9IaWRlLmFuaW1hdGUoIGhpZGVQcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUgKTtcblx0XHR9XG5cblx0XHR0b3RhbCA9IHRvU2hvdy5zaG93KCkub3V0ZXJIZWlnaHQoKTtcblx0XHR0b0hpZGUuYW5pbWF0ZSggaGlkZVByb3BzLCB7XG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCBub3csIGZ4ICkge1xuXHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCBub3cgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0b1Nob3dcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hbmltYXRlKCBzaG93UHJvcHMsIHtcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0Y29tcGxldGU6IGNvbXBsZXRlLFxuXHRcdFx0XHRzdGVwOiBmdW5jdGlvbiggbm93LCBmeCApIHtcblx0XHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCBub3cgKTtcblx0XHRcdFx0XHRpZiAoIGZ4LnByb3AgIT09IFwiaGVpZ2h0XCIgKSB7XG5cdFx0XHRcdFx0XHRhZGp1c3QgKz0gZngubm93O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoYXQub3B0aW9ucy5oZWlnaHRTdHlsZSAhPT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCB0b3RhbCAtIHRvSGlkZS5vdXRlckhlaWdodCgpIC0gYWRqdXN0ICk7XG5cdFx0XHRcdFx0XHRhZGp1c3QgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0X3RvZ2dsZUNvbXBsZXRlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgdG9IaWRlID0gZGF0YS5vbGRQYW5lbDtcblxuXHRcdHRvSGlkZVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiIClcblx0XHRcdC5wcmV2KClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci10b3BcIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIgKTtcblxuXHRcdC8vIFdvcmsgYXJvdW5kIGZvciByZW5kZXJpbmcgYnVnIGluIElFICgjNTQyMSlcblx0XHRpZiAoIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHR0b0hpZGUucGFyZW50KClbMF0uY2xhc3NOYW1lID0gdG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIG51bGwsIGRhdGEgKTtcblx0fVxufSk7XG5cblxuXG4vLyBERVBSRUNBVEVEXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblx0Ly8gbmF2aWdhdGlvbiBvcHRpb25zXG5cdChmdW5jdGlvbiggJCwgcHJvdG90eXBlICkge1xuXHRcdCQuZXh0ZW5kKCBwcm90b3R5cGUub3B0aW9ucywge1xuXHRcdFx0bmF2aWdhdGlvbjogZmFsc2UsXG5cdFx0XHRuYXZpZ2F0aW9uRmlsdGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaHJlZi50b0xvd2VyQ2FzZSgpID09PSBsb2NhdGlvbi5ocmVmLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgX2NyZWF0ZSA9IHByb3RvdHlwZS5fY3JlYXRlO1xuXHRcdHByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uICkge1xuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0aGVhZGVycyA9IHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaGVhZGVyICksXG5cdFx0XHRcdFx0Y29udGVudCA9IGhlYWRlcnMubmV4dCgpLFxuXHRcdFx0XHRcdGN1cnJlbnQgPSBoZWFkZXJzLmFkZCggY29udGVudCApXG5cdFx0XHRcdFx0XHQuZmluZCggXCJhXCIgKVxuXHRcdFx0XHRcdFx0LmZpbHRlciggdGhpcy5vcHRpb25zLm5hdmlnYXRpb25GaWx0ZXIgKVxuXHRcdFx0XHRcdFx0WyAwIF07XG5cdFx0XHRcdGlmICggY3VycmVudCApIHtcblx0XHRcdFx0XHRoZWFkZXJzLmFkZCggY29udGVudCApLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0XHRcdGlmICggJC5jb250YWlucyggdGhpcywgY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0Lm9wdGlvbnMuYWN0aXZlID0gTWF0aC5mbG9vciggaW5kZXggLyAyICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X2NyZWF0ZS5jYWxsKCB0aGlzICk7XG5cdFx0fTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG5cblx0Ly8gaGVpZ2h0IG9wdGlvbnNcblx0KGZ1bmN0aW9uKCAkLCBwcm90b3R5cGUgKSB7XG5cdFx0JC5leHRlbmQoIHByb3RvdHlwZS5vcHRpb25zLCB7XG5cdFx0XHRoZWlnaHRTdHlsZTogbnVsbCwgLy8gcmVtb3ZlIGRlZmF1bHQgc28gd2UgZmFsbCBiYWNrIHRvIG9sZCB2YWx1ZXNcblx0XHRcdGF1dG9IZWlnaHQ6IHRydWUsIC8vIHVzZSBoZWlnaHRTdHlsZTogXCJhdXRvXCJcblx0XHRcdGNsZWFyU3R5bGU6IGZhbHNlLCAvLyB1c2UgaGVpZ2h0U3R5bGU6IFwiY29udGVudFwiXG5cdFx0XHRmaWxsU3BhY2U6IGZhbHNlIC8vIHVzZSBoZWlnaHRTdHlsZTogXCJmaWxsXCJcblx0XHR9KTtcblxuXHRcdHZhciBfY3JlYXRlID0gcHJvdG90eXBlLl9jcmVhdGUsXG5cdFx0XHRfc2V0T3B0aW9uID0gcHJvdG90eXBlLl9zZXRPcHRpb247XG5cblx0XHQkLmV4dGVuZCggcHJvdG90eXBlLCB7XG5cdFx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmhlaWdodFN0eWxlID0gdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlIHx8XG5cdFx0XHRcdFx0dGhpcy5fbWVyZ2VIZWlnaHRTdHlsZSgpO1xuXG5cdFx0XHRcdF9jcmVhdGUuY2FsbCggdGhpcyApO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0aWYgKCBrZXkgPT09IFwiYXV0b0hlaWdodFwiIHx8IGtleSA9PT0gXCJjbGVhclN0eWxlXCIgfHwga2V5ID09PSBcImZpbGxTcGFjZVwiICkge1xuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSA9IHRoaXMuX21lcmdlSGVpZ2h0U3R5bGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfc2V0T3B0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH0sXG5cblx0XHRcdF9tZXJnZUhlaWdodFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRcdFx0aWYgKCBvcHRpb25zLmZpbGxTcGFjZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJmaWxsXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9wdGlvbnMuY2xlYXJTdHlsZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJjb250ZW50XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9wdGlvbnMuYXV0b0hlaWdodCApIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJhdXRvXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG5cblx0Ly8gaWNvbiBvcHRpb25zXG5cdChmdW5jdGlvbiggJCwgcHJvdG90eXBlICkge1xuXHRcdCQuZXh0ZW5kKCBwcm90b3R5cGUub3B0aW9ucy5pY29ucywge1xuXHRcdFx0YWN0aXZlSGVhZGVyOiBudWxsLCAvLyByZW1vdmUgZGVmYXVsdCBzbyB3ZSBmYWxsIGJhY2sgdG8gb2xkIHZhbHVlc1xuXHRcdFx0aGVhZGVyU2VsZWN0ZWQ6IFwidWktaWNvbi10cmlhbmdsZS0xLXNcIlxuXHRcdH0pO1xuXG5cdFx0dmFyIF9jcmVhdGVJY29ucyA9IHByb3RvdHlwZS5fY3JlYXRlSWNvbnM7XG5cdFx0cHJvdG90eXBlLl9jcmVhdGVJY29ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuaWNvbnMgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgPSB0aGlzLm9wdGlvbnMuaWNvbnMuYWN0aXZlSGVhZGVyIHx8XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmljb25zLmhlYWRlclNlbGVjdGVkO1xuXHRcdFx0fVxuXHRcdFx0X2NyZWF0ZUljb25zLmNhbGwoIHRoaXMgKTtcblx0XHR9O1xuXHR9KCBqUXVlcnksIGpRdWVyeS51aS5hY2NvcmRpb24ucHJvdG90eXBlICkgKTtcblxuXHQvLyBleHBhbmRlZCBhY3RpdmUgb3B0aW9uLCBhY3RpdmF0ZSBtZXRob2Rcblx0KGZ1bmN0aW9uKCAkLCBwcm90b3R5cGUgKSB7XG5cdFx0cHJvdG90eXBlLmFjdGl2YXRlID0gcHJvdG90eXBlLl9hY3RpdmF0ZTtcblxuXHRcdHZhciBfZmluZEFjdGl2ZSA9IHByb3RvdHlwZS5fZmluZEFjdGl2ZTtcblx0XHRwcm90b3R5cGUuX2ZpbmRBY3RpdmUgPSBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0aW5kZXggPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggJiYgdHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRpbmRleCA9IHRoaXMuaGVhZGVycy5pbmRleCggdGhpcy5oZWFkZXJzLmZpbHRlciggaW5kZXggKSApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRpbmRleCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX2ZpbmRBY3RpdmUuY2FsbCggdGhpcywgaW5kZXggKTtcblx0XHR9O1xuXHR9KCBqUXVlcnksIGpRdWVyeS51aS5hY2NvcmRpb24ucHJvdG90eXBlICkgKTtcblxuXHQvLyByZXNpemUgbWV0aG9kXG5cdGpRdWVyeS51aS5hY2NvcmRpb24ucHJvdG90eXBlLnJlc2l6ZSA9IGpRdWVyeS51aS5hY2NvcmRpb24ucHJvdG90eXBlLnJlZnJlc2g7XG5cblx0Ly8gY2hhbmdlIGV2ZW50c1xuXHQoZnVuY3Rpb24oICQsIHByb3RvdHlwZSApIHtcblx0XHQkLmV4dGVuZCggcHJvdG90eXBlLm9wdGlvbnMsIHtcblx0XHRcdGNoYW5nZTogbnVsbCxcblx0XHRcdGNoYW5nZXN0YXJ0OiBudWxsXG5cdFx0fSk7XG5cblx0XHR2YXIgX3RyaWdnZXIgPSBwcm90b3R5cGUuX3RyaWdnZXI7XG5cdFx0cHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdFx0dmFyIHJldCA9IF90cmlnZ2VyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiYmVmb3JlQWN0aXZhdGVcIiApIHtcblx0XHRcdFx0cmV0ID0gX3RyaWdnZXIuY2FsbCggdGhpcywgXCJjaGFuZ2VzdGFydFwiLCBldmVudCwge1xuXHRcdFx0XHRcdG9sZEhlYWRlcjogZGF0YS5vbGRIZWFkZXIsXG5cdFx0XHRcdFx0b2xkQ29udGVudDogZGF0YS5vbGRQYW5lbCxcblx0XHRcdFx0XHRuZXdIZWFkZXI6IGRhdGEubmV3SGVhZGVyLFxuXHRcdFx0XHRcdG5ld0NvbnRlbnQ6IGRhdGEubmV3UGFuZWxcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImFjdGl2YXRlXCIgKSB7XG5cdFx0XHRcdHJldCA9IF90cmlnZ2VyLmNhbGwoIHRoaXMsIFwiY2hhbmdlXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0b2xkSGVhZGVyOiBkYXRhLm9sZEhlYWRlcixcblx0XHRcdFx0XHRvbGRDb250ZW50OiBkYXRhLm9sZFBhbmVsLFxuXHRcdFx0XHRcdG5ld0hlYWRlcjogZGF0YS5uZXdIZWFkZXIsXG5cdFx0XHRcdFx0bmV3Q29udGVudDogZGF0YS5uZXdQYW5lbFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG5cblx0Ly8gYW5pbWF0ZWQgb3B0aW9uXG5cdC8vIE5PVEU6IHRoaXMgb25seSBwcm92aWRlcyBzdXBwb3J0IGZvciBcInNsaWRlXCIsIFwiYm91bmNlc2xpZGVcIiwgYW5kIGVhc2luZ3Ncblx0Ly8gbm90IHRoZSBmdWxsICQudWkuYWNjb3JkaW9uLmFuaW1hdGlvbnMgQVBJXG5cdChmdW5jdGlvbiggJCwgcHJvdG90eXBlICkge1xuXHRcdCQuZXh0ZW5kKCBwcm90b3R5cGUub3B0aW9ucywge1xuXHRcdFx0YW5pbWF0ZTogbnVsbCxcblx0XHRcdGFuaW1hdGVkOiBcInNsaWRlXCJcblx0XHR9KTtcblxuXHRcdHZhciBfY3JlYXRlID0gcHJvdG90eXBlLl9jcmVhdGU7XG5cdFx0cHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdFx0aWYgKCBvcHRpb25zLmFuaW1hdGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuYW5pbWF0ZWQgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5hbmltYXRlID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMuYW5pbWF0ZWQgPT09IFwic2xpZGVcIiApIHtcblx0XHRcdFx0XHRvcHRpb25zLmFuaW1hdGUgPSAzMDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMuYW5pbWF0ZWQgPT09IFwiYm91bmNlc2xpZGVcIiApIHtcblx0XHRcdFx0XHRvcHRpb25zLmFuaW1hdGUgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogMjAwLFxuXHRcdFx0XHRcdFx0ZG93bjoge1xuXHRcdFx0XHRcdFx0XHRlYXNpbmc6IFwiZWFzZU91dEJvdW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogMTAwMFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5hbmltYXRlID0gb3B0aW9ucy5hbmltYXRlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfY3JlYXRlLmNhbGwoIHRoaXMgKTtcblx0XHR9O1xuXHR9KCBqUXVlcnksIGpRdWVyeS51aS5hY2NvcmRpb24ucHJvdG90eXBlICkgKTtcbn1cblxufSkoIGpRdWVyeSApO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIHVzZWQgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnMgd2l0aCByZW1vdGUgZGF0YSBzb3VyY2VzXG52YXIgcmVxdWVzdEluZGV4ID0gMDtcblxuJC53aWRnZXQoIFwidWkuYXV0b2NvbXBsZXRlXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8aW5wdXQ+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhcHBlbmRUbzogXCJib2R5XCIsXG5cdFx0YXV0b0ZvY3VzOiBmYWxzZSxcblx0XHRkZWxheTogMzAwLFxuXHRcdG1pbkxlbmd0aDogMSxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0bXk6IFwibGVmdCB0b3BcIixcblx0XHRcdGF0OiBcImxlZnQgYm90dG9tXCIsXG5cdFx0XHRjb2xsaXNpb246IFwibm9uZVwiXG5cdFx0fSxcblx0XHRzb3VyY2U6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0Zm9jdXM6IG51bGwsXG5cdFx0b3BlbjogbnVsbCxcblx0XHRyZXNwb25zZTogbnVsbCxcblx0XHRzZWFyY2g6IG51bGwsXG5cdFx0c2VsZWN0OiBudWxsXG5cdH0sXG5cblx0cGVuZGluZzogMCxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBTb21lIGJyb3dzZXJzIG9ubHkgcmVwZWF0IGtleWRvd24gZXZlbnRzLCBub3Qga2V5cHJlc3MgZXZlbnRzLFxuXHRcdC8vIHNvIHdlIHVzZSB0aGUgc3VwcHJlc3NLZXlQcmVzcyBmbGFnIHRvIGRldGVybWluZSBpZiB3ZSd2ZSBhbHJlYWR5XG5cdFx0Ly8gaGFuZGxlZCB0aGUga2V5ZG93biBldmVudC4gIzcyNjlcblx0XHQvLyBVbmZvcnR1bmF0ZWx5IHRoZSBjb2RlIGZvciAmIGluIGtleXByZXNzIGlzIHRoZSBzYW1lIGFzIHRoZSB1cCBhcnJvdyxcblx0XHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgZmxhZyB0byBhdm9pZCBoYW5kbGluZyBrZXlwcmVzc1xuXHRcdC8vIGV2ZW50cyB3aGVuIHdlIGtub3cgdGhlIGtleWRvd24gZXZlbnQgd2FzIHVzZWQgdG8gbW9kaWZ5IHRoZVxuXHRcdC8vIHNlYXJjaCB0ZXJtLiAjNzc5OVxuXHRcdHZhciBzdXBwcmVzc0tleVByZXNzLCBzdXBwcmVzc0tleVByZXNzUmVwZWF0LCBzdXBwcmVzc0lucHV0O1xuXG5cdFx0dGhpcy5pc011bHRpTGluZSA9IHRoaXMuX2lzTXVsdGlMaW5lKCk7XG5cdFx0dGhpcy52YWx1ZU1ldGhvZCA9IHRoaXMuZWxlbWVudFsgdGhpcy5lbGVtZW50LmlzKCBcImlucHV0LHRleHRhcmVhXCIgKSA/IFwidmFsXCIgOiBcInRleHRcIiBdO1xuXHRcdHRoaXMuaXNOZXdNZW51ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFwiIClcblx0XHRcdC5hdHRyKCBcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LnByb3AoIFwicmVhZE9ubHlcIiApICkge1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHN1cHByZXNzSW5wdXQgPSB0cnVlO1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSBmYWxzZTtcblx0XHRcdFx0c3VwcHJlc3NJbnB1dCA9IGZhbHNlO1xuXHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXHRcdFx0XHRzd2l0Y2goIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwicHJldmlvdXNQYWdlXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJuZXh0UGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fa2V5RXZlbnQoIFwicHJldmlvdXNcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkRPV046XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fa2V5RXZlbnQoIFwibmV4dFwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRU5URVI6XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5OVU1QQURfRU5URVI6XG5cdFx0XHRcdFx0Ly8gd2hlbiBtZW51IGlzIG9wZW4gYW5kIGhhcyBmb2N1c1xuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmFjdGl2ZSApIHtcblx0XHRcdFx0XHRcdC8vICM2MDU1IC0gT3BlcmEgc3RpbGwgYWxsb3dzIHRoZSBrZXlwcmVzcyB0byBvY2N1clxuXHRcdFx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGZvcm1zIHRvIHN1Ym1pdFxuXHRcdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5tZW51LnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5UQUI6XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1lbnUuYWN0aXZlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5tZW51LnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5FU0NBUEU6XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZSggdGhpcy50ZXJtICk7XG5cdFx0XHRcdFx0XHR0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHRcdFx0Ly8gRGlmZmVyZW50IGJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgYmVoYXZpb3IgZm9yIGVzY2FwZVxuXHRcdFx0XHRcdFx0Ly8gU2luZ2xlIHByZXNzIGNhbiBtZWFuIHVuZG8gb3IgY2xlYXJcblx0XHRcdFx0XHRcdC8vIERvdWJsZSBwcmVzcyBpbiBJRSBtZWFucyBjbGVhciB0aGUgd2hvbGUgZm9ybVxuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gc2VhcmNoIHRpbWVvdXQgc2hvdWxkIGJlIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGlucHV0IHZhbHVlIGlzIGNoYW5nZWRcblx0XHRcdFx0XHR0aGlzLl9zZWFyY2hUaW1lb3V0KCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBzdXBwcmVzc0tleVByZXNzICkge1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVwbGljYXRlIHNvbWUga2V5IGhhbmRsZXJzIHRvIGFsbG93IHRoZW0gdG8gcmVwZWF0IGluIEZpcmVmb3ggYW5kIE9wZXJhXG5cdFx0XHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXHRcdFx0XHRzd2l0Y2goIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwicHJldmlvdXNQYWdlXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJuZXh0UGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHRcdFx0dGhpcy5fa2V5RXZlbnQoIFwicHJldmlvdXNcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkRPV046XG5cdFx0XHRcdFx0dGhpcy5fa2V5RXZlbnQoIFwibmV4dFwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW5wdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBzdXBwcmVzc0lucHV0ICkge1xuXHRcdFx0XHRcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zZWFyY2hUaW1lb3V0KCBldmVudCApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuXHRcdFx0XHR0aGlzLnByZXZpb3VzID0gdGhpcy5fdmFsdWUoKTtcblx0XHRcdH0sXG5cdFx0XHRibHVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jYW5jZWxCbHVyICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdFx0XHR0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2UoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9pbml0U291cmNlKCk7XG5cdFx0dGhpcy5tZW51ID0gJCggXCI8dWw+XCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWF1dG9jb21wbGV0ZVwiIClcblx0XHRcdC5hcHBlbmRUbyggdGhpcy5kb2N1bWVudC5maW5kKCB0aGlzLm9wdGlvbnMuYXBwZW5kVG8gfHwgXCJib2R5XCIgKVsgMCBdIClcblx0XHRcdC5tZW51KHtcblx0XHRcdFx0Ly8gY3VzdG9tIGtleSBoYW5kbGluZyBmb3Igbm93XG5cdFx0XHRcdGlucHV0OiAkKCksXG5cdFx0XHRcdC8vIGRpc2FibGUgQVJJQSBzdXBwb3J0LCB0aGUgbGl2ZSByZWdpb24gdGFrZXMgY2FyZSBvZiB0aGF0XG5cdFx0XHRcdHJvbGU6IG51bGxcblx0XHRcdH0pXG5cdFx0XHQuekluZGV4KCB0aGlzLmVsZW1lbnQuekluZGV4KCkgKyAxIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5kYXRhKCBcIm1lbnVcIiApO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMubWVudS5lbGVtZW50LCB7XG5cdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gcHJldmVudCBtb3ZpbmcgZm9jdXMgb3V0IG9mIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0XHQvLyBzbyB3ZSBzZXQgYSBmbGFnIHRvIGtub3cgd2hlbiB3ZSBzaG91bGQgaWdub3JlIHRoZSBibHVyIGV2ZW50XG5cdFx0XHRcdHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGNsaWNraW5nIG9uIHRoZSBzY3JvbGxiYXIgY2F1c2VzIGZvY3VzIHRvIHNoaWZ0IHRvIHRoZSBib2R5XG5cdFx0XHRcdC8vIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYSBtb3VzZXVwIG9yIGEgY2xpY2sgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkXG5cdFx0XHRcdC8vIHNvIHdlIGhhdmUgdG8gdHJhY2sgdGhlIG5leHQgbW91c2Vkb3duIGFuZCBjbG9zZSB0aGUgbWVudSBpZlxuXHRcdFx0XHQvLyB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG91dHNpZGUgb2YgdGhlIGF1dG9jb21wbGV0ZVxuXHRcdFx0XHR2YXIgbWVudUVsZW1lbnQgPSB0aGlzLm1lbnUuZWxlbWVudFsgMCBdO1xuXHRcdFx0XHRpZiAoICEkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQub25lKCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGF0LmVsZW1lbnRbIDAgXSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ICE9PSBtZW51RWxlbWVudCAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ISQuY29udGFpbnMoIG1lbnVFbGVtZW50LCBldmVudC50YXJnZXQgKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGF0LmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWVudWZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQvLyAjNzAyNCAtIFByZXZlbnQgYWNjaWRlbnRhbCBhY3RpdmF0aW9uIG9mIG1lbnUgaXRlbXMgaW4gRmlyZWZveFxuXHRcdFx0XHRpZiAoIHRoaXMuaXNOZXdNZW51ICkge1xuXHRcdFx0XHRcdHRoaXMuaXNOZXdNZW51ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ebW91c2UvLnRlc3QoIGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5vbmUoIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS50cmlnZ2VyKCBldmVudC5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJhY2sgY29tcGF0IGZvciBfcmVuZGVySXRlbSB1c2luZyBpdGVtLmF1dG9jb21wbGV0ZSwgdmlhICM3ODEwXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoZSBmYWxsYmFjaywgc2VlICM4MTU2XG5cdFx0XHRcdHZhciBpdGVtID0gdWkuaXRlbS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIgKSB8fCB1aS5pdGVtLmRhdGEoIFwiaXRlbS5hdXRvY29tcGxldGVcIiApO1xuXHRcdFx0XHRpZiAoIGZhbHNlICE9PSB0aGlzLl90cmlnZ2VyKCBcImZvY3VzXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApICkge1xuXHRcdFx0XHRcdC8vIHVzZSB2YWx1ZSB0byBtYXRjaCB3aGF0IHdpbGwgZW5kIHVwIGluIHRoZSBpbnB1dCwgaWYgaXQgd2FzIGEga2V5IGV2ZW50XG5cdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ea2V5Ly50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcm1hbGx5IHRoZSBpbnB1dCBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgaXRlbSdzIHZhbHVlIGFzIHRoZVxuXHRcdFx0XHRcdC8vIG1lbnUgaXMgbmF2aWdhdGVkLCBjYXVzaW5nIHNjcmVlbiByZWFkZXJzIHRvIG5vdGljZSBhIGNoYW5nZSBhbmRcblx0XHRcdFx0XHQvLyBhbm5vdW5jZSB0aGUgaXRlbS4gU2luY2UgdGhlIGZvY3VzIGV2ZW50IHdhcyBjYW5jZWxlZCwgdGhpcyBkb2Vzbid0XG5cdFx0XHRcdFx0Ly8gaGFwcGVuLCBzbyB3ZSB1cGRhdGUgdGhlIGxpdmUgcmVnaW9uIHNvIHRoYXQgc2NyZWVuIHJlYWRlcnMgY2FuXG5cdFx0XHRcdFx0Ly8gc3RpbGwgbm90aWNlIHRoZSBjaGFuZ2UgYW5kIGFubm91bmNlIGl0LlxuXHRcdFx0XHRcdHRoaXMubGl2ZVJlZ2lvbi50ZXh0KCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtZW51c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQvLyBiYWNrIGNvbXBhdCBmb3IgX3JlbmRlckl0ZW0gdXNpbmcgaXRlbS5hdXRvY29tcGxldGUsIHZpYSAjNzgxMFxuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGUgZmFsbGJhY2ssIHNlZSAjODE1NlxuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICkgfHwgdWkuaXRlbS5kYXRhKCBcIml0ZW0uYXV0b2NvbXBsZXRlXCIgKSxcblx0XHRcdFx0XHRwcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG5cblx0XHRcdFx0Ly8gb25seSB0cmlnZ2VyIHdoZW4gZm9jdXMgd2FzIGxvc3QgKGNsaWNrIG9uIG1lbnUpXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdC8vICM2MTA5IC0gSUUgdHJpZ2dlcnMgdHdvIGZvY3VzIGV2ZW50cyBhbmQgdGhlIHNlY29uZFxuXHRcdFx0XHRcdC8vIGlzIGFzeW5jaHJvbm91cywgc28gd2UgbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXNcblx0XHRcdFx0XHQvLyB0ZXJtIHN5bmNocm9ub3VzbHkgYW5kIGFzeW5jaHJvbm91c2x5IDotKFxuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWUoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXNldCB0aGUgdGVybSBhZnRlciB0aGUgc2VsZWN0IGV2ZW50XG5cdFx0XHRcdC8vIHRoaXMgYWxsb3dzIGN1c3RvbSBzZWxlY3QgaGFuZGxpbmcgdG8gd29yayBwcm9wZXJseVxuXHRcdFx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMubGl2ZVJlZ2lvbiA9ICQoIFwiPHNwYW4+XCIsIHtcblx0XHRcdFx0cm9sZTogXCJzdGF0dXNcIixcblx0XHRcdFx0XCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIlxuXHRcdFx0fSlcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApXG5cdFx0XHQuaW5zZXJ0QWZ0ZXIoIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0aWYgKCAkLmZuLmJnaWZyYW1lICkge1xuXHRcdFx0dGhpcy5tZW51LmVsZW1lbnQuYmdpZnJhbWUoKTtcblx0XHR9XG5cblx0XHQvLyB0dXJuaW5nIG9mZiBhdXRvY29tcGxldGUgcHJldmVudHMgdGhlIGJyb3dzZXIgZnJvbSByZW1lbWJlcmluZyB0aGVcblx0XHQvLyB2YWx1ZSB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBoaXN0b3J5LCBzbyB3ZSByZS1lbmFibGUgYXV0b2NvbXBsZXRlXG5cdFx0Ly8gaWYgdGhlIHBhZ2UgaXMgdW5sb2FkZWQgYmVmb3JlIHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLiAjNzc5MFxuXHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywge1xuXHRcdFx0YmVmb3JldW5sb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZVwiICk7XG5cdFx0dGhpcy5tZW51LmVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0dGhpcy5saXZlUmVnaW9uLnJlbW92ZSgpO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0aWYgKCBrZXkgPT09IFwic291cmNlXCIgKSB7XG5cdFx0XHR0aGlzLl9pbml0U291cmNlKCk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImFwcGVuZFRvXCIgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5hcHBlbmRUbyggdGhpcy5kb2N1bWVudC5maW5kKCB2YWx1ZSB8fCBcImJvZHlcIiApWzBdICk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgJiYgdmFsdWUgJiYgdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNNdWx0aUxpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRleHRhcmVhcyBhcmUgYWx3YXlzIG11bHRpLWxpbmVcblx0XHRpZiAoIHRoaXMuZWxlbWVudC5pcyggXCJ0ZXh0YXJlYVwiICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0Ly8gSW5wdXRzIGFyZSBhbHdheXMgc2luZ2xlLWxpbmUsIGV2ZW4gaWYgaW5zaWRlIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcblx0XHQvLyBJRSBhbHNvIHRyZWF0cyBpbnB1dHMgYXMgY29udGVudEVkaXRhYmxlXG5cdFx0aWYgKCB0aGlzLmVsZW1lbnQuaXMoIFwiaW5wdXRcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBBbGwgb3RoZXIgZWxlbWVudCB0eXBlcyBhcmUgZGV0ZXJtaW5lZCBieSB3aGV0aGVyIG9yIG5vdCB0aGV5J3JlIGNvbnRlbnRFZGl0YWJsZVxuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQucHJvcCggXCJpc0NvbnRlbnRFZGl0YWJsZVwiICk7XG5cdH0sXG5cblx0X2luaXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnJheSwgdXJsLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKCAkLmlzQXJyYXkodGhpcy5vcHRpb25zLnNvdXJjZSkgKSB7XG5cdFx0XHRhcnJheSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdFx0cmVzcG9uc2UoICQudWkuYXV0b2NvbXBsZXRlLmZpbHRlciggYXJyYXksIHJlcXVlc3QudGVybSApICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuc291cmNlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dXJsID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcblx0XHRcdHRoaXMuc291cmNlID0gZnVuY3Rpb24oIHJlcXVlc3QsIHJlc3BvbnNlICkge1xuXHRcdFx0XHRpZiAoIHRoYXQueGhyICkge1xuXHRcdFx0XHRcdHRoYXQueGhyLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhhdC54aHIgPSAkLmFqYXgoe1xuXHRcdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRcdGRhdGE6IHJlcXVlc3QsXG5cdFx0XHRcdFx0ZGF0YVR5cGU6IFwianNvblwiLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UoIGRhdGEgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBbXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWFyY2hUaW1lb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuc2VhcmNoaW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBvbmx5IHNlYXJjaCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcblx0XHRcdGlmICggdGhpcy50ZXJtICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuc2VhcmNoKCBudWxsLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSApO1xuXHR9LFxuXG5cdHNlYXJjaDogZnVuY3Rpb24oIHZhbHVlLCBldmVudCApIHtcblx0XHR2YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMuX3ZhbHVlKCk7XG5cblx0XHQvLyBhbHdheXMgc2F2ZSB0aGUgYWN0dWFsIHZhbHVlLCBub3QgdGhlIG9uZSBwYXNzZWQgYXMgYW4gYXJndW1lbnRcblx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0aWYgKCB2YWx1ZS5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWluTGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcInNlYXJjaFwiLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fc2VhcmNoKCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLnBlbmRpbmcrKztcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdHRoaXMuY2FuY2VsU2VhcmNoID0gZmFsc2U7XG5cblx0XHR0aGlzLnNvdXJjZSggeyB0ZXJtOiB2YWx1ZSB9LCB0aGlzLl9yZXNwb25zZSgpICk7XG5cdH0sXG5cblx0X3Jlc3BvbnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRpbmRleCA9ICsrcmVxdWVzdEluZGV4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gcmVxdWVzdEluZGV4ICkge1xuXHRcdFx0XHR0aGF0Ll9fcmVzcG9uc2UoIGNvbnRlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5wZW5kaW5nLS07XG5cdFx0XHRpZiAoICF0aGF0LnBlbmRpbmcgKSB7XG5cdFx0XHRcdHRoYXQuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtbG9hZGluZ1wiICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfX3Jlc3BvbnNlOiBmdW5jdGlvbiggY29udGVudCApIHtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHRjb250ZW50ID0gdGhpcy5fbm9ybWFsaXplKCBjb250ZW50ICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwicmVzcG9uc2VcIiwgbnVsbCwgeyBjb250ZW50OiBjb250ZW50IH0gKTtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCAmJiAhdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHR0aGlzLl9zdWdnZXN0KCBjb250ZW50ICk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB1c2UgLl9jbG9zZSgpIGluc3RlYWQgb2YgLmNsb3NlKCkgc28gd2UgZG9uJ3QgY2FuY2VsIGZ1dHVyZSBzZWFyY2hlc1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmNhbmNlbFNlYXJjaCA9IHRydWU7XG5cdFx0dGhpcy5fY2xvc2UoIGV2ZW50ICk7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5oaWRlKCk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHsgaXRlbTogdGhpcy5zZWxlY3RlZEl0ZW0gfSApO1xuXHRcdH1cblx0fSxcblxuXHRfbm9ybWFsaXplOiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0Ly8gYXNzdW1lIGFsbCBpdGVtcyBoYXZlIHRoZSByaWdodCBmb3JtYXQgd2hlbiB0aGUgZmlyc3QgaXRlbSBpcyBjb21wbGV0ZVxuXHRcdGlmICggaXRlbXMubGVuZ3RoICYmIGl0ZW1zWzBdLmxhYmVsICYmIGl0ZW1zWzBdLnZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5tYXAoIGl0ZW1zLCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGFiZWw6IGl0ZW0sXG5cdFx0XHRcdFx0dmFsdWU6IGl0ZW1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkLmV4dGVuZCh7XG5cdFx0XHRcdGxhYmVsOiBpdGVtLmxhYmVsIHx8IGl0ZW0udmFsdWUsXG5cdFx0XHRcdHZhbHVlOiBpdGVtLnZhbHVlIHx8IGl0ZW0ubGFiZWxcblx0XHRcdH0sIGl0ZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRfc3VnZ2VzdDogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdHZhciB1bCA9IHRoaXMubWVudS5lbGVtZW50XG5cdFx0XHQuZW1wdHkoKVxuXHRcdFx0LnpJbmRleCggdGhpcy5lbGVtZW50LnpJbmRleCgpICsgMSApO1xuXHRcdHRoaXMuX3JlbmRlck1lbnUoIHVsLCBpdGVtcyApO1xuXHRcdHRoaXMubWVudS5yZWZyZXNoKCk7XG5cblx0XHQvLyBzaXplIGFuZCBwb3NpdGlvbiBtZW51XG5cdFx0dWwuc2hvdygpO1xuXHRcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcblx0XHR1bC5wb3NpdGlvbiggJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuZWxlbWVudFxuXHRcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyApIHtcblx0XHRcdHRoaXMubWVudS5uZXh0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNpemVNZW51OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudDtcblx0XHR1bC5vdXRlcldpZHRoKCBNYXRoLm1heChcblx0XHRcdC8vIEZpcmVmb3ggd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1Zylcblx0XHRcdC8vIHNvIHdlIGFkZCAxcHggdG8gYXZvaWQgdGhlIHdyYXBwaW5nICgjNzUxMylcblx0XHRcdHVsLndpZHRoKCBcIlwiICkub3V0ZXJXaWR0aCgpICsgMSxcblx0XHRcdHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKClcblx0XHQpICk7XG5cdH0sXG5cblx0X3JlbmRlck1lbnU6IGZ1bmN0aW9uKCB1bCwgaXRlbXMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggaXRlbXMsIGZ1bmN0aW9uKCBpbmRleCwgaXRlbSApIHtcblx0XHRcdHRoYXQuX3JlbmRlckl0ZW1EYXRhKCB1bCwgaXRlbSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtRGF0YTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKCB1bCwgaXRlbSApLmRhdGEoIFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiwgaXRlbSApO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtOiBmdW5jdGlvbiggdWwsIGl0ZW0gKSB7XG5cdFx0cmV0dXJuICQoIFwiPGxpPlwiIClcblx0XHRcdC5hcHBlbmQoICQoIFwiPGE+XCIgKS50ZXh0KCBpdGVtLmxhYmVsICkgKVxuXHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm1lbnUuaXNGaXJzdEl0ZW0oKSAmJiAvXnByZXZpb3VzLy50ZXN0KCBkaXJlY3Rpb24gKSB8fFxuXHRcdFx0XHR0aGlzLm1lbnUuaXNMYXN0SXRlbSgpICYmIC9ebmV4dC8udGVzdCggZGlyZWN0aW9uICkgKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSggdGhpcy50ZXJtICk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm1lbnVbIGRpcmVjdGlvbiBdKCBldmVudCApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVudS5lbGVtZW50O1xuXHR9LFxuXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVNZXRob2QuYXBwbHkoIHRoaXMuZWxlbWVudCwgYXJndW1lbnRzICk7XG5cdH0sXG5cblx0X2tleUV2ZW50OiBmdW5jdGlvbigga2V5RXZlbnQsIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgfHwgdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5fbW92ZSgga2V5RXZlbnQsIGV2ZW50ICk7XG5cblx0XHRcdC8vIHByZXZlbnRzIG1vdmluZyBjdXJzb3IgdG8gYmVnaW5uaW5nL2VuZCBvZiB0aGUgdGV4dCBmaWVsZCBpbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRlc2NhcGVSZWdleDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oYXJyYXksIHRlcm0pIHtcblx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoICQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KHRlcm0pLCBcImlcIiApO1xuXHRcdHJldHVybiAkLmdyZXAoIGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIG1hdGNoZXIudGVzdCggdmFsdWUubGFiZWwgfHwgdmFsdWUudmFsdWUgfHwgdmFsdWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuLy8gbGl2ZSByZWdpb24gZXh0ZW5zaW9uLCBhZGRpbmcgYSBgbWVzc2FnZXNgIG9wdGlvblxuLy8gTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJLiBXZSBhcmUgc3RpbGwgaW52ZXN0aWdhdGluZ1xuLy8gYSBmdWxsIHNvbHV0aW9uIGZvciBzdHJpbmcgbWFuaXB1bGF0aW9uIGFuZCBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiQud2lkZ2V0KCBcInVpLmF1dG9jb21wbGV0ZVwiLCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRvcHRpb25zOiB7XG5cdFx0bWVzc2FnZXM6IHtcblx0XHRcdG5vUmVzdWx0czogXCJObyBzZWFyY2ggcmVzdWx0cy5cIixcblx0XHRcdHJlc3VsdHM6IGZ1bmN0aW9uKCBhbW91bnQgKSB7XG5cdFx0XHRcdHJldHVybiBhbW91bnQgKyAoIGFtb3VudCA+IDEgPyBcIiByZXN1bHRzIGFyZVwiIDogXCIgcmVzdWx0IGlzXCIgKSArXG5cdFx0XHRcdFx0XCIgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cIjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0dmFyIG1lc3NhZ2U7XG5cdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMucmVzdWx0cyggY29udGVudC5sZW5ndGggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5ub1Jlc3VsdHM7XG5cdFx0fVxuXHRcdHRoaXMubGl2ZVJlZ2lvbi50ZXh0KCBtZXNzYWdlICk7XG5cdH1cbn0pO1xuXG5cbn0oIGpRdWVyeSApKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgbGFzdEFjdGl2ZSwgc3RhcnRYUG9zLCBzdGFydFlQb3MsIGNsaWNrRHJhZ2dlZCxcblx0YmFzZUNsYXNzZXMgPSBcInVpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIsXG5cdHN0YXRlQ2xhc3NlcyA9IFwidWktc3RhdGUtaG92ZXIgdWktc3RhdGUtYWN0aXZlIFwiLFxuXHR0eXBlQ2xhc3NlcyA9IFwidWktYnV0dG9uLWljb25zLW9ubHkgdWktYnV0dG9uLWljb24tb25seSB1aS1idXR0b24tdGV4dC1pY29ucyB1aS1idXR0b24tdGV4dC1pY29uLXByaW1hcnkgdWktYnV0dG9uLXRleHQtaWNvbi1zZWNvbmRhcnkgdWktYnV0dG9uLXRleHQtb25seVwiLFxuXHRmb3JtUmVzZXRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJ1dHRvbnMgPSAkKCB0aGlzICkuZmluZCggXCI6dWktYnV0dG9uXCIgKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0YnV0dG9ucy5idXR0b24oIFwicmVmcmVzaFwiICk7XG5cdFx0fSwgMSApO1xuXHR9LFxuXHRyYWRpb0dyb3VwID0gZnVuY3Rpb24oIHJhZGlvICkge1xuXHRcdHZhciBuYW1lID0gcmFkaW8ubmFtZSxcblx0XHRcdGZvcm0gPSByYWRpby5mb3JtLFxuXHRcdFx0cmFkaW9zID0gJCggW10gKTtcblx0XHRpZiAoIG5hbWUgKSB7XG5cdFx0XHRpZiAoIGZvcm0gKSB7XG5cdFx0XHRcdHJhZGlvcyA9ICQoIGZvcm0gKS5maW5kKCBcIltuYW1lPSdcIiArIG5hbWUgKyBcIiddXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGlvcyA9ICQoIFwiW25hbWU9J1wiICsgbmFtZSArIFwiJ11cIiwgcmFkaW8ub3duZXJEb2N1bWVudCApXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAhdGhpcy5mb3JtO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmFkaW9zO1xuXHR9O1xuXG4kLndpZGdldCggXCJ1aS5idXR0b25cIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxidXR0b24+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogbnVsbCxcblx0XHR0ZXh0OiB0cnVlLFxuXHRcdGxhYmVsOiBudWxsLFxuXHRcdGljb25zOiB7XG5cdFx0XHRwcmltYXJ5OiBudWxsLFxuXHRcdFx0c2Vjb25kYXJ5OiBudWxsXG5cdFx0fVxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCJmb3JtXCIgKVxuXHRcdFx0LnVuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZm9ybVJlc2V0SGFuZGxlciApO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9ICEhdGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRlcm1pbmVCdXR0b25UeXBlKCk7XG5cdFx0dGhpcy5oYXNUaXRsZSA9ICEhdGhpcy5idXR0b25FbGVtZW50LmF0dHIoIFwidGl0bGVcIiApO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRvZ2dsZUJ1dHRvbiA9IHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiLFxuXHRcdFx0YWN0aXZlQ2xhc3MgPSAhdG9nZ2xlQnV0dG9uID8gXCJ1aS1zdGF0ZS1hY3RpdmVcIiA6IFwiXCIsXG5cdFx0XHRmb2N1c0NsYXNzID0gXCJ1aS1zdGF0ZS1mb2N1c1wiO1xuXG5cdFx0aWYgKCBvcHRpb25zLmxhYmVsID09PSBudWxsICkge1xuXHRcdFx0b3B0aW9ucy5sYWJlbCA9ICh0aGlzLnR5cGUgPT09IFwiaW5wdXRcIiA/IHRoaXMuYnV0dG9uRWxlbWVudC52YWwoKSA6IHRoaXMuYnV0dG9uRWxlbWVudC5odG1sKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hvdmVyYWJsZSggdGhpcy5idXR0b25FbGVtZW50ICk7XG5cblx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggYmFzZUNsYXNzZXMgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcImJ1dHRvblwiIClcblx0XHRcdC5iaW5kKCBcIm1vdXNlZW50ZXJcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gbGFzdEFjdGl2ZSApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCBcIm1vdXNlbGVhdmVcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggYWN0aXZlQ2xhc3MgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKCBcImZvY3VzXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gbm8gbmVlZCB0byBjaGVjayBkaXNhYmxlZCwgZm9jdXMgd29uJ3QgYmUgdHJpZ2dlcmVkIGFueXdheVxuXHRcdFx0XHR0aGF0LmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoIGZvY3VzQ2xhc3MgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJibHVyXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKCBmb2N1c0NsYXNzICk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggdG9nZ2xlQnV0dG9uICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmJpbmQoIFwiY2hhbmdlXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjbGlja0RyYWdnZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBpZiBtb3VzZSBtb3ZlcyBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cCAoZHJhZykgc2V0IGNsaWNrRHJhZ2dlZCBmbGFnXG5cdFx0XHQvLyBwcmV2ZW50cyBpc3N1ZSB3aGVyZSBidXR0b24gc3RhdGUgY2hhbmdlcyBidXQgY2hlY2tib3gvcmFkaW8gY2hlY2tlZCBzdGF0ZVxuXHRcdFx0Ly8gZG9lcyBub3QgaW4gRmlyZWZveCAoc2VlIHRpY2tldCAjNjk3MClcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHQuYmluZCggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNsaWNrRHJhZ2dlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHN0YXJ0WFBvcyA9IGV2ZW50LnBhZ2VYO1xuXHRcdFx0XHRcdHN0YXJ0WVBvcyA9IGV2ZW50LnBhZ2VZO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJtb3VzZXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHN0YXJ0WFBvcyAhPT0gZXZlbnQucGFnZVggfHwgc3RhcnRZUG9zICE9PSBldmVudC5wYWdlWSApIHtcblx0XHRcdFx0XHRcdGNsaWNrRHJhZ2dlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiApIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKCBcImNsaWNrXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkIHx8IGNsaWNrRHJhZ2dlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0JCggdGhpcyApLnRvZ2dsZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdHRoYXQuYnV0dG9uRWxlbWVudC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCB0aGF0LmVsZW1lbnRbMF0uY2hlY2tlZCApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCB8fCBjbGlja0RyYWdnZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0aGF0LmJ1dHRvbkVsZW1lbnQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIgKTtcblxuXHRcdFx0XHR2YXIgcmFkaW8gPSB0aGF0LmVsZW1lbnRbIDAgXTtcblx0XHRcdFx0cmFkaW9Hcm91cCggcmFkaW8gKVxuXHRcdFx0XHRcdC5ub3QoIHJhZGlvIClcblx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVsgMCBdO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50XG5cdFx0XHRcdC5iaW5kKCBcIm1vdXNlZG93blwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHRsYXN0QWN0aXZlID0gdGhpcztcblx0XHRcdFx0XHR0aGF0LmRvY3VtZW50Lm9uZSggXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0bGFzdEFjdGl2ZSA9IG51bGw7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKCBcIm1vdXNldXBcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKCBcImtleWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5TUEFDRSB8fCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRU5URVIgKSB7XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKCBcImtleXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdGlmICggdGhpcy5idXR0b25FbGVtZW50LmlzKFwiYVwiKSApIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmtleXVwKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UgKSB7XG5cdFx0XHRcdFx0XHQvLyBUT0RPIHBhc3MgdGhyb3VnaCBvcmlnaW5hbCBldmVudCBjb3JyZWN0bHkgKGp1c3QgYXMgMm5kIGFyZ3VtZW50IGRvZXNuJ3Qgd29yaylcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5jbGljaygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogcHVsbCBvdXQgJC5XaWRnZXQncyBoYW5kbGluZyBmb3IgdGhlIGRpc2FibGVkIG9wdGlvbiBpbnRvXG5cdFx0Ly8gJC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb25EaXNhYmxlZCBzbyBpdCdzIGVhc3kgdG8gcHJveHkgYW5kIGNhblxuXHRcdC8vIGJlIG92ZXJyaWRkZW4gYnkgaW5kaXZpZHVhbCBwbHVnaW5zXG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIG9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR0aGlzLl9yZXNldEJ1dHRvbigpO1xuXHR9LFxuXG5cdF9kZXRlcm1pbmVCdXR0b25UeXBlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5jZXN0b3IsIGxhYmVsU2VsZWN0b3IsIGNoZWNrZWQ7XG5cblx0XHRpZiAoIHRoaXMuZWxlbWVudC5pcyhcIlt0eXBlPWNoZWNrYm94XVwiKSApIHtcblx0XHRcdHRoaXMudHlwZSA9IFwiY2hlY2tib3hcIjtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmVsZW1lbnQuaXMoXCJbdHlwZT1yYWRpb11cIikgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBcInJhZGlvXCI7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5lbGVtZW50LmlzKFwiaW5wdXRcIikgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBcImlucHV0XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudHlwZSA9IFwiYnV0dG9uXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdC8vIHdlIGRvbid0IHNlYXJjaCBhZ2FpbnN0IHRoZSBkb2N1bWVudCBpbiBjYXNlIHRoZSBlbGVtZW50XG5cdFx0XHQvLyBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgRE9NXG5cdFx0XHRhbmNlc3RvciA9IHRoaXMuZWxlbWVudC5wYXJlbnRzKCkubGFzdCgpO1xuXHRcdFx0bGFiZWxTZWxlY3RvciA9IFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZWxlbWVudC5hdHRyKFwiaWRcIikgKyBcIiddXCI7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKCBsYWJlbFNlbGVjdG9yICk7XG5cdFx0XHRpZiAoICF0aGlzLmJ1dHRvbkVsZW1lbnQubGVuZ3RoICkge1xuXHRcdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLmxlbmd0aCA/IGFuY2VzdG9yLnNpYmxpbmdzKCkgOiB0aGlzLmVsZW1lbnQuc2libGluZ3MoKTtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50ID0gYW5jZXN0b3IuZmlsdGVyKCBsYWJlbFNlbGVjdG9yICk7XG5cdFx0XHRcdGlmICggIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50ID0gYW5jZXN0b3IuZmluZCggbGFiZWxTZWxlY3RvciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKTtcblxuXHRcdFx0Y2hlY2tlZCA9IHRoaXMuZWxlbWVudC5pcyggXCI6Y2hlY2tlZFwiICk7XG5cdFx0XHRpZiAoIGNoZWNrZWQgKSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LnByb3AoIFwiYXJpYS1wcmVzc2VkXCIsIGNoZWNrZWQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdH1cblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJ1dHRvbkVsZW1lbnQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVwiICk7XG5cdFx0dGhpcy5idXR0b25FbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIGJhc2VDbGFzc2VzICsgXCIgXCIgKyBzdGF0ZUNsYXNzZXMgKyBcIiBcIiArIHR5cGVDbGFzc2VzIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXByZXNzZWRcIiApXG5cdFx0XHQuaHRtbCggdGhpcy5idXR0b25FbGVtZW50LmZpbmQoXCIudWktYnV0dG9uLXRleHRcIikuaHRtbCgpICk7XG5cblx0XHRpZiAoICF0aGlzLmhhc1RpdGxlICkge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUF0dHIoIFwidGl0bGVcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9yZXNldEJ1dHRvbigpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdC8vU2VlICM4MjM3ICYgIzg4Mjhcblx0XHR2YXIgaXNEaXNhYmxlZCA9IHRoaXMuZWxlbWVudC5pcyggXCJpbnB1dCwgYnV0dG9uXCIgKSA/IHRoaXMuZWxlbWVudC5pcyggXCI6ZGlzYWJsZWRcIiApIDogdGhpcy5lbGVtZW50Lmhhc0NsYXNzKCBcInVpLWJ1dHRvbi1kaXNhYmxlZFwiICk7XG5cblx0XHRpZiAoIGlzRGlzYWJsZWQgIT09IHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCBpc0Rpc2FibGVkICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRyYWRpb0dyb3VwKCB0aGlzLmVsZW1lbnRbMF0gKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5pcyggXCI6Y2hlY2tlZFwiICkgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmJ1dHRvbiggXCJ3aWRnZXRcIiApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmJ1dHRvbiggXCJ3aWRnZXRcIiApXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiApIHtcblx0XHRcdGlmICggdGhpcy5lbGVtZW50LmlzKCBcIjpjaGVja2VkXCIgKSApIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50XG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRCdXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy50eXBlID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5sYWJlbCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbCggdGhpcy5vcHRpb25zLmxhYmVsICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBidXR0b25FbGVtZW50ID0gdGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKCB0eXBlQ2xhc3NlcyApLFxuXHRcdFx0YnV0dG9uVGV4dCA9ICQoIFwiPHNwYW4+PC9zcGFuPlwiLCB0aGlzLmRvY3VtZW50WzBdIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWJ1dHRvbi10ZXh0XCIgKVxuXHRcdFx0XHQuaHRtbCggdGhpcy5vcHRpb25zLmxhYmVsIClcblx0XHRcdFx0LmFwcGVuZFRvKCBidXR0b25FbGVtZW50LmVtcHR5KCkgKVxuXHRcdFx0XHQudGV4dCgpLFxuXHRcdFx0aWNvbnMgPSB0aGlzLm9wdGlvbnMuaWNvbnMsXG5cdFx0XHRtdWx0aXBsZUljb25zID0gaWNvbnMucHJpbWFyeSAmJiBpY29ucy5zZWNvbmRhcnksXG5cdFx0XHRidXR0b25DbGFzc2VzID0gW107XG5cblx0XHRpZiAoIGljb25zLnByaW1hcnkgfHwgaWNvbnMuc2Vjb25kYXJ5ICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudGV4dCApIHtcblx0XHRcdFx0YnV0dG9uQ2xhc3Nlcy5wdXNoKCBcInVpLWJ1dHRvbi10ZXh0LWljb25cIiArICggbXVsdGlwbGVJY29ucyA/IFwic1wiIDogKCBpY29ucy5wcmltYXJ5ID8gXCItcHJpbWFyeVwiIDogXCItc2Vjb25kYXJ5XCIgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaWNvbnMucHJpbWFyeSApIHtcblx0XHRcdFx0YnV0dG9uRWxlbWVudC5wcmVwZW5kKCBcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24taWNvbi1wcmltYXJ5IHVpLWljb24gXCIgKyBpY29ucy5wcmltYXJ5ICsgXCInPjwvc3Bhbj5cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGljb25zLnNlY29uZGFyeSApIHtcblx0XHRcdFx0YnV0dG9uRWxlbWVudC5hcHBlbmQoIFwiPHNwYW4gY2xhc3M9J3VpLWJ1dHRvbi1pY29uLXNlY29uZGFyeSB1aS1pY29uIFwiICsgaWNvbnMuc2Vjb25kYXJ5ICsgXCInPjwvc3Bhbj5cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF0aGlzLm9wdGlvbnMudGV4dCApIHtcblx0XHRcdFx0YnV0dG9uQ2xhc3Nlcy5wdXNoKCBtdWx0aXBsZUljb25zID8gXCJ1aS1idXR0b24taWNvbnMtb25seVwiIDogXCJ1aS1idXR0b24taWNvbi1vbmx5XCIgKTtcblxuXHRcdFx0XHRpZiAoICF0aGlzLmhhc1RpdGxlICkge1xuXHRcdFx0XHRcdGJ1dHRvbkVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiLCAkLnRyaW0oIGJ1dHRvblRleHQgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJ1dHRvbkNsYXNzZXMucHVzaCggXCJ1aS1idXR0b24tdGV4dC1vbmx5XCIgKTtcblx0XHR9XG5cdFx0YnV0dG9uRWxlbWVudC5hZGRDbGFzcyggYnV0dG9uQ2xhc3Nlcy5qb2luKCBcIiBcIiApICk7XG5cdH1cbn0pO1xuXG4kLndpZGdldCggXCJ1aS5idXR0b25zZXRcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRpdGVtczogXCJidXR0b24sIGlucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPXJlc2V0XSwgaW5wdXRbdHlwZT1jaGVja2JveF0sIGlucHV0W3R5cGU9cmFkaW9dLCBhLCA6ZGF0YShidXR0b24pXCJcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktYnV0dG9uc2V0XCIgKTtcblx0fSxcblxuXHRfaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMuYnV0dG9ucy5idXR0b24oIFwib3B0aW9uXCIsIGtleSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBydGwgPSB0aGlzLmVsZW1lbnQuY3NzKCBcImRpcmVjdGlvblwiICkgPT09IFwicnRsXCI7XG5cblx0XHR0aGlzLmJ1dHRvbnMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zIClcblx0XHRcdC5maWx0ZXIoIFwiOnVpLWJ1dHRvblwiIClcblx0XHRcdFx0LmJ1dHRvbiggXCJyZWZyZXNoXCIgKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQubm90KCBcIjp1aS1idXR0b25cIiApXG5cdFx0XHRcdC5idXR0b24oKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmJ1dHRvbiggXCJ3aWRnZXRcIiApWyAwIF07XG5cdFx0XHR9KVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbCB1aS1jb3JuZXItbGVmdCB1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHRcdC5maWx0ZXIoIFwiOmZpcnN0XCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggcnRsID8gXCJ1aS1jb3JuZXItcmlnaHRcIiA6IFwidWktY29ybmVyLWxlZnRcIiApXG5cdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHQuZmlsdGVyKCBcIjpsYXN0XCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggcnRsID8gXCJ1aS1jb3JuZXItbGVmdFwiIDogXCJ1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHRcdC5lbmQoKVxuXHRcdFx0LmVuZCgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktYnV0dG9uc2V0XCIgKTtcblx0XHR0aGlzLmJ1dHRvbnNcblx0XHRcdC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItbGVmdCB1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHQuZW5kKClcblx0XHRcdC5idXR0b24oIFwiZGVzdHJveVwiICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZXh0ZW5kKCQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuOS4yXCIgfSB9KTtcblxudmFyIFBST1BfTkFNRSA9ICdkYXRlcGlja2VyJztcbnZhciBkcHV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbnZhciBpbnN0QWN0aXZlO1xuXG4vKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxuICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cbiAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXG5cbmZ1bmN0aW9uIERhdGVwaWNrZXIoKSB7XG5cdHRoaXMuZGVidWcgPSBmYWxzZTsgLy8gQ2hhbmdlIHRoaXMgdG8gdHJ1ZSB0byBzdGFydCBkZWJ1Z2dpbmdcblx0dGhpcy5fY3VySW5zdCA9IG51bGw7IC8vIFRoZSBjdXJyZW50IGluc3RhbmNlIGluIHVzZVxuXHR0aGlzLl9rZXlFdmVudCA9IGZhbHNlOyAvLyBJZiB0aGUgbGFzdCBldmVudCB3YXMgYSBrZXkgZXZlbnRcblx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSBbXTsgLy8gTGlzdCBvZiBkYXRlIHBpY2tlciBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWRcblx0dGhpcy5fZGF0ZXBpY2tlclNob3dpbmcgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgcG9wdXAgcGlja2VyIGlzIHNob3dpbmcgLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5faW5EaWFsb2cgPSBmYWxzZTsgLy8gVHJ1ZSBpZiBzaG93aW5nIHdpdGhpbiBhIFwiZGlhbG9nXCIsIGZhbHNlIGlmIG5vdFxuXHR0aGlzLl9tYWluRGl2SWQgPSAndWktZGF0ZXBpY2tlci1kaXYnOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxuXHR0aGlzLl9pbmxpbmVDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWlubGluZSc7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2FwcGVuZENsYXNzID0gJ3VpLWRhdGVwaWNrZXItYXBwZW5kJzsgLy8gVGhlIG5hbWUgb2YgdGhlIGFwcGVuZCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdHJpZ2dlckNsYXNzID0gJ3VpLWRhdGVwaWNrZXItdHJpZ2dlcic7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaWFsb2dDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWRpYWxvZyc7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2Rpc2FibGVDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWRpc2FibGVkJzsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpc2FibGVkIGNvdmVyaW5nIG1hcmtlciBjbGFzc1xuXHR0aGlzLl91bnNlbGVjdGFibGVDbGFzcyA9ICd1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZSc7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fY3VycmVudENsYXNzID0gJ3VpLWRhdGVwaWNrZXItY3VycmVudC1kYXknOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2RheU92ZXJDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyJzsgLy8gVGhlIG5hbWUgb2YgdGhlIGRheSBob3ZlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5yZWdpb25hbCA9IFtdOyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UgY29kZVxuXHR0aGlzLnJlZ2lvbmFsWycnXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLCAvLyBEaXNwbGF5IHRleHQgZm9yIGNsb3NlIGxpbmtcblx0XHRwcmV2VGV4dDogJ1ByZXYnLCAvLyBEaXNwbGF5IHRleHQgZm9yIHByZXZpb3VzIG1vbnRoIGxpbmtcblx0XHRuZXh0VGV4dDogJ05leHQnLCAvLyBEaXNwbGF5IHRleHQgZm9yIG5leHQgbW9udGggbGlua1xuXHRcdGN1cnJlbnRUZXh0OiAnVG9kYXknLCAvLyBEaXNwbGF5IHRleHQgZm9yIGN1cnJlbnQgbW9udGggbGlua1xuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLFxuXHRcdFx0J0p1bHknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPY3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ01vJywnVHUnLCdXZScsJ1RoJywnRnInLCdTYSddLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XG5cdFx0d2Vla0hlYWRlcjogJ1drJywgLy8gQ29sdW1uIGhlYWRlciBmb3Igd2VlayBvZiB0aGUgeWVhclxuXHRcdGRhdGVGb3JtYXQ6ICdtbS9kZC95eScsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcblx0XHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXG5cdFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxuXHRcdHllYXJTdWZmaXg6ICcnIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcblx0fTtcblx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZXNcblx0XHRzaG93T246ICdmb2N1cycsIC8vICdmb2N1cycgZm9yIHBvcHVwIG9uIGZvY3VzLFxuXHRcdFx0Ly8gJ2J1dHRvbicgZm9yIHRyaWdnZXIgYnV0dG9uLCBvciAnYm90aCcgZm9yIGVpdGhlclxuXHRcdHNob3dBbmltOiAnZmFkZUluJywgLy8gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cFxuXHRcdHNob3dPcHRpb25zOiB7fSwgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xuXHRcdGRlZmF1bHREYXRlOiBudWxsLCAvLyBVc2VkIHdoZW4gZmllbGQgaXMgYmxhbms6IGFjdHVhbCBkYXRlLFxuXHRcdFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcblx0XHRhcHBlbmRUZXh0OiAnJywgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxuXHRcdGJ1dHRvblRleHQ6ICcuLi4nLCAvLyBUZXh0IGZvciB0cmlnZ2VyIGJ1dHRvblxuXHRcdGJ1dHRvbkltYWdlOiAnJywgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxuXHRcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cblx0XHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3Ncblx0XHRcdC8vIGlmIG5vdCBhcHBsaWNhYmxlLCBmYWxzZSB0byBqdXN0IGRpc2FibGUgdGhlbVxuXHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQ6IGZhbHNlLCAvLyBUcnVlIGlmIGRhdGUgZm9ybWF0dGluZyBhcHBsaWVkIHRvIHByZXYvdG9kYXkvbmV4dCBsaW5rc1xuXHRcdGdvdG9DdXJyZW50OiBmYWxzZSwgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXG5cdFx0Y2hhbmdlTW9udGg6IGZhbHNlLCAvLyBUcnVlIGlmIG1vbnRoIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHRjaGFuZ2VZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB5ZWFyIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHR5ZWFyUmFuZ2U6ICdjLTEwOmMrMTAnLCAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcblx0XHRcdC8vIGVpdGhlciByZWxhdGl2ZSB0byB0b2RheSdzIHllYXIgKC1ubjorbm4pLCByZWxhdGl2ZSB0byBjdXJyZW50bHkgZGlzcGxheWVkIHllYXJcblx0XHRcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXG5cdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcblx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxuXHRcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcblx0XHRcdC8vIHRha2VzIGEgRGF0ZSBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIGZvciBpdFxuXHRcdHNob3J0WWVhckN1dG9mZjogJysxMCcsIC8vIFNob3J0IHllYXIgdmFsdWVzIDwgdGhpcyBhcmUgaW4gdGhlIGN1cnJlbnQgY2VudHVyeSxcblx0XHRcdC8vID4gdGhpcyBhcmUgaW4gdGhlIHByZXZpb3VzIGNlbnR1cnksXG5cdFx0XHQvLyBzdHJpbmcgdmFsdWUgc3RhcnRpbmcgd2l0aCAnKycgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXG5cdFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRkdXJhdGlvbjogJ2Zhc3QnLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcblx0XHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXG5cdFx0XHQvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yICcnLFxuXHRcdFx0Ly8gWzJdID0gY2VsbCB0aXRsZSAob3B0aW9uYWwpLCBlLmcuICQuZGF0ZXBpY2tlci5ub1dlZWtlbmRzXG5cdFx0YmVmb3JlU2hvdzogbnVsbCwgLy8gRnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpbnB1dCBmaWVsZCBhbmRcblx0XHRcdC8vIHJldHVybnMgYSBzZXQgb2YgY3VzdG9tIHNldHRpbmdzIGZvciB0aGUgZGF0ZSBwaWNrZXJcblx0XHRvblNlbGVjdDogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcblx0XHRvbkNoYW5nZU1vbnRoWWVhcjogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgbW9udGggb3IgeWVhciBpcyBjaGFuZ2VkXG5cdFx0b25DbG9zZTogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgZGF0ZXBpY2tlciBpcyBjbG9zZWRcblx0XHRudW1iZXJPZk1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzaG93IGF0IGEgdGltZVxuXHRcdHNob3dDdXJyZW50QXRQb3M6IDAsIC8vIFRoZSBwb3NpdGlvbiBpbiBtdWx0aXBlIG1vbnRocyBhdCB3aGljaCB0byBzaG93IHRoZSBjdXJyZW50IG1vbnRoIChzdGFydGluZyBhdCAwKVxuXHRcdHN0ZXBNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmRcblx0XHRzdGVwQmlnTW9udGhzOiAxMiwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZCBmb3IgdGhlIGJpZyBsaW5rc1xuXHRcdGFsdEZpZWxkOiAnJywgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXG5cdFx0YWx0Rm9ybWF0OiAnJywgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxuXHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcblx0XHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xuXHRcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxuXHR9O1xuXHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsnJ10pO1xuXHR0aGlzLmRwRGl2ID0gYmluZEhvdmVyKCQoJzxkaXYgaWQ9XCInICsgdGhpcy5fbWFpbkRpdklkICsgJ1wiIGNsYXNzPVwidWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGxcIj48L2Rpdj4nKSk7XG59XG5cbiQuZXh0ZW5kKERhdGVwaWNrZXIucHJvdG90eXBlLCB7XG5cdC8qIENsYXNzIG5hbWUgYWRkZWQgdG8gZWxlbWVudHMgdG8gaW5kaWNhdGUgYWxyZWFkeSBjb25maWd1cmVkIHdpdGggYSBkYXRlIHBpY2tlci4gKi9cblx0bWFya2VyQ2xhc3NOYW1lOiAnaGFzRGF0ZXBpY2tlcicsXG5cblx0Ly9LZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRtYXhSb3dzOiA0LFxuXG5cdC8qIERlYnVnIGxvZ2dpbmcgKGlmIGVuYWJsZWQpLiAqL1xuXHRsb2c6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5kZWJ1Zylcblx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KCcnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8vIFRPRE8gcmVuYW1lIHRvIFwid2lkZ2V0XCIgd2hlbiBzd2l0Y2hpbmcgdG8gd2lkZ2V0IGZhY3Rvcnlcblx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRwRGl2O1xuXHR9LFxuXG5cdC8qIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBkYXRlIHBpY2tlci5cblx0ICAgQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdCAgIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0ICovXG5cdHNldERlZmF1bHRzOiBmdW5jdGlvbihzZXR0aW5ncykge1xuXHRcdGV4dGVuZFJlbW92ZSh0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAgIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGZvciB0aGlzIGRhdGUgcGlja2VyIGluc3RhbmNlIChhbm9ueW1vdXMpICovXG5cdF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XG5cdFx0Ly8gY2hlY2sgZm9yIHNldHRpbmdzIG9uIHRoZSBjb250cm9sIGl0c2VsZiAtIGluIG5hbWVzcGFjZSAnZGF0ZTonXG5cdFx0dmFyIGlubGluZVNldHRpbmdzID0gbnVsbDtcblx0XHRmb3IgKHZhciBhdHRyTmFtZSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGU6JyArIGF0dHJOYW1lKTtcblx0XHRcdGlmIChhdHRyVmFsdWUpIHtcblx0XHRcdFx0aW5saW5lU2V0dGluZ3MgPSBpbmxpbmVTZXR0aW5ncyB8fCB7fTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpbmxpbmVTZXR0aW5nc1thdHRyTmFtZV0gPSBldmFsKGF0dHJWYWx1ZSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlubGluZVNldHRpbmdzW2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgaW5saW5lID0gKG5vZGVOYW1lID09ICdkaXYnIHx8IG5vZGVOYW1lID09ICdzcGFuJyk7XG5cdFx0aWYgKCF0YXJnZXQuaWQpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dGFyZ2V0LmlkID0gJ2RwJyArIHRoaXMudXVpZDtcblx0XHR9XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9uZXdJbnN0KCQodGFyZ2V0KSwgaW5saW5lKTtcblx0XHRpbnN0LnNldHRpbmdzID0gJC5leHRlbmQoe30sIHNldHRpbmdzIHx8IHt9LCBpbmxpbmVTZXR0aW5ncyB8fCB7fSk7XG5cdFx0aWYgKG5vZGVOYW1lID09ICdpbnB1dCcpIHtcblx0XHRcdHRoaXMuX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XG5cdFx0fSBlbHNlIGlmIChpbmxpbmUpIHtcblx0XHRcdHRoaXMuX2lubGluZURhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdC4gKi9cblx0X25ld0luc3Q6IGZ1bmN0aW9uKHRhcmdldCwgaW5saW5lKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WzBdLmlkLnJlcGxhY2UoLyhbXkEtWmEtejAtOV8tXSkvZywgJ1xcXFxcXFxcJDEnKTsgLy8gZXNjYXBlIGpRdWVyeSBtZXRhIGNoYXJzXG5cdFx0cmV0dXJuIHtpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XG5cdFx0XHRzZWxlY3RlZERheTogMCwgc2VsZWN0ZWRNb250aDogMCwgc2VsZWN0ZWRZZWFyOiAwLCAvLyBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ZHJhd01vbnRoOiAwLCBkcmF3WWVhcjogMCwgLy8gbW9udGggYmVpbmcgZHJhd25cblx0XHRcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3Rcblx0XHRcdGRwRGl2OiAoIWlubGluZSA/IHRoaXMuZHBEaXYgOiAvLyBwcmVzZW50YXRpb24gZGl2XG5cdFx0XHRiaW5kSG92ZXIoJCgnPGRpdiBjbGFzcz1cIicgKyB0aGlzLl9pbmxpbmVDbGFzcyArICcgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGxcIj48L2Rpdj4nKSkpfTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xuXHRfY29ubmVjdERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5zdCkge1xuXHRcdHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoW10pO1xuXHRcdGluc3QudHJpZ2dlciA9ICQoW10pO1xuXHRcdGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fYXR0YWNobWVudHMoaW5wdXQsIGluc3QpO1xuXHRcdGlucHV0LmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5rZXlkb3duKHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRrZXlwcmVzcyh0aGlzLl9kb0tleVByZXNzKS5rZXl1cCh0aGlzLl9kb0tleVVwKS5cblx0XHRcdGJpbmQoXCJzZXREYXRhLmRhdGVwaWNrZXJcIiwgZnVuY3Rpb24oZXZlbnQsIGtleSwgdmFsdWUpIHtcblx0XHRcdFx0aW5zdC5zZXR0aW5nc1trZXldID0gdmFsdWU7XG5cdFx0XHR9KS5iaW5kKFwiZ2V0RGF0YS5kYXRlcGlja2VyXCIsIGZ1bmN0aW9uKGV2ZW50LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2dldChpbnN0LCBrZXkpO1xuXHRcdFx0fSk7XG5cdFx0dGhpcy5fYXV0b1NpemUoaW5zdCk7XG5cdFx0JC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHQvL0lmIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLCBkaXNhYmxlIHRoZSBkYXRlcGlja2VyIG9uY2UgaXQgaGFzIGJlZW4gYXR0YWNoZWQgdG8gdGhlIGlucHV0IChzZWUgdGlja2V0ICM1NjY1KVxuXHRcdGlmKCBpbnN0LnNldHRpbmdzLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBNYWtlIGF0dGFjaG1lbnRzIGJhc2VkIG9uIHNldHRpbmdzLiAqL1xuXHRfYXR0YWNobWVudHM6IGZ1bmN0aW9uKGlucHV0LCBpbnN0KSB7XG5cdFx0dmFyIGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgJ2FwcGVuZFRleHQnKTtcblx0XHR2YXIgaXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgJ2lzUlRMJyk7XG5cdFx0aWYgKGluc3QuYXBwZW5kKVxuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0aWYgKGFwcGVuZFRleHQpIHtcblx0XHRcdGluc3QuYXBwZW5kID0gJCgnPHNwYW4gY2xhc3M9XCInICsgdGhpcy5fYXBwZW5kQ2xhc3MgKyAnXCI+JyArIGFwcGVuZFRleHQgKyAnPC9zcGFuPicpO1xuXHRcdFx0aW5wdXRbaXNSVEwgPyAnYmVmb3JlJyA6ICdhZnRlciddKGluc3QuYXBwZW5kKTtcblx0XHR9XG5cdFx0aW5wdXQudW5iaW5kKCdmb2N1cycsIHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblx0XHRpZiAoaW5zdC50cmlnZ2VyKVxuXHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdHZhciBzaG93T24gPSB0aGlzLl9nZXQoaW5zdCwgJ3Nob3dPbicpO1xuXHRcdGlmIChzaG93T24gPT0gJ2ZvY3VzJyB8fCBzaG93T24gPT0gJ2JvdGgnKSAvLyBwb3AtdXAgZGF0ZSBwaWNrZXIgd2hlbiBpbiB0aGUgbWFya2VkIGZpZWxkXG5cdFx0XHRpbnB1dC5mb2N1cyh0aGlzLl9zaG93RGF0ZXBpY2tlcik7XG5cdFx0aWYgKHNob3dPbiA9PSAnYnV0dG9uJyB8fCBzaG93T24gPT0gJ2JvdGgnKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHR2YXIgYnV0dG9uVGV4dCA9IHRoaXMuX2dldChpbnN0LCAnYnV0dG9uVGV4dCcpO1xuXHRcdFx0dmFyIGJ1dHRvbkltYWdlID0gdGhpcy5fZ2V0KGluc3QsICdidXR0b25JbWFnZScpO1xuXHRcdFx0aW5zdC50cmlnZ2VyID0gJCh0aGlzLl9nZXQoaW5zdCwgJ2J1dHRvbkltYWdlT25seScpID9cblx0XHRcdFx0JCgnPGltZy8+JykuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRhdHRyKHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9KSA6XG5cdFx0XHRcdCQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPicpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuXG5cdFx0XHRcdFx0aHRtbChidXR0b25JbWFnZSA9PSAnJyA/IGJ1dHRvblRleHQgOiAkKCc8aW1nLz4nKS5hdHRyKFxuXHRcdFx0XHRcdHsgc3JjOmJ1dHRvbkltYWdlLCBhbHQ6YnV0dG9uVGV4dCwgdGl0bGU6YnV0dG9uVGV4dCB9KSkpO1xuXHRcdFx0aW5wdXRbaXNSVEwgPyAnYmVmb3JlJyA6ICdhZnRlciddKGluc3QudHJpZ2dlcik7XG5cdFx0XHRpbnN0LnRyaWdnZXIuY2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09IGlucHV0WzBdKVxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0ZWxzZSBpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPSBpbnB1dFswXSkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiBBcHBseSB0aGUgbWF4aW11bSBsZW5ndGggZm9yIHRoZSBkYXRlIGZvcm1hdC4gKi9cblx0X2F1dG9TaXplOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0aWYgKHRoaXMuX2dldChpbnN0LCAnYXV0b1NpemUnKSAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoMjAwOSwgMTIgLSAxLCAyMCk7IC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXG5cdFx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0aWYgKGRhdGVGb3JtYXQubWF0Y2goL1tETV0vKSkge1xuXHRcdFx0XHR2YXIgZmluZE1heCA9IGZ1bmN0aW9uKG5hbWVzKSB7XG5cdFx0XHRcdFx0dmFyIG1heCA9IDA7XG5cdFx0XHRcdFx0dmFyIG1heEkgPSAwO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1heEk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGUuc2V0TW9udGgoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL01NLykgP1xuXHRcdFx0XHRcdCdtb250aE5hbWVzJyA6ICdtb250aE5hbWVzU2hvcnQnKSkpKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKGZpbmRNYXgodGhpcy5fZ2V0KGluc3QsIChkYXRlRm9ybWF0Lm1hdGNoKC9ERC8pID9cblx0XHRcdFx0XHQnZGF5TmFtZXMnIDogJ2RheU5hbWVzU2hvcnQnKSkpICsgMjAgLSBkYXRlLmdldERheSgpKTtcblx0XHRcdH1cblx0XHRcdGluc3QuaW5wdXQuYXR0cignc2l6ZScsIHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgZGF0ZSkubGVuZ3RoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXR0YWNoIGFuIGlubGluZSBkYXRlIHBpY2tlciB0byBhIGRpdi4gKi9cblx0X2lubGluZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5zdCkge1xuXHRcdHZhciBkaXZTcGFuID0gJCh0YXJnZXQpO1xuXHRcdGlmIChkaXZTcGFuLmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSlcblx0XHRcdHJldHVybjtcblx0XHRkaXZTcGFuLmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5hcHBlbmQoaW5zdC5kcERpdikuXG5cdFx0XHRiaW5kKFwic2V0RGF0YS5kYXRlcGlja2VyXCIsIGZ1bmN0aW9uKGV2ZW50LCBrZXksIHZhbHVlKXtcblx0XHRcdFx0aW5zdC5zZXR0aW5nc1trZXldID0gdmFsdWU7XG5cdFx0XHR9KS5iaW5kKFwiZ2V0RGF0YS5kYXRlcGlja2VyXCIsIGZ1bmN0aW9uKGV2ZW50LCBrZXkpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZ2V0KGluc3QsIGtleSk7XG5cdFx0XHR9KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHRoaXMuX3NldERhdGUoaW5zdCwgdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgYmVmb3JlIHNob3dpbmcgaXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHRcdC8vIFNldCBkaXNwbGF5OmJsb2NrIGluIHBsYWNlIG9mIGluc3QuZHBEaXYuc2hvdygpIHdoaWNoIHdvbid0IHdvcmsgb24gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC83NTUyIC0gQSBEYXRlcGlja2VyIGNyZWF0ZWQgb24gYSBkZXRhY2hlZCBkaXYgaGFzIHplcm8gaGVpZ2h0XG5cdFx0aW5zdC5kcERpdi5jc3MoIFwiZGlzcGxheVwiLCBcImJsb2NrXCIgKTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGluIGEgXCJkaWFsb2dcIiBib3guXG5cdCAgIEBwYXJhbSAgaW5wdXQgICAgIGVsZW1lbnQgLSBpZ25vcmVkXG5cdCAgIEBwYXJhbSAgZGF0ZSAgICAgIHN0cmluZyBvciBEYXRlIC0gdGhlIGluaXRpYWwgZGF0ZSB0byBkaXNwbGF5XG5cdCAgIEBwYXJhbSAgb25TZWxlY3QgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcblx0ICAgQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcblx0ICAgQHBhcmFtICBwb3MgICAgICAgaW50WzJdIC0gY29vcmRpbmF0ZXMgZm9yIHRoZSBkaWFsb2cncyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcmVlbiBvclxuXHQgICAgICAgICAgICAgICAgICAgICBldmVudCAtIHdpdGggeC95IGNvb3JkaW5hdGVzIG9yXG5cdCAgICAgICAgICAgICAgICAgICAgIGxlYXZlIGVtcHR5IGZvciBkZWZhdWx0IChzY3JlZW4gY2VudHJlKVxuXHQgICBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdCAqL1xuXHRfZGlhbG9nRGF0ZXBpY2tlcjogZnVuY3Rpb24oaW5wdXQsIGRhdGUsIG9uU2VsZWN0LCBzZXR0aW5ncywgcG9zKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHR2YXIgaWQgPSAnZHAnICsgdGhpcy51dWlkO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIicgKyBpZCArXG5cdFx0XHRcdCdcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwcHg7IHdpZHRoOiAwcHg7XCIvPicpO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQua2V5ZG93bih0aGlzLl9kb0tleURvd24pO1xuXHRcdFx0JCgnYm9keScpLmFwcGVuZCh0aGlzLl9kaWFsb2dJbnB1dCk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QodGhpcy5fZGlhbG9nSW5wdXQsIGZhbHNlKTtcblx0XHRcdGluc3Quc2V0dGluZ3MgPSB7fTtcblx0XHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRkYXRlID0gKGRhdGUgJiYgZGF0ZS5jb25zdHJ1Y3RvciA9PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKSA6IGRhdGUpO1xuXHRcdHRoaXMuX2RpYWxvZ0lucHV0LnZhbChkYXRlKTtcblxuXHRcdHRoaXMuX3BvcyA9IChwb3MgPyAocG9zLmxlbmd0aCA/IHBvcyA6IFtwb3MucGFnZVgsIHBvcy5wYWdlWV0pIDogbnVsbCk7XG5cdFx0aWYgKCF0aGlzLl9wb3MpIHtcblx0XHRcdHZhciBicm93c2VyV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHR2YXIgYnJvd3NlckhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cdFx0XHR2YXIgc2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHZhciBzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xuXHRcdFx0XHRbKGJyb3dzZXJXaWR0aCAvIDIpIC0gMTAwICsgc2Nyb2xsWCwgKGJyb3dzZXJIZWlnaHQgLyAyKSAtIDE1MCArIHNjcm9sbFldO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKCdsZWZ0JywgKHRoaXMuX3Bvc1swXSArIDIwKSArICdweCcpLmNzcygndG9wJywgdGhpcy5fcG9zWzFdICsgJ3B4Jyk7XG5cdFx0aW5zdC5zZXR0aW5ncy5vblNlbGVjdCA9IG9uU2VsZWN0O1xuXHRcdHRoaXMuX2luRGlhbG9nID0gdHJ1ZTtcblx0XHR0aGlzLmRwRGl2LmFkZENsYXNzKHRoaXMuX2RpYWxvZ0NsYXNzKTtcblx0XHR0aGlzLl9zaG93RGF0ZXBpY2tlcih0aGlzLl9kaWFsb2dJbnB1dFswXSk7XG5cdFx0aWYgKCQuYmxvY2tVSSlcblx0XHRcdCQuYmxvY2tVSSh0aGlzLmRwRGl2KTtcblx0XHQkLmRhdGEodGhpcy5fZGlhbG9nSW5wdXRbMF0sIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogRGV0YWNoIGEgZGF0ZXBpY2tlciBmcm9tIGl0cyBjb250cm9sLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuICovXG5cdF9kZXN0cm95RGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0JC5yZW1vdmVEYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblx0XHRpZiAobm9kZU5hbWUgPT0gJ2lucHV0Jykge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5cblx0XHRcdFx0dW5iaW5kKCdmb2N1cycsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS5cblx0XHRcdFx0dW5iaW5kKCdrZXlkb3duJywgdGhpcy5fZG9LZXlEb3duKS5cblx0XHRcdFx0dW5iaW5kKCdrZXlwcmVzcycsIHRoaXMuX2RvS2V5UHJlc3MpLlxuXHRcdFx0XHR1bmJpbmQoJ2tleXVwJywgdGhpcy5fZG9LZXlVcCk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PSAnZGl2JyB8fCBub2RlTmFtZSA9PSAnc3BhbicpXG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5lbXB0eSgpO1xuXHR9LFxuXG5cdC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuICovXG5cdF9lbmFibGVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR2YXIgJHRhcmdldCA9ICQodGFyZ2V0KTtcblx0XHR2YXIgaW5zdCA9ICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAobm9kZU5hbWUgPT0gJ2lucHV0Jykge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKCdidXR0b24nKS5cblx0XHRcdFx0ZWFjaChmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKCdpbWcnKS5jc3Moe29wYWNpdHk6ICcxLjAnLCBjdXJzb3I6ICcnfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG5vZGVOYW1lID09ICdkaXYnIHx8IG5vZGVOYW1lID09ICdzcGFuJykge1xuXHRcdFx0dmFyIGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oJy4nICsgdGhpcy5faW5saW5lQ2xhc3MpO1xuXHRcdFx0aW5saW5lLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoJ3VpLXN0YXRlLWRpc2FibGVkJyk7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PSB0YXJnZXQgPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gZGVsZXRlIGVudHJ5XG5cdH0sXG5cblx0LyogRGlzYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuICovXG5cdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09ICdpbnB1dCcpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKCdidXR0b24nKS5cblx0XHRcdFx0ZWFjaChmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IHRydWU7IH0pLmVuZCgpLlxuXHRcdFx0XHRmaWx0ZXIoJ2ltZycpLmNzcyh7b3BhY2l0eTogJzAuNScsIGN1cnNvcjogJ2RlZmF1bHQnfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG5vZGVOYW1lID09ICdkaXYnIHx8IG5vZGVOYW1lID09ICdzcGFuJykge1xuXHRcdFx0dmFyIGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oJy4nICsgdGhpcy5faW5saW5lQ2xhc3MpO1xuXHRcdFx0aW5saW5lLmNoaWxkcmVuKCkuYWRkQ2xhc3MoJ3VpLXN0YXRlLWRpc2FibGVkJyk7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0XHR0aGlzLl9kaXNhYmxlZElucHV0c1t0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGhdID0gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgICBAcmV0dXJuIGJvb2xlYW4gLSB0cnVlIGlmIGRpc2FibGVkLCBmYWxzZSBpZiBlbmFibGVkICovXG5cdF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkSW5wdXRzW2ldID09IHRhcmdldClcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgICBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAgIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhICovXG5cdF9nZXRJbnN0OiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHRocm93ICdNaXNzaW5nIGluc3RhbmNlIGRhdGEgZm9yIHRoaXMgZGF0ZXBpY2tlcic7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAgIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAgIEBwYXJhbSAgbmFtZSAgICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVwZGF0ZSBvclxuXHQgICAgICAgICAgICAgICAgICAgc3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxuXHQgICAgICAgICAgICAgICAgICAgd2hlbiByZXRyaWV2aW5nIGFsc28gJ2FsbCcgZm9yIGFsbCBpbnN0YW5jZSBzZXR0aW5ncyBvclxuXHQgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHRzJyBmb3IgYWxsIGdsb2JhbCBkZWZhdWx0c1xuXHQgICBAcGFyYW0gIHZhbHVlICAgYW55IC0gdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNldHRpbmdcblx0ICAgICAgICAgICAgICAgICAgIChvbWl0IGlmIGFib3ZlIGlzIGFuIG9iamVjdCBvciB0byByZXRyaWV2ZSBhIHZhbHVlKSAqL1xuXHRfb3B0aW9uRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiAobmFtZSA9PSAnZGVmYXVsdHMnID8gJC5leHRlbmQoe30sICQuZGF0ZXBpY2tlci5fZGVmYXVsdHMpIDpcblx0XHRcdFx0KGluc3QgPyAobmFtZSA9PSAnYWxsJyA/ICQuZXh0ZW5kKHt9LCBpbnN0LnNldHRpbmdzKSA6XG5cdFx0XHRcdHRoaXMuX2dldChpbnN0LCBuYW1lKSkgOiBudWxsKSk7XG5cdFx0fVxuXHRcdHZhciBzZXR0aW5ncyA9IG5hbWUgfHwge307XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG5cdFx0XHRzZXR0aW5ncyA9IHt9O1xuXHRcdFx0c2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdGlmICh0aGlzLl9jdXJJbnN0ID09IGluc3QpIHtcblx0XHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCB0cnVlKTtcblx0XHRcdHZhciBtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCAnbWluJyk7XG5cdFx0XHR2YXIgbWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21heCcpO1xuXHRcdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTtcblx0XHRcdC8vIHJlZm9ybWF0IHRoZSBvbGQgbWluRGF0ZS9tYXhEYXRlIHZhbHVlcyBpZiBkYXRlRm9ybWF0IGNoYW5nZXMgYW5kIGEgbmV3IG1pbkRhdGUvbWF4RGF0ZSBpc24ndCBwcm92aWRlZFxuXHRcdFx0aWYgKG1pbkRhdGUgIT09IG51bGwgJiYgc2V0dGluZ3NbJ2RhdGVGb3JtYXQnXSAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzWydtaW5EYXRlJ10gPT09IHVuZGVmaW5lZClcblx0XHRcdFx0aW5zdC5zZXR0aW5ncy5taW5EYXRlID0gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBtaW5EYXRlKTtcblx0XHRcdGlmIChtYXhEYXRlICE9PSBudWxsICYmIHNldHRpbmdzWydkYXRlRm9ybWF0J10gIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5nc1snbWF4RGF0ZSddID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWF4RGF0ZSk7XG5cdFx0XHR0aGlzLl9hdHRhY2htZW50cygkKHRhcmdldCksIGluc3QpO1xuXHRcdFx0dGhpcy5fYXV0b1NpemUoaW5zdCk7XG5cdFx0XHR0aGlzLl9zZXREYXRlKGluc3QsIGRhdGUpO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gY2hhbmdlIG1ldGhvZCBkZXByZWNhdGVkXG5cdF9jaGFuZ2VEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5fb3B0aW9uRGF0ZXBpY2tlcih0YXJnZXQsIG5hbWUsIHZhbHVlKTtcblx0fSxcblxuXHQvKiBSZWRyYXcgdGhlIGRhdGUgcGlja2VyIGF0dGFjaGVkIHRvIGFuIGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhbiAqL1xuXHRfcmVmcmVzaERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAgIEBwYXJhbSAgdGFyZ2V0ICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgICBAcGFyYW0gIGRhdGUgICAgIERhdGUgLSB0aGUgbmV3IGRhdGUgKi9cblx0X3NldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIGRhdGUpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEdldCB0aGUgZGF0ZShzKSBmb3IgdGhlIGZpcnN0IGVudHJ5IGluIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICAgQHBhcmFtICBub0RlZmF1bHQgIGJvb2xlYW4gLSB0cnVlIGlmIG5vIGRlZmF1bHQgZGF0ZSBpcyB0byBiZSB1c2VkXG5cdCAgIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGUgKi9cblx0X2dldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5vRGVmYXVsdCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0ICYmICFpbnN0LmlubGluZSlcblx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KTtcblx0XHRyZXR1cm4gKGluc3QgPyB0aGlzLl9nZXREYXRlKGluc3QpIDogbnVsbCk7XG5cdH0sXG5cblx0LyogSGFuZGxlIGtleXN0cm9rZXMuICovXG5cdF9kb0tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblx0XHR2YXIgaGFuZGxlZCA9IHRydWU7XG5cdFx0dmFyIGlzUlRMID0gaW5zdC5kcERpdi5pcygnLnVpLWRhdGVwaWNrZXItcnRsJyk7XG5cdFx0aW5zdC5fa2V5RXZlbnQgPSB0cnVlO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nKVxuXHRcdFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cdFx0XHRcdGNhc2UgOTogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gdGFiIG91dFxuXHRcdFx0XHRjYXNlIDEzOiB2YXIgc2VsID0gJCgndGQuJyArICQuZGF0ZXBpY2tlci5fZGF5T3ZlckNsYXNzICsgJzpub3QoLicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9jdXJyZW50Q2xhc3MgKyAnKScsIGluc3QuZHBEaXYpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbFswXSlcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXkoZXZlbnQudGFyZ2V0LCBpbnN0LnNlbGVjdGVkTW9udGgsIGluc3Quc2VsZWN0ZWRZZWFyLCBzZWxbMF0pO1xuXHRcdFx0XHRcdFx0XHR2YXIgb25TZWxlY3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnb25TZWxlY3QnKTtcblx0XHRcdFx0XHRcdFx0aWYgKG9uU2VsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGVTdHIgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUoaW5zdCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZG9uJ3Qgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdFx0XHRicmVhazsgLy8gc2VsZWN0IHRoZSB2YWx1ZSBvbiBlbnRlclxuXHRcdFx0XHRjYXNlIDI3OiAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcblx0XHRcdFx0Y2FzZSAzMzogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3N0ZXBCaWdNb250aHMnKSA6XG5cdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc3RlcE1vbnRocycpKSwgJ00nKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBwcmV2aW91cyBtb250aC95ZWFyIG9uIHBhZ2UgdXAvKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzQ6ICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwQmlnTW9udGhzJykgOlxuXHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3N0ZXBNb250aHMnKSksICdNJyk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJC5kYXRlcGlja2VyLl9jbGVhckRhdGUoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY2xlYXIgb24gY3RybCBvciBjb21tYW5kICtlbmRcblx0XHRcdFx0Y2FzZSAzNjogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY3VycmVudCBvbiBjdHJsIG9yIGNvbW1hbmQgK2hvbWVcblx0XHRcdFx0Y2FzZSAzNzogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gKzEgOiAtMSksICdEJyk7XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0Ly8gLTEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArbGVmdFxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3N0ZXBCaWdNb250aHMnKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3N0ZXBNb250aHMnKSksICdNJyk7XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtsZWZ0IG9uIE1hY1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzg6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIC03LCAnRCcpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyAtMSB3ZWVrIG9uIGN0cmwgb3IgY29tbWFuZCArdXBcblx0XHRcdFx0Y2FzZSAzOTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gLTEgOiArMSksICdEJyk7XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0Ly8gKzEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArcmlnaHRcblx0XHRcdFx0XHRcdGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSkgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwQmlnTW9udGhzJykgOlxuXHRcdFx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwTW9udGhzJykpLCAnTScpO1xuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArcmlnaHRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQwOiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCArNywgJ0QnKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cblx0XHRcdFx0ZGVmYXVsdDogaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzYgJiYgZXZlbnQuY3RybEtleSkgLy8gZGlzcGxheSB0aGUgZGF0ZSBwaWNrZXIgb24gY3RybCtob21lXG5cdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKHRoaXMpO1xuXHRcdGVsc2Uge1xuXHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXG5cdF9kb0tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdjb25zdHJhaW5JbnB1dCcpKSB7XG5cdFx0XHR2YXIgY2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSk7XG5cdFx0XHR2YXIgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PSB1bmRlZmluZWQgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCAoY2hyIDwgJyAnIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xuXHRfZG9LZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpICE9IGluc3QubGFzdFZhbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdkYXRlRm9ybWF0JyksXG5cdFx0XHRcdFx0KGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCksXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0XHRpZiAoZGF0ZSkgeyAvLyBvbmx5IGlmIHZhbGlkXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIubG9nKGVycik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qIFBvcC11cCB0aGUgZGF0ZSBwaWNrZXIgZm9yIGEgZ2l2ZW4gaW5wdXQgZmllbGQuXG5cdCAgIElmIGZhbHNlIHJldHVybmVkIGZyb20gYmVmb3JlU2hvdyBldmVudCBoYW5kbGVyIGRvIG5vdCBzaG93LlxuXHQgICBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlciBvclxuXHQgICAgICAgICAgICAgICAgICBldmVudCAtIGlmIHRyaWdnZXJlZCBieSBmb2N1cyAqL1xuXHRfc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0aW5wdXQgPSBpbnB1dC50YXJnZXQgfHwgaW5wdXQ7XG5cdFx0aWYgKGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2lucHV0JykgLy8gZmluZCBmcm9tIGJ1dHRvbi9pbWFnZSB0cmlnZ2VyXG5cdFx0XHRpbnB1dCA9ICQoJ2lucHV0JywgaW5wdXQucGFyZW50Tm9kZSlbMF07XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoaW5wdXQpIHx8ICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09IGlucHV0KSAvLyBhbHJlYWR5IGhlcmVcblx0XHRcdHJldHVybjtcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChpbnB1dCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT0gaW5zdCkge1xuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0LmRwRGl2LnN0b3AodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRpZiAoIGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlciggJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WzBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBiZWZvcmVTaG93ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2JlZm9yZVNob3cnKTtcblx0XHR2YXIgYmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XG5cdFx0aWYoYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSl7XG5cdFx0XHQvL2ZhbHNlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBiZWZvcmVTaG93U2V0dGluZ3MpO1xuXHRcdGluc3QubGFzdFZhbCA9IG51bGw7XG5cdFx0JC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPSBpbnB1dDtcblx0XHQkLmRhdGVwaWNrZXIuX3NldERhdGVGcm9tRmllbGQoaW5zdCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faW5EaWFsb2cpIC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRpbnB1dC52YWx1ZSA9ICcnO1xuXHRcdGlmICghJC5kYXRlcGlja2VyLl9wb3MpIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKGlucHV0KTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcblx0XHR9XG5cdFx0dmFyIGlzRml4ZWQgPSBmYWxzZTtcblx0XHQkKGlucHV0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT0gJ2ZpeGVkJztcblx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHR9KTtcblx0XHR2YXIgb2Zmc2V0ID0ge2xlZnQ6ICQuZGF0ZXBpY2tlci5fcG9zWzBdLCB0b3A6ICQuZGF0ZXBpY2tlci5fcG9zWzFdfTtcblx0XHQkLmRhdGVwaWNrZXIuX3BvcyA9IG51bGw7XG5cdFx0Ly90byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3hcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCk7XG5cdFx0Ly8gZGV0ZXJtaW5lIHNpemluZyBvZmZzY3JlZW5cblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246ICdhYnNvbHV0ZScsIGRpc3BsYXk6ICdibG9jaycsIHRvcDogJy0xMDAwcHgnfSk7XG5cdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdC8vIGZpeCB3aWR0aCBmb3IgZHluYW1pYyBudW1iZXIgb2YgZGF0ZSBwaWNrZXJzXG5cdFx0Ly8gYW5kIGFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xuXHRcdG9mZnNldCA9ICQuZGF0ZXBpY2tlci5fY2hlY2tPZmZzZXQoaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkKTtcblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246ICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/XG5cdFx0XHQnc3RhdGljJyA6IChpc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScpKSwgZGlzcGxheTogJ25vbmUnLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgKyAncHgnLCB0b3A6IG9mZnNldC50b3AgKyAncHgnfSk7XG5cdFx0aWYgKCFpbnN0LmlubGluZSkge1xuXHRcdFx0dmFyIHNob3dBbmltID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3Nob3dBbmltJyk7XG5cdFx0XHR2YXIgZHVyYXRpb24gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnZHVyYXRpb24nKTtcblx0XHRcdHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY292ZXIgPSBpbnN0LmRwRGl2LmZpbmQoJ2lmcmFtZS51aS1kYXRlcGlja2VyLWNvdmVyJyk7IC8vIElFNi0gb25seVxuXHRcdFx0XHRpZiggISEgY292ZXIubGVuZ3RoICl7XG5cdFx0XHRcdFx0dmFyIGJvcmRlcnMgPSAkLmRhdGVwaWNrZXIuX2dldEJvcmRlcnMoaW5zdC5kcERpdik7XG5cdFx0XHRcdFx0Y292ZXIuY3NzKHtsZWZ0OiAtYm9yZGVyc1swXSwgdG9wOiAtYm9yZGVyc1sxXSxcblx0XHRcdFx0XHRcdHdpZHRoOiBpbnN0LmRwRGl2Lm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCl9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGluc3QuZHBEaXYuekluZGV4KCQoaW5wdXQpLnpJbmRleCgpKzEpO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyA9IHRydWU7XG5cblx0XHRcdC8vIERFUFJFQ0FURUQ6IGFmdGVyIEJDIGZvciAxLjgueCAkLmVmZmVjdHNbIHNob3dBbmltIF0gaXMgbm90IG5lZWRlZFxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgKCAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdIHx8ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSApIClcblx0XHRcdFx0aW5zdC5kcERpdi5zaG93KHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc2hvd09wdGlvbnMnKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0aW5zdC5kcERpdltzaG93QW5pbSB8fCAnc2hvdyddKChzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCksIHBvc3RQcm9jZXNzKTtcblx0XHRcdGlmICghc2hvd0FuaW0gfHwgIWR1cmF0aW9uKVxuXHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0aWYgKGluc3QuaW5wdXQuaXMoJzp2aXNpYmxlJykgJiYgIWluc3QuaW5wdXQuaXMoJzpkaXNhYmxlZCcpKVxuXHRcdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QgPSBpbnN0O1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cblx0X3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR0aGlzLm1heFJvd3MgPSA0OyAvL1Jlc2V0IHRoZSBtYXggbnVtYmVyIG9mIHJvd3MgYmVpbmcgZGlzcGxheWVkIChzZWUgIzcwNDMpXG5cdFx0dmFyIGJvcmRlcnMgPSAkLmRhdGVwaWNrZXIuX2dldEJvcmRlcnMoaW5zdC5kcERpdik7XG5cdFx0aW5zdEFjdGl2ZSA9IGluc3Q7IC8vIGZvciBkZWxlZ2F0ZSBob3ZlciBldmVudHNcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuX2dlbmVyYXRlSFRNTChpbnN0KSk7XG5cdFx0dGhpcy5fYXR0YWNoSGFuZGxlcnMoaW5zdCk7XG5cdFx0dmFyIGNvdmVyID0gaW5zdC5kcERpdi5maW5kKCdpZnJhbWUudWktZGF0ZXBpY2tlci1jb3ZlcicpOyAvLyBJRTYtIG9ubHlcblx0XHRpZiggISFjb3Zlci5sZW5ndGggKXsgLy9hdm9pZCBjYWxsIHRvIG91dGVyWFhYWCgpIHdoZW4gbm90IGluIElFNlxuXHRcdFx0Y292ZXIuY3NzKHtsZWZ0OiAtYm9yZGVyc1swXSwgdG9wOiAtYm9yZGVyc1sxXSwgd2lkdGg6IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLCBoZWlnaHQ6IGluc3QuZHBEaXYub3V0ZXJIZWlnaHQoKX0pXG5cdFx0fVxuXHRcdGluc3QuZHBEaXYuZmluZCgnLicgKyB0aGlzLl9kYXlPdmVyQ2xhc3MgKyAnIGEnKS5tb3VzZW92ZXIoKTtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCk7XG5cdFx0dmFyIGNvbHMgPSBudW1Nb250aHNbMV07XG5cdFx0dmFyIHdpZHRoID0gMTc7XG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcygndWktZGF0ZXBpY2tlci1tdWx0aS0yIHVpLWRhdGVwaWNrZXItbXVsdGktMyB1aS1kYXRlcGlja2VyLW11bHRpLTQnKS53aWR0aCgnJyk7XG5cdFx0aWYgKGNvbHMgPiAxKVxuXHRcdFx0aW5zdC5kcERpdi5hZGRDbGFzcygndWktZGF0ZXBpY2tlci1tdWx0aS0nICsgY29scykuY3NzKCd3aWR0aCcsICh3aWR0aCAqIGNvbHMpICsgJ2VtJyk7XG5cdFx0aW5zdC5kcERpdlsobnVtTW9udGhzWzBdICE9IDEgfHwgbnVtTW9udGhzWzFdICE9IDEgPyAnYWRkJyA6ICdyZW1vdmUnKSArXG5cdFx0XHQnQ2xhc3MnXSgndWktZGF0ZXBpY2tlci1tdWx0aScpO1xuXHRcdGluc3QuZHBEaXZbKHRoaXMuX2dldChpbnN0LCAnaXNSVEwnKSA/ICdhZGQnIDogJ3JlbW92ZScpICtcblx0XHRcdCdDbGFzcyddKCd1aS1kYXRlcGlja2VyLXJ0bCcpO1xuXHRcdGlmIChpbnN0ID09ICQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmIGluc3QuaW5wdXQgJiZcblx0XHRcdFx0Ly8gIzY2OTQgLSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgaWYgaXQncyBhbHJlYWR5IGZvY3VzZWRcblx0XHRcdFx0Ly8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxuXHRcdFx0XHRpbnN0LmlucHV0LmlzKCc6dmlzaWJsZScpICYmICFpbnN0LmlucHV0LmlzKCc6ZGlzYWJsZWQnKSAmJiBpbnN0LmlucHV0WzBdICE9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG5cdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7XG5cdFx0Ly8gZGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiggaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdHZhciBvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWw7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vYXNzdXJlIHRoYXQgaW5zdC55ZWFyc2h0bWwgZGlkbid0IGNoYW5nZS5cblx0XHRcdFx0aWYoIG9yaWd5ZWFyc2h0bWwgPT09IGluc3QueWVhcnNodG1sICYmIGluc3QueWVhcnNodG1sICl7XG5cdFx0XHRcdFx0aW5zdC5kcERpdi5maW5kKCdzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0JykucmVwbGFjZVdpdGgoaW5zdC55ZWFyc2h0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIHNpemUgb2YgbGVmdCBhbmQgdG9wIGJvcmRlcnMgZm9yIGFuIGVsZW1lbnQuXG5cdCAgIEBwYXJhbSAgZWxlbSAgKGpRdWVyeSBvYmplY3QpIHRoZSBlbGVtZW50IG9mIGludGVyZXN0XG5cdCAgIEByZXR1cm4gIChudW1iZXJbMl0pIHRoZSBsZWZ0IGFuZCB0b3AgYm9yZGVycyAqL1xuXHRfZ2V0Qm9yZGVyczogZnVuY3Rpb24oZWxlbSkge1xuXHRcdHZhciBjb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB7dGhpbjogMSwgbWVkaXVtOiAyLCB0aGljazogM31bdmFsdWVdIHx8IHZhbHVlO1xuXHRcdH07XG5cdFx0cmV0dXJuIFtwYXJzZUZsb2F0KGNvbnZlcnQoZWxlbS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykpKSxcblx0XHRcdHBhcnNlRmxvYXQoY29udmVydChlbGVtLmNzcygnYm9yZGVyLXRvcC13aWR0aCcpKSldO1xuXHR9LFxuXG5cdC8qIENoZWNrIHBvc2l0aW9uaW5nIHRvIHJlbWFpbiBvbiBzY3JlZW4uICovXG5cdF9jaGVja09mZnNldDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkKSB7XG5cdFx0dmFyIGRwV2lkdGggPSBpbnN0LmRwRGl2Lm91dGVyV2lkdGgoKTtcblx0XHR2YXIgZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCk7XG5cdFx0dmFyIGlucHV0V2lkdGggPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlcldpZHRoKCkgOiAwO1xuXHRcdHZhciBpbnB1dEhlaWdodCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0Lm91dGVySGVpZ2h0KCkgOiAwO1xuXHRcdHZhciB2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpO1xuXHRcdHZhciB2aWV3SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKTtcblxuXHRcdG9mZnNldC5sZWZ0IC09ICh0aGlzLl9nZXQoaW5zdCwgJ2lzUlRMJykgPyAoZHBXaWR0aCAtIGlucHV0V2lkdGgpIDogMCk7XG5cdFx0b2Zmc2V0LmxlZnQgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT0gaW5zdC5pbnB1dC5vZmZzZXQoKS5sZWZ0KSA/ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA6IDA7XG5cdFx0b2Zmc2V0LnRvcCAtPSAoaXNGaXhlZCAmJiBvZmZzZXQudG9wID09IChpbnN0LmlucHV0Lm9mZnNldCgpLnRvcCArIGlucHV0SGVpZ2h0KSkgPyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA6IDA7XG5cblx0XHQvLyBub3cgY2hlY2sgaWYgZGF0ZXBpY2tlciBpcyBzaG93aW5nIG91dHNpZGUgd2luZG93IHZpZXdwb3J0IC0gbW92ZSB0byBhIGJldHRlciBwbGFjZSBpZiBzby5cblx0XHRvZmZzZXQubGVmdCAtPSBNYXRoLm1pbihvZmZzZXQubGVmdCwgKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCA+IHZpZXdXaWR0aCAmJiB2aWV3V2lkdGggPiBkcFdpZHRoKSA/XG5cdFx0XHRNYXRoLmFicyhvZmZzZXQubGVmdCArIGRwV2lkdGggLSB2aWV3V2lkdGgpIDogMCk7XG5cdFx0b2Zmc2V0LnRvcCAtPSBNYXRoLm1pbihvZmZzZXQudG9wLCAob2Zmc2V0LnRvcCArIGRwSGVpZ2h0ID4gdmlld0hlaWdodCAmJiB2aWV3SGVpZ2h0ID4gZHBIZWlnaHQpID9cblx0XHRcdE1hdGguYWJzKGRwSGVpZ2h0ICsgaW5wdXRIZWlnaHQpIDogMCk7XG5cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdC8qIEZpbmQgYW4gb2JqZWN0J3MgcG9zaXRpb24gb24gdGhlIHNjcmVlbi4gKi9cblx0X2ZpbmRQb3M6IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChvYmopO1xuXHRcdHZhciBpc1JUTCA9IHRoaXMuX2dldChpbnN0LCAnaXNSVEwnKTtcblx0XHR3aGlsZSAob2JqICYmIChvYmoudHlwZSA9PSAnaGlkZGVuJyB8fCBvYmoubm9kZVR5cGUgIT0gMSB8fCAkLmV4cHIuZmlsdGVycy5oaWRkZW4ob2JqKSkpIHtcblx0XHRcdG9iaiA9IG9ialtpc1JUTCA/ICdwcmV2aW91c1NpYmxpbmcnIDogJ25leHRTaWJsaW5nJ107XG5cdFx0fVxuXHRcdHZhciBwb3NpdGlvbiA9ICQob2JqKS5vZmZzZXQoKTtcblx0XHRyZXR1cm4gW3Bvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgICBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlciAqL1xuXHRfaGlkZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9jdXJJbnN0O1xuXHRcdGlmICghaW5zdCB8fCAoaW5wdXQgJiYgaW5zdCAhPSAkLmRhdGEoaW5wdXQsIFBST1BfTkFNRSkpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICh0aGlzLl9kYXRlcGlja2VyU2hvd2luZykge1xuXHRcdFx0dmFyIHNob3dBbmltID0gdGhpcy5fZ2V0KGluc3QsICdzaG93QW5pbScpO1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5fZ2V0KGluc3QsICdkdXJhdGlvbicpO1xuXHRcdFx0dmFyIHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fdGlkeURpYWxvZyhpbnN0KTtcblx0XHRcdH07XG5cblx0XHRcdC8vIERFUFJFQ0FURUQ6IGFmdGVyIEJDIGZvciAxLjgueCAkLmVmZmVjdHNbIHNob3dBbmltIF0gaXMgbm90IG5lZWRlZFxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgKCAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdIHx8ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSApIClcblx0XHRcdFx0aW5zdC5kcERpdi5oaWRlKHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc2hvd09wdGlvbnMnKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0aW5zdC5kcERpdlsoc2hvd0FuaW0gPT0gJ3NsaWRlRG93bicgPyAnc2xpZGVVcCcgOlxuXHRcdFx0XHRcdChzaG93QW5pbSA9PSAnZmFkZUluJyA/ICdmYWRlT3V0JyA6ICdoaWRlJykpXSgoc2hvd0FuaW0gPyBkdXJhdGlvbiA6IG51bGwpLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHRpZiAoIXNob3dBbmltKVxuXHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0dGhpcy5fZGF0ZXBpY2tlclNob3dpbmcgPSBmYWxzZTtcblx0XHRcdHZhciBvbkNsb3NlID0gdGhpcy5fZ2V0KGluc3QsICdvbkNsb3NlJyk7XG5cdFx0XHRpZiAob25DbG9zZSlcblx0XHRcdFx0b25DbG9zZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSxcblx0XHRcdFx0XHRbKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogJycpLCBpbnN0XSk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX2luRGlhbG9nKSB7XG5cdFx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAnMCcsIHRvcDogJy0xMDBweCcgfSk7XG5cdFx0XHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodGhpcy5kcERpdik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFRpZHkgdXAgYWZ0ZXIgYSBkaWFsb2cgZGlzcGxheS4gKi9cblx0X3RpZHlEaWFsb2c6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKHRoaXMuX2RpYWxvZ0NsYXNzKS51bmJpbmQoJy51aS1kYXRlcGlja2VyLWNhbGVuZGFyJyk7XG5cdH0sXG5cblx0LyogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuICovXG5cdF9jaGVja0V4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCEkLmRhdGVwaWNrZXIuX2N1ckluc3QpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoJHRhcmdldFswXSk7XG5cblx0XHRpZiAoICggKCAkdGFyZ2V0WzBdLmlkICE9ICQuZGF0ZXBpY2tlci5fbWFpbkRpdklkICYmXG5cdFx0XHRcdCR0YXJnZXQucGFyZW50cygnIycgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09IDAgJiZcblx0XHRcdFx0ISR0YXJnZXQuaGFzQ2xhc3MoJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSkgJiZcblx0XHRcdFx0ISR0YXJnZXQuY2xvc2VzdChcIi5cIiArICQuZGF0ZXBpY2tlci5fdHJpZ2dlckNsYXNzKS5sZW5ndGggJiZcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAhKCQuZGF0ZXBpY2tlci5faW5EaWFsb2cgJiYgJC5ibG9ja1VJKSApICkgfHxcblx0XHRcdCggJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT0gaW5zdCApIClcblx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0fSxcblxuXHQvKiBBZGp1c3Qgb25lIG9mIHRoZSBkYXRlIHN1Yi1maWVsZHMuICovXG5cdF9hZGp1c3REYXRlOiBmdW5jdGlvbihpZCwgb2Zmc2V0LCBwZXJpb2QpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cdFx0aWYgKHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKHRhcmdldFswXSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCwgb2Zmc2V0ICtcblx0XHRcdChwZXJpb2QgPT0gJ00nID8gdGhpcy5fZ2V0KGluc3QsICdzaG93Q3VycmVudEF0UG9zJykgOiAwKSwgLy8gdW5kbyBwb3NpdGlvbmluZ1xuXHRcdFx0cGVyaW9kKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3IgY3VycmVudCBsaW5rLiAqL1xuXHRfZ290b1RvZGF5OiBmdW5jdGlvbihpZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKTtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpZiAodGhpcy5fZ2V0KGluc3QsICdnb3RvQ3VycmVudCcpICYmIGluc3QuY3VycmVudERheSkge1xuXHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IGluc3QuY3VycmVudERheTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGg7XG5cdFx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdH1cblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSh0YXJnZXQpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgbmV3IG1vbnRoL3llYXIuICovXG5cdF9zZWxlY3RNb250aFllYXI6IGZ1bmN0aW9uKGlkLCBzZWxlY3QsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKTtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpbnN0WydzZWxlY3RlZCcgKyAocGVyaW9kID09ICdNJyA/ICdNb250aCcgOiAnWWVhcicpXSA9XG5cdFx0aW5zdFsnZHJhdycgKyAocGVyaW9kID09ICdNJyA/ICdNb250aCcgOiAnWWVhcicpXSA9XG5cdFx0XHRwYXJzZUludChzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRJbmRleF0udmFsdWUsMTApO1xuXHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXG5cdF9zZWxlY3REYXk6IGZ1bmN0aW9uKGlkLCBtb250aCwgeWVhciwgdGQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0aWYgKCQodGQpLmhhc0NsYXNzKHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKCdhJywgdGQpLmh0bWwoKTtcblx0XHRpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG1vbnRoO1xuXHRcdGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IHllYXI7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZShpZCwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhcikpO1xuXHR9LFxuXG5cdC8qIEVyYXNlIHRoZSBpbnB1dCBmaWVsZCBhbmQgaGlkZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9jbGVhckRhdGU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUodGFyZ2V0LCAnJyk7XG5cdH0sXG5cblx0LyogVXBkYXRlIHRoZSBpbnB1dCBmaWVsZCB3aXRoIHRoZSBzZWxlY3RlZCBkYXRlLiAqL1xuXHRfc2VsZWN0RGF0ZTogZnVuY3Rpb24oaWQsIGRhdGVTdHIpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cdFx0ZGF0ZVN0ciA9IChkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0aWYgKGluc3QuaW5wdXQpXG5cdFx0XHRpbnN0LmlucHV0LnZhbChkYXRlU3RyKTtcblx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0dmFyIG9uU2VsZWN0ID0gdGhpcy5fZ2V0KGluc3QsICdvblNlbGVjdCcpO1xuXHRcdGlmIChvblNlbGVjdClcblx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pOyAgLy8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHRlbHNlIGlmIChpbnN0LmlucHV0KVxuXHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0aWYgKGluc3QuaW5saW5lKVxuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WzBdO1xuXHRcdFx0aWYgKHR5cGVvZihpbnN0LmlucHV0WzBdKSAhPSAnb2JqZWN0Jylcblx0XHRcdFx0aW5zdC5pbnB1dC5mb2N1cygpOyAvLyByZXN0b3JlIGZvY3VzXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKiBVcGRhdGUgYW55IGFsdGVybmF0ZSBmaWVsZCB0byBzeW5jaHJvbmlzZSB3aXRoIHRoZSBtYWluIGZpZWxkLiAqL1xuXHRfdXBkYXRlQWx0ZXJuYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIGFsdEZpZWxkID0gdGhpcy5fZ2V0KGluc3QsICdhbHRGaWVsZCcpO1xuXHRcdGlmIChhbHRGaWVsZCkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0dmFyIGFsdEZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCAnYWx0Rm9ybWF0JykgfHwgdGhpcy5fZ2V0KGluc3QsICdkYXRlRm9ybWF0Jyk7XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCk7XG5cdFx0XHR2YXIgZGF0ZVN0ciA9IHRoaXMuZm9ybWF0RGF0ZShhbHRGb3JtYXQsIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHQkKGFsdEZpZWxkKS5lYWNoKGZ1bmN0aW9uKCkgeyAkKHRoaXMpLnZhbChkYXRlU3RyKTsgfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCBhcyBiZWZvcmVTaG93RGF5IGZ1bmN0aW9uIHRvIHByZXZlbnQgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxuXHQgICBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBjdXN0b21pc2Vcblx0ICAgQHJldHVybiBbYm9vbGVhbiwgc3RyaW5nXSAtIGlzIHRoaXMgZGF0ZSBzZWxlY3RhYmxlPywgd2hhdCBpcyBpdHMgQ1NTIGNsYXNzPyAqL1xuXHRub1dlZWtlbmRzOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG5cdFx0cmV0dXJuIFsoZGF5ID4gMCAmJiBkYXkgPCA2KSwgJyddO1xuXHR9LFxuXG5cdC8qIFNldCBhcyBjYWxjdWxhdGVXZWVrIHRvIGRldGVybWluZSB0aGUgd2VlayBvZiB0aGUgeWVhciBiYXNlZCBvbiB0aGUgSVNPIDg2MDEgZGVmaW5pdGlvbi5cblx0ICAgQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gZ2V0IHRoZSB3ZWVrIGZvclxuXHQgICBAcmV0dXJuICBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIHdpdGhpbiB0aGUgeWVhciB0aGF0IGNvbnRhaW5zIHRoaXMgZGF0ZSAqL1xuXHRpc284NjAxV2VlazogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cdFx0Ly8gRmluZCBUaHVyc2RheSBvZiB0aGlzIHdlZWsgc3RhcnRpbmcgb24gTW9uZGF5XG5cdFx0Y2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTtcblx0XHR2YXIgdGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSgxKTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcblx0fSxcblxuXHQvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXG5cdCAgIFNlZSBmb3JtYXREYXRlIGJlbG93IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cy5cblxuXHQgICBAcGFyYW0gIGZvcm1hdCAgICBzdHJpbmcgLSB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAgIEBwYXJhbSAgdmFsdWUgICAgIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcblx0ICAgQHBhcmFtICBzZXR0aW5ncyAgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxuXHQgICAgICAgICAgICAgICAgICAgICBzaG9ydFllYXJDdXRvZmYgIG51bWJlciAtIHRoZSBjdXRvZmYgeWVhciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGNlbnR1cnkgKG9wdGlvbmFsKVxuXHQgICAgICAgICAgICAgICAgICAgICBkYXlOYW1lc1Nob3J0ICAgIHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXMgICAgICAgICBzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAgICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydCAgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzICAgICAgIHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICAgQHJldHVybiAgRGF0ZSAtIHRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciBudWxsIGlmIHZhbHVlIGlzIGJsYW5rICovXG5cdHBhcnNlRGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG5cdFx0aWYgKGZvcm1hdCA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpXG5cdFx0XHR0aHJvdyAnSW52YWxpZCBhcmd1bWVudHMnO1xuXHRcdHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArICcnKTtcblx0XHRpZiAodmFsdWUgPT0gJycpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgc2hvcnRZZWFyQ3V0b2ZmID0gKHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuc2hvcnRZZWFyQ3V0b2ZmO1xuXHRcdHNob3J0WWVhckN1dG9mZiA9ICh0eXBlb2Ygc2hvcnRZZWFyQ3V0b2ZmICE9ICdzdHJpbmcnID8gc2hvcnRZZWFyQ3V0b2ZmIDpcblx0XHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpO1xuXHRcdHZhciBkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQ7XG5cdFx0dmFyIGRheU5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcztcblx0XHR2YXIgbW9udGhOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0O1xuXHRcdHZhciBtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXM7XG5cdFx0dmFyIHllYXIgPSAtMTtcblx0XHR2YXIgbW9udGggPSAtMTtcblx0XHR2YXIgZGF5ID0gLTE7XG5cdFx0dmFyIGRveSA9IC0xO1xuXHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XG5cdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdHZhciBsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09IG1hdGNoKTtcblx0XHRcdGlmIChtYXRjaGVzKVxuXHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9O1xuXHRcdC8vIEV4dHJhY3QgYSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0dmFyIGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHR2YXIgaXNEb3VibGVkID0gbG9va0FoZWFkKG1hdGNoKTtcblx0XHRcdHZhciBzaXplID0gKG1hdGNoID09ICdAJyA/IDE0IDogKG1hdGNoID09ICchJyA/IDIwIDpcblx0XHRcdFx0KG1hdGNoID09ICd5JyAmJiBpc0RvdWJsZWQgPyA0IDogKG1hdGNoID09ICdvJyA/IDMgOiAyKSkpKTtcblx0XHRcdHZhciBkaWdpdHMgPSBuZXcgUmVnRXhwKCdeXFxcXGR7MSwnICsgc2l6ZSArICd9Jyk7XG5cdFx0XHR2YXIgbnVtID0gdmFsdWUuc3Vic3RyaW5nKGlWYWx1ZSkubWF0Y2goZGlnaXRzKTtcblx0XHRcdGlmICghbnVtKVxuXHRcdFx0XHR0aHJvdyAnTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gJyArIGlWYWx1ZTtcblx0XHRcdGlWYWx1ZSArPSBudW1bMF0ubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xuXHRcdH07XG5cdFx0Ly8gRXh0cmFjdCBhIG5hbWUgZnJvbSB0aGUgc3RyaW5nIHZhbHVlIGFuZCBjb252ZXJ0IHRvIGFuIGluZGV4XG5cdFx0dmFyIGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHR2YXIgbmFtZXMgPSAkLm1hcChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcywgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0cmV0dXJuIFsgW2ssIHZdIF07XG5cdFx0XHR9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xuXHRcdFx0fSk7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdCQuZWFjaChuYW1lcywgZnVuY3Rpb24gKGksIHBhaXIpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyWzFdO1xuXHRcdFx0XHRpZiAodmFsdWUuc3Vic3RyKGlWYWx1ZSwgbmFtZS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBwYWlyWzBdO1xuXHRcdFx0XHRcdGlWYWx1ZSArPSBuYW1lLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKGluZGV4ICE9IC0xKVxuXHRcdFx0XHRyZXR1cm4gaW5kZXggKyAxO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyAnVW5rbm93biBuYW1lIGF0IHBvc2l0aW9uICcgKyBpVmFsdWU7XG5cdFx0fTtcblx0XHQvLyBDb25maXJtIHRoYXQgYSBsaXRlcmFsIGNoYXJhY3RlciBtYXRjaGVzIHRoZSBzdHJpbmcgdmFsdWVcblx0XHR2YXIgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgIT0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KSlcblx0XHRcdFx0dGhyb3cgJ1VuZXhwZWN0ZWQgbGl0ZXJhbCBhdCBwb3NpdGlvbiAnICsgaVZhbHVlO1xuXHRcdFx0aVZhbHVlKys7XG5cdFx0fTtcblx0XHR2YXIgaVZhbHVlID0gMDtcblx0XHRmb3IgKHZhciBpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xuXHRcdFx0aWYgKGxpdGVyYWwpXG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdGRheSA9IGdldE51bWJlcignZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnRCc6XG5cdFx0XHRcdFx0XHRnZXROYW1lKCdEJywgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbyc6XG5cdFx0XHRcdFx0XHRkb3kgPSBnZXROdW1iZXIoJ28nKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROdW1iZXIoJ20nKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROYW1lKCdNJywgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3knOlxuXHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlcigneScpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnQCc6XG5cdFx0XHRcdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKGdldE51bWJlcignQCcpKTtcblx0XHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKCchJykgLSB0aGlzLl90aWNrc1RvMTk3MCkgLyAxMDAwMCk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0aWYgKGxvb2tBaGVhZChcIidcIikpXG5cdFx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKXtcblx0XHRcdHZhciBleHRyYSA9IHZhbHVlLnN1YnN0cihpVmFsdWUpO1xuXHRcdFx0aWYgKCEvXlxccysvLnRlc3QoZXh0cmEpKSB7XG5cdFx0XHRcdHRocm93IFwiRXh0cmEvdW5wYXJzZWQgY2hhcmFjdGVycyBmb3VuZCBpbiBkYXRlOiBcIiArIGV4dHJhO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoeWVhciA9PSAtMSlcblx0XHRcdHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0ZWxzZSBpZiAoeWVhciA8IDEwMClcblx0XHRcdHllYXIgKz0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpIC0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICtcblx0XHRcdFx0KHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IC0xMDApO1xuXHRcdGlmIChkb3kgPiAtMSkge1xuXHRcdFx0bW9udGggPSAxO1xuXHRcdFx0ZGF5ID0gZG95O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR2YXIgZGltID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGggLSAxKTtcblx0XHRcdFx0aWYgKGRheSA8PSBkaW0pXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdG1vbnRoKys7XG5cdFx0XHRcdGRheSAtPSBkaW07XG5cdFx0XHR9IHdoaWxlICh0cnVlKTtcblx0XHR9XG5cdFx0dmFyIGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXHRcdGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgIT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9IG1vbnRoIHx8IGRhdGUuZ2V0RGF0ZSgpICE9IGRheSlcblx0XHRcdHRocm93ICdJbnZhbGlkIGRhdGUnOyAvLyBFLmcuIDMxLzAyLzAwXG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU3RhbmRhcmQgZGF0ZSBmb3JtYXRzLiAqL1xuXHRBVE9NOiAneXktbW0tZGQnLCAvLyBSRkMgMzMzOSAoSVNPIDg2MDEpXG5cdENPT0tJRTogJ0QsIGRkIE0geXknLFxuXHRJU09fODYwMTogJ3l5LW1tLWRkJyxcblx0UkZDXzgyMjogJ0QsIGQgTSB5Jyxcblx0UkZDXzg1MDogJ0RELCBkZC1NLXknLFxuXHRSRkNfMTAzNjogJ0QsIGQgTSB5Jyxcblx0UkZDXzExMjM6ICdELCBkIE0geXknLFxuXHRSRkNfMjgyMjogJ0QsIGQgTSB5eScsXG5cdFJTUzogJ0QsIGQgTSB5JywgLy8gUkZDIDgyMlxuXHRUSUNLUzogJyEnLFxuXHRUSU1FU1RBTVA6ICdAJyxcblx0VzNDOiAneXktbW0tZGQnLCAvLyBJU08gODYwMVxuXG5cdF90aWNrc1RvMTk3MDogKCgoMTk3MCAtIDEpICogMzY1ICsgTWF0aC5mbG9vcigxOTcwIC8gNCkgLSBNYXRoLmZsb29yKDE5NzAgLyAxMDApICtcblx0XHRNYXRoLmZsb29yKDE5NzAgLyA0MDApKSAqIDI0ICogNjAgKiA2MCAqIDEwMDAwMDAwKSxcblxuXHQvKiBGb3JtYXQgYSBkYXRlIG9iamVjdCBpbnRvIGEgc3RyaW5nIHZhbHVlLlxuXHQgICBUaGUgZm9ybWF0IGNhbiBiZSBjb21iaW5hdGlvbnMgb2YgdGhlIGZvbGxvd2luZzpcblx0ICAgZCAgLSBkYXkgb2YgbW9udGggKG5vIGxlYWRpbmcgemVybylcblx0ICAgZGQgLSBkYXkgb2YgbW9udGggKHR3byBkaWdpdClcblx0ICAgbyAgLSBkYXkgb2YgeWVhciAobm8gbGVhZGluZyB6ZXJvcylcblx0ICAgb28gLSBkYXkgb2YgeWVhciAodGhyZWUgZGlnaXQpXG5cdCAgIEQgIC0gZGF5IG5hbWUgc2hvcnRcblx0ICAgREQgLSBkYXkgbmFtZSBsb25nXG5cdCAgIG0gIC0gbW9udGggb2YgeWVhciAobm8gbGVhZGluZyB6ZXJvKVxuXHQgICBtbSAtIG1vbnRoIG9mIHllYXIgKHR3byBkaWdpdClcblx0ICAgTSAgLSBtb250aCBuYW1lIHNob3J0XG5cdCAgIE1NIC0gbW9udGggbmFtZSBsb25nXG5cdCAgIHkgIC0geWVhciAodHdvIGRpZ2l0KVxuXHQgICB5eSAtIHllYXIgKGZvdXIgZGlnaXQpXG5cdCAgIEAgLSBVbml4IHRpbWVzdGFtcCAobXMgc2luY2UgMDEvMDEvMTk3MClcblx0ICAgISAtIFdpbmRvd3MgdGlja3MgKDEwMG5zIHNpbmNlIDAxLzAxLzAwMDEpXG5cdCAgICcuLi4nIC0gbGl0ZXJhbCB0ZXh0XG5cdCAgICcnIC0gc2luZ2xlIHF1b3RlXG5cblx0ICAgQHBhcmFtICBmb3JtYXQgICAgc3RyaW5nIC0gdGhlIGRlc2lyZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAgIEBwYXJhbSAgZGF0ZSAgICAgIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICAgQHBhcmFtICBzZXR0aW5ncyAgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxuXHQgICAgICAgICAgICAgICAgICAgICBkYXlOYW1lc1Nob3J0ICAgIHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXMgICAgICAgICBzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAgICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydCAgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzICAgICAgIHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICAgQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdCAqL1xuXHRmb3JtYXREYXRlOiBmdW5jdGlvbiAoZm9ybWF0LCBkYXRlLCBzZXR0aW5ncykge1xuXHRcdGlmICghZGF0ZSlcblx0XHRcdHJldHVybiAnJztcblx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0O1xuXHRcdHZhciBkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXM7XG5cdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydDtcblx0XHR2YXIgbW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzO1xuXHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHR2YXIgbG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gKGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PSBtYXRjaCk7XG5cdFx0XHRpZiAobWF0Y2hlcylcblx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0fTtcblx0XHQvLyBGb3JtYXQgYSBudW1iZXIsIHdpdGggbGVhZGluZyB6ZXJvIGlmIG5lY2Vzc2FyeVxuXHRcdHZhciBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIGxlbikge1xuXHRcdFx0dmFyIG51bSA9ICcnICsgdmFsdWU7XG5cdFx0XHRpZiAobG9va0FoZWFkKG1hdGNoKSlcblx0XHRcdFx0d2hpbGUgKG51bS5sZW5ndGggPCBsZW4pXG5cdFx0XHRcdFx0bnVtID0gJzAnICsgbnVtO1xuXHRcdFx0cmV0dXJuIG51bTtcblx0XHR9O1xuXHRcdC8vIEZvcm1hdCBhIG5hbWUsIHNob3J0IG9yIGxvbmcgYXMgcmVxdWVzdGVkXG5cdFx0dmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xuXHRcdFx0cmV0dXJuIChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzW3ZhbHVlXSA6IHNob3J0TmFtZXNbdmFsdWVdKTtcblx0XHR9O1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xuXHRcdGlmIChkYXRlKVxuXHRcdFx0Zm9yICh2YXIgaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdFx0aWYgKGxpdGVyYWwpXG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpXG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCdkJywgZGF0ZS5nZXREYXRlKCksIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0QnOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZSgnRCcsIGRhdGUuZ2V0RGF5KCksIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdvJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcignbycsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCgobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCksIDMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCdtJywgZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKCdNJywgZGF0ZS5nZXRNb250aCgpLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3knOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKGxvb2tBaGVhZCgneScpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDpcblx0XHRcdFx0XHRcdFx0XHQoZGF0ZS5nZXRZZWFyKCkgJSAxMDAgPCAxMCA/ICcwJyA6ICcnKSArIGRhdGUuZ2V0WWVhcigpICUgMTAwKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdAJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCkgKiAxMDAwMCArIHRoaXMuX3RpY2tzVG8xOTcwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9LFxuXG5cdC8qIEV4dHJhY3QgYWxsIHBvc3NpYmxlIGNoYXJhY3RlcnMgZnJvbSB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9wb3NzaWJsZUNoYXJzOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdFx0dmFyIGNoYXJzID0gJyc7XG5cdFx0dmFyIGxpdGVyYWwgPSBmYWxzZTtcblx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0dmFyIGxvb2tBaGVhZCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT0gbWF0Y2gpO1xuXHRcdFx0aWYgKG1hdGNoZXMpXG5cdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH07XG5cdFx0Zm9yICh2YXIgaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspXG5cdFx0XHRpZiAobGl0ZXJhbClcblx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpXG5cdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZCc6IGNhc2UgJ20nOiBjYXNlICd5JzogY2FzZSAnQCc6XG5cdFx0XHRcdFx0XHRjaGFycyArPSAnMDEyMzQ1Njc4OSc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdEJzogY2FzZSAnTSc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gQWNjZXB0IGFueXRoaW5nXG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdFx0XHRjaGFycyArPSBcIidcIjtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0fVxuXHRcdHJldHVybiBjaGFycztcblx0fSxcblxuXHQvKiBHZXQgYSBzZXR0aW5nIHZhbHVlLCBkZWZhdWx0aW5nIGlmIG5lY2Vzc2FyeS4gKi9cblx0X2dldDogZnVuY3Rpb24oaW5zdCwgbmFtZSkge1xuXHRcdHJldHVybiBpbnN0LnNldHRpbmdzW25hbWVdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0aW5zdC5zZXR0aW5nc1tuYW1lXSA6IHRoaXMuX2RlZmF1bHRzW25hbWVdO1xuXHR9LFxuXG5cdC8qIFBhcnNlIGV4aXN0aW5nIGRhdGUgYW5kIGluaXRpYWxpc2UgZGF0ZSBwaWNrZXIuICovXG5cdF9zZXREYXRlRnJvbUZpZWxkOiBmdW5jdGlvbihpbnN0LCBub0RlZmF1bHQpIHtcblx0XHRpZiAoaW5zdC5pbnB1dC52YWwoKSA9PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKTtcblx0XHR2YXIgZGF0ZXMgPSBpbnN0Lmxhc3RWYWwgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IG51bGw7XG5cdFx0dmFyIGRhdGUsIGRlZmF1bHREYXRlO1xuXHRcdGRhdGUgPSBkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpO1xuXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KTtcblx0XHR0cnkge1xuXHRcdFx0ZGF0ZSA9IHRoaXMucGFyc2VEYXRlKGRhdGVGb3JtYXQsIGRhdGVzLCBzZXR0aW5ncykgfHwgZGVmYXVsdERhdGU7XG5cdFx0fSBjYXRjaCAoZXZlbnQpIHtcblx0XHRcdHRoaXMubG9nKGV2ZW50KTtcblx0XHRcdGRhdGVzID0gKG5vRGVmYXVsdCA/ICcnIDogZGF0ZXMpO1xuXHRcdH1cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGluc3QuY3VycmVudERheSA9IChkYXRlcyA/IGRhdGUuZ2V0RGF0ZSgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50TW9udGggPSAoZGF0ZXMgPyBkYXRlLmdldE1vbnRoKCkgOiAwKTtcblx0XHRpbnN0LmN1cnJlbnRZZWFyID0gKGRhdGVzID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogMCk7XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xuXHRfZ2V0RGVmYXVsdERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCxcblx0XHRcdHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsICdkZWZhdWx0RGF0ZScpLCBuZXcgRGF0ZSgpKSk7XG5cdH0sXG5cblx0LyogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuICovXG5cdF9kZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fTtcblx0XHR2YXIgb2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpLFxuXHRcdFx0XHRcdG9mZnNldCwgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gSWdub3JlXG5cdFx0XHR9XG5cdFx0XHR2YXIgZGF0ZSA9IChvZmZzZXQudG9Mb3dlckNhc2UoKS5tYXRjaCgvXmMvKSA/XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpIHx8IG5ldyBEYXRlKCk7XG5cdFx0XHR2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdHZhciBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdHZhciBkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdHZhciBwYXR0ZXJuID0gLyhbKy1dP1swLTldKylcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2c7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0d2hpbGUgKG1hdGNoZXMpIHtcblx0XHRcdFx0c3dpdGNoIChtYXRjaGVzWzJdIHx8ICdkJykge1xuXHRcdFx0XHRcdGNhc2UgJ2QnIDogY2FzZSAnRCcgOlxuXHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd3JyA6IGNhc2UgJ1cnIDpcblx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKSAqIDc7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ20nIDogY2FzZSAnTScgOlxuXHRcdFx0XHRcdFx0bW9udGggKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwxMCk7XG5cdFx0XHRcdFx0XHRkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3knOiBjYXNlICdZJyA6XG5cdFx0XHRcdFx0XHR5ZWFyICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApO1xuXHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSk7XG5cdFx0fTtcblx0XHR2YXIgbmV3RGF0ZSA9IChkYXRlID09IG51bGwgfHwgZGF0ZSA9PT0gJycgPyBkZWZhdWx0RGF0ZSA6ICh0eXBlb2YgZGF0ZSA9PSAnc3RyaW5nJyA/IG9mZnNldFN0cmluZyhkYXRlKSA6XG5cdFx0XHQodHlwZW9mIGRhdGUgPT0gJ251bWJlcicgPyAoaXNOYU4oZGF0ZSkgPyBkZWZhdWx0RGF0ZSA6IG9mZnNldE51bWVyaWMoZGF0ZSkpIDogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKSkpO1xuXHRcdG5ld0RhdGUgPSAobmV3RGF0ZSAmJiBuZXdEYXRlLnRvU3RyaW5nKCkgPT0gJ0ludmFsaWQgRGF0ZScgPyBkZWZhdWx0RGF0ZSA6IG5ld0RhdGUpO1xuXHRcdGlmIChuZXdEYXRlKSB7XG5cdFx0XHRuZXdEYXRlLnNldEhvdXJzKDApO1xuXHRcdFx0bmV3RGF0ZS5zZXRNaW51dGVzKDApO1xuXHRcdFx0bmV3RGF0ZS5zZXRTZWNvbmRzKDApO1xuXHRcdFx0bmV3RGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXdEYXRlKTtcblx0fSxcblxuXHQvKiBIYW5kbGUgc3dpdGNoIHRvL2Zyb20gZGF5bGlnaHQgc2F2aW5nLlxuXHQgICBIb3VycyBtYXkgYmUgbm9uLXplcm8gb24gZGF5bGlnaHQgc2F2aW5nIGN1dC1vdmVyOlxuXHQgICA+IDEyIHdoZW4gbWlkbmlnaHQgY2hhbmdlb3ZlciwgYnV0IHRoZW4gY2Fubm90IGdlbmVyYXRlXG5cdCAgIG1pZG5pZ2h0IGRhdGV0aW1lLCBzbyBqdW1wIHRvIDFBTSwgb3RoZXJ3aXNlIHJlc2V0LlxuXHQgICBAcGFyYW0gIGRhdGUgIChEYXRlKSB0aGUgZGF0ZSB0byBjaGVja1xuXHQgICBAcmV0dXJuICAoRGF0ZSkgdGhlIGNvcnJlY3RlZCBkYXRlICovXG5cdF9kYXlsaWdodFNhdmluZ0FkanVzdDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdGlmICghZGF0ZSkgcmV0dXJuIG51bGw7XG5cdFx0ZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSArIDIgOiAwKTtcblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9zZXREYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBub0NoYW5nZSkge1xuXHRcdHZhciBjbGVhciA9ICFkYXRlO1xuXHRcdHZhciBvcmlnTW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XG5cdFx0dmFyIG9yaWdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXI7XG5cdFx0dmFyIG5ld0RhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIGRhdGUsIG5ldyBEYXRlKCkpKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gbmV3RGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0gbmV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICgob3JpZ01vbnRoICE9IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPSBpbnN0LnNlbGVjdGVkWWVhcikgJiYgIW5vQ2hhbmdlKVxuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xuXHRcdGlmIChpbnN0LmlucHV0KSB7XG5cdFx0XHRpbnN0LmlucHV0LnZhbChjbGVhciA/ICcnIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfZ2V0RGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzdGFydERhdGUgPSAoIWluc3QuY3VycmVudFllYXIgfHwgKGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PSAnJykgPyBudWxsIDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKFxuXHRcdFx0aW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRcdHJldHVybiBzdGFydERhdGU7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBvbnh4eCBoYW5kbGVycy4gIFRoZXNlIGFyZSBkZWNsYXJlZCBzdGF0aWNhbGx5IHNvXG5cdCAqIHRoZXkgd29yayB3aXRoIHN0YXRpYyBjb2RlIHRyYW5zZm9ybWVycyBsaWtlIENhamEuXG5cdCAqL1xuXHRfYXR0YWNoSGFuZGxlcnM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RlcE1vbnRocyA9IHRoaXMuX2dldChpbnN0LCAnc3RlcE1vbnRocycpO1xuXHRcdHZhciBpZCA9ICcjJyArIGluc3QuaWQucmVwbGFjZSggL1xcXFxcXFxcL2csIFwiXFxcXFwiICk7XG5cdFx0aW5zdC5kcERpdi5maW5kKCdbZGF0YS1oYW5kbGVyXScpLm1hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHtcblx0XHRcdFx0cHJldjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHdpbmRvd1snRFBfalF1ZXJ5XycgKyBkcHV1aWRdLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsIC1zdGVwTW9udGhzLCAnTScpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0d2luZG93WydEUF9qUXVlcnlfJyArIGRwdXVpZF0uZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShpZCwgK3N0ZXBNb250aHMsICdNJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXS5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b2RheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHdpbmRvd1snRFBfalF1ZXJ5XycgKyBkcHV1aWRdLmRhdGVwaWNrZXIuX2dvdG9Ub2RheShpZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdERheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHdpbmRvd1snRFBfalF1ZXJ5XycgKyBkcHV1aWRdLmRhdGVwaWNrZXIuX3NlbGVjdERheShpZCwgK3RoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLW1vbnRoJyksICt0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS15ZWFyJyksIHRoaXMpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0TW9udGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXS5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsICdNJyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0d2luZG93WydEUF9qUXVlcnlfJyArIGRwdXVpZF0uZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCAnWScpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdCQodGhpcykuYmluZCh0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1ldmVudCcpLCBoYW5kbGVyW3RoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXInKV0pO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9nZW5lcmF0ZUhUTUw6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRuZXcgRGF0ZSh0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpLCB0b2RheS5nZXREYXRlKCkpKTsgLy8gY2xlYXIgdGltZVxuXHRcdHZhciBpc1JUTCA9IHRoaXMuX2dldChpbnN0LCAnaXNSVEwnKTtcblx0XHR2YXIgc2hvd0J1dHRvblBhbmVsID0gdGhpcy5fZ2V0KGluc3QsICdzaG93QnV0dG9uUGFuZWwnKTtcblx0XHR2YXIgaGlkZUlmTm9QcmV2TmV4dCA9IHRoaXMuX2dldChpbnN0LCAnaGlkZUlmTm9QcmV2TmV4dCcpO1xuXHRcdHZhciBuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsICduYXZpZ2F0aW9uQXNEYXRlRm9ybWF0Jyk7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpO1xuXHRcdHZhciBzaG93Q3VycmVudEF0UG9zID0gdGhpcy5fZ2V0KGluc3QsICdzaG93Q3VycmVudEF0UG9zJyk7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgJ3N0ZXBNb250aHMnKTtcblx0XHR2YXIgaXNNdWx0aU1vbnRoID0gKG51bU1vbnRoc1swXSAhPSAxIHx8IG51bU1vbnRoc1sxXSAhPSAxKTtcblx0XHR2YXIgY3VycmVudERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCgoIWluc3QuY3VycmVudERheSA/IG5ldyBEYXRlKDk5OTksIDksIDkpIDpcblx0XHRcdG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0dmFyIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsICdtaW4nKTtcblx0XHR2YXIgbWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21heCcpO1xuXHRcdHZhciBkcmF3TW9udGggPSBpbnN0LmRyYXdNb250aCAtIHNob3dDdXJyZW50QXRQb3M7XG5cdFx0dmFyIGRyYXdZZWFyID0gaW5zdC5kcmF3WWVhcjtcblx0XHRpZiAoZHJhd01vbnRoIDwgMCkge1xuXHRcdFx0ZHJhd01vbnRoICs9IDEyO1xuXHRcdFx0ZHJhd1llYXItLTtcblx0XHR9XG5cdFx0aWYgKG1heERhdGUpIHtcblx0XHRcdHZhciBtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobWF4RGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRtYXhEYXRlLmdldE1vbnRoKCkgLSAobnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSArIDEsIG1heERhdGUuZ2V0RGF0ZSgpKSk7XG5cdFx0XHRtYXhEcmF3ID0gKG1pbkRhdGUgJiYgbWF4RHJhdyA8IG1pbkRhdGUgPyBtaW5EYXRlIDogbWF4RHJhdyk7XG5cdFx0XHR3aGlsZSAodGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSkpID4gbWF4RHJhdykge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAxMTtcblx0XHRcdFx0XHRkcmF3WWVhci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xuXHRcdGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcblx0XHR2YXIgcHJldlRleHQgPSB0aGlzLl9nZXQoaW5zdCwgJ3ByZXZUZXh0Jyk7XG5cdFx0cHJldlRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblx0XHR2YXIgcHJldiA9ICh0aGlzLl9jYW5BZGp1c3RNb250aChpbnN0LCAtMSwgZHJhd1llYXIsIGRyYXdNb250aCkgP1xuXHRcdFx0JzxhIGNsYXNzPVwidWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGxcIiBkYXRhLWhhbmRsZXI9XCJwcmV2XCIgZGF0YS1ldmVudD1cImNsaWNrXCInICtcblx0XHRcdCcgdGl0bGU9XCInICsgcHJldlRleHQgKyAnXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLScgKyAoIGlzUlRMID8gJ2UnIDogJ3cnKSArICdcIj4nICsgcHJldlRleHQgKyAnPC9zcGFuPjwvYT4nIDpcblx0XHRcdChoaWRlSWZOb1ByZXZOZXh0ID8gJycgOiAnPGEgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZFwiIHRpdGxlPVwiJysgcHJldlRleHQgKydcIj48c3BhbiBjbGFzcz1cInVpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtJyArICggaXNSVEwgPyAnZScgOiAndycpICsgJ1wiPicgKyBwcmV2VGV4dCArICc8L3NwYW4+PC9hPicpKTtcblx0XHR2YXIgbmV4dFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgJ25leHRUZXh0Jyk7XG5cdFx0bmV4dFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBuZXh0VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShuZXh0VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggKyBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblx0XHR2YXIgbmV4dCA9ICh0aGlzLl9jYW5BZGp1c3RNb250aChpbnN0LCArMSwgZHJhd1llYXIsIGRyYXdNb250aCkgP1xuXHRcdFx0JzxhIGNsYXNzPVwidWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGxcIiBkYXRhLWhhbmRsZXI9XCJuZXh0XCIgZGF0YS1ldmVudD1cImNsaWNrXCInICtcblx0XHRcdCcgdGl0bGU9XCInICsgbmV4dFRleHQgKyAnXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLScgKyAoIGlzUlRMID8gJ3cnIDogJ2UnKSArICdcIj4nICsgbmV4dFRleHQgKyAnPC9zcGFuPjwvYT4nIDpcblx0XHRcdChoaWRlSWZOb1ByZXZOZXh0ID8gJycgOiAnPGEgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZFwiIHRpdGxlPVwiJysgbmV4dFRleHQgKyAnXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLScgKyAoIGlzUlRMID8gJ3cnIDogJ2UnKSArICdcIj4nICsgbmV4dFRleHQgKyAnPC9zcGFuPjwvYT4nKSk7XG5cdFx0dmFyIGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsICdjdXJyZW50VGV4dCcpO1xuXHRcdHZhciBnb3RvRGF0ZSA9ICh0aGlzLl9nZXQoaW5zdCwgJ2dvdG9DdXJyZW50JykgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheSk7XG5cdFx0Y3VycmVudFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBjdXJyZW50VGV4dCA6XG5cdFx0XHR0aGlzLmZvcm1hdERhdGUoY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblx0XHR2YXIgY29udHJvbHMgPSAoIWluc3QuaW5saW5lID8gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidWktZGF0ZXBpY2tlci1jbG9zZSB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXByaW1hcnkgdWktY29ybmVyLWFsbFwiIGRhdGEtaGFuZGxlcj1cImhpZGVcIiBkYXRhLWV2ZW50PVwiY2xpY2tcIj4nICtcblx0XHRcdHRoaXMuX2dldChpbnN0LCAnY2xvc2VUZXh0JykgKyAnPC9idXR0b24+JyA6ICcnKTtcblx0XHR2YXIgYnV0dG9uUGFuZWwgPSAoc2hvd0J1dHRvblBhbmVsKSA/ICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1idXR0b25wYW5lIHVpLXdpZGdldC1jb250ZW50XCI+JyArIChpc1JUTCA/IGNvbnRyb2xzIDogJycpICtcblx0XHRcdCh0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZ290b0RhdGUpID8gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidWktZGF0ZXBpY2tlci1jdXJyZW50IHVpLXN0YXRlLWRlZmF1bHQgdWktcHJpb3JpdHktc2Vjb25kYXJ5IHVpLWNvcm5lci1hbGxcIiBkYXRhLWhhbmRsZXI9XCJ0b2RheVwiIGRhdGEtZXZlbnQ9XCJjbGlja1wiJyArXG5cdFx0XHQnPicgKyBjdXJyZW50VGV4dCArICc8L2J1dHRvbj4nIDogJycpICsgKGlzUlRMID8gJycgOiBjb250cm9scykgKyAnPC9kaXY+JyA6ICcnO1xuXHRcdHZhciBmaXJzdERheSA9IHBhcnNlSW50KHRoaXMuX2dldChpbnN0LCAnZmlyc3REYXknKSwxMCk7XG5cdFx0Zmlyc3REYXkgPSAoaXNOYU4oZmlyc3REYXkpID8gMCA6IGZpcnN0RGF5KTtcblx0XHR2YXIgc2hvd1dlZWsgPSB0aGlzLl9nZXQoaW5zdCwgJ3Nob3dXZWVrJyk7XG5cdFx0dmFyIGRheU5hbWVzID0gdGhpcy5fZ2V0KGluc3QsICdkYXlOYW1lcycpO1xuXHRcdHZhciBkYXlOYW1lc1Nob3J0ID0gdGhpcy5fZ2V0KGluc3QsICdkYXlOYW1lc1Nob3J0Jyk7XG5cdFx0dmFyIGRheU5hbWVzTWluID0gdGhpcy5fZ2V0KGluc3QsICdkYXlOYW1lc01pbicpO1xuXHRcdHZhciBtb250aE5hbWVzID0gdGhpcy5fZ2V0KGluc3QsICdtb250aE5hbWVzJyk7XG5cdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuX2dldChpbnN0LCAnbW9udGhOYW1lc1Nob3J0Jyk7XG5cdFx0dmFyIGJlZm9yZVNob3dEYXkgPSB0aGlzLl9nZXQoaW5zdCwgJ2JlZm9yZVNob3dEYXknKTtcblx0XHR2YXIgc2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsICdzaG93T3RoZXJNb250aHMnKTtcblx0XHR2YXIgc2VsZWN0T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgJ3NlbGVjdE90aGVyTW9udGhzJyk7XG5cdFx0dmFyIGNhbGN1bGF0ZVdlZWsgPSB0aGlzLl9nZXQoaW5zdCwgJ2NhbGN1bGF0ZVdlZWsnKSB8fCB0aGlzLmlzbzg2MDFXZWVrO1xuXHRcdHZhciBkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpO1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgbnVtTW9udGhzWzBdOyByb3crKykge1xuXHRcdFx0dmFyIGdyb3VwID0gJyc7XG5cdFx0XHR0aGlzLm1heFJvd3MgPSA0O1xuXHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgbnVtTW9udGhzWzFdOyBjb2wrKykge1xuXHRcdFx0XHR2YXIgc2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgaW5zdC5zZWxlY3RlZERheSkpO1xuXHRcdFx0XHR2YXIgY29ybmVyQ2xhc3MgPSAnIHVpLWNvcm5lci1hbGwnO1xuXHRcdFx0XHR2YXIgY2FsZW5kZXIgPSAnJztcblx0XHRcdFx0aWYgKGlzTXVsdGlNb250aCkge1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9ICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1ncm91cCc7XG5cdFx0XHRcdFx0aWYgKG51bU1vbnRoc1sxXSA+IDEpXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDA6IGNhbGVuZGVyICs9ICcgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdCc7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSAnIHVpLWNvcm5lci0nICsgKGlzUlRMID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIG51bU1vbnRoc1sxXS0xOiBjYWxlbmRlciArPSAnIHVpLWRhdGVwaWNrZXItZ3JvdXAtbGFzdCc7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSAnIHVpLWNvcm5lci0nICsgKGlzUlRMID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjYWxlbmRlciArPSAnIHVpLWRhdGVwaWNrZXItZ3JvdXAtbWlkZGxlJzsgY29ybmVyQ2xhc3MgPSAnJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gJ1wiPic7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gJzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCcgKyBjb3JuZXJDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHQoL2FsbHxsZWZ0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT0gMCA/IChpc1JUTCA/IG5leHQgOiBwcmV2KSA6ICcnKSArXG5cdFx0XHRcdFx0KC9hbGx8cmlnaHQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PSAwID8gKGlzUlRMID8gcHJldiA6IG5leHQpIDogJycpICtcblx0XHRcdFx0XHR0aGlzLl9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0XHRcdHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdCc8L2Rpdj48dGFibGUgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLWNhbGVuZGFyXCI+PHRoZWFkPicgK1xuXHRcdFx0XHRcdCc8dHI+Jztcblx0XHRcdFx0dmFyIHRoZWFkID0gKHNob3dXZWVrID8gJzx0aCBjbGFzcz1cInVpLWRhdGVwaWNrZXItd2Vlay1jb2xcIj4nICsgdGhpcy5fZ2V0KGluc3QsICd3ZWVrSGVhZGVyJykgKyAnPC90aD4nIDogJycpO1xuXHRcdFx0XHRmb3IgKHZhciBkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0dmFyIGRheSA9IChkb3cgKyBmaXJzdERheSkgJSA3O1xuXHRcdFx0XHRcdHRoZWFkICs9ICc8dGgnICsgKChkb3cgKyBmaXJzdERheSArIDYpICUgNyA+PSA1ID8gJyBjbGFzcz1cInVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIicgOiAnJykgKyAnPicgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIHRpdGxlPVwiJyArIGRheU5hbWVzW2RheV0gKyAnXCI+JyArIGRheU5hbWVzTWluW2RheV0gKyAnPC9zcGFuPjwvdGg+Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSB0aGVhZCArICc8L3RyPjwvdGhlYWQ+PHRib2R5Pic7XG5cdFx0XHRcdHZhciBkYXlzSW5Nb250aCA9IHRoaXMuX2dldERheXNJbk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpO1xuXHRcdFx0XHRpZiAoZHJhd1llYXIgPT0gaW5zdC5zZWxlY3RlZFllYXIgJiYgZHJhd01vbnRoID09IGluc3Quc2VsZWN0ZWRNb250aClcblx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gTWF0aC5taW4oaW5zdC5zZWxlY3RlZERheSwgZGF5c0luTW9udGgpO1xuXHRcdFx0XHR2YXIgbGVhZERheXMgPSAodGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpIC0gZmlyc3REYXkgKyA3KSAlIDc7XG5cdFx0XHRcdHZhciBjdXJSb3dzID0gTWF0aC5jZWlsKChsZWFkRGF5cyArIGRheXNJbk1vbnRoKSAvIDcpOyAvLyBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIHRvIGdlbmVyYXRlXG5cdFx0XHRcdHZhciBudW1Sb3dzID0gKGlzTXVsdGlNb250aCA/IHRoaXMubWF4Um93cyA+IGN1clJvd3MgPyB0aGlzLm1heFJvd3MgOiBjdXJSb3dzIDogY3VyUm93cyk7IC8vSWYgbXVsdGlwbGUgbW9udGhzLCB1c2UgdGhlIGhpZ2hlciBudW1iZXIgb2Ygcm93cyAoc2VlICM3MDQzKVxuXHRcdFx0XHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xuXHRcdFx0XHR2YXIgcHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSAtIGxlYWREYXlzKSk7XG5cdFx0XHRcdGZvciAodmFyIGRSb3cgPSAwOyBkUm93IDwgbnVtUm93czsgZFJvdysrKSB7IC8vIGNyZWF0ZSBkYXRlIHBpY2tlciByb3dzXG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gJzx0cj4nO1xuXHRcdFx0XHRcdHZhciB0Ym9keSA9ICghc2hvd1dlZWsgPyAnJyA6ICc8dGQgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXdlZWstY29sXCI+JyArXG5cdFx0XHRcdFx0XHR0aGlzLl9nZXQoaW5zdCwgJ2NhbGN1bGF0ZVdlZWsnKShwcmludERhdGUpICsgJzwvdGQ+Jyk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgZG93ID0gMDsgZG93IDwgNzsgZG93KyspIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIGRheXNcblx0XHRcdFx0XHRcdHZhciBkYXlTZXR0aW5ncyA9IChiZWZvcmVTaG93RGF5ID9cblx0XHRcdFx0XHRcdFx0YmVmb3JlU2hvd0RheS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgW3ByaW50RGF0ZV0pIDogW3RydWUsICcnXSk7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXJNb250aCA9IChwcmludERhdGUuZ2V0TW9udGgoKSAhPSBkcmF3TW9udGgpO1xuXHRcdFx0XHRcdFx0dmFyIHVuc2VsZWN0YWJsZSA9IChvdGhlck1vbnRoICYmICFzZWxlY3RPdGhlck1vbnRocykgfHwgIWRheVNldHRpbmdzWzBdIHx8XG5cdFx0XHRcdFx0XHRcdChtaW5EYXRlICYmIHByaW50RGF0ZSA8IG1pbkRhdGUpIHx8IChtYXhEYXRlICYmIHByaW50RGF0ZSA+IG1heERhdGUpO1xuXHRcdFx0XHRcdFx0dGJvZHkgKz0gJzx0ZCBjbGFzcz1cIicgK1xuXHRcdFx0XHRcdFx0XHQoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyAnIHVpLWRhdGVwaWNrZXItd2Vlay1lbmQnIDogJycpICsgLy8gaGlnaGxpZ2h0IHdlZWtlbmRzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gJyB1aS1kYXRlcGlja2VyLW90aGVyLW1vbnRoJyA6ICcnKSArIC8vIGhpZ2hsaWdodCBkYXlzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCgocHJpbnREYXRlLmdldFRpbWUoKSA9PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PSBpbnN0LnNlbGVjdGVkTW9udGggJiYgaW5zdC5fa2V5RXZlbnQpIHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcblx0XHRcdFx0XHRcdFx0KGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PSBwcmludERhdGUuZ2V0VGltZSgpICYmIGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpKSA/XG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHQnICcgKyB0aGlzLl9kYXlPdmVyQ2xhc3MgOiAnJykgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyAnICcgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArICcgdWktc3RhdGUtZGlzYWJsZWQnOiAnJykgKyAgLy8gaGlnaGxpZ2h0IHVuc2VsZWN0YWJsZSBkYXlzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyAnJyA6ICcgJyArIGRheVNldHRpbmdzWzFdICsgLy8gaGlnaGxpZ2h0IGN1c3RvbSBkYXRlc1xuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyAnICcgKyB0aGlzLl9jdXJyZW50Q2xhc3MgOiAnJykgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09IHRvZGF5LmdldFRpbWUoKSA/ICcgdWktZGF0ZXBpY2tlci10b2RheScgOiAnJykpICsgJ1wiJyArIC8vIGhpZ2hsaWdodCB0b2RheSAoaWYgZGlmZmVyZW50KVxuXHRcdFx0XHRcdFx0XHQoKCFvdGhlck1vbnRoIHx8IHNob3dPdGhlck1vbnRocykgJiYgZGF5U2V0dGluZ3NbMl0gPyAnIHRpdGxlPVwiJyArIGRheVNldHRpbmdzWzJdICsgJ1wiJyA6ICcnKSArIC8vIGNlbGwgdGl0bGVcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/ICcnIDogJyBkYXRhLWhhbmRsZXI9XCJzZWxlY3REYXlcIiBkYXRhLWV2ZW50PVwiY2xpY2tcIiBkYXRhLW1vbnRoPVwiJyArIHByaW50RGF0ZS5nZXRNb250aCgpICsgJ1wiIGRhdGEteWVhcj1cIicgKyBwcmludERhdGUuZ2V0RnVsbFllYXIoKSArICdcIicpICsgJz4nICsgLy8gYWN0aW9uc1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gJyYjeGEwOycgOiAvLyBkaXNwbGF5IGZvciBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/ICc8c3BhbiBjbGFzcz1cInVpLXN0YXRlLWRlZmF1bHRcIj4nICsgcHJpbnREYXRlLmdldERhdGUoKSArICc8L3NwYW4+JyA6ICc8YSBjbGFzcz1cInVpLXN0YXRlLWRlZmF1bHQnICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT0gdG9kYXkuZ2V0VGltZSgpID8gJyB1aS1zdGF0ZS1oaWdobGlnaHQnIDogJycpICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gJyB1aS1zdGF0ZS1hY3RpdmUnIDogJycpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCA/ICcgdWktcHJpb3JpdHktc2Vjb25kYXJ5JyA6ICcnKSArIC8vIGRpc3Rpbmd1aXNoIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCdcIiBocmVmPVwiI1wiPicgKyBwcmludERhdGUuZ2V0RGF0ZSgpICsgJzwvYT4nKSkgKyAnPC90ZD4nOyAvLyBkaXNwbGF5IHNlbGVjdGFibGUgZGF0ZVxuXHRcdFx0XHRcdFx0cHJpbnREYXRlLnNldERhdGUocHJpbnREYXRlLmdldERhdGUoKSArIDEpO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QocHJpbnREYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gdGJvZHkgKyAnPC90cj4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRyYXdNb250aCsrO1xuXHRcdFx0XHRpZiAoZHJhd01vbnRoID4gMTEpIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAwO1xuXHRcdFx0XHRcdGRyYXdZZWFyKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gJzwvdGJvZHk+PC90YWJsZT4nICsgKGlzTXVsdGlNb250aCA/ICc8L2Rpdj4nICtcblx0XHRcdFx0XHRcdFx0KChudW1Nb250aHNbMF0gPiAwICYmIGNvbCA9PSBudW1Nb250aHNbMV0tMSkgPyAnPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItcm93LWJyZWFrXCI+PC9kaXY+JyA6ICcnKSA6ICcnKTtcblx0XHRcdFx0Z3JvdXAgKz0gY2FsZW5kZXI7XG5cdFx0XHR9XG5cdFx0XHRodG1sICs9IGdyb3VwO1xuXHRcdH1cblx0XHRodG1sICs9IGJ1dHRvblBhbmVsICsgKCQudWkuaWU2ICYmICFpbnN0LmlubGluZSA/XG5cdFx0XHQnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OmZhbHNlO1wiIGNsYXNzPVwidWktZGF0ZXBpY2tlci1jb3ZlclwiIGZyYW1lYm9yZGVyPVwiMFwiPjwvaWZyYW1lPicgOiAnJyk7XG5cdFx0aW5zdC5fa2V5RXZlbnQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgbW9udGggYW5kIHllYXIgaGVhZGVyLiAqL1xuXHRfZ2VuZXJhdGVNb250aFllYXJIZWFkZXI6IGZ1bmN0aW9uKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRzZWNvbmRhcnksIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkge1xuXHRcdHZhciBjaGFuZ2VNb250aCA9IHRoaXMuX2dldChpbnN0LCAnY2hhbmdlTW9udGgnKTtcblx0XHR2YXIgY2hhbmdlWWVhciA9IHRoaXMuX2dldChpbnN0LCAnY2hhbmdlWWVhcicpO1xuXHRcdHZhciBzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoaW5zdCwgJ3Nob3dNb250aEFmdGVyWWVhcicpO1xuXHRcdHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXRpdGxlXCI+Jztcblx0XHR2YXIgbW9udGhIdG1sID0gJyc7XG5cdFx0Ly8gbW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKHNlY29uZGFyeSB8fCAhY2hhbmdlTW9udGgpXG5cdFx0XHRtb250aEh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidWktZGF0ZXBpY2tlci1tb250aFwiPicgKyBtb250aE5hbWVzW2RyYXdNb250aF0gKyAnPC9zcGFuPic7XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgaW5NaW5ZZWFyID0gKG1pbkRhdGUgJiYgbWluRGF0ZS5nZXRGdWxsWWVhcigpID09IGRyYXdZZWFyKTtcblx0XHRcdHZhciBpbk1heFllYXIgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgPT0gZHJhd1llYXIpO1xuXHRcdFx0bW9udGhIdG1sICs9ICc8c2VsZWN0IGNsYXNzPVwidWktZGF0ZXBpY2tlci1tb250aFwiIGRhdGEtaGFuZGxlcj1cInNlbGVjdE1vbnRoXCIgZGF0YS1ldmVudD1cImNoYW5nZVwiPic7XG5cdFx0XHRmb3IgKHZhciBtb250aCA9IDA7IG1vbnRoIDwgMTI7IG1vbnRoKyspIHtcblx0XHRcdFx0aWYgKCghaW5NaW5ZZWFyIHx8IG1vbnRoID49IG1pbkRhdGUuZ2V0TW9udGgoKSkgJiZcblx0XHRcdFx0XHRcdCghaW5NYXhZZWFyIHx8IG1vbnRoIDw9IG1heERhdGUuZ2V0TW9udGgoKSkpXG5cdFx0XHRcdFx0bW9udGhIdG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIG1vbnRoICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQobW9udGggPT0gZHJhd01vbnRoID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICtcblx0XHRcdFx0XHRcdCc+JyArIG1vbnRoTmFtZXNTaG9ydFttb250aF0gKyAnPC9vcHRpb24+Jztcblx0XHRcdH1cblx0XHRcdG1vbnRoSHRtbCArPSAnPC9zZWxlY3Q+Jztcblx0XHR9XG5cdFx0aWYgKCFzaG93TW9udGhBZnRlclllYXIpXG5cdFx0XHRodG1sICs9IG1vbnRoSHRtbCArIChzZWNvbmRhcnkgfHwgIShjaGFuZ2VNb250aCAmJiBjaGFuZ2VZZWFyKSA/ICcmI3hhMDsnIDogJycpO1xuXHRcdC8vIHllYXIgc2VsZWN0aW9uXG5cdFx0aWYgKCAhaW5zdC55ZWFyc2h0bWwgKSB7XG5cdFx0XHRpbnN0LnllYXJzaHRtbCA9ICcnO1xuXHRcdFx0aWYgKHNlY29uZGFyeSB8fCAhY2hhbmdlWWVhcilcblx0XHRcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXllYXJcIj4nICsgZHJhd1llYXIgKyAnPC9zcGFuPic7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXlcblx0XHRcdFx0dmFyIHllYXJzID0gdGhpcy5fZ2V0KGluc3QsICd5ZWFyUmFuZ2UnKS5zcGxpdCgnOicpO1xuXHRcdFx0XHR2YXIgdGhpc1llYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdHZhciBkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgeWVhciA9ICh2YWx1ZS5tYXRjaCgvY1srLV0uKi8pID8gZHJhd1llYXIgKyBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMSksIDEwKSA6XG5cdFx0XHRcdFx0XHQodmFsdWUubWF0Y2goL1srLV0uKi8pID8gdGhpc1llYXIgKyBwYXJzZUludCh2YWx1ZSwgMTApIDpcblx0XHRcdFx0XHRcdHBhcnNlSW50KHZhbHVlLCAxMCkpKTtcblx0XHRcdFx0XHRyZXR1cm4gKGlzTmFOKHllYXIpID8gdGhpc1llYXIgOiB5ZWFyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIHllYXIgPSBkZXRlcm1pbmVZZWFyKHllYXJzWzBdKTtcblx0XHRcdFx0dmFyIGVuZFllYXIgPSBNYXRoLm1heCh5ZWFyLCBkZXRlcm1pbmVZZWFyKHllYXJzWzFdIHx8ICcnKSk7XG5cdFx0XHRcdHllYXIgPSAobWluRGF0ZSA/IE1hdGgubWF4KHllYXIsIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgOiB5ZWFyKTtcblx0XHRcdFx0ZW5kWWVhciA9IChtYXhEYXRlID8gTWF0aC5taW4oZW5kWWVhciwgbWF4RGF0ZS5nZXRGdWxsWWVhcigpKSA6IGVuZFllYXIpO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSAnPHNlbGVjdCBjbGFzcz1cInVpLWRhdGVwaWNrZXIteWVhclwiIGRhdGEtaGFuZGxlcj1cInNlbGVjdFllYXJcIiBkYXRhLWV2ZW50PVwiY2hhbmdlXCI+Jztcblx0XHRcdFx0Zm9yICg7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgeWVhciArICdcIicgK1xuXHRcdFx0XHRcdFx0KHllYXIgPT0gZHJhd1llYXIgPyAnIHNlbGVjdGVkPVwic2VsZWN0ZWRcIicgOiAnJykgK1xuXHRcdFx0XHRcdFx0Jz4nICsgeWVhciArICc8L29wdGlvbj4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9ICc8L3NlbGVjdD4nO1xuXG5cdFx0XHRcdGh0bWwgKz0gaW5zdC55ZWFyc2h0bWw7XG5cdFx0XHRcdGluc3QueWVhcnNodG1sID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aHRtbCArPSB0aGlzLl9nZXQoaW5zdCwgJ3llYXJTdWZmaXgnKTtcblx0XHRpZiAoc2hvd01vbnRoQWZ0ZXJZZWFyKVxuXHRcdFx0aHRtbCArPSAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyAnJiN4YTA7JyA6ICcnKSArIG1vbnRoSHRtbDtcblx0XHRodG1sICs9ICc8L2Rpdj4nOyAvLyBDbG9zZSBkYXRlcGlja2VyX2hlYWRlclxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdEluc3REYXRlOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5kcmF3WWVhciArIChwZXJpb2QgPT0gJ1knID8gb2Zmc2V0IDogMCk7XG5cdFx0dmFyIG1vbnRoID0gaW5zdC5kcmF3TW9udGggKyAocGVyaW9kID09ICdNJyA/IG9mZnNldCA6IDApO1xuXHRcdHZhciBkYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCB0aGlzLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcblx0XHRcdChwZXJpb2QgPT0gJ0QnID8gb2Zmc2V0IDogMCk7XG5cdFx0dmFyIGRhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LFxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmIChwZXJpb2QgPT0gJ00nIHx8IHBlcmlvZCA9PSAnWScpXG5cdFx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdH0sXG5cblx0LyogRW5zdXJlIGEgZGF0ZSBpcyB3aXRoaW4gYW55IG1pbi9tYXggYm91bmRzLiAqL1xuXHRfcmVzdHJpY3RNaW5NYXg6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21pbicpO1xuXHRcdHZhciBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCAnbWF4Jyk7XG5cdFx0dmFyIG5ld0RhdGUgPSAobWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBkYXRlKTtcblx0XHRuZXdEYXRlID0gKG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZSk7XG5cdFx0cmV0dXJuIG5ld0RhdGU7XG5cdH0sXG5cblx0LyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xuXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG9uQ2hhbmdlID0gdGhpcy5fZ2V0KGluc3QsICdvbkNoYW5nZU1vbnRoWWVhcicpO1xuXHRcdGlmIChvbkNoYW5nZSlcblx0XHRcdG9uQ2hhbmdlLmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLFxuXHRcdFx0XHRbaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3RdKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBtb250aHMgdG8gc2hvdy4gKi9cblx0X2dldE51bWJlck9mTW9udGhzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldChpbnN0LCAnbnVtYmVyT2ZNb250aHMnKTtcblx0XHRyZXR1cm4gKG51bU1vbnRocyA9PSBudWxsID8gWzEsIDFdIDogKHR5cGVvZiBudW1Nb250aHMgPT0gJ251bWJlcicgPyBbMSwgbnVtTW9udGhzXSA6IG51bU1vbnRocykpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGUgLSBlbnN1cmUgbm8gdGltZSBjb21wb25lbnRzIGFyZSBzZXQuICovXG5cdF9nZXRNaW5NYXhEYXRlOiBmdW5jdGlvbihpbnN0LCBtaW5NYXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCB0aGlzLl9nZXQoaW5zdCwgbWluTWF4ICsgJ0RhdGUnKSwgbnVsbCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBnaXZlbiBtb250aC4gKi9cblx0X2dldERheXNJbk1vbnRoOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCAzMikpLmdldERhdGUoKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGZpcnN0IG9mIGEgbW9udGguICovXG5cdF9nZXRGaXJzdERheU9mTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFwibmV4dC9wcmV2XCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXG5cdF9jYW5BZGp1c3RNb250aDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KTtcblx0XHR2YXIgZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGN1clllYXIsXG5cdFx0XHRjdXJNb250aCArIChvZmZzZXQgPCAwID8gb2Zmc2V0IDogbnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSwgMSkpO1xuXHRcdGlmIChvZmZzZXQgPCAwKVxuXHRcdFx0ZGF0ZS5zZXREYXRlKHRoaXMuX2dldERheXNJbk1vbnRoKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKSk7XG5cdFx0cmV0dXJuIHRoaXMuX2lzSW5SYW5nZShpbnN0LCBkYXRlKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21pbicpO1xuXHRcdHZhciBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCAnbWF4Jyk7XG5cdFx0cmV0dXJuICgoIW1pbkRhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPj0gbWluRGF0ZS5nZXRUaW1lKCkpICYmXG5cdFx0XHQoIW1heERhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPD0gbWF4RGF0ZS5nZXRUaW1lKCkpKTtcblx0fSxcblxuXHQvKiBQcm92aWRlIHRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBmb3JtYXR0aW5nL3BhcnNpbmcuICovXG5cdF9nZXRGb3JtYXRDb25maWc6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc2hvcnRZZWFyQ3V0b2ZmID0gdGhpcy5fZ2V0KGluc3QsICdzaG9ydFllYXJDdXRvZmYnKTtcblx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPSAnc3RyaW5nJyA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKSk7XG5cdFx0cmV0dXJuIHtzaG9ydFllYXJDdXRvZmY6IHNob3J0WWVhckN1dG9mZixcblx0XHRcdGRheU5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCAnZGF5TmFtZXNTaG9ydCcpLCBkYXlOYW1lczogdGhpcy5fZ2V0KGluc3QsICdkYXlOYW1lcycpLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgJ21vbnRoTmFtZXNTaG9ydCcpLCBtb250aE5hbWVzOiB0aGlzLl9nZXQoaW5zdCwgJ21vbnRoTmFtZXMnKX07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xuXHRcdGlmICghZGF5KSB7XG5cdFx0XHRpbnN0LmN1cnJlbnREYXkgPSBpbnN0LnNlbGVjdGVkRGF5O1xuXHRcdFx0aW5zdC5jdXJyZW50TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyID0gaW5zdC5zZWxlY3RlZFllYXI7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gKGRheSA/ICh0eXBlb2YgZGF5ID09ICdvYmplY3QnID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXREYXRlKHRoaXMuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpLCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHR9XG59KTtcblxuLypcbiAqIEJpbmQgaG92ZXIgZXZlbnRzIGZvciBkYXRlcGlja2VyIGVsZW1lbnRzLlxuICogRG9uZSB2aWEgZGVsZWdhdGUgc28gdGhlIGJpbmRpbmcgb25seSBvY2N1cnMgb25jZSBpbiB0aGUgbGlmZXRpbWUgb2YgdGhlIHBhcmVudCBkaXYuXG4gKiBHbG9iYWwgaW5zdEFjdGl2ZSwgc2V0IGJ5IF91cGRhdGVEYXRlcGlja2VyIGFsbG93cyB0aGUgaGFuZGxlcnMgdG8gZmluZCB0aGVpciB3YXkgYmFjayB0byB0aGUgYWN0aXZlIHBpY2tlci5cbiAqL1xuZnVuY3Rpb24gYmluZEhvdmVyKGRwRGl2KSB7XG5cdHZhciBzZWxlY3RvciA9ICdidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGEnO1xuXHRyZXR1cm4gZHBEaXYuZGVsZWdhdGUoc2VsZWN0b3IsICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcygndWktc3RhdGUtaG92ZXInKTtcblx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCd1aS1kYXRlcGlja2VyLXByZXYnKSAhPSAtMSkgJCh0aGlzKS5yZW1vdmVDbGFzcygndWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyJyk7XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZigndWktZGF0ZXBpY2tlci1uZXh0JykgIT0gLTEpICQodGhpcykucmVtb3ZlQ2xhc3MoJ3VpLWRhdGVwaWNrZXItbmV4dC1ob3ZlcicpO1xuXHRcdH0pXG5cdFx0LmRlbGVnYXRlKHNlbGVjdG9yLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oKXtcblx0XHRcdGlmICghJC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggaW5zdEFjdGl2ZS5pbmxpbmUgPyBkcERpdi5wYXJlbnQoKVswXSA6IGluc3RBY3RpdmUuaW5wdXRbMF0pKSB7XG5cdFx0XHRcdCQodGhpcykucGFyZW50cygnLnVpLWRhdGVwaWNrZXItY2FsZW5kYXInKS5maW5kKCdhJykucmVtb3ZlQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCd1aS1kYXRlcGlja2VyLXByZXYnKSAhPSAtMSkgJCh0aGlzKS5hZGRDbGFzcygndWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyJyk7XG5cdFx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCd1aS1kYXRlcGlja2VyLW5leHQnKSAhPSAtMSkgJCh0aGlzKS5hZGRDbGFzcygndWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG59XG5cbi8qIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhICovXG5mdW5jdGlvbiBleHRlbmRSZW1vdmUodGFyZ2V0LCBwcm9wcykge1xuXHQkLmV4dGVuZCh0YXJnZXQsIHByb3BzKTtcblx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcylcblx0XHRpZiAocHJvcHNbbmFtZV0gPT0gbnVsbCB8fCBwcm9wc1tuYW1lXSA9PSB1bmRlZmluZWQpXG5cdFx0XHR0YXJnZXRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbi8qIEludm9rZSB0aGUgZGF0ZXBpY2tlciBmdW5jdGlvbmFsaXR5LlxuICAgQHBhcmFtICBvcHRpb25zICBzdHJpbmcgLSBhIGNvbW1hbmQsIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG9yXG5cdCAgICAgICAgICAgICAgICBPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoISQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCkge1xuXHRcdCQoZG9jdW1lbnQpLm1vdXNlZG93bigkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljaykuXG5cdFx0XHRmaW5kKGRvY3VtZW50LmJvZHkpLmFwcGVuZCgkLmRhdGVwaWNrZXIuZHBEaXYpO1xuXHRcdCQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IHRydWU7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnICYmIChvcHRpb25zID09ICdpc0Rpc2FibGVkJyB8fCBvcHRpb25zID09ICdnZXREYXRlJyB8fCBvcHRpb25zID09ICd3aWRnZXQnKSlcblx0XHRyZXR1cm4gJC5kYXRlcGlja2VyWydfJyArIG9wdGlvbnMgKyAnRGF0ZXBpY2tlciddLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHRpZiAob3B0aW9ucyA9PSAnb3B0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PSAnc3RyaW5nJylcblx0XHRyZXR1cm4gJC5kYXRlcGlja2VyWydfJyArIG9wdGlvbnMgKyAnRGF0ZXBpY2tlciddLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnID9cblx0XHRcdCQuZGF0ZXBpY2tlclsnXycgKyBvcHRpb25zICsgJ0RhdGVwaWNrZXInXS5cblx0XHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc10uY29uY2F0KG90aGVyQXJncykpIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlcih0aGlzLCBvcHRpb25zKTtcblx0fSk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjkuMlwiO1xuXG4vLyBXb3JrYXJvdW5kIGZvciAjNDA1NVxuLy8gQWRkIGFub3RoZXIgZ2xvYmFsIHRvIGF2b2lkIG5vQ29uZmxpY3QgaXNzdWVzIHdpdGggaW5saW5lIGV2ZW50IGhhbmRsZXJzXG53aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXSA9ICQ7XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHVpRGlhbG9nQ2xhc3NlcyA9IFwidWktZGlhbG9nIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIFwiLFxuXHRzaXplUmVsYXRlZE9wdGlvbnMgPSB7XG5cdFx0YnV0dG9uczogdHJ1ZSxcblx0XHRoZWlnaHQ6IHRydWUsXG5cdFx0bWF4SGVpZ2h0OiB0cnVlLFxuXHRcdG1heFdpZHRoOiB0cnVlLFxuXHRcdG1pbkhlaWdodDogdHJ1ZSxcblx0XHRtaW5XaWR0aDogdHJ1ZSxcblx0XHR3aWR0aDogdHJ1ZVxuXHR9LFxuXHRyZXNpemFibGVSZWxhdGVkT3B0aW9ucyA9IHtcblx0XHRtYXhIZWlnaHQ6IHRydWUsXG5cdFx0bWF4V2lkdGg6IHRydWUsXG5cdFx0bWluSGVpZ2h0OiB0cnVlLFxuXHRcdG1pbldpZHRoOiB0cnVlXG5cdH07XG5cbiQud2lkZ2V0KFwidWkuZGlhbG9nXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YXV0b09wZW46IHRydWUsXG5cdFx0YnV0dG9uczoge30sXG5cdFx0Y2xvc2VPbkVzY2FwZTogdHJ1ZSxcblx0XHRjbG9zZVRleHQ6IFwiY2xvc2VcIixcblx0XHRkaWFsb2dDbGFzczogXCJcIixcblx0XHRkcmFnZ2FibGU6IHRydWUsXG5cdFx0aGlkZTogbnVsbCxcblx0XHRoZWlnaHQ6IFwiYXV0b1wiLFxuXHRcdG1heEhlaWdodDogZmFsc2UsXG5cdFx0bWF4V2lkdGg6IGZhbHNlLFxuXHRcdG1pbkhlaWdodDogMTUwLFxuXHRcdG1pbldpZHRoOiAxNTAsXG5cdFx0bW9kYWw6IGZhbHNlLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJjZW50ZXJcIixcblx0XHRcdGF0OiBcImNlbnRlclwiLFxuXHRcdFx0b2Y6IHdpbmRvdyxcblx0XHRcdGNvbGxpc2lvbjogXCJmaXRcIixcblx0XHRcdC8vIGVuc3VyZSB0aGF0IHRoZSB0aXRsZWJhciBpcyBuZXZlciBvdXRzaWRlIHRoZSBkb2N1bWVudFxuXHRcdFx0dXNpbmc6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRcdHZhciB0b3BPZmZzZXQgPSAkKCB0aGlzICkuY3NzKCBwb3MgKS5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdGlmICggdG9wT2Zmc2V0IDwgMCApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuY3NzKCBcInRvcFwiLCBwb3MudG9wIC0gdG9wT2Zmc2V0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlc2l6YWJsZTogdHJ1ZSxcblx0XHRzaG93OiBudWxsLFxuXHRcdHN0YWNrOiB0cnVlLFxuXHRcdHRpdGxlOiBcIlwiLFxuXHRcdHdpZHRoOiAzMDAsXG5cdFx0ekluZGV4OiAxMDAwXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmlnaW5hbFRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoIFwidGl0bGVcIiApO1xuXHRcdC8vICM1NzQyIC0gLmF0dHIoKSBtaWdodCByZXR1cm4gYSBET01FbGVtZW50XG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcmlnaW5hbFRpdGxlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dGhpcy5vcmlnaW5hbFRpdGxlID0gXCJcIjtcblx0XHR9XG5cdFx0dGhpcy5vbGRQb3NpdGlvbiA9IHtcblx0XHRcdHBhcmVudDogdGhpcy5lbGVtZW50LnBhcmVudCgpLFxuXHRcdFx0aW5kZXg6IHRoaXMuZWxlbWVudC5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4KCB0aGlzLmVsZW1lbnQgKVxuXHRcdH07XG5cdFx0dGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlIHx8IHRoaXMub3JpZ2luYWxUaXRsZTtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXG5cdFx0XHR0aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwgXCImIzE2MDtcIixcblx0XHRcdHVpRGlhbG9nLFxuXHRcdFx0dWlEaWFsb2dUaXRsZWJhcixcblx0XHRcdHVpRGlhbG9nVGl0bGViYXJDbG9zZSxcblx0XHRcdHVpRGlhbG9nVGl0bGUsXG5cdFx0XHR1aURpYWxvZ0J1dHRvblBhbmU7XG5cblx0XHRcdHVpRGlhbG9nID0gKCB0aGlzLnVpRGlhbG9nID0gJCggXCI8ZGl2PlwiICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHVpRGlhbG9nQ2xhc3NlcyArIG9wdGlvbnMuZGlhbG9nQ2xhc3MgKVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRkaXNwbGF5OiBcIm5vbmVcIixcblx0XHRcdFx0XHRvdXRsaW5lOiAwLCAvLyBUT0RPOiBtb3ZlIHRvIHN0eWxlc2hlZXRcblx0XHRcdFx0XHR6SW5kZXg6IG9wdGlvbnMuekluZGV4XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC8vIHNldHRpbmcgdGFiSW5kZXggbWFrZXMgdGhlIGRpdiBmb2N1c2FibGVcblx0XHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEpXG5cdFx0XHRcdC5rZXlkb3duKGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuY2xvc2VPbkVzY2FwZSAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQua2V5Q29kZSAmJlxuXHRcdFx0XHRcdFx0XHRldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFICkge1xuXHRcdFx0XHRcdFx0dGhhdC5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQubW91c2Vkb3duKGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHR0aGF0Lm1vdmVUb1RvcCggZmFsc2UsIGV2ZW50ICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hcHBlbmRUbyggXCJib2R5XCIgKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGl0bGVcIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudFwiIClcblx0XHRcdFx0LmFwcGVuZFRvKCB1aURpYWxvZyApO1xuXG5cdFx0XHR1aURpYWxvZ1RpdGxlYmFyID0gKCB0aGlzLnVpRGlhbG9nVGl0bGViYXIgPSAkKCBcIjxkaXY+XCIgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctdGl0bGViYXIgIHVpLXdpZGdldC1oZWFkZXIgIFwiICtcblx0XHRcdFx0XHRcInVpLWNvcm5lci1hbGwgIHVpLWhlbHBlci1jbGVhcmZpeFwiIClcblx0XHRcdFx0LmJpbmQoIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIERpYWxvZyBpc24ndCBnZXR0aW5nIGZvY3VzIHdoZW4gZHJhZ2dpbmcgKCM4MDYzKVxuXHRcdFx0XHRcdHVpRGlhbG9nLmZvY3VzKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5wcmVwZW5kVG8oIHVpRGlhbG9nICk7XG5cblx0XHRcdHVpRGlhbG9nVGl0bGViYXJDbG9zZSA9ICQoIFwiPGEgaHJlZj0nIyc+PC9hPlwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWRpYWxvZy10aXRsZWJhci1jbG9zZSAgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcImJ1dHRvblwiIClcblx0XHRcdFx0LmNsaWNrKGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoYXQuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hcHBlbmRUbyggdWlEaWFsb2dUaXRsZWJhciApO1xuXG5cdFx0XHQoIHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlVGV4dCA9ICQoIFwiPHNwYW4+XCIgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1pY29uIHVpLWljb24tY2xvc2V0aGlja1wiIClcblx0XHRcdFx0LnRleHQoIG9wdGlvbnMuY2xvc2VUZXh0IClcblx0XHRcdFx0LmFwcGVuZFRvKCB1aURpYWxvZ1RpdGxlYmFyQ2xvc2UgKTtcblxuXHRcdFx0dWlEaWFsb2dUaXRsZSA9ICQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZGlhbG9nLXRpdGxlXCIgKVxuXHRcdFx0XHQuaHRtbCggdGl0bGUgKVxuXHRcdFx0XHQucHJlcGVuZFRvKCB1aURpYWxvZ1RpdGxlYmFyICk7XG5cblx0XHRcdHVpRGlhbG9nQnV0dG9uUGFuZSA9ICggdGhpcy51aURpYWxvZ0J1dHRvblBhbmUgPSAkKCBcIjxkaXY+XCIgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXhcIiApO1xuXG5cdFx0XHQoIHRoaXMudWlCdXR0b25TZXQgPSAkKCBcIjxkaXY+XCIgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctYnV0dG9uc2V0XCIgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIHVpRGlhbG9nQnV0dG9uUGFuZSApO1xuXG5cdFx0dWlEaWFsb2cuYXR0cih7XG5cdFx0XHRyb2xlOiBcImRpYWxvZ1wiLFxuXHRcdFx0XCJhcmlhLWxhYmVsbGVkYnlcIjogdWlEaWFsb2dUaXRsZS5hdHRyKCBcImlkXCIgKVxuXHRcdH0pO1xuXG5cdFx0dWlEaWFsb2dUaXRsZWJhci5maW5kKCBcIipcIiApLmFkZCggdWlEaWFsb2dUaXRsZWJhciApLmRpc2FibGVTZWxlY3Rpb24oKTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHVpRGlhbG9nVGl0bGViYXJDbG9zZSApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdWlEaWFsb2dUaXRsZWJhckNsb3NlICk7XG5cblx0XHRpZiAoIG9wdGlvbnMuZHJhZ2dhYmxlICYmICQuZm4uZHJhZ2dhYmxlICkge1xuXHRcdFx0dGhpcy5fbWFrZURyYWdnYWJsZSgpO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMucmVzaXphYmxlICYmICQuZm4ucmVzaXphYmxlICkge1xuXHRcdFx0dGhpcy5fbWFrZVJlc2l6YWJsZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZUJ1dHRvbnMoIG9wdGlvbnMuYnV0dG9ucyApO1xuXHRcdHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuXG5cdFx0aWYgKCAkLmZuLmJnaWZyYW1lICkge1xuXHRcdFx0dWlEaWFsb2cuYmdpZnJhbWUoKTtcblx0XHR9XG5cblx0XHQvLyBwcmV2ZW50IHRhYmJpbmcgb3V0IG9mIG1vZGFsIGRpYWxvZ3Ncblx0XHR0aGlzLl9vbiggdWlEaWFsb2csIHsga2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCAhb3B0aW9ucy5tb2RhbCB8fCBldmVudC5rZXlDb2RlICE9PSAkLnVpLmtleUNvZGUuVEFCICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0YWJiYWJsZXMgPSAkKCBcIjp0YWJiYWJsZVwiLCB1aURpYWxvZyApLFxuXHRcdFx0XHRmaXJzdCA9IHRhYmJhYmxlcy5maWx0ZXIoIFwiOmZpcnN0XCIgKSxcblx0XHRcdFx0bGFzdCAgPSB0YWJiYWJsZXMuZmlsdGVyKCBcIjpsYXN0XCIgKTtcblxuXHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGxhc3RbMF0gJiYgIWV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0XHRmaXJzdC5mb2N1cyggMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC50YXJnZXQgPT09IGZpcnN0WzBdICYmIGV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0XHRsYXN0LmZvY3VzKCAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9fSk7XG5cdH0sXG5cblx0X2luaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmF1dG9PcGVuICkge1xuXHRcdFx0dGhpcy5vcGVuKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV4dCxcblx0XHRcdG9sZFBvc2l0aW9uID0gdGhpcy5vbGRQb3NpdGlvbjtcblxuXHRcdGlmICggdGhpcy5vdmVybGF5ICkge1xuXHRcdFx0dGhpcy5vdmVybGF5LmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0dGhpcy51aURpYWxvZy5oaWRlKCk7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcIiApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXBwZW5kVG8oIFwiYm9keVwiICk7XG5cdFx0dGhpcy51aURpYWxvZy5yZW1vdmUoKTtcblxuXHRcdGlmICggdGhpcy5vcmlnaW5hbFRpdGxlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgdGhpcy5vcmlnaW5hbFRpdGxlICk7XG5cdFx0fVxuXG5cdFx0bmV4dCA9IG9sZFBvc2l0aW9uLnBhcmVudC5jaGlsZHJlbigpLmVxKCBvbGRQb3NpdGlvbi5pbmRleCApO1xuXHRcdC8vIERvbid0IHRyeSB0byBwbGFjZSB0aGUgZGlhbG9nIG5leHQgdG8gaXRzZWxmICgjODYxMylcblx0XHRpZiAoIG5leHQubGVuZ3RoICYmIG5leHRbIDAgXSAhPT0gdGhpcy5lbGVtZW50WyAwIF0gKSB7XG5cdFx0XHRuZXh0LmJlZm9yZSggdGhpcy5lbGVtZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZFBvc2l0aW9uLnBhcmVudC5hcHBlbmQoIHRoaXMuZWxlbWVudCApO1xuXHRcdH1cblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVpRGlhbG9nO1xuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0bWF4WiwgdGhpc1o7XG5cblx0XHRpZiAoICF0aGlzLl9pc09wZW4gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBmYWxzZSA9PT0gdGhpcy5fdHJpZ2dlciggXCJiZWZvcmVDbG9zZVwiLCBldmVudCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0aGlzLm92ZXJsYXkgKSB7XG5cdFx0XHR0aGlzLm92ZXJsYXkuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhpZGUgKSB7XG5cdFx0XHR0aGlzLl9oaWRlKCB0aGlzLnVpRGlhbG9nLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLmhpZGUoKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQgKTtcblx0XHR9XG5cblx0XHQkLnVpLmRpYWxvZy5vdmVybGF5LnJlc2l6ZSgpO1xuXG5cdFx0Ly8gYWRqdXN0IHRoZSBtYXhaIHRvIGFsbG93IG90aGVyIG1vZGFsIGRpYWxvZ3MgdG8gY29udGludWUgdG8gd29yayAoc2VlICM0MzA5KVxuXHRcdGlmICggdGhpcy5vcHRpb25zLm1vZGFsICkge1xuXHRcdFx0bWF4WiA9IDA7XG5cdFx0XHQkKCBcIi51aS1kaWFsb2dcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gdGhhdC51aURpYWxvZ1swXSApIHtcblx0XHRcdFx0XHR0aGlzWiA9ICQoIHRoaXMgKS5jc3MoIFwiei1pbmRleFwiICk7XG5cdFx0XHRcdFx0aWYgKCAhaXNOYU4oIHRoaXNaICkgKSB7XG5cdFx0XHRcdFx0XHRtYXhaID0gTWF0aC5tYXgoIG1heFosIHRoaXNaICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdCQudWkuZGlhbG9nLm1heFogPSBtYXhaO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGlzT3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT3Blbjtcblx0fSxcblxuXHQvLyB0aGUgZm9yY2UgcGFyYW1ldGVyIGFsbG93cyB1cyB0byBtb3ZlIG1vZGFsIGRpYWxvZ3MgdG8gdGhlaXIgY29ycmVjdFxuXHQvLyBwb3NpdGlvbiBvbiBvcGVuXG5cdG1vdmVUb1RvcDogZnVuY3Rpb24oIGZvcmNlLCBldmVudCApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHNhdmVTY3JvbGw7XG5cblx0XHRpZiAoICggb3B0aW9ucy5tb2RhbCAmJiAhZm9yY2UgKSB8fFxuXHRcdFx0XHQoICFvcHRpb25zLnN0YWNrICYmICFvcHRpb25zLm1vZGFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy56SW5kZXggPiAkLnVpLmRpYWxvZy5tYXhaICkge1xuXHRcdFx0JC51aS5kaWFsb2cubWF4WiA9IG9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdCQudWkuZGlhbG9nLm1heFogKz0gMTtcblx0XHRcdCQudWkuZGlhbG9nLm92ZXJsYXkubWF4WiA9ICQudWkuZGlhbG9nLm1heFo7XG5cdFx0XHR0aGlzLm92ZXJsYXkuJGVsLmNzcyggXCJ6LWluZGV4XCIsICQudWkuZGlhbG9nLm92ZXJsYXkubWF4WiApO1xuXHRcdH1cblxuXHRcdC8vIFNhdmUgYW5kIHRoZW4gcmVzdG9yZSBzY3JvbGxcblx0XHQvLyBPcGVyYSA5LjUrIHJlc2V0cyB3aGVuIHBhcmVudCB6LWluZGV4IGlzIGNoYW5nZWQuXG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC8zMTkzXG5cdFx0c2F2ZVNjcm9sbCA9IHtcblx0XHRcdHNjcm9sbFRvcDogdGhpcy5lbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0c2Nyb2xsTGVmdDogdGhpcy5lbGVtZW50LnNjcm9sbExlZnQoKVxuXHRcdH07XG5cdFx0JC51aS5kaWFsb2cubWF4WiArPSAxO1xuXHRcdHRoaXMudWlEaWFsb2cuY3NzKCBcInotaW5kZXhcIiwgJC51aS5kaWFsb2cubWF4WiApO1xuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBzYXZlU2Nyb2xsICk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLl9pc09wZW4gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGhhc0ZvY3VzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHVpRGlhbG9nID0gdGhpcy51aURpYWxvZztcblxuXHRcdHRoaXMuX3NpemUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbiggb3B0aW9ucy5wb3NpdGlvbiApO1xuXHRcdHVpRGlhbG9nLnNob3coIG9wdGlvbnMuc2hvdyApO1xuXHRcdHRoaXMub3ZlcmxheSA9IG9wdGlvbnMubW9kYWwgPyBuZXcgJC51aS5kaWFsb2cub3ZlcmxheSggdGhpcyApIDogbnVsbDtcblx0XHR0aGlzLm1vdmVUb1RvcCggdHJ1ZSApO1xuXG5cdFx0Ly8gc2V0IGZvY3VzIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGluIHRoZSBjb250ZW50IGFyZWEgb3IgdGhlIGZpcnN0IGJ1dHRvblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBubyB0YWJiYWJsZSBlbGVtZW50cywgc2V0IGZvY3VzIG9uIHRoZSBkaWFsb2cgaXRzZWxmXG5cdFx0aGFzRm9jdXMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCI6dGFiYmFibGVcIiApO1xuXHRcdGlmICggIWhhc0ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZ0J1dHRvblBhbmUuZmluZCggXCI6dGFiYmFibGVcIiApO1xuXHRcdFx0aWYgKCAhaGFzRm9jdXMubGVuZ3RoICkge1xuXHRcdFx0XHRoYXNGb2N1cyA9IHVpRGlhbG9nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRoYXNGb2N1cy5lcSggMCApLmZvY3VzKCk7XG5cblx0XHR0aGlzLl9pc09wZW4gPSB0cnVlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwib3BlblwiICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY3JlYXRlQnV0dG9uczogZnVuY3Rpb24oIGJ1dHRvbnMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0aGFzQnV0dG9ucyA9IGZhbHNlO1xuXG5cdFx0Ly8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgYnV0dG9uIHBhbmUsIHJlbW92ZSBpdFxuXHRcdHRoaXMudWlEaWFsb2dCdXR0b25QYW5lLnJlbW92ZSgpO1xuXHRcdHRoaXMudWlCdXR0b25TZXQuZW1wdHkoKTtcblxuXHRcdGlmICggdHlwZW9mIGJ1dHRvbnMgPT09IFwib2JqZWN0XCIgJiYgYnV0dG9ucyAhPT0gbnVsbCApIHtcblx0XHRcdCQuZWFjaCggYnV0dG9ucywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhKGhhc0J1dHRvbnMgPSB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIGhhc0J1dHRvbnMgKSB7XG5cdFx0XHQkLmVhY2goIGJ1dHRvbnMsIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGJ1dHRvbiwgY2xpY2s7XG5cdFx0XHRcdHByb3BzID0gJC5pc0Z1bmN0aW9uKCBwcm9wcyApID9cblx0XHRcdFx0XHR7IGNsaWNrOiBwcm9wcywgdGV4dDogbmFtZSB9IDpcblx0XHRcdFx0XHRwcm9wcztcblx0XHRcdFx0Ly8gRGVmYXVsdCB0byBhIG5vbi1zdWJtaXR0aW5nIGJ1dHRvblxuXHRcdFx0XHRwcm9wcyA9ICQuZXh0ZW5kKCB7IHR5cGU6IFwiYnV0dG9uXCIgfSwgcHJvcHMgKTtcblx0XHRcdFx0Ly8gQ2hhbmdlIHRoZSBjb250ZXh0IGZvciB0aGUgY2xpY2sgY2FsbGJhY2sgdG8gYmUgdGhlIG1haW4gZWxlbWVudFxuXHRcdFx0XHRjbGljayA9IHByb3BzLmNsaWNrO1xuXHRcdFx0XHRwcm9wcy5jbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNsaWNrLmFwcGx5KCB0aGF0LmVsZW1lbnRbMF0sIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRidXR0b24gPSAkKCBcIjxidXR0b24+PC9idXR0b24+XCIsIHByb3BzIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHRoYXQudWlCdXR0b25TZXQgKTtcblx0XHRcdFx0aWYgKCAkLmZuLmJ1dHRvbiApIHtcblx0XHRcdFx0XHRidXR0b24uYnV0dG9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy51aURpYWxvZy5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctYnV0dG9uc1wiICk7XG5cdFx0XHR0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5hcHBlbmRUbyggdGhpcy51aURpYWxvZyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLnJlbW92ZUNsYXNzKCBcInVpLWRpYWxvZy1idXR0b25zXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X21ha2VEcmFnZ2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRmdW5jdGlvbiBmaWx0ZXJlZFVpKCB1aSApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHBvc2l0aW9uOiB1aS5wb3NpdGlvbixcblx0XHRcdFx0b2Zmc2V0OiB1aS5vZmZzZXRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpcy51aURpYWxvZy5kcmFnZ2FibGUoe1xuXHRcdFx0Y2FuY2VsOiBcIi51aS1kaWFsb2ctY29udGVudCwgLnVpLWRpYWxvZy10aXRsZWJhci1jbG9zZVwiLFxuXHRcdFx0aGFuZGxlOiBcIi51aS1kaWFsb2ctdGl0bGViYXJcIixcblx0XHRcdGNvbnRhaW5tZW50OiBcImRvY3VtZW50XCIsXG5cdFx0XHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWRpYWxvZy1kcmFnZ2luZ1wiICk7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJkcmFnXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0b3B0aW9ucy5wb3NpdGlvbiA9IFtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5kb2N1bWVudC5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wIC0gdGhhdC5kb2N1bWVudC5zY3JvbGxUb3AoKVxuXHRcdFx0XHRdO1xuXHRcdFx0XHQkKCB0aGlzIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktZGlhbG9nLWRyYWdnaW5nXCIgKTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJkcmFnU3RvcFwiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0XHQkLnVpLmRpYWxvZy5vdmVybGF5LnJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9tYWtlUmVzaXphYmxlOiBmdW5jdGlvbiggaGFuZGxlcyApIHtcblx0XHRoYW5kbGVzID0gKGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5yZXNpemFibGUgOiBoYW5kbGVzKTtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0Ly8gLnVpLXJlc2l6YWJsZSBoYXMgcG9zaXRpb246IHJlbGF0aXZlIGRlZmluZWQgaW4gdGhlIHN0eWxlc2hlZXRcblx0XHRcdC8vIGJ1dCBkaWFsb2dzIGhhdmUgdG8gdXNlIGFic29sdXRlIG9yIGZpeGVkIHBvc2l0aW9uaW5nXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMudWlEaWFsb2cuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdHJlc2l6ZUhhbmRsZXMgPSB0eXBlb2YgaGFuZGxlcyA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRoYW5kbGVzXHQ6XG5cdFx0XHRcdFwibixlLHMsdyxzZSxzdyxuZSxud1wiO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSggdWkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB1aS5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0XHRvcmlnaW5hbFNpemU6IHVpLm9yaWdpbmFsU2l6ZSxcblx0XHRcdFx0cG9zaXRpb246IHVpLnBvc2l0aW9uLFxuXHRcdFx0XHRzaXplOiB1aS5zaXplXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKHtcblx0XHRcdGNhbmNlbDogXCIudWktZGlhbG9nLWNvbnRlbnRcIixcblx0XHRcdGNvbnRhaW5tZW50OiBcImRvY3VtZW50XCIsXG5cdFx0XHRhbHNvUmVzaXplOiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRtYXhXaWR0aDogb3B0aW9ucy5tYXhXaWR0aCxcblx0XHRcdG1heEhlaWdodDogb3B0aW9ucy5tYXhIZWlnaHQsXG5cdFx0XHRtaW5XaWR0aDogb3B0aW9ucy5taW5XaWR0aCxcblx0XHRcdG1pbkhlaWdodDogdGhpcy5fbWluSGVpZ2h0KCksXG5cdFx0XHRoYW5kbGVzOiByZXNpemVIYW5kbGVzLFxuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctcmVzaXppbmdcIiApO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVN0YXJ0XCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzaXplOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVwiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1kaWFsb2ctcmVzaXppbmdcIiApO1xuXHRcdFx0XHRvcHRpb25zLmhlaWdodCA9ICQoIHRoaXMgKS5oZWlnaHQoKTtcblx0XHRcdFx0b3B0aW9ucy53aWR0aCA9ICQoIHRoaXMgKS53aWR0aCgpO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVN0b3BcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdFx0JC51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUoKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5jc3MoIFwicG9zaXRpb25cIiwgcG9zaXRpb24gKVxuXHRcdC5maW5kKCBcIi51aS1yZXNpemFibGUtc2VcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktaWNvbiB1aS1pY29uLWdyaXAtZGlhZ29uYWwtc2VcIiApO1xuXHR9LFxuXG5cdF9taW5IZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvcHRpb25zLmhlaWdodCA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5IZWlnaHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbiggb3B0aW9ucy5taW5IZWlnaHQsIG9wdGlvbnMuaGVpZ2h0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3NpdGlvbjogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHZhciBteUF0ID0gW10sXG5cdFx0XHRvZmZzZXQgPSBbIDAsIDAgXSxcblx0XHRcdGlzVmlzaWJsZTtcblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cdFx0XHQvLyBkZWVwIGV4dGVuZGluZyBjb252ZXJ0cyBhcnJheXMgdG8gb2JqZWN0cyBpbiBqUXVlcnkgPD0gMS4zLjIgOi0oXG5cdC8vXHRcdGlmICh0eXBlb2YgcG9zaXRpb24gPT0gJ3N0cmluZycgfHwgJC5pc0FycmF5KHBvc2l0aW9uKSkge1xuXHQvL1x0XHRcdG15QXQgPSAkLmlzQXJyYXkocG9zaXRpb24pID8gcG9zaXRpb24gOiBwb3NpdGlvbi5zcGxpdCgnICcpO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHBvc2l0aW9uID09PSBcIm9iamVjdFwiICYmIFwiMFwiIGluIHBvc2l0aW9uICkgKSB7XG5cdFx0XHRcdG15QXQgPSBwb3NpdGlvbi5zcGxpdCA/IHBvc2l0aW9uLnNwbGl0KCBcIiBcIiApIDogWyBwb3NpdGlvblsgMCBdLCBwb3NpdGlvblsgMSBdIF07XG5cdFx0XHRcdGlmICggbXlBdC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0bXlBdFsgMSBdID0gbXlBdFsgMCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBvZmZzZXRQb3NpdGlvbiApIHtcblx0XHRcdFx0XHRpZiAoICtteUF0WyBpIF0gPT09IG15QXRbIGkgXSApIHtcblx0XHRcdFx0XHRcdG9mZnNldFsgaSBdID0gbXlBdFsgaSBdO1xuXHRcdFx0XHRcdFx0bXlBdFsgaSBdID0gb2Zmc2V0UG9zaXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwb3NpdGlvbiA9IHtcblx0XHRcdFx0XHRteTogbXlBdFswXSArIChvZmZzZXRbMF0gPCAwID8gb2Zmc2V0WzBdIDogXCIrXCIgKyBvZmZzZXRbMF0pICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0bXlBdFsxXSArIChvZmZzZXRbMV0gPCAwID8gb2Zmc2V0WzFdIDogXCIrXCIgKyBvZmZzZXRbMV0pLFxuXHRcdFx0XHRcdGF0OiBteUF0LmpvaW4oIFwiIFwiIClcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cG9zaXRpb24gPSAkLmV4dGVuZCgge30sICQudWkuZGlhbG9nLnByb3RvdHlwZS5vcHRpb25zLnBvc2l0aW9uLCBwb3NpdGlvbiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9ICQudWkuZGlhbG9nLnByb3RvdHlwZS5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdC8vIG5lZWQgdG8gc2hvdyB0aGUgZGlhbG9nIHRvIGdldCB0aGUgYWN0dWFsIG9mZnNldCBpbiB0aGUgcG9zaXRpb24gcGx1Z2luXG5cdFx0aXNWaXNpYmxlID0gdGhpcy51aURpYWxvZy5pcyggXCI6dmlzaWJsZVwiICk7XG5cdFx0aWYgKCAhaXNWaXNpYmxlICkge1xuXHRcdFx0dGhpcy51aURpYWxvZy5zaG93KCk7XG5cdFx0fVxuXHRcdHRoaXMudWlEaWFsb2cucG9zaXRpb24oIHBvc2l0aW9uICk7XG5cdFx0aWYgKCAhaXNWaXNpYmxlICkge1xuXHRcdFx0dGhpcy51aURpYWxvZy5oaWRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRyZXNpemFibGVPcHRpb25zID0ge30sXG5cdFx0XHRyZXNpemUgPSBmYWxzZTtcblxuXHRcdCQuZWFjaCggb3B0aW9ucywgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGF0Ll9zZXRPcHRpb24oIGtleSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBrZXkgaW4gc2l6ZVJlbGF0ZWRPcHRpb25zICkge1xuXHRcdFx0XHRyZXNpemUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBrZXkgaW4gcmVzaXphYmxlUmVsYXRlZE9wdGlvbnMgKSB7XG5cdFx0XHRcdHJlc2l6YWJsZU9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIHJlc2l6ZSApIHtcblx0XHRcdHRoaXMuX3NpemUoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnVpRGlhbG9nLmlzKCBcIjpkYXRhKHJlc2l6YWJsZSlcIiApICkge1xuXHRcdFx0dGhpcy51aURpYWxvZy5yZXNpemFibGUoIFwib3B0aW9uXCIsIHJlc2l6YWJsZU9wdGlvbnMgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSxcblx0XHRcdHVpRGlhbG9nID0gdGhpcy51aURpYWxvZztcblxuXHRcdHN3aXRjaCAoIGtleSApIHtcblx0XHRcdGNhc2UgXCJidXR0b25zXCI6XG5cdFx0XHRcdHRoaXMuX2NyZWF0ZUJ1dHRvbnMoIHZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImNsb3NlVGV4dFwiOlxuXHRcdFx0XHQvLyBlbnN1cmUgdGhhdCB3ZSBhbHdheXMgcGFzcyBhIHN0cmluZ1xuXHRcdFx0XHR0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZVRleHQudGV4dCggXCJcIiArIHZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRpYWxvZ0NsYXNzXCI6XG5cdFx0XHRcdHVpRGlhbG9nXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuZGlhbG9nQ2xhc3MgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggdWlEaWFsb2dDbGFzc2VzICsgdmFsdWUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZGlzYWJsZWRcIjpcblx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0XHR1aURpYWxvZy5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctZGlzYWJsZWRcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVpRGlhbG9nLnJlbW92ZUNsYXNzKCBcInVpLWRpYWxvZy1kaXNhYmxlZFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZHJhZ2dhYmxlXCI6XG5cdFx0XHRcdGlzRHJhZ2dhYmxlID0gdWlEaWFsb2cuaXMoIFwiOmRhdGEoZHJhZ2dhYmxlKVwiICk7XG5cdFx0XHRcdGlmICggaXNEcmFnZ2FibGUgJiYgIXZhbHVlICkge1xuXHRcdFx0XHRcdHVpRGlhbG9nLmRyYWdnYWJsZSggXCJkZXN0cm95XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggIWlzRHJhZ2dhYmxlICYmIHZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuX21ha2VEcmFnZ2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJwb3NpdGlvblwiOlxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiggdmFsdWUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicmVzaXphYmxlXCI6XG5cdFx0XHRcdC8vIGN1cnJlbnRseSByZXNpemFibGUsIGJlY29taW5nIG5vbi1yZXNpemFibGVcblx0XHRcdFx0aXNSZXNpemFibGUgPSB1aURpYWxvZy5pcyggXCI6ZGF0YShyZXNpemFibGUpXCIgKTtcblx0XHRcdFx0aWYgKCBpc1Jlc2l6YWJsZSAmJiAhdmFsdWUgKSB7XG5cdFx0XHRcdFx0dWlEaWFsb2cucmVzaXphYmxlKCBcImRlc3Ryb3lcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3VycmVudGx5IHJlc2l6YWJsZSwgY2hhbmdpbmcgaGFuZGxlc1xuXHRcdFx0XHRpZiAoIGlzUmVzaXphYmxlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHR1aURpYWxvZy5yZXNpemFibGUoIFwib3B0aW9uXCIsIFwiaGFuZGxlc1wiLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3VycmVudGx5IG5vbi1yZXNpemFibGUsIGJlY29taW5nIHJlc2l6YWJsZVxuXHRcdFx0XHRpZiAoICFpc1Jlc2l6YWJsZSAmJiB2YWx1ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFrZVJlc2l6YWJsZSggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ0aXRsZVwiOlxuXHRcdFx0XHQvLyBjb252ZXJ0IHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gbyBhIHN0cmluZywgZm9yIGh0bWwoKSB0byBub3QgdGhyb3cgdXBcblx0XHRcdFx0JCggXCIudWktZGlhbG9nLXRpdGxlXCIsIHRoaXMudWlEaWFsb2dUaXRsZWJhciApXG5cdFx0XHRcdFx0Lmh0bWwoIFwiXCIgKyAoIHZhbHVlIHx8IFwiJiMxNjA7XCIgKSApO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zaXplOiBmdW5jdGlvbigpIHtcblx0XHQvKiBJZiB0aGUgdXNlciBoYXMgcmVzaXplZCB0aGUgZGlhbG9nLCB0aGUgLnVpLWRpYWxvZyBhbmQgLnVpLWRpYWxvZy1jb250ZW50XG5cdFx0ICogZGl2cyB3aWxsIGJvdGggaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IHNldCwgc28gd2UgbmVlZCB0byByZXNldCB0aGVtXG5cdFx0ICovXG5cdFx0dmFyIG5vbkNvbnRlbnRIZWlnaHQsIG1pbkNvbnRlbnRIZWlnaHQsIGF1dG9IZWlnaHQsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aXNWaXNpYmxlID0gdGhpcy51aURpYWxvZy5pcyggXCI6dmlzaWJsZVwiICk7XG5cblx0XHQvLyByZXNldCBjb250ZW50IHNpemluZ1xuXHRcdHRoaXMuZWxlbWVudC5zaG93KCkuY3NzKHtcblx0XHRcdHdpZHRoOiBcImF1dG9cIixcblx0XHRcdG1pbkhlaWdodDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH0pO1xuXG5cdFx0aWYgKCBvcHRpb25zLm1pbldpZHRoID4gb3B0aW9ucy53aWR0aCApIHtcblx0XHRcdG9wdGlvbnMud2lkdGggPSBvcHRpb25zLm1pbldpZHRoO1xuXHRcdH1cblxuXHRcdC8vIHJlc2V0IHdyYXBwZXIgc2l6aW5nXG5cdFx0Ly8gZGV0ZXJtaW5lIHRoZSBoZWlnaHQgb2YgYWxsIHRoZSBub24tY29udGVudCBlbGVtZW50c1xuXHRcdG5vbkNvbnRlbnRIZWlnaHQgPSB0aGlzLnVpRGlhbG9nLmNzcyh7XG5cdFx0XHRcdGhlaWdodDogXCJhdXRvXCIsXG5cdFx0XHRcdHdpZHRoOiBvcHRpb25zLndpZHRoXG5cdFx0XHR9KVxuXHRcdFx0Lm91dGVySGVpZ2h0KCk7XG5cdFx0bWluQ29udGVudEhlaWdodCA9IE1hdGgubWF4KCAwLCBvcHRpb25zLm1pbkhlaWdodCAtIG5vbkNvbnRlbnRIZWlnaHQgKTtcblxuXHRcdGlmICggb3B0aW9ucy5oZWlnaHQgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0Ly8gb25seSBuZWVkZWQgZm9yIElFNiBzdXBwb3J0XG5cdFx0XHRpZiAoICQuc3VwcG9ydC5taW5IZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5jc3Moe1xuXHRcdFx0XHRcdG1pbkhlaWdodDogbWluQ29udGVudEhlaWdodCxcblx0XHRcdFx0XHRoZWlnaHQ6IFwiYXV0b1wiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy51aURpYWxvZy5zaG93KCk7XG5cdFx0XHRcdGF1dG9IZWlnaHQgPSB0aGlzLmVsZW1lbnQuY3NzKCBcImhlaWdodFwiLCBcImF1dG9cIiApLmhlaWdodCgpO1xuXHRcdFx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHRcdFx0dGhpcy51aURpYWxvZy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lbGVtZW50LmhlaWdodCggTWF0aC5tYXgoIGF1dG9IZWlnaHQsIG1pbkNvbnRlbnRIZWlnaHQgKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuaGVpZ2h0KCBNYXRoLm1heCggb3B0aW9ucy5oZWlnaHQgLSBub25Db250ZW50SGVpZ2h0LCAwICkgKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy51aURpYWxvZy5pcyggXCI6ZGF0YShyZXNpemFibGUpXCIgKSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCBcIm1pbkhlaWdodFwiLCB0aGlzLl9taW5IZWlnaHQoKSApO1xuXHRcdH1cblx0fVxufSk7XG5cbiQuZXh0ZW5kKCQudWkuZGlhbG9nLCB7XG5cdHV1aWQ6IDAsXG5cdG1heFo6IDAsXG5cblx0Z2V0VGl0bGVJZDogZnVuY3Rpb24oJGVsKSB7XG5cdFx0dmFyIGlkID0gJGVsLmF0dHIoIFwiaWRcIiApO1xuXHRcdGlmICggIWlkICkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHRpZCA9IHRoaXMudXVpZDtcblx0XHR9XG5cdFx0cmV0dXJuIFwidWktZGlhbG9nLXRpdGxlLVwiICsgaWQ7XG5cdH0sXG5cblx0b3ZlcmxheTogZnVuY3Rpb24oIGRpYWxvZyApIHtcblx0XHR0aGlzLiRlbCA9ICQudWkuZGlhbG9nLm92ZXJsYXkuY3JlYXRlKCBkaWFsb2cgKTtcblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLmRpYWxvZy5vdmVybGF5LCB7XG5cdGluc3RhbmNlczogW10sXG5cdC8vIHJldXNlIG9sZCBpbnN0YW5jZXMgZHVlIHRvIElFIG1lbW9yeSBsZWFrIHdpdGggYWxwaGEgdHJhbnNwYXJlbmN5IChzZWUgIzUxODUpXG5cdG9sZEluc3RhbmNlczogW10sXG5cdG1heFo6IDAsXG5cdGV2ZW50czogJC5tYXAoXG5cdFx0XCJmb2N1cyxtb3VzZWRvd24sbW91c2V1cCxrZXlkb3duLGtleXByZXNzLGNsaWNrXCIuc3BsaXQoIFwiLFwiICksXG5cdFx0ZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50ICsgXCIuZGlhbG9nLW92ZXJsYXlcIjtcblx0XHR9XG5cdCkuam9pbiggXCIgXCIgKSxcblx0Y3JlYXRlOiBmdW5jdGlvbiggZGlhbG9nICkge1xuXHRcdGlmICggdGhpcy5pbnN0YW5jZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gcHJldmVudCB1c2Ugb2YgYW5jaG9ycyBhbmQgaW5wdXRzXG5cdFx0XHQvLyB3ZSB1c2UgYSBzZXRUaW1lb3V0IGluIGNhc2UgdGhlIG92ZXJsYXkgaXMgY3JlYXRlZCBmcm9tIGFuXG5cdFx0XHQvLyBldmVudCB0aGF0IHdlJ3JlIGdvaW5nIHRvIGJlIGNhbmNlbGxpbmcgKHNlZSAjMjgwNClcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGhhbmRsZSAkKGVsKS5kaWFsb2coKS5kaWFsb2coJ2Nsb3NlJykgKHNlZSAjNDA2NSlcblx0XHRcdFx0aWYgKCAkLnVpLmRpYWxvZy5vdmVybGF5Lmluc3RhbmNlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0JCggZG9jdW1lbnQgKS5iaW5kKCAkLnVpLmRpYWxvZy5vdmVybGF5LmV2ZW50cywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0Ly8gc3RvcCBldmVudHMgaWYgdGhlIHotaW5kZXggb2YgdGhlIHRhcmdldCBpcyA8IHRoZSB6LWluZGV4IG9mIHRoZSBvdmVybGF5XG5cdFx0XHRcdFx0XHQvLyB3ZSBjYW5ub3QgcmV0dXJuIHRydWUgd2hlbiB3ZSBkb24ndCB3YW50IHRvIGNhbmNlbCB0aGUgZXZlbnQgKCMzNTIzKVxuXHRcdFx0XHRcdFx0aWYgKCAkKCBldmVudC50YXJnZXQgKS56SW5kZXgoKSA8ICQudWkuZGlhbG9nLm92ZXJsYXkubWF4WiApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxICk7XG5cblx0XHRcdC8vIGhhbmRsZSB3aW5kb3cgcmVzaXplXG5cdFx0XHQkKCB3aW5kb3cgKS5iaW5kKCBcInJlc2l6ZS5kaWFsb2ctb3ZlcmxheVwiLCAkLnVpLmRpYWxvZy5vdmVybGF5LnJlc2l6ZSApO1xuXHRcdH1cblxuXHRcdHZhciAkZWwgPSAoIHRoaXMub2xkSW5zdGFuY2VzLnBvcCgpIHx8ICQoIFwiPGRpdj5cIiApLmFkZENsYXNzKCBcInVpLXdpZGdldC1vdmVybGF5XCIgKSApO1xuXG5cdFx0Ly8gYWxsb3cgY2xvc2luZyBieSBwcmVzc2luZyB0aGUgZXNjYXBlIGtleVxuXHRcdCQoIGRvY3VtZW50ICkuYmluZCggXCJrZXlkb3duLmRpYWxvZy1vdmVybGF5XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBpbnN0YW5jZXMgPSAkLnVpLmRpYWxvZy5vdmVybGF5Lmluc3RhbmNlcztcblx0XHRcdC8vIG9ubHkgcmVhY3QgdG8gdGhlIGV2ZW50IGlmIHdlJ3JlIHRoZSB0b3Agb3ZlcmxheVxuXHRcdFx0aWYgKCBpbnN0YW5jZXMubGVuZ3RoICE9PSAwICYmIGluc3RhbmNlc1sgaW5zdGFuY2VzLmxlbmd0aCAtIDEgXSA9PT0gJGVsICYmXG5cdFx0XHRcdGRpYWxvZy5vcHRpb25zLmNsb3NlT25Fc2NhcGUgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGV2ZW50LmtleUNvZGUgJiZcblx0XHRcdFx0ZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVTQ0FQRSApIHtcblxuXHRcdFx0XHRkaWFsb2cuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQkZWwuYXBwZW5kVG8oIGRvY3VtZW50LmJvZHkgKS5jc3Moe1xuXHRcdFx0d2lkdGg6IHRoaXMud2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5oZWlnaHQoKVxuXHRcdH0pO1xuXG5cdFx0aWYgKCAkLmZuLmJnaWZyYW1lICkge1xuXHRcdFx0JGVsLmJnaWZyYW1lKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbnN0YW5jZXMucHVzaCggJGVsICk7XG5cdFx0cmV0dXJuICRlbDtcblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbiggJGVsICkge1xuXHRcdHZhciBpbmRleE9mID0gJC5pbkFycmF5KCAkZWwsIHRoaXMuaW5zdGFuY2VzICksXG5cdFx0XHRtYXhaID0gMDtcblxuXHRcdGlmICggaW5kZXhPZiAhPT0gLTEgKSB7XG5cdFx0XHR0aGlzLm9sZEluc3RhbmNlcy5wdXNoKCB0aGlzLmluc3RhbmNlcy5zcGxpY2UoIGluZGV4T2YsIDEgKVsgMCBdICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHQkKCBbIGRvY3VtZW50LCB3aW5kb3cgXSApLnVuYmluZCggXCIuZGlhbG9nLW92ZXJsYXlcIiApO1xuXHRcdH1cblxuXHRcdCRlbC5oZWlnaHQoIDAgKS53aWR0aCggMCApLnJlbW92ZSgpO1xuXG5cdFx0Ly8gYWRqdXN0IHRoZSBtYXhaIHRvIGFsbG93IG90aGVyIG1vZGFsIGRpYWxvZ3MgdG8gY29udGludWUgdG8gd29yayAoc2VlICM0MzA5KVxuXHRcdCQuZWFjaCggdGhpcy5pbnN0YW5jZXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bWF4WiA9IE1hdGgubWF4KCBtYXhaLCB0aGlzLmNzcyggXCJ6LWluZGV4XCIgKSApO1xuXHRcdH0pO1xuXHRcdHRoaXMubWF4WiA9IG1heFo7XG5cdH0sXG5cblx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0b2Zmc2V0SGVpZ2h0O1xuXHRcdC8vIGhhbmRsZSBJRVxuXHRcdGlmICggJC51aS5pZSApIHtcblx0XHRcdHNjcm9sbEhlaWdodCA9IE1hdGgubWF4KFxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodFxuXHRcdFx0KTtcblx0XHRcdG9mZnNldEhlaWdodCA9IE1hdGgubWF4KFxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodFxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBzY3JvbGxIZWlnaHQgPCBvZmZzZXRIZWlnaHQgKSB7XG5cdFx0XHRcdHJldHVybiAkKCB3aW5kb3cgKS5oZWlnaHQoKSArIFwicHhcIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBzY3JvbGxIZWlnaHQgKyBcInB4XCI7XG5cdFx0XHR9XG5cdFx0Ly8gaGFuZGxlIFwiZ29vZFwiIGJyb3dzZXJzXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAkKCBkb2N1bWVudCApLmhlaWdodCgpICsgXCJweFwiO1xuXHRcdH1cblx0fSxcblxuXHR3aWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFdpZHRoLFxuXHRcdFx0b2Zmc2V0V2lkdGg7XG5cdFx0Ly8gaGFuZGxlIElFXG5cdFx0aWYgKCAkLnVpLmllICkge1xuXHRcdFx0c2Nyb2xsV2lkdGggPSBNYXRoLm1heChcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoLFxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoXG5cdFx0XHQpO1xuXHRcdFx0b2Zmc2V0V2lkdGggPSBNYXRoLm1heChcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoIHNjcm9sbFdpZHRoIDwgb2Zmc2V0V2lkdGggKSB7XG5cdFx0XHRcdHJldHVybiAkKCB3aW5kb3cgKS53aWR0aCgpICsgXCJweFwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHNjcm9sbFdpZHRoICsgXCJweFwiO1xuXHRcdFx0fVxuXHRcdC8vIGhhbmRsZSBcImdvb2RcIiBicm93c2Vyc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gJCggZG9jdW1lbnQgKS53aWR0aCgpICsgXCJweFwiO1xuXHRcdH1cblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdC8qIElmIHRoZSBkaWFsb2cgaXMgZHJhZ2dhYmxlIGFuZCB0aGUgdXNlciBkcmFncyBpdCBwYXN0IHRoZVxuXHRcdCAqIHJpZ2h0IGVkZ2Ugb2YgdGhlIHdpbmRvdywgdGhlIGRvY3VtZW50IGJlY29tZXMgd2lkZXIgc28gd2Vcblx0XHQgKiBuZWVkIHRvIHN0cmV0Y2ggdGhlIG92ZXJsYXkuIElmIHRoZSB1c2VyIHRoZW4gZHJhZ3MgdGhlXG5cdFx0ICogZGlhbG9nIGJhY2sgdG8gdGhlIGxlZnQsIHRoZSBkb2N1bWVudCB3aWxsIGJlY29tZSBuYXJyb3dlcixcblx0XHQgKiBzbyB3ZSBuZWVkIHRvIHNocmluayB0aGUgb3ZlcmxheSB0byB0aGUgYXBwcm9wcmlhdGUgc2l6ZS5cblx0XHQgKiBUaGlzIGlzIGhhbmRsZWQgYnkgc2hyaW5raW5nIHRoZSBvdmVybGF5IGJlZm9yZSBzZXR0aW5nIGl0XG5cdFx0ICogdG8gdGhlIGZ1bGwgZG9jdW1lbnQgc2l6ZS5cblx0XHQgKi9cblx0XHR2YXIgJG92ZXJsYXlzID0gJCggW10gKTtcblx0XHQkLmVhY2goICQudWkuZGlhbG9nLm92ZXJsYXkuaW5zdGFuY2VzLCBmdW5jdGlvbigpIHtcblx0XHRcdCRvdmVybGF5cyA9ICRvdmVybGF5cy5hZGQoIHRoaXMgKTtcblx0XHR9KTtcblxuXHRcdCRvdmVybGF5cy5jc3Moe1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9KS5jc3Moe1xuXHRcdFx0d2lkdGg6ICQudWkuZGlhbG9nLm92ZXJsYXkud2lkdGgoKSxcblx0XHRcdGhlaWdodDogJC51aS5kaWFsb2cub3ZlcmxheS5oZWlnaHQoKVxuXHRcdH0pO1xuXHR9XG59KTtcblxuJC5leHRlbmQoICQudWkuZGlhbG9nLm92ZXJsYXkucHJvdG90eXBlLCB7XG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdCQudWkuZGlhbG9nLm92ZXJsYXkuZGVzdHJveSggdGhpcy4kZWwgKTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5kcmFnZ2FibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcImRyYWdcIixcblx0b3B0aW9uczoge1xuXHRcdGFkZENsYXNzZXM6IHRydWUsXG5cdFx0YXBwZW5kVG86IFwicGFyZW50XCIsXG5cdFx0YXhpczogZmFsc2UsXG5cdFx0Y29ubmVjdFRvU29ydGFibGU6IGZhbHNlLFxuXHRcdGNvbnRhaW5tZW50OiBmYWxzZSxcblx0XHRjdXJzb3I6IFwiYXV0b1wiLFxuXHRcdGN1cnNvckF0OiBmYWxzZSxcblx0XHRncmlkOiBmYWxzZSxcblx0XHRoYW5kbGU6IGZhbHNlLFxuXHRcdGhlbHBlcjogXCJvcmlnaW5hbFwiLFxuXHRcdGlmcmFtZUZpeDogZmFsc2UsXG5cdFx0b3BhY2l0eTogZmFsc2UsXG5cdFx0cmVmcmVzaFBvc2l0aW9uczogZmFsc2UsXG5cdFx0cmV2ZXJ0OiBmYWxzZSxcblx0XHRyZXZlcnREdXJhdGlvbjogNTAwLFxuXHRcdHNjb3BlOiBcImRlZmF1bHRcIixcblx0XHRzY3JvbGw6IHRydWUsXG5cdFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxuXHRcdHNjcm9sbFNwZWVkOiAyMCxcblx0XHRzbmFwOiBmYWxzZSxcblx0XHRzbmFwTW9kZTogXCJib3RoXCIsXG5cdFx0c25hcFRvbGVyYW5jZTogMjAsXG5cdFx0c3RhY2s6IGZhbHNlLFxuXHRcdHpJbmRleDogZmFsc2Vcblx0fSxcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmhlbHBlciA9PSAnb3JpZ2luYWwnICYmICEoL14oPzpyfGF8ZikvKS50ZXN0KHRoaXMuZWxlbWVudC5jc3MoXCJwb3NpdGlvblwiKSkpXG5cdFx0XHR0aGlzLmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG5cdFx0KHRoaXMub3B0aW9ucy5hZGRDbGFzc2VzICYmIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZVwiKSk7XG5cdFx0KHRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZGlzYWJsZWRcIikpO1xuXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWRyYWdnYWJsZSB1aS1kcmFnZ2FibGUtZHJhZ2dpbmcgdWktZHJhZ2dhYmxlLWRpc2FibGVkXCIgKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBhbW9uZyBvdGhlcnMsIHByZXZlbnQgYSBkcmFnIG9uIGEgcmVzaXphYmxlLWhhbmRsZVxuXHRcdGlmICh0aGlzLmhlbHBlciB8fCBvLmRpc2FibGVkIHx8ICQoZXZlbnQudGFyZ2V0KS5pcygnLnVpLXJlc2l6YWJsZS1oYW5kbGUnKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdC8vUXVpdCBpZiB3ZSdyZSBub3Qgb24gYSB2YWxpZCBoYW5kbGVcblx0XHR0aGlzLmhhbmRsZSA9IHRoaXMuX2dldEhhbmRsZShldmVudCk7XG5cdFx0aWYgKCF0aGlzLmhhbmRsZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdCQoby5pZnJhbWVGaXggPT09IHRydWUgPyBcImlmcmFtZVwiIDogby5pZnJhbWVGaXgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQkKCc8ZGl2IGNsYXNzPVwidWktZHJhZ2dhYmxlLWlmcmFtZUZpeFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZjtcIj48L2Rpdj4nKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdHdpZHRoOiB0aGlzLm9mZnNldFdpZHRoK1wicHhcIiwgaGVpZ2h0OiB0aGlzLm9mZnNldEhlaWdodCtcInB4XCIsXG5cdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsIG9wYWNpdHk6IFwiMC4wMDFcIiwgekluZGV4OiAxMDAwXG5cdFx0XHR9KVxuXHRcdFx0LmNzcygkKHRoaXMpLm9mZnNldCgpKVxuXHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHZpc2libGUgaGVscGVyXG5cdFx0dGhpcy5oZWxwZXIgPSB0aGlzLl9jcmVhdGVIZWxwZXIoZXZlbnQpO1xuXG5cdFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vSWYgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIHNldCB0aGUgZ2xvYmFsIGRyYWdnYWJsZVxuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKVxuXHRcdFx0JC51aS5kZG1hbmFnZXIuY3VycmVudCA9IHRoaXM7XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9TdG9yZSB0aGUgaGVscGVyJ3MgY3NzIHBvc2l0aW9uXG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyhcInBvc2l0aW9uXCIpO1xuXHRcdHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KCk7XG5cblx0XHQvL1RoZSBlbGVtZW50J3MgYWJzb2x1dGUgcG9zaXRpb24gb24gdGhlIHBhZ2UgbWludXMgbWFyZ2luc1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblx0XHR0aGlzLm9mZnNldCA9IHtcblx0XHRcdHRvcDogdGhpcy5vZmZzZXQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdFxuXHRcdH07XG5cblx0XHQkLmV4dGVuZCh0aGlzLm9mZnNldCwge1xuXHRcdFx0Y2xpY2s6IHsgLy9XaGVyZSB0aGUgY2xpY2sgaGFwcGVuZWQsIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQubGVmdCxcblx0XHRcdFx0dG9wOiBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LnRvcFxuXHRcdFx0fSxcblx0XHRcdHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXG5cdFx0XHRyZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKSAvL1RoaXMgaXMgYSByZWxhdGl2ZSB0byBhYnNvbHV0ZSBwb3NpdGlvbiBtaW51cyB0aGUgYWN0dWFsIHBvc2l0aW9uIGNhbGN1bGF0aW9uIC0gb25seSB1c2VkIGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIGhlbHBlclxuXHRcdH0pO1xuXG5cdFx0Ly9HZW5lcmF0ZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25cblx0XHR0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgJ2N1cnNvckF0JyBpcyBzdXBwbGllZFxuXHRcdChvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCkpO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdGlmKG8uY29udGFpbm1lbnQpXG5cdFx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXG5cdFx0Ly9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXG5cdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cilcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcblxuXG5cdFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50LCB0cnVlKTsgLy9FeGVjdXRlIHRoZSBkcmFnIG9uY2UgLSB0aGlzIGNhdXNlcyB0aGUgaGVscGVyIG5vdCB0byBiZSB2aXNpYmxlIGJlZm9yZSBnZXR0aW5nIGl0cyBjb3JyZWN0IHBvc2l0aW9uXG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0YXJ0ZWQgKHNlZSAjNTAwMylcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkgJC51aS5kZG1hbmFnZXIuZHJhZ1N0YXJ0KHRoaXMsIGV2ZW50KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cblx0XHQvL0NvbXB1dGUgdGhlIGhlbHBlcnMgcG9zaXRpb25cblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cblx0XHQvL0NhbGwgcGx1Z2lucyBhbmQgY2FsbGJhY2tzIGFuZCB1c2UgdGhlIHJlc3VsdGluZyBwb3NpdGlvbiBpZiBzb21ldGhpbmcgaXMgcmV0dXJuZWRcblx0XHRpZiAoIW5vUHJvcGFnYXRpb24pIHtcblx0XHRcdHZhciB1aSA9IHRoaXMuX3VpSGFzaCgpO1xuXHRcdFx0aWYodGhpcy5fdHJpZ2dlcignZHJhZycsIGV2ZW50LCB1aSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9IFwieVwiKSB0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0KydweCc7XG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9IFwieFwiKSB0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCsncHgnO1xuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSAkLnVpLmRkbWFuYWdlci5kcmFnKHRoaXMsIGV2ZW50KTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0dmFyIGRyb3BwZWQgPSBmYWxzZTtcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKVxuXHRcdFx0ZHJvcHBlZCA9ICQudWkuZGRtYW5hZ2VyLmRyb3AodGhpcywgZXZlbnQpO1xuXG5cdFx0Ly9pZiBhIGRyb3AgY29tZXMgZnJvbSBvdXRzaWRlIChhIHNvcnRhYmxlKVxuXHRcdGlmKHRoaXMuZHJvcHBlZCkge1xuXHRcdFx0ZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcblx0XHRcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIG9yaWdpbmFsIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGluIHRoZSBET00gZG9uJ3QgYm90aGVyIHRvIGNvbnRpbnVlIChzZWUgIzgyNjkpXG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRbMF0sIGVsZW1lbnRJbkRvbSA9IGZhbHNlO1xuXHRcdHdoaWxlICggZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRpZiAoZWxlbWVudCA9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0ZWxlbWVudEluRG9tID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAhZWxlbWVudEluRG9tICYmIHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiApXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRpZigodGhpcy5vcHRpb25zLnJldmVydCA9PSBcImludmFsaWRcIiAmJiAhZHJvcHBlZCkgfHwgKHRoaXMub3B0aW9ucy5yZXZlcnQgPT0gXCJ2YWxpZFwiICYmIGRyb3BwZWQpIHx8IHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucmV2ZXJ0KSAmJiB0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwodGhpcy5lbGVtZW50LCBkcm9wcGVkKSkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdCQodGhpcy5oZWxwZXIpLmFuaW1hdGUodGhpcy5vcmlnaW5hbFBvc2l0aW9uLCBwYXJzZUludCh0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb24sIDEwKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoYXQuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGF0Ll9jbGVhcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvL1JlbW92ZSBmcmFtZSBoZWxwZXJzXG5cdFx0JChcImRpdi51aS1kcmFnZ2FibGUtaWZyYW1lRml4XCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdFx0fSk7XG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0b3BwZWQgKHNlZSAjNTAwMylcblx0XHRpZiggJC51aS5kZG1hbmFnZXIgKSAkLnVpLmRkbWFuYWdlci5kcmFnU3RvcCh0aGlzLCBldmVudCk7XG5cblx0XHRyZXR1cm4gJC51aS5tb3VzZS5wcm90b3R5cGUuX21vdXNlVXAuY2FsbCh0aGlzLCBldmVudCk7XG5cdH0sXG5cblx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuaGVscGVyLmlzKFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKSkge1xuXHRcdFx0dGhpcy5fbW91c2VVcCh7fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfZ2V0SGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIGhhbmRsZSA9ICF0aGlzLm9wdGlvbnMuaGFuZGxlIHx8ICEkKHRoaXMub3B0aW9ucy5oYW5kbGUsIHRoaXMuZWxlbWVudCkubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdCQodGhpcy5vcHRpb25zLmhhbmRsZSwgdGhpcy5lbGVtZW50KVxuXHRcdFx0LmZpbmQoXCIqXCIpXG5cdFx0XHQuYW5kU2VsZigpXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYodGhpcyA9PSBldmVudC50YXJnZXQpIGhhbmRsZSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBoYW5kbGU7XG5cblx0fSxcblxuXHRfY3JlYXRlSGVscGVyOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0dmFyIGhlbHBlciA9ICQuaXNGdW5jdGlvbihvLmhlbHBlcikgPyAkKG8uaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50XSkpIDogKG8uaGVscGVyID09ICdjbG9uZScgPyB0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKCdpZCcpIDogdGhpcy5lbGVtZW50KTtcblxuXHRcdGlmKCFoZWxwZXIucGFyZW50cygnYm9keScpLmxlbmd0aClcblx0XHRcdGhlbHBlci5hcHBlbmRUbygoby5hcHBlbmRUbyA9PSAncGFyZW50JyA/IHRoaXMuZWxlbWVudFswXS5wYXJlbnROb2RlIDogby5hcHBlbmRUbykpO1xuXG5cdFx0aWYoaGVscGVyWzBdICE9IHRoaXMuZWxlbWVudFswXSAmJiAhKC8oZml4ZWR8YWJzb2x1dGUpLykudGVzdChoZWxwZXIuY3NzKFwicG9zaXRpb25cIikpKVxuXHRcdFx0aGVscGVyLmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XG5cblx0XHRyZXR1cm4gaGVscGVyO1xuXG5cdH0sXG5cblx0X2FkanVzdE9mZnNldEZyb21IZWxwZXI6IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09ICdzdHJpbmcnKSB7XG5cdFx0XHRvYmogPSBvYmouc3BsaXQoJyAnKTtcblx0XHR9XG5cdFx0aWYgKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRvYmogPSB7bGVmdDogK29ialswXSwgdG9wOiArb2JqWzFdIHx8IDB9O1xuXHRcdH1cblx0XHRpZiAoJ2xlZnQnIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmICgncmlnaHQnIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSBvYmoucmlnaHQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKCd0b3AnIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHRcdGlmICgnYm90dG9tJyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXG5cdFx0dGhpcy5vZmZzZXRQYXJlbnQgPSB0aGlzLmhlbHBlci5vZmZzZXRQYXJlbnQoKTtcblx0XHR2YXIgcG8gPSB0aGlzLm9mZnNldFBhcmVudC5vZmZzZXQoKTtcblxuXHRcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBtb2RpZnkgYSBvZmZzZXQgY2FsY3VsYXRlZCBvbiBzdGFydCwgc2luY2UgdGhlIGZvbGxvd2luZyBoYXBwZW5lZDpcblx0XHQvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XG5cdFx0Ly8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndCB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoYXRcblx0XHQvLyAgICB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCwgYW5kIG5ldmVyIHJlY2FsY3VsYXRlZCB1cG9uIGRyYWdcblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09ICdhYnNvbHV0ZScgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHRpZigodGhpcy5vZmZzZXRQYXJlbnRbMF0gPT0gZG9jdW1lbnQuYm9keSkgLy9UaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpcyBpbmZvcm1hdGlvblxuXHRcdHx8ICh0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lICYmIHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnaHRtbCcgJiYgJC51aS5pZSkpIC8vVWdseSBJRSBmaXhcblx0XHRcdHBvID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT0gXCJyZWxhdGl2ZVwiKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuZWxlbWVudC5wb3NpdGlvbigpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBwLnRvcCAtIChwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXCJ0b3BcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdGxlZnQ6IHAubGVmdCAtIChwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXCJsZWZ0XCIpLDEwKSB8fCAwKSArIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdH0sXG5cblx0X2NhY2hlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tYXJnaW5zID0ge1xuXHRcdFx0bGVmdDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5MZWZ0XCIpLDEwKSB8fCAwKSxcblx0XHRcdHRvcDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Ub3BcIiksMTApIHx8IDApLFxuXHRcdFx0cmlnaHQ6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luUmlnaHRcIiksMTApIHx8IDApLFxuXHRcdFx0Ym90dG9tOiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpbkJvdHRvbVwiKSwxMCkgfHwgMClcblx0XHR9O1xuXHR9LFxuXG5cdF9jYWNoZUhlbHBlclByb3BvcnRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zID0ge1xuXHRcdFx0d2lkdGg6IHRoaXMuaGVscGVyLm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5oZWxwZXIub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdH0sXG5cblx0X3NldENvbnRhaW5tZW50OiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdGlmKG8uY29udGFpbm1lbnQgPT0gJ3BhcmVudCcpIG8uY29udGFpbm1lbnQgPSB0aGlzLmhlbHBlclswXS5wYXJlbnROb2RlO1xuXHRcdGlmKG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyB8fCBvLmNvbnRhaW5tZW50ID09ICd3aW5kb3cnKSB0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0by5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gMCA6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgPyAwIDogJCh3aW5kb3cpLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdChvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgPyAwIDogJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkgKyAkKG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyA/IGRvY3VtZW50IDogd2luZG93KS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0KG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyA/IDAgOiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpICsgKCQoby5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gZG9jdW1lbnQgOiB3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XTtcblxuXHRcdGlmKCEoL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLykudGVzdChvLmNvbnRhaW5tZW50KSAmJiBvLmNvbnRhaW5tZW50LmNvbnN0cnVjdG9yICE9IEFycmF5KSB7XG5cdFx0XHR2YXIgYyA9ICQoby5jb250YWlubWVudCk7XG5cdFx0XHR2YXIgY2UgPSBjWzBdOyBpZighY2UpIHJldHVybjtcblx0XHRcdHZhciBjbyA9IGMub2Zmc2V0KCk7XG5cdFx0XHR2YXIgb3ZlciA9ICgkKGNlKS5jc3MoXCJvdmVyZmxvd1wiKSAhPSAnaGlkZGVuJyk7XG5cblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdMZWZ0XCIpLDEwKSB8fCAwKSxcblx0XHRcdFx0KHBhcnNlSW50KCQoY2UpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nVG9wXCIpLDEwKSB8fCAwKSxcblx0XHRcdFx0KG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxXaWR0aCxjZS5vZmZzZXRXaWR0aCkgOiBjZS5vZmZzZXRXaWR0aCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0IC0gdGhpcy5tYXJnaW5zLnJpZ2h0LFxuXHRcdFx0XHQob3ZlciA/IE1hdGgubWF4KGNlLnNjcm9sbEhlaWdodCxjZS5vZmZzZXRIZWlnaHQpIDogY2Uub2Zmc2V0SGVpZ2h0KSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwicGFkZGluZ0JvdHRvbVwiKSwxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3AgIC0gdGhpcy5tYXJnaW5zLmJvdHRvbVxuXHRcdFx0XTtcblx0XHRcdHRoaXMucmVsYXRpdmVfY29udGFpbmVyID0gYztcblxuXHRcdH0gZWxzZSBpZihvLmNvbnRhaW5tZW50LmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcblx0XHR9XG5cblx0fSxcblxuXHRfY29udmVydFBvc2l0aW9uVG86IGZ1bmN0aW9uKGQsIHBvcykge1xuXG5cdFx0aWYoIXBvcykgcG9zID0gdGhpcy5wb3NpdGlvbjtcblx0XHR2YXIgbW9kID0gZCA9PSBcImFic29sdXRlXCIgPyAxIDogLTE7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT0gJ2Fic29sdXRlJyAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LCBzY3JvbGxJc1Jvb3ROb2RlID0gKC8oaHRtbHxib2R5KS9pKS50ZXN0KHNjcm9sbFswXS50YWdOYW1lKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cG9zLnRvcFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0KyB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2RcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2RcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0LSAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogKCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkgKiBtb2QpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwb3MubGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdCsgdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdCsgdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2RcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0LSAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSApICogbW9kKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09ICdhYnNvbHV0ZScgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCwgc2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cdFx0dmFyIHBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cblx0XHQgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxuXHRcdCAqL1xuXG5cdFx0aWYodGhpcy5vcmlnaW5hbFBvc2l0aW9uKSB7IC8vSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXG5cdFx0XHR2YXIgY29udGFpbm1lbnQ7XG5cdFx0XHRpZih0aGlzLmNvbnRhaW5tZW50KSB7XG5cdFx0XHRpZiAodGhpcy5yZWxhdGl2ZV9jb250YWluZXIpe1xuXHRcdFx0XHR2YXIgY28gPSB0aGlzLnJlbGF0aXZlX2NvbnRhaW5lci5vZmZzZXQoKTtcblx0XHRcdFx0Y29udGFpbm1lbnQgPSBbIHRoaXMuY29udGFpbm1lbnRbMF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbMV0gKyBjby50b3AsXG5cdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsyXSArIGNvLmxlZnQsXG5cdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFszXSArIGNvLnRvcCBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnRhaW5tZW50ID0gdGhpcy5jb250YWlubWVudDtcblx0XHRcdH1cblxuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCBjb250YWlubWVudFswXSkgcGFnZVggPSBjb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wIDwgY29udGFpbm1lbnRbMV0pIHBhZ2VZID0gY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WzJdKSBwYWdlWCA9IGNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkgcGFnZVkgPSBjb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdH1cblxuXHRcdFx0aWYoby5ncmlkKSB7XG5cdFx0XHRcdC8vQ2hlY2sgZm9yIGdyaWQgZWxlbWVudHMgc2V0IHRvIDAgdG8gcHJldmVudCBkaXZpZGUgYnkgMCBlcnJvciBjYXVzaW5nIGludmFsaWQgYXJndW1lbnQgZXJyb3JzIGluIElFIChzZWUgdGlja2V0ICM2OTUwKVxuXHRcdFx0XHR2YXIgdG9wID0gby5ncmlkWzFdID8gdGhpcy5vcmlnaW5hbFBhZ2VZICsgTWF0aC5yb3VuZCgocGFnZVkgLSB0aGlzLm9yaWdpbmFsUGFnZVkpIC8gby5ncmlkWzFdKSAqIG8uZ3JpZFsxXSA6IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudCA/ICghKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdIHx8IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSA/IHRvcCA6ICghKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdHZhciBsZWZ0ID0gby5ncmlkWzBdID8gdGhpcy5vcmlnaW5hbFBhZ2VYICsgTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVgpIC8gby5ncmlkWzBdKSAqIG8uZ3JpZFswXSA6IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudCA/ICghKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0gfHwgbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkgPyBsZWZ0IDogKCEobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCBjb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVlcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5wYXJlbnQudG9wXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KyAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogKCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwYWdlWFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KyAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSApKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyLnJlbW92ZUNsYXNzKFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpO1xuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9IHRoaXMuZWxlbWVudFswXSAmJiAhdGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsKSB0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHQvL2lmKCQudWkuZGRtYW5hZ2VyKSAkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gbnVsbDtcblx0XHR0aGlzLmhlbHBlciA9IG51bGw7XG5cdFx0dGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gRnJvbSBub3cgb24gYnVsayBzdHVmZiAtIG1haW5seSBoZWxwZXJzXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCB1aSkge1xuXHRcdHVpID0gdWkgfHwgdGhpcy5fdWlIYXNoKCk7XG5cdFx0JC51aS5wbHVnaW4uY2FsbCh0aGlzLCB0eXBlLCBbZXZlbnQsIHVpXSk7XG5cdFx0aWYodHlwZSA9PSBcImRyYWdcIikgdGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7IC8vVGhlIGFic29sdXRlIHBvc2l0aW9uIGhhcyB0byBiZSByZWNhbGN1bGF0ZWQgYWZ0ZXIgcGx1Z2luc1xuXHRcdHJldHVybiAkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCh0aGlzLCB0eXBlLCBldmVudCwgdWkpO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogdGhpcy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcblx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdG9mZnNldDogdGhpcy5wb3NpdGlvbkFic1xuXHRcdH07XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImNvbm5lY3RUb1NvcnRhYmxlXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksIG8gPSBpbnN0Lm9wdGlvbnMsXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblx0XHRpbnN0LnNvcnRhYmxlcyA9IFtdO1xuXHRcdCQoby5jb25uZWN0VG9Tb3J0YWJsZSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9ICQuZGF0YSh0aGlzLCAnc29ydGFibGUnKTtcblx0XHRcdGlmIChzb3J0YWJsZSAmJiAhc29ydGFibGUub3B0aW9ucy5kaXNhYmxlZCkge1xuXHRcdFx0XHRpbnN0LnNvcnRhYmxlcy5wdXNoKHtcblx0XHRcdFx0XHRpbnN0YW5jZTogc29ydGFibGUsXG5cdFx0XHRcdFx0c2hvdWxkUmV2ZXJ0OiBzb3J0YWJsZS5vcHRpb25zLnJldmVydFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29ydGFibGUucmVmcmVzaFBvc2l0aW9ucygpO1x0Ly8gQ2FsbCB0aGUgc29ydGFibGUncyByZWZyZXNoUG9zaXRpb25zIGF0IGRyYWcgc3RhcnQgdG8gcmVmcmVzaCB0aGUgY29udGFpbmVyQ2FjaGUgc2luY2UgdGhlIHNvcnRhYmxlIGNvbnRhaW5lciBjYWNoZSBpcyB1c2VkIGluIGRyYWcgYW5kIG5lZWRzIHRvIGJlIHVwIHRvIGRhdGUgKHRoaXMgd2lsbCBlbnN1cmUgaXQncyBpbml0aWFsaXNlZCBhcyB3ZWxsIGFzIGJlaW5nIGtlcHQgaW4gc3RlcCB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHQgaGF2ZSBoYXBwZW5lZCBvbiB0aGUgcGFnZSkuXG5cdFx0XHRcdHNvcnRhYmxlLl90cmlnZ2VyKFwiYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgc3RpbGwgb3ZlciB0aGUgc29ydGFibGUsIHdlIGZha2UgdGhlIHN0b3AgZXZlbnQgb2YgdGhlIHNvcnRhYmxlLCBidXQgYWxzbyByZW1vdmUgaGVscGVyXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblxuXHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMDtcblxuXHRcdFx0XHRpbnN0LmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlOyAvL0Rvbid0IHJlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBkcmFnZ2FibGUgaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7IC8vUmVtb3ZlIGl0IGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSAoc28gc29ydGFibGUgcGx1Z2lucyBsaWtlIHJldmVydCBzdGlsbCB3b3JrKVxuXG5cdFx0XHRcdC8vVGhlIHNvcnRhYmxlIHJldmVydCBpcyBzdXBwb3J0ZWQsIGFuZCB3ZSBoYXZlIHRvIHNldCBhIHRlbXBvcmFyeSBkcm9wcGVkIHZhcmlhYmxlIG9uIHRoZSBkcmFnZ2FibGUgdG8gc3VwcG9ydCByZXZlcnQ6ICd2YWxpZC9pbnZhbGlkJ1xuXHRcdFx0XHRpZih0aGlzLnNob3VsZFJldmVydCkgdGhpcy5pbnN0YW5jZS5vcHRpb25zLnJldmVydCA9IHRydWU7XG5cblx0XHRcdFx0Ly9UcmlnZ2VyIHRoZSBzdG9wIG9mIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0b3AoZXZlbnQpO1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuX2hlbHBlcjtcblxuXHRcdFx0XHQvL0lmIHRoZSBoZWxwZXIgaGFzIGJlZW4gdGhlIG9yaWdpbmFsIGl0ZW0sIHJlc3RvcmUgcHJvcGVydGllcyBpbiB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYoaW5zdC5vcHRpb25zLmhlbHBlciA9PSAnb3JpZ2luYWwnKVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0uY3NzKHsgdG9wOiAnYXV0bycsIGxlZnQ6ICdhdXRvJyB9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7IC8vUmVtb3ZlIHRoZSBoZWxwZXIgaW4gdGhlIHNvcnRhYmxlIGluc3RhbmNlXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsIGV2ZW50LCB1aVNvcnRhYmxlKTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksIHRoYXQgPSB0aGlzO1xuXG5cdFx0dmFyIGNoZWNrUG9zID0gZnVuY3Rpb24obykge1xuXHRcdFx0dmFyIGR5Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay50b3AsIGR4Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0dmFyIGhlbHBlclRvcCA9IHRoaXMucG9zaXRpb25BYnMudG9wLCBoZWxwZXJMZWZ0ID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0O1xuXHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBvLmhlaWdodCwgaXRlbVdpZHRoID0gby53aWR0aDtcblx0XHRcdHZhciBpdGVtVG9wID0gby50b3AsIGl0ZW1MZWZ0ID0gby5sZWZ0O1xuXG5cdFx0XHRyZXR1cm4gJC51aS5pc092ZXIoaGVscGVyVG9wICsgZHlDbGljaywgaGVscGVyTGVmdCArIGR4Q2xpY2ssIGl0ZW1Ub3AsIGl0ZW1MZWZ0LCBpdGVtSGVpZ2h0LCBpdGVtV2lkdGgpO1xuXHRcdH07XG5cblx0XHQkLmVhY2goaW5zdC5zb3J0YWJsZXMsIGZ1bmN0aW9uKGkpIHtcblxuXHRcdFx0dmFyIGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlO1xuXHRcdFx0dmFyIHRoaXNTb3J0YWJsZSA9IHRoaXM7XG5cdFx0XHQvL0NvcHkgb3ZlciBzb21lIHZhcmlhYmxlcyB0byBhbGxvdyBjYWxsaW5nIHRoZSBzb3J0YWJsZSdzIG5hdGl2ZSBfaW50ZXJzZWN0c1dpdGhcblx0XHRcdHRoaXMuaW5zdGFuY2UucG9zaXRpb25BYnMgPSBpbnN0LnBvc2l0aW9uQWJzO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGluc3QuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljayA9IGluc3Qub2Zmc2V0LmNsaWNrO1xuXG5cdFx0XHRpZih0aGlzLmluc3RhbmNlLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmluc3RhbmNlLmNvbnRhaW5lckNhY2hlKSkge1xuXHRcdFx0XHRpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSB0cnVlO1xuXHRcdFx0XHQkLmVhY2goaW5zdC5zb3J0YWJsZXMsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLnBvc2l0aW9uQWJzID0gaW5zdC5wb3NpdGlvbkFicztcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmhlbHBlclByb3BvcnRpb25zID0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucztcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljayA9IGluc3Qub2Zmc2V0LmNsaWNrO1xuXHRcdFx0XHRcdGlmICAodGhpcyAhPSB0aGlzU29ydGFibGVcblx0XHRcdFx0XHRcdCYmIHRoaXMuaW5zdGFuY2UuX2ludGVyc2VjdHNXaXRoKHRoaXMuaW5zdGFuY2UuY29udGFpbmVyQ2FjaGUpXG5cdFx0XHRcdFx0XHQmJiAkLnVpLmNvbnRhaW5zKHRoaXNTb3J0YWJsZS5pbnN0YW5jZS5lbGVtZW50WzBdLCB0aGlzLmluc3RhbmNlLmVsZW1lbnRbMF0pKVxuXHRcdFx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5uZXJtb3N0SW50ZXJzZWN0aW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZihpbm5lcm1vc3RJbnRlcnNlY3RpbmcpIHtcblx0XHRcdFx0Ly9JZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSwgc28gb3VyIG1vdmUtaW4gc3R1ZmYgZ2V0cyBmaXJlZCBvbmx5IG9uY2Vcblx0XHRcdFx0aWYoIXRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDE7XG5cdFx0XHRcdFx0Ly9Ob3cgd2UgZmFrZSB0aGUgc3RhcnQgb2YgZHJhZ2dpbmcgZm9yIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSxcblx0XHRcdFx0XHQvL2J5IGNsb25pbmcgdGhlIGxpc3QgZ3JvdXAgaXRlbSwgYXBwZW5kaW5nIGl0IHRvIHRoZSBzb3J0YWJsZSBhbmQgdXNpbmcgaXQgYXMgaW5zdC5jdXJyZW50SXRlbVxuXHRcdFx0XHRcdC8vV2UgY2FuIHRoZW4gZmlyZSB0aGUgc3RhcnQgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIHdpdGggb3VyIHBhc3NlZCBicm93c2VyIGV2ZW50LCBhbmQgb3VyIG93biBoZWxwZXIgKHNvIGl0IGRvZXNuJ3QgY3JlYXRlIGEgbmV3IG9uZSlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtID0gJCh0aGF0KS5jbG9uZSgpLnJlbW92ZUF0dHIoJ2lkJykuYXBwZW5kVG8odGhpcy5pbnN0YW5jZS5lbGVtZW50KS5kYXRhKFwic29ydGFibGUtaXRlbVwiLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuX2hlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXI7IC8vU3RvcmUgaGVscGVyIG9wdGlvbiB0byBsYXRlciByZXN0b3JlIGl0XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdWkuaGVscGVyWzBdOyB9O1xuXG5cdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbVswXTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZUNhcHR1cmUoZXZlbnQsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RhcnQoZXZlbnQsIHRydWUsIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9CZWNhdXNlIHRoZSBicm93c2VyIGV2ZW50IGlzIHdheSBvZmYgdGhlIG5ldyBhcHBlbmRlZCBwb3J0bGV0LCB3ZSBtb2RpZnkgYSBjb3VwbGUgb2YgdmFyaWFibGVzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXNcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljay50b3AgPSBpbnN0Lm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2subGVmdCA9IGluc3Qub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LmxlZnQgLT0gaW5zdC5vZmZzZXQucGFyZW50LmxlZnQgLSB0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQubGVmdDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQudG9wIC09IGluc3Qub2Zmc2V0LnBhcmVudC50b3AgLSB0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQudG9wO1xuXG5cdFx0XHRcdFx0aW5zdC5fdHJpZ2dlcihcInRvU29ydGFibGVcIiwgZXZlbnQpO1xuXHRcdFx0XHRcdGluc3QuZHJvcHBlZCA9IHRoaXMuaW5zdGFuY2UuZWxlbWVudDsgLy9kcmFnZ2FibGUgcmV2ZXJ0IG5lZWRzIHRoYXRcblx0XHRcdFx0XHQvL2hhY2sgc28gcmVjZWl2ZS91cGRhdGUgY2FsbGJhY2tzIHdvcmsgKG1vc3RseSlcblx0XHRcdFx0XHRpbnN0LmN1cnJlbnRJdGVtID0gaW5zdC5lbGVtZW50O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuZnJvbU91dHNpZGUgPSBpbnN0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1Byb3ZpZGVkIHdlIGRpZCBhbGwgdGhlIHByZXZpb3VzIHN0ZXBzLCB3ZSBjYW4gZmlyZSB0aGUgZHJhZyBldmVudCBvZiB0aGUgc29ydGFibGUgb24gZXZlcnkgZHJhZ2dhYmxlIGRyYWcsIHdoZW4gaXQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHRpZih0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtKSB0aGlzLmluc3RhbmNlLl9tb3VzZURyYWcoZXZlbnQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vSWYgaXQgZG9lc24ndCBpbnRlcnNlY3Qgd2l0aCB0aGUgc29ydGFibGUsIGFuZCBpdCBpbnRlcnNlY3RlZCBiZWZvcmUsXG5cdFx0XHRcdC8vd2UgZmFrZSB0aGUgZHJhZyBzdG9wIG9mIHRoZSBzb3J0YWJsZSwgYnV0IG1ha2Ugc3VyZSBpdCBkb2Vzbid0IHJlbW92ZSB0aGUgaGVscGVyIGJ5IHVzaW5nIGNhbmNlbEhlbHBlclJlbW92YWxcblx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5pc092ZXIpIHtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly9QcmV2ZW50IHJldmVydGluZyBvbiB0aGlzIGZvcmNlZCBzdG9wXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLnJldmVydCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIG91dCBldmVudCBuZWVkcyB0byBiZSB0cmlnZ2VyZWQgaW5kZXBlbmRlbnRseVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX3RyaWdnZXIoJ291dCcsIGV2ZW50LCB0aGlzLmluc3RhbmNlLl91aUhhc2godGhpcy5pbnN0YW5jZSkpO1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdG9wKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXI7XG5cblx0XHRcdFx0XHQvL05vdyB3ZSByZW1vdmUgb3VyIGN1cnJlbnRJdGVtLCB0aGUgbGlzdCBncm91cCBjbG9uZSBhZ2FpbiwgYW5kIHRoZSBwbGFjZWhvbGRlciwgYW5kIGFuaW1hdGUgdGhlIGhlbHBlciBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgc2l6ZVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlcikgdGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlci5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdGluc3QuX3RyaWdnZXIoXCJmcm9tU29ydGFibGVcIiwgZXZlbnQpO1xuXHRcdFx0XHRcdGluc3QuZHJvcHBlZCA9IGZhbHNlOyAvL2RyYWdnYWJsZSByZXZlcnQgbmVlZHMgdGhhdFxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KTtcblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwiY3Vyc29yXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciB0ID0gJCgnYm9keScpLCBvID0gJCh0aGlzKS5kYXRhKCdkcmFnZ2FibGUnKS5vcHRpb25zO1xuXHRcdGlmICh0LmNzcyhcImN1cnNvclwiKSkgby5fY3Vyc29yID0gdC5jc3MoXCJjdXJzb3JcIik7XG5cdFx0dC5jc3MoXCJjdXJzb3JcIiwgby5jdXJzb3IpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YSgnZHJhZ2dhYmxlJykub3B0aW9ucztcblx0XHRpZiAoby5fY3Vyc29yKSAkKCdib2R5JykuY3NzKFwiY3Vyc29yXCIsIG8uX2N1cnNvcik7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJvcGFjaXR5XCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciB0ID0gJCh1aS5oZWxwZXIpLCBvID0gJCh0aGlzKS5kYXRhKCdkcmFnZ2FibGUnKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwib3BhY2l0eVwiKSkgby5fb3BhY2l0eSA9IHQuY3NzKFwib3BhY2l0eVwiKTtcblx0XHR0LmNzcygnb3BhY2l0eScsIG8ub3BhY2l0eSk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKCdkcmFnZ2FibGUnKS5vcHRpb25zO1xuXHRcdGlmKG8uX29wYWNpdHkpICQodWkuaGVscGVyKS5jc3MoJ29wYWNpdHknLCBvLl9vcGFjaXR5KTtcblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInNjcm9sbFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKTtcblx0XHRpZihpLnNjcm9sbFBhcmVudFswXSAhPSBkb2N1bWVudCAmJiBpLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9ICdIVE1MJykgaS5vdmVyZmxvd09mZnNldCA9IGkuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLCBvID0gaS5vcHRpb25zLCBzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0aWYoaS5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPSAnSFRNTCcpIHtcblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT0gJ3gnKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LnRvcCArIGkuc2Nyb2xsUGFyZW50WzBdLm9mZnNldEhlaWdodCkgLSBldmVudC5wYWdlWSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHRlbHNlIGlmKGV2ZW50LnBhZ2VZIC0gaS5vdmVyZmxvd09mZnNldC50b3AgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wIC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT0gJ3knKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRXaWR0aCkgLSBldmVudC5wYWdlWCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdGVsc2UgaWYoZXZlbnQucGFnZVggLSBpLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT0gJ3gnKSB7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdGVsc2UgaWYoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSArIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPSAneScpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0ZWxzZSBpZigkKHdpbmRvdykud2lkdGgoKSAtIChldmVudC5wYWdlWCAtICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmKHNjcm9sbGVkICE9PSBmYWxzZSAmJiAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKVxuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoaSwgZXZlbnQpO1xuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzbmFwXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksIG8gPSBpLm9wdGlvbnM7XG5cdFx0aS5zbmFwRWxlbWVudHMgPSBbXTtcblxuXHRcdCQoby5zbmFwLmNvbnN0cnVjdG9yICE9IFN0cmluZyA/ICggby5zbmFwLml0ZW1zIHx8ICc6ZGF0YShkcmFnZ2FibGUpJyApIDogby5zbmFwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICR0ID0gJCh0aGlzKTsgdmFyICRvID0gJHQub2Zmc2V0KCk7XG5cdFx0XHRpZih0aGlzICE9IGkuZWxlbWVudFswXSkgaS5zbmFwRWxlbWVudHMucHVzaCh7XG5cdFx0XHRcdGl0ZW06IHRoaXMsXG5cdFx0XHRcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0dG9wOiAkby50b3AsIGxlZnQ6ICRvLmxlZnRcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksIG8gPSBpbnN0Lm9wdGlvbnM7XG5cdFx0dmFyIGQgPSBvLnNuYXBUb2xlcmFuY2U7XG5cblx0XHR2YXIgeDEgPSB1aS5vZmZzZXQubGVmdCwgeDIgPSB4MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MSA9IHVpLm9mZnNldC50b3AsIHkyID0geTEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodDtcblxuXHRcdGZvciAodmFyIGkgPSBpbnN0LnNuYXBFbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cblx0XHRcdHZhciBsID0gaW5zdC5zbmFwRWxlbWVudHNbaV0ubGVmdCwgciA9IGwgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS53aWR0aCxcblx0XHRcdFx0dCA9IGluc3Quc25hcEVsZW1lbnRzW2ldLnRvcCwgYiA9IHQgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS5oZWlnaHQ7XG5cblx0XHRcdC8vWWVzLCBJIGtub3csIHRoaXMgaXMgaW5zYW5lIDspXG5cdFx0XHRpZighKChsLWQgPCB4MSAmJiB4MSA8IHIrZCAmJiB0LWQgPCB5MSAmJiB5MSA8IGIrZCkgfHwgKGwtZCA8IHgxICYmIHgxIDwgcitkICYmIHQtZCA8IHkyICYmIHkyIDwgYitkKSB8fCAobC1kIDwgeDIgJiYgeDIgPCByK2QgJiYgdC1kIDwgeTEgJiYgeTEgPCBiK2QpIHx8IChsLWQgPCB4MiAmJiB4MiA8IHIrZCAmJiB0LWQgPCB5MiAmJiB5MiA8IGIrZCkpKSB7XG5cdFx0XHRcdGlmKGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nKSAoaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZSAmJiBpbnN0Lm9wdGlvbnMuc25hcC5yZWxlYXNlLmNhbGwoaW5zdC5lbGVtZW50LCBldmVudCwgJC5leHRlbmQoaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0gfSkpKTtcblx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uc25hcE1vZGUgIT0gJ2lubmVyJykge1xuXHRcdFx0XHR2YXIgdHMgPSBNYXRoLmFicyh0IC0geTIpIDw9IGQ7XG5cdFx0XHRcdHZhciBicyA9IE1hdGguYWJzKGIgLSB5MSkgPD0gZDtcblx0XHRcdFx0dmFyIGxzID0gTWF0aC5hYnMobCAtIHgyKSA8PSBkO1xuXHRcdFx0XHR2YXIgcnMgPSBNYXRoLmFicyhyIC0geDEpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiB0IC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0aWYoYnMpIHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0aWYobHMpIHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiAwLCBsZWZ0OiBsIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdGlmKHJzKSB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaXJzdCA9ICh0cyB8fCBicyB8fCBscyB8fCBycyk7XG5cblx0XHRcdGlmKG8uc25hcE1vZGUgIT0gJ291dGVyJykge1xuXHRcdFx0XHR2YXIgdHMgPSBNYXRoLmFicyh0IC0geTEpIDw9IGQ7XG5cdFx0XHRcdHZhciBicyA9IE1hdGguYWJzKGIgLSB5MikgPD0gZDtcblx0XHRcdFx0dmFyIGxzID0gTWF0aC5hYnMobCAtIHgxKSA8PSBkO1xuXHRcdFx0XHR2YXIgcnMgPSBNYXRoLmFicyhyIC0geDIpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiB0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdGlmKGJzKSB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiBiIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0aWYobHMpIHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiAwLCBsZWZ0OiBsIH0pLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcblx0XHRcdFx0aWYocnMpIHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiAwLCBsZWZ0OiByIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyAmJiAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpKVxuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnNuYXAuc25hcCAmJiBpbnN0Lm9wdGlvbnMuc25hcC5zbmFwLmNhbGwoaW5zdC5lbGVtZW50LCBldmVudCwgJC5leHRlbmQoaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0gfSkpKTtcblx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KTtcblxuXHRcdH07XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInN0YWNrXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIG8gPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIikub3B0aW9ucztcblxuXHRcdHZhciBncm91cCA9ICQubWFrZUFycmF5KCQoby5zdGFjaykpLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRyZXR1cm4gKHBhcnNlSW50KCQoYSkuY3NzKFwiekluZGV4XCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCk7XG5cdFx0fSk7XG5cdFx0aWYgKCFncm91cC5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWluID0gcGFyc2VJbnQoZ3JvdXBbMF0uc3R5bGUuekluZGV4KSB8fCAwO1xuXHRcdCQoZ3JvdXApLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0dGhpcy5zdHlsZS56SW5kZXggPSBtaW4gKyBpO1xuXHRcdH0pO1xuXG5cdFx0dGhpc1swXS5zdHlsZS56SW5kZXggPSBtaW4gKyBncm91cC5sZW5ndGg7XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInpJbmRleFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwiekluZGV4XCIpKSBvLl96SW5kZXggPSB0LmNzcyhcInpJbmRleFwiKTtcblx0XHR0LmNzcygnekluZGV4Jywgby56SW5kZXgpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKG8uX3pJbmRleCkgJCh1aS5oZWxwZXIpLmNzcygnekluZGV4Jywgby5fekluZGV4KTtcblx0fVxufSk7XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5kcm9wcGFibGVcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcImRyb3BcIixcblx0b3B0aW9uczoge1xuXHRcdGFjY2VwdDogJyonLFxuXHRcdGFjdGl2ZUNsYXNzOiBmYWxzZSxcblx0XHRhZGRDbGFzc2VzOiB0cnVlLFxuXHRcdGdyZWVkeTogZmFsc2UsXG5cdFx0aG92ZXJDbGFzczogZmFsc2UsXG5cdFx0c2NvcGU6ICdkZWZhdWx0Jyxcblx0XHR0b2xlcmFuY2U6ICdpbnRlcnNlY3QnXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIGFjY2VwdCA9IG8uYWNjZXB0O1xuXHRcdHRoaXMuaXNvdmVyID0gMDsgdGhpcy5pc291dCA9IDE7XG5cblx0XHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0IDogZnVuY3Rpb24oZCkge1xuXHRcdFx0cmV0dXJuIGQuaXMoYWNjZXB0KTtcblx0XHR9O1xuXG5cdFx0Ly9TdG9yZSB0aGUgZHJvcHBhYmxlJ3MgcHJvcG9ydGlvbnNcblx0XHR0aGlzLnByb3BvcnRpb25zID0geyB3aWR0aDogdGhpcy5lbGVtZW50WzBdLm9mZnNldFdpZHRoLCBoZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5vZmZzZXRIZWlnaHQgfTtcblxuXHRcdC8vIEFkZCB0aGUgcmVmZXJlbmNlIGFuZCBwb3NpdGlvbnMgdG8gdGhlIG1hbmFnZXJcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW28uc2NvcGVdID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tvLnNjb3BlXSB8fCBbXTtcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW28uc2NvcGVdLnB1c2godGhpcyk7XG5cblx0XHQoby5hZGRDbGFzc2VzICYmIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyb3BwYWJsZVwiKSk7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRyb3AgPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3RoaXMub3B0aW9ucy5zY29wZV07XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZHJvcC5sZW5ndGg7IGkrKyApXG5cdFx0XHRpZiAoIGRyb3BbaV0gPT0gdGhpcyApXG5cdFx0XHRcdGRyb3Auc3BsaWNlKGksIDEpO1xuXG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktZHJvcHBhYmxlIHVpLWRyb3BwYWJsZS1kaXNhYmxlZFwiKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cblx0XHRpZihrZXkgPT0gJ2FjY2VwdCcpIHtcblx0XHRcdHRoaXMuYWNjZXB0ID0gJC5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRyZXR1cm4gZC5pcyh2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHQkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcblx0XHRpZih0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdChkcmFnZ2FibGUgJiYgdGhpcy5fdHJpZ2dlcignYWN0aXZhdGUnLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKSk7XG5cdH0sXG5cblx0X2RlYWN0aXZhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHQoZHJhZ2dhYmxlICYmIHRoaXMuX3RyaWdnZXIoJ2RlYWN0aXZhdGUnLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKSk7XG5cdH0sXG5cblx0X292ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcblx0XHRpZiAoIWRyYWdnYWJsZSB8fCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KVswXSA9PSB0aGlzLmVsZW1lbnRbMF0pIHJldHVybjsgLy8gQmFpbCBpZiBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBhcmUgc2FtZSBlbGVtZW50XG5cblx0XHRpZiAodGhpcy5hY2NlcHQuY2FsbCh0aGlzLmVsZW1lbnRbMF0sKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpKSB7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcykgdGhpcy5lbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ292ZXInLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcblx0XHR9XG5cblx0fSxcblxuXHRfb3V0OiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYgKCFkcmFnZ2FibGUgfHwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudClbMF0gPT0gdGhpcy5lbGVtZW50WzBdKSByZXR1cm47IC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXG5cdFx0aWYgKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdvdXQnLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcblx0XHR9XG5cblx0fSxcblxuXHRfZHJvcDogZnVuY3Rpb24oZXZlbnQsY3VzdG9tKSB7XG5cblx0XHR2YXIgZHJhZ2dhYmxlID0gY3VzdG9tIHx8ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYgKCFkcmFnZ2FibGUgfHwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudClbMF0gPT0gdGhpcy5lbGVtZW50WzBdKSByZXR1cm4gZmFsc2U7IC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXG5cdFx0dmFyIGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoXCI6ZGF0YShkcm9wcGFibGUpXCIpLm5vdChcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIikuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbnN0ID0gJC5kYXRhKHRoaXMsICdkcm9wcGFibGUnKTtcblx0XHRcdGlmKFxuXHRcdFx0XHRpbnN0Lm9wdGlvbnMuZ3JlZWR5XG5cdFx0XHRcdCYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWRcblx0XHRcdFx0JiYgaW5zdC5vcHRpb25zLnNjb3BlID09IGRyYWdnYWJsZS5vcHRpb25zLnNjb3BlXG5cdFx0XHRcdCYmIGluc3QuYWNjZXB0LmNhbGwoaW5zdC5lbGVtZW50WzBdLCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSlcblx0XHRcdFx0JiYgJC51aS5pbnRlcnNlY3QoZHJhZ2dhYmxlLCAkLmV4dGVuZChpbnN0LCB7IG9mZnNldDogaW5zdC5lbGVtZW50Lm9mZnNldCgpIH0pLCBpbnN0Lm9wdGlvbnMudG9sZXJhbmNlKVxuXHRcdFx0KSB7IGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gdHJ1ZTsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fSk7XG5cdFx0aWYoY2hpbGRyZW5JbnRlcnNlY3Rpb24pIHJldHVybiBmYWxzZTtcblxuXHRcdGlmKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignZHJvcCcsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHR1aTogZnVuY3Rpb24oYykge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkcmFnZ2FibGU6IChjLmN1cnJlbnRJdGVtIHx8IGMuZWxlbWVudCksXG5cdFx0XHRoZWxwZXI6IGMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IGMucG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IGMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLmludGVyc2VjdCA9IGZ1bmN0aW9uKGRyYWdnYWJsZSwgZHJvcHBhYmxlLCB0b2xlcmFuY2VNb2RlKSB7XG5cblx0aWYgKCFkcm9wcGFibGUub2Zmc2V0KSByZXR1cm4gZmFsc2U7XG5cblx0dmFyIHgxID0gKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQsIHgyID0geDEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0eTEgPSAoZHJhZ2dhYmxlLnBvc2l0aW9uQWJzIHx8IGRyYWdnYWJsZS5wb3NpdGlvbi5hYnNvbHV0ZSkudG9wLCB5MiA9IHkxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLmhlaWdodDtcblx0dmFyIGwgPSBkcm9wcGFibGUub2Zmc2V0LmxlZnQsIHIgPSBsICsgZHJvcHBhYmxlLnByb3BvcnRpb25zLndpZHRoLFxuXHRcdHQgPSBkcm9wcGFibGUub2Zmc2V0LnRvcCwgYiA9IHQgKyBkcm9wcGFibGUucHJvcG9ydGlvbnMuaGVpZ2h0O1xuXG5cdHN3aXRjaCAodG9sZXJhbmNlTW9kZSkge1xuXHRcdGNhc2UgJ2ZpdCc6XG5cdFx0XHRyZXR1cm4gKGwgPD0geDEgJiYgeDIgPD0gclxuXHRcdFx0XHQmJiB0IDw9IHkxICYmIHkyIDw9IGIpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaW50ZXJzZWN0Jzpcblx0XHRcdHJldHVybiAobCA8IHgxICsgKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIpIC8vIFJpZ2h0IEhhbGZcblx0XHRcdFx0JiYgeDIgLSAoZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC8gMikgPCByIC8vIExlZnQgSGFsZlxuXHRcdFx0XHQmJiB0IDwgeTEgKyAoZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIpIC8vIEJvdHRvbSBIYWxmXG5cdFx0XHRcdCYmIHkyIC0gKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyKSA8IGIgKTsgLy8gVG9wIEhhbGZcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3BvaW50ZXInOlxuXHRcdFx0dmFyIGRyYWdnYWJsZUxlZnQgPSAoKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQgKyAoZHJhZ2dhYmxlLmNsaWNrT2Zmc2V0IHx8IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2spLmxlZnQpLFxuXHRcdFx0XHRkcmFnZ2FibGVUb3AgPSAoKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLnRvcCArIChkcmFnZ2FibGUuY2xpY2tPZmZzZXQgfHwgZHJhZ2dhYmxlLm9mZnNldC5jbGljaykudG9wKSxcblx0XHRcdFx0aXNPdmVyID0gJC51aS5pc092ZXIoZHJhZ2dhYmxlVG9wLCBkcmFnZ2FibGVMZWZ0LCB0LCBsLCBkcm9wcGFibGUucHJvcG9ydGlvbnMuaGVpZ2h0LCBkcm9wcGFibGUucHJvcG9ydGlvbnMud2lkdGgpO1xuXHRcdFx0cmV0dXJuIGlzT3Zlcjtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3RvdWNoJzpcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0KHkxID49IHQgJiYgeTEgPD0gYikgfHxcdC8vIFRvcCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdFx0KHkyID49IHQgJiYgeTIgPD0gYikgfHxcdC8vIEJvdHRvbSBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdFx0KHkxIDwgdCAmJiB5MiA+IGIpXHRcdC8vIFN1cnJvdW5kZWQgdmVydGljYWxseVxuXHRcdFx0XHQpICYmIChcblx0XHRcdFx0XHQoeDEgPj0gbCAmJiB4MSA8PSByKSB8fFx0Ly8gTGVmdCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdFx0KHgyID49IGwgJiYgeDIgPD0gcikgfHxcdC8vIFJpZ2h0IGVkZ2UgdG91Y2hpbmdcblx0XHRcdFx0XHQoeDEgPCBsICYmIHgyID4gcilcdFx0Ly8gU3Vycm91bmRlZCBob3Jpem9udGFsbHlcblx0XHRcdFx0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cbn07XG5cbi8qXG5cdFRoaXMgbWFuYWdlciB0cmFja3Mgb2Zmc2V0cyBvZiBkcmFnZ2FibGVzIGFuZCBkcm9wcGFibGVzXG4qL1xuJC51aS5kZG1hbmFnZXIgPSB7XG5cdGN1cnJlbnQ6IG51bGwsXG5cdGRyb3BwYWJsZXM6IHsgJ2RlZmF1bHQnOiBbXSB9LFxuXHRwcmVwYXJlT2Zmc2V0czogZnVuY3Rpb24odCwgZXZlbnQpIHtcblxuXHRcdHZhciBtID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1t0Lm9wdGlvbnMuc2NvcGVdIHx8IFtdO1xuXHRcdHZhciB0eXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbDsgLy8gd29ya2Fyb3VuZCBmb3IgIzIzMTdcblx0XHR2YXIgbGlzdCA9ICh0LmN1cnJlbnRJdGVtIHx8IHQuZWxlbWVudCkuZmluZChcIjpkYXRhKGRyb3BwYWJsZSlcIikuYW5kU2VsZigpO1xuXG5cdFx0ZHJvcHBhYmxlc0xvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRpZihtW2ldLm9wdGlvbnMuZGlzYWJsZWQgfHwgKHQgJiYgIW1baV0uYWNjZXB0LmNhbGwobVtpXS5lbGVtZW50WzBdLCh0LmN1cnJlbnRJdGVtIHx8IHQuZWxlbWVudCkpKSkgY29udGludWU7XHQvL05vIGRpc2FibGVkIGFuZCBub24tYWNjZXB0ZWRcblx0XHRcdGZvciAodmFyIGo9MDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHsgaWYobGlzdFtqXSA9PSBtW2ldLmVsZW1lbnRbMF0pIHsgbVtpXS5wcm9wb3J0aW9ucy5oZWlnaHQgPSAwOyBjb250aW51ZSBkcm9wcGFibGVzTG9vcDsgfSB9OyAvL0ZpbHRlciBvdXQgZWxlbWVudHMgaW4gdGhlIGN1cnJlbnQgZHJhZ2dlZCBpdGVtXG5cdFx0XHRtW2ldLnZpc2libGUgPSBtW2ldLmVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIjsgaWYoIW1baV0udmlzaWJsZSkgY29udGludWU7IFx0XHRcdFx0XHRcdFx0XHRcdC8vSWYgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUsIGNvbnRpbnVlXG5cblx0XHRcdGlmKHR5cGUgPT0gXCJtb3VzZWRvd25cIikgbVtpXS5fYWN0aXZhdGUuY2FsbChtW2ldLCBldmVudCk7IC8vQWN0aXZhdGUgdGhlIGRyb3BwYWJsZSBpZiB1c2VkIGRpcmVjdGx5IGZyb20gZHJhZ2dhYmxlc1xuXG5cdFx0XHRtW2ldLm9mZnNldCA9IG1baV0uZWxlbWVudC5vZmZzZXQoKTtcblx0XHRcdG1baV0ucHJvcG9ydGlvbnMgPSB7IHdpZHRoOiBtW2ldLmVsZW1lbnRbMF0ub2Zmc2V0V2lkdGgsIGhlaWdodDogbVtpXS5lbGVtZW50WzBdLm9mZnNldEhlaWdodCB9O1xuXG5cdFx0fVxuXG5cdH0sXG5cdGRyb3A6IGZ1bmN0aW9uKGRyYWdnYWJsZSwgZXZlbnQpIHtcblxuXHRcdHZhciBkcm9wcGVkID0gZmFsc2U7XG5cdFx0JC5lYWNoKCQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGVdIHx8IFtdLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0aWYoIXRoaXMub3B0aW9ucykgcmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgdGhpcy52aXNpYmxlICYmICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgdGhpcywgdGhpcy5vcHRpb25zLnRvbGVyYW5jZSkpXG5cdFx0XHRcdGRyb3BwZWQgPSB0aGlzLl9kcm9wLmNhbGwodGhpcywgZXZlbnQpIHx8IGRyb3BwZWQ7XG5cblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiB0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkpIHtcblx0XHRcdFx0dGhpcy5pc291dCA9IDE7IHRoaXMuaXNvdmVyID0gMDtcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXHRcdHJldHVybiBkcm9wcGVkO1xuXG5cdH0sXG5cdGRyYWdTdGFydDogZnVuY3Rpb24oIGRyYWdnYWJsZSwgZXZlbnQgKSB7XG5cdFx0Ly9MaXN0ZW4gZm9yIHNjcm9sbGluZyBzbyB0aGF0IGlmIHRoZSBkcmFnZ2luZyBjYXVzZXMgc2Nyb2xsaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgZHJvcHBhYmxlcyBjYW4gYmUgcmVjYWxjdWxhdGVkIChzZWUgIzUwMDMpXG5cdFx0ZHJhZ2dhYmxlLmVsZW1lbnQucGFyZW50c1VudGlsKCBcImJvZHlcIiApLmJpbmQoIFwic2Nyb2xsLmRyb3BwYWJsZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCAhZHJhZ2dhYmxlLm9wdGlvbnMucmVmcmVzaFBvc2l0aW9ucyApICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBkcmFnZ2FibGUsIGV2ZW50ICk7XG5cdFx0fSk7XG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGRyYWdnYWJsZSwgZXZlbnQpIHtcblxuXHRcdC8vSWYgeW91IGhhdmUgYSBoaWdobHkgZHluYW1pYyBwYWdlLCB5b3UgbWlnaHQgdHJ5IHRoaXMgb3B0aW9uLiBJdCByZW5kZXJzIHBvc2l0aW9ucyBldmVyeSB0aW1lIHlvdSBtb3ZlIHRoZSBtb3VzZS5cblx0XHRpZihkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSAkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhkcmFnZ2FibGUsIGV2ZW50KTtcblxuXHRcdC8vUnVuIHRocm91Z2ggYWxsIGRyb3BwYWJsZXMgYW5kIGNoZWNrIHRoZWlyIHBvc2l0aW9ucyBiYXNlZCBvbiBzcGVjaWZpYyB0b2xlcmFuY2Ugb3B0aW9uc1xuXHRcdCQuZWFjaCgkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW2RyYWdnYWJsZS5vcHRpb25zLnNjb3BlXSB8fCBbXSwgZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmdyZWVkeUNoaWxkIHx8ICF0aGlzLnZpc2libGUpIHJldHVybjtcblx0XHRcdHZhciBpbnRlcnNlY3RzID0gJC51aS5pbnRlcnNlY3QoZHJhZ2dhYmxlLCB0aGlzLCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlKTtcblxuXHRcdFx0dmFyIGMgPSAhaW50ZXJzZWN0cyAmJiB0aGlzLmlzb3ZlciA9PSAxID8gJ2lzb3V0JyA6IChpbnRlcnNlY3RzICYmIHRoaXMuaXNvdmVyID09IDAgPyAnaXNvdmVyJyA6IG51bGwpO1xuXHRcdFx0aWYoIWMpIHJldHVybjtcblxuXHRcdFx0dmFyIHBhcmVudEluc3RhbmNlO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5ncmVlZHkpIHtcblx0XHRcdFx0Ly8gZmluZCBkcm9wcGFibGUgcGFyZW50cyB3aXRoIHNhbWUgc2NvcGVcblx0XHRcdFx0dmFyIHNjb3BlID0gdGhpcy5vcHRpb25zLnNjb3BlO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudHMoJzpkYXRhKGRyb3BwYWJsZSknKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiAkLmRhdGEodGhpcywgJ2Ryb3BwYWJsZScpLm9wdGlvbnMuc2NvcGUgPT09IHNjb3BlO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAocGFyZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHBhcmVudEluc3RhbmNlID0gJC5kYXRhKHBhcmVudFswXSwgJ2Ryb3BwYWJsZScpO1xuXHRcdFx0XHRcdHBhcmVudEluc3RhbmNlLmdyZWVkeUNoaWxkID0gKGMgPT0gJ2lzb3ZlcicgPyAxIDogMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2UganVzdCBtb3ZlZCBpbnRvIGEgZ3JlZWR5IGNoaWxkXG5cdFx0XHRpZiAocGFyZW50SW5zdGFuY2UgJiYgYyA9PSAnaXNvdmVyJykge1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZVsnaXNvdmVyJ10gPSAwO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZVsnaXNvdXQnXSA9IDE7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLl9vdXQuY2FsbChwYXJlbnRJbnN0YW5jZSwgZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzW2NdID0gMTsgdGhpc1tjID09ICdpc291dCcgPyAnaXNvdmVyJyA6ICdpc291dCddID0gMDtcblx0XHRcdHRoaXNbYyA9PSBcImlzb3ZlclwiID8gXCJfb3ZlclwiIDogXCJfb3V0XCJdLmNhbGwodGhpcywgZXZlbnQpO1xuXG5cdFx0XHQvLyB3ZSBqdXN0IG1vdmVkIG91dCBvZiBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT0gJ2lzb3V0Jykge1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZVsnaXNvdXQnXSA9IDA7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlWydpc292ZXInXSA9IDE7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLl9vdmVyLmNhbGwocGFyZW50SW5zdGFuY2UsIGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnU3RvcDogZnVuY3Rpb24oIGRyYWdnYWJsZSwgZXZlbnQgKSB7XG5cdFx0ZHJhZ2dhYmxlLmVsZW1lbnQucGFyZW50c1VudGlsKCBcImJvZHlcIiApLnVuYmluZCggXCJzY3JvbGwuZHJvcHBhYmxlXCIgKTtcblx0XHQvL0NhbGwgcHJlcGFyZU9mZnNldHMgb25lIGZpbmFsIHRpbWUgc2luY2UgSUUgZG9lcyBub3QgZmlyZSByZXR1cm4gc2Nyb2xsIGV2ZW50cyB3aGVuIG92ZXJmbG93IHdhcyBjYXVzZWQgYnkgZHJhZyAoc2VlICM1MDAzKVxuXHRcdGlmKCAhZHJhZ2dhYmxlLm9wdGlvbnMucmVmcmVzaFBvc2l0aW9ucyApICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBkcmFnZ2FibGUsIGV2ZW50ICk7XG5cdH1cbn07XG5cbn0pKGpRdWVyeSk7XG47KGpRdWVyeS5lZmZlY3RzIHx8IChmdW5jdGlvbigkLCB1bmRlZmluZWQpIHtcblxudmFyIGJhY2tDb21wYXQgPSAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UsXG5cdC8vIHByZWZpeCB1c2VkIGZvciBzdG9yaW5nIGRhdGEgb24gLmRhdGEoKVxuXHRkYXRhU3BhY2UgPSBcInVpLWVmZmVjdHMtXCI7XG5cbiQuZWZmZWN0cyA9IHtcblx0ZWZmZWN0OiB7fVxufTtcblxuLyohXG4gKiBqUXVlcnkgQ29sb3IgQW5pbWF0aW9ucyB2Mi4wLjBcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEyIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiBNb24gQXVnIDEzIDEzOjQxOjAyIDIwMTIgLTA1MDBcbiAqL1xuKGZ1bmN0aW9uKCBqUXVlcnksIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgc3RlcEhvb2tzID0gXCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyQm90dG9tQ29sb3IgYm9yZGVyTGVmdENvbG9yIGJvcmRlclJpZ2h0Q29sb3IgYm9yZGVyVG9wQ29sb3IgY29sb3IgY29sdW1uUnVsZUNvbG9yIG91dGxpbmVDb2xvciB0ZXh0RGVjb3JhdGlvbkNvbG9yIHRleHRFbXBoYXNpc0NvbG9yXCIuc3BsaXQoXCIgXCIpLFxuXG5cdC8vIHBsdXNlcXVhbHMgdGVzdCBmb3IgKz0gMTAwIC09IDEwMFxuXHRycGx1c2VxdWFscyA9IC9eKFtcXC0rXSk9XFxzKihcXGQrXFwuP1xcZCopLyxcblx0Ly8gYSBzZXQgb2YgUkUncyB0aGF0IGNhbiBtYXRjaCBzdHJpbmdzIGFuZCBnZW5lcmF0ZSBjb2xvciB0dXBsZXMuXG5cdHN0cmluZ1BhcnNlcnMgPSBbe1xuXHRcdFx0cmU6IC9yZ2JhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqKD86LFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDEgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAyIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMyBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDQgXVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdHJlOiAvcmdiYT9cXChcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKig/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAxIF0gKiAyLjU1LFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDIgXSAqIDIuNTUsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMyBdICogMi41NSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyA0IF1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHQvLyB0aGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcblx0XHRcdHJlOiAvIyhbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDEgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMiBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAzIF0sIDE2IClcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHQvLyB0aGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcblx0XHRcdHJlOiAvIyhbYS1mMC05XSkoW2EtZjAtOV0pKFthLWYwLTldKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDEgXSArIGV4ZWNSZXN1bHRbIDEgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMiBdICsgZXhlY1Jlc3VsdFsgMiBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAzIF0gKyBleGVjUmVzdWx0WyAzIF0sIDE2IClcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRyZTogL2hzbGE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRzcGFjZTogXCJoc2xhXCIsXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDIgXSAvIDEwMCxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0gLyAxMDAsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0Ly8galF1ZXJ5LkNvbG9yKCApXG5cdGNvbG9yID0galF1ZXJ5LkNvbG9yID0gZnVuY3Rpb24oIGNvbG9yLCBncmVlbiwgYmx1ZSwgYWxwaGEgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuQ29sb3IuZm4ucGFyc2UoIGNvbG9yLCBncmVlbiwgYmx1ZSwgYWxwaGEgKTtcblx0fSxcblx0c3BhY2VzID0ge1xuXHRcdHJnYmE6IHtcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdHJlZDoge1xuXHRcdFx0XHRcdGlkeDogMCxcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRncmVlbjoge1xuXHRcdFx0XHRcdGlkeDogMSxcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRibHVlOiB7XG5cdFx0XHRcdFx0aWR4OiAyLFxuXHRcdFx0XHRcdHR5cGU6IFwiYnl0ZVwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0aHNsYToge1xuXHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0aHVlOiB7XG5cdFx0XHRcdFx0aWR4OiAwLFxuXHRcdFx0XHRcdHR5cGU6IFwiZGVncmVlc1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNhdHVyYXRpb246IHtcblx0XHRcdFx0XHRpZHg6IDEsXG5cdFx0XHRcdFx0dHlwZTogXCJwZXJjZW50XCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bGlnaHRuZXNzOiB7XG5cdFx0XHRcdFx0aWR4OiAyLFxuXHRcdFx0XHRcdHR5cGU6IFwicGVyY2VudFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHByb3BUeXBlcyA9IHtcblx0XHRcImJ5dGVcIjoge1xuXHRcdFx0Zmxvb3I6IHRydWUsXG5cdFx0XHRtYXg6IDI1NVxuXHRcdH0sXG5cdFx0XCJwZXJjZW50XCI6IHtcblx0XHRcdG1heDogMVxuXHRcdH0sXG5cdFx0XCJkZWdyZWVzXCI6IHtcblx0XHRcdG1vZDogMzYwLFxuXHRcdFx0Zmxvb3I6IHRydWVcblx0XHR9XG5cdH0sXG5cdHN1cHBvcnQgPSBjb2xvci5zdXBwb3J0ID0ge30sXG5cblx0Ly8gZWxlbWVudCBmb3Igc3VwcG9ydCB0ZXN0c1xuXHRzdXBwb3J0RWxlbSA9IGpRdWVyeSggXCI8cD5cIiApWyAwIF0sXG5cblx0Ly8gY29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzXG5cdGNvbG9ycyxcblxuXHQvLyBsb2NhbCBhbGlhc2VzIG9mIGZ1bmN0aW9ucyBjYWxsZWQgb2Z0ZW5cblx0ZWFjaCA9IGpRdWVyeS5lYWNoO1xuXG4vLyBkZXRlcm1pbmUgcmdiYSBzdXBwb3J0IGltbWVkaWF0ZWx5XG5zdXBwb3J0RWxlbS5zdHlsZS5jc3NUZXh0ID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMSwxLDEsLjUpXCI7XG5zdXBwb3J0LnJnYmEgPSBzdXBwb3J0RWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IuaW5kZXhPZiggXCJyZ2JhXCIgKSA+IC0xO1xuXG4vLyBkZWZpbmUgY2FjaGUgbmFtZSBhbmQgYWxwaGEgcHJvcGVydGllc1xuLy8gZm9yIHJnYmEgYW5kIGhzbGEgc3BhY2VzXG5lYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRzcGFjZS5jYWNoZSA9IFwiX1wiICsgc3BhY2VOYW1lO1xuXHRzcGFjZS5wcm9wcy5hbHBoYSA9IHtcblx0XHRpZHg6IDMsXG5cdFx0dHlwZTogXCJwZXJjZW50XCIsXG5cdFx0ZGVmOiAxXG5cdH07XG59KTtcblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBwcm9wLCBhbGxvd0VtcHR5ICkge1xuXHR2YXIgdHlwZSA9IHByb3BUeXBlc1sgcHJvcC50eXBlIF0gfHwge307XG5cblx0aWYgKCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdHJldHVybiAoYWxsb3dFbXB0eSB8fCAhcHJvcC5kZWYpID8gbnVsbCA6IHByb3AuZGVmO1xuXHR9XG5cblx0Ly8gfn4gaXMgYW4gc2hvcnQgd2F5IG9mIGRvaW5nIGZsb29yIGZvciBwb3NpdGl2ZSBudW1iZXJzXG5cdHZhbHVlID0gdHlwZS5mbG9vciA/IH5+dmFsdWUgOiBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdC8vIElFIHdpbGwgcGFzcyBpbiBlbXB0eSBzdHJpbmdzIGFzIHZhbHVlIGZvciBhbHBoYSxcblx0Ly8gd2hpY2ggd2lsbCBoaXQgdGhpcyBjYXNlXG5cdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHByb3AuZGVmO1xuXHR9XG5cblx0aWYgKCB0eXBlLm1vZCApIHtcblx0XHQvLyB3ZSBhZGQgbW9kIGJlZm9yZSBtb2RkaW5nIHRvIG1ha2Ugc3VyZSB0aGF0IG5lZ2F0aXZlcyB2YWx1ZXNcblx0XHQvLyBnZXQgY29udmVydGVkIHByb3Blcmx5OiAtMTAgLT4gMzUwXG5cdFx0cmV0dXJuICh2YWx1ZSArIHR5cGUubW9kKSAlIHR5cGUubW9kO1xuXHR9XG5cblx0Ly8gZm9yIG5vdyBhbGwgcHJvcGVydHkgdHlwZXMgd2l0aG91dCBtb2QgaGF2ZSBtaW4gYW5kIG1heFxuXHRyZXR1cm4gMCA+IHZhbHVlID8gMCA6IHR5cGUubWF4IDwgdmFsdWUgPyB0eXBlLm1heCA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdQYXJzZSggc3RyaW5nICkge1xuXHR2YXIgaW5zdCA9IGNvbG9yKCksXG5cdFx0cmdiYSA9IGluc3QuX3JnYmEgPSBbXTtcblxuXHRzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcblxuXHRlYWNoKCBzdHJpbmdQYXJzZXJzLCBmdW5jdGlvbiggaSwgcGFyc2VyICkge1xuXHRcdHZhciBwYXJzZWQsXG5cdFx0XHRtYXRjaCA9IHBhcnNlci5yZS5leGVjKCBzdHJpbmcgKSxcblx0XHRcdHZhbHVlcyA9IG1hdGNoICYmIHBhcnNlci5wYXJzZSggbWF0Y2ggKSxcblx0XHRcdHNwYWNlTmFtZSA9IHBhcnNlci5zcGFjZSB8fCBcInJnYmFcIjtcblxuXHRcdGlmICggdmFsdWVzICkge1xuXHRcdFx0cGFyc2VkID0gaW5zdFsgc3BhY2VOYW1lIF0oIHZhbHVlcyApO1xuXG5cdFx0XHQvLyBpZiB0aGlzIHdhcyBhbiByZ2JhIHBhcnNlIHRoZSBhc3NpZ25tZW50IG1pZ2h0IGhhcHBlbiB0d2ljZVxuXHRcdFx0Ly8gb2ggd2VsbC4uLi5cblx0XHRcdGluc3RbIHNwYWNlc1sgc3BhY2VOYW1lIF0uY2FjaGUgXSA9IHBhcnNlZFsgc3BhY2VzWyBzcGFjZU5hbWUgXS5jYWNoZSBdO1xuXHRcdFx0cmdiYSA9IGluc3QuX3JnYmEgPSBwYXJzZWQuX3JnYmE7XG5cblx0XHRcdC8vIGV4aXQgZWFjaCggc3RyaW5nUGFyc2VycyApIGhlcmUgYmVjYXVzZSB3ZSBtYXRjaGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBGb3VuZCBhIHN0cmluZ1BhcnNlciB0aGF0IGhhbmRsZWQgaXRcblx0aWYgKCByZ2JhLmxlbmd0aCApIHtcblxuXHRcdC8vIGlmIHRoaXMgY2FtZSBmcm9tIGEgcGFyc2VkIHN0cmluZywgZm9yY2UgXCJ0cmFuc3BhcmVudFwiIHdoZW4gYWxwaGEgaXMgMFxuXHRcdC8vIGNocm9tZSwgKGFuZCBtYXliZSBvdGhlcnMpIHJldHVybiBcInRyYW5zcGFyZW50XCIgYXMgcmdiYSgwLDAsMCwwKVxuXHRcdGlmICggcmdiYS5qb2luKCkgPT09IFwiMCwwLDAsMFwiICkge1xuXHRcdFx0alF1ZXJ5LmV4dGVuZCggcmdiYSwgY29sb3JzLnRyYW5zcGFyZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnN0O1xuXHR9XG5cblx0Ly8gbmFtZWQgY29sb3JzXG5cdHJldHVybiBjb2xvcnNbIHN0cmluZyBdO1xufVxuXG5jb2xvci5mbiA9IGpRdWVyeS5leHRlbmQoIGNvbG9yLnByb3RvdHlwZSwge1xuXHRwYXJzZTogZnVuY3Rpb24oIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhICkge1xuXHRcdGlmICggcmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9yZ2JhID0gWyBudWxsLCBudWxsLCBudWxsLCBudWxsIF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCByZWQuanF1ZXJ5IHx8IHJlZC5ub2RlVHlwZSApIHtcblx0XHRcdHJlZCA9IGpRdWVyeSggcmVkICkuY3NzKCBncmVlbiApO1xuXHRcdFx0Z3JlZW4gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QgPSB0aGlzLFxuXHRcdFx0dHlwZSA9IGpRdWVyeS50eXBlKCByZWQgKSxcblx0XHRcdHJnYmEgPSB0aGlzLl9yZ2JhID0gW107XG5cblx0XHQvLyBtb3JlIHRoYW4gMSBhcmd1bWVudCBzcGVjaWZpZWQgLSBhc3N1bWUgKCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSApXG5cdFx0aWYgKCBncmVlbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmVkID0gWyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSBdO1xuXHRcdFx0dHlwZSA9IFwiYXJyYXlcIjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZSggc3RyaW5nUGFyc2UoIHJlZCApIHx8IGNvbG9ycy5fZGVmYXVsdCApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJhcnJheVwiICkge1xuXHRcdFx0ZWFjaCggc3BhY2VzLnJnYmEucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHRcdHJnYmFbIHByb3AuaWR4IF0gPSBjbGFtcCggcmVkWyBwcm9wLmlkeCBdLCBwcm9wICk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdGlmICggcmVkIGluc3RhbmNlb2YgY29sb3IgKSB7XG5cdFx0XHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdFx0XHRcdFx0aWYgKCByZWRbIHNwYWNlLmNhY2hlIF0gKSB7XG5cdFx0XHRcdFx0XHRpbnN0WyBzcGFjZS5jYWNoZSBdID0gcmVkWyBzcGFjZS5jYWNoZSBdLnNsaWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlID0gc3BhY2UuY2FjaGU7XG5cdFx0XHRcdFx0ZWFjaCggc3BhY2UucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjYWNoZSBkb2Vzbid0IGV4aXN0LCBhbmQgd2Uga25vdyBob3cgdG8gY29udmVydFxuXHRcdFx0XHRcdFx0aWYgKCAhaW5zdFsgY2FjaGUgXSAmJiBzcGFjZS50byApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgdmFsdWUgd2FzIG51bGwsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdFxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUga2V5IHdhcyBhbHBoYSwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0IGVpdGhlclxuXHRcdFx0XHRcdFx0XHRpZiAoIGtleSA9PT0gXCJhbHBoYVwiIHx8IHJlZFsga2V5IF0gPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aW5zdFsgY2FjaGUgXSA9IHNwYWNlLnRvKCBpbnN0Ll9yZ2JhICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBhbGxvdyBudWxscyBmb3IgQUxMIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHQvLyBjYWxsIGNsYW1wIHdpdGggYWx3YXlzQWxsb3dFbXB0eVxuXHRcdFx0XHRcdFx0aW5zdFsgY2FjaGUgXVsgcHJvcC5pZHggXSA9IGNsYW1wKCByZWRbIGtleSBdLCBwcm9wLCB0cnVlICk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBldmVyeXRoaW5nIGRlZmluZWQgYnV0IGFscGhhP1xuXHRcdFx0XHRcdGlmICggaW5zdFsgY2FjaGUgXSAmJiAkLmluQXJyYXkoIG51bGwsIGluc3RbIGNhY2hlIF0uc2xpY2UoIDAsIDMgKSApIDwgMCApIHtcblx0XHRcdFx0XHRcdC8vIHVzZSB0aGUgZGVmYXVsdCBvZiAxXG5cdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdWyAzIF0gPSAxO1xuXHRcdFx0XHRcdFx0aWYgKCBzcGFjZS5mcm9tICkge1xuXHRcdFx0XHRcdFx0XHRpbnN0Ll9yZ2JhID0gc3BhY2UuZnJvbSggaW5zdFsgY2FjaGUgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggY29tcGFyZSApIHtcblx0XHR2YXIgaXMgPSBjb2xvciggY29tcGFyZSApLFxuXHRcdFx0c2FtZSA9IHRydWUsXG5cdFx0XHRpbnN0ID0gdGhpcztcblxuXHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIF8sIHNwYWNlICkge1xuXHRcdFx0dmFyIGxvY2FsQ2FjaGUsXG5cdFx0XHRcdGlzQ2FjaGUgPSBpc1sgc3BhY2UuY2FjaGUgXTtcblx0XHRcdGlmIChpc0NhY2hlKSB7XG5cdFx0XHRcdGxvY2FsQ2FjaGUgPSBpbnN0WyBzcGFjZS5jYWNoZSBdIHx8IHNwYWNlLnRvICYmIHNwYWNlLnRvKCBpbnN0Ll9yZ2JhICkgfHwgW107XG5cdFx0XHRcdGVhY2goIHNwYWNlLnByb3BzLCBmdW5jdGlvbiggXywgcHJvcCApIHtcblx0XHRcdFx0XHRpZiAoIGlzQ2FjaGVbIHByb3AuaWR4IF0gIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHNhbWUgPSAoIGlzQ2FjaGVbIHByb3AuaWR4IF0gPT09IGxvY2FsQ2FjaGVbIHByb3AuaWR4IF0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBzYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2FtZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gc2FtZTtcblx0fSxcblx0X3NwYWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdXNlZCA9IFtdLFxuXHRcdFx0aW5zdCA9IHRoaXM7XG5cdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0XHRcdGlmICggaW5zdFsgc3BhY2UuY2FjaGUgXSApIHtcblx0XHRcdFx0dXNlZC5wdXNoKCBzcGFjZU5hbWUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdXNlZC5wb3AoKTtcblx0fSxcblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oIG90aGVyLCBkaXN0YW5jZSApIHtcblx0XHR2YXIgZW5kID0gY29sb3IoIG90aGVyICksXG5cdFx0XHRzcGFjZU5hbWUgPSBlbmQuX3NwYWNlKCksXG5cdFx0XHRzcGFjZSA9IHNwYWNlc1sgc3BhY2VOYW1lIF0sXG5cdFx0XHRzdGFydENvbG9yID0gdGhpcy5hbHBoYSgpID09PSAwID8gY29sb3IoIFwidHJhbnNwYXJlbnRcIiApIDogdGhpcyxcblx0XHRcdHN0YXJ0ID0gc3RhcnRDb2xvclsgc3BhY2UuY2FjaGUgXSB8fCBzcGFjZS50byggc3RhcnRDb2xvci5fcmdiYSApLFxuXHRcdFx0cmVzdWx0ID0gc3RhcnQuc2xpY2UoKTtcblxuXHRcdGVuZCA9IGVuZFsgc3BhY2UuY2FjaGUgXTtcblx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHRcdHZhciBpbmRleCA9IHByb3AuaWR4LFxuXHRcdFx0XHRzdGFydFZhbHVlID0gc3RhcnRbIGluZGV4IF0sXG5cdFx0XHRcdGVuZFZhbHVlID0gZW5kWyBpbmRleCBdLFxuXHRcdFx0XHR0eXBlID0gcHJvcFR5cGVzWyBwcm9wLnR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaWYgbnVsbCwgZG9uJ3Qgb3ZlcnJpZGUgc3RhcnQgdmFsdWVcblx0XHRcdGlmICggZW5kVmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGlmIG51bGwgLSB1c2UgZW5kXG5cdFx0XHRpZiAoIHN0YXJ0VmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJlc3VsdFsgaW5kZXggXSA9IGVuZFZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlLm1vZCApIHtcblx0XHRcdFx0XHRpZiAoIGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSA+IHR5cGUubW9kIC8gMiApIHtcblx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgKz0gdHlwZS5tb2Q7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhcnRWYWx1ZSAtIGVuZFZhbHVlID4gdHlwZS5tb2QgLyAyICkge1xuXHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSAtPSB0eXBlLm1vZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0WyBpbmRleCBdID0gY2xhbXAoICggZW5kVmFsdWUgLSBzdGFydFZhbHVlICkgKiBkaXN0YW5jZSArIHN0YXJ0VmFsdWUsIHByb3AgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpc1sgc3BhY2VOYW1lIF0oIHJlc3VsdCApO1xuXHR9LFxuXHRibGVuZDogZnVuY3Rpb24oIG9wYXF1ZSApIHtcblx0XHQvLyBpZiB3ZSBhcmUgYWxyZWFkeSBvcGFxdWUgLSByZXR1cm4gb3Vyc2VsZlxuXHRcdGlmICggdGhpcy5fcmdiYVsgMyBdID09PSAxICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dmFyIHJnYiA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcblx0XHRcdGEgPSByZ2IucG9wKCksXG5cdFx0XHRibGVuZCA9IGNvbG9yKCBvcGFxdWUgKS5fcmdiYTtcblxuXHRcdHJldHVybiBjb2xvciggalF1ZXJ5Lm1hcCggcmdiLCBmdW5jdGlvbiggdiwgaSApIHtcblx0XHRcdHJldHVybiAoIDEgLSBhICkgKiBibGVuZFsgaSBdICsgYSAqIHY7XG5cdFx0fSkpO1xuXHR9LFxuXHR0b1JnYmFTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmVmaXggPSBcInJnYmEoXCIsXG5cdFx0XHRyZ2JhID0galF1ZXJ5Lm1hcCggdGhpcy5fcmdiYSwgZnVuY3Rpb24oIHYsIGkgKSB7XG5cdFx0XHRcdHJldHVybiB2ID09IG51bGwgPyAoIGkgPiAyID8gMSA6IDAgKSA6IHY7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggcmdiYVsgMyBdID09PSAxICkge1xuXHRcdFx0cmdiYS5wb3AoKTtcblx0XHRcdHByZWZpeCA9IFwicmdiKFwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmVmaXggKyByZ2JhLmpvaW4oKSArIFwiKVwiO1xuXHR9LFxuXHR0b0hzbGFTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmVmaXggPSBcImhzbGEoXCIsXG5cdFx0XHRoc2xhID0galF1ZXJ5Lm1hcCggdGhpcy5oc2xhKCksIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0XHRpZiAoIHYgPT0gbnVsbCApIHtcblx0XHRcdFx0XHR2ID0gaSA+IDIgPyAxIDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNhdGNoIDEgYW5kIDJcblx0XHRcdFx0aWYgKCBpICYmIGkgPCAzICkge1xuXHRcdFx0XHRcdHYgPSBNYXRoLnJvdW5kKCB2ICogMTAwICkgKyBcIiVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKCBoc2xhWyAzIF0gPT09IDEgKSB7XG5cdFx0XHRoc2xhLnBvcCgpO1xuXHRcdFx0cHJlZml4ID0gXCJoc2woXCI7XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXggKyBoc2xhLmpvaW4oKSArIFwiKVwiO1xuXHR9LFxuXHR0b0hleFN0cmluZzogZnVuY3Rpb24oIGluY2x1ZGVBbHBoYSApIHtcblx0XHR2YXIgcmdiYSA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcblx0XHRcdGFscGhhID0gcmdiYS5wb3AoKTtcblxuXHRcdGlmICggaW5jbHVkZUFscGhhICkge1xuXHRcdFx0cmdiYS5wdXNoKCB+figgYWxwaGEgKiAyNTUgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBcIiNcIiArIGpRdWVyeS5tYXAoIHJnYmEsIGZ1bmN0aW9uKCB2ICkge1xuXG5cdFx0XHQvLyBkZWZhdWx0IHRvIDAgd2hlbiBudWxscyBleGlzdFxuXHRcdFx0diA9ICggdiB8fCAwICkudG9TdHJpbmcoIDE2ICk7XG5cdFx0XHRyZXR1cm4gdi5sZW5ndGggPT09IDEgPyBcIjBcIiArIHYgOiB2O1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH0sXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmdiYVsgMyBdID09PSAwID8gXCJ0cmFuc3BhcmVudFwiIDogdGhpcy50b1JnYmFTdHJpbmcoKTtcblx0fVxufSk7XG5jb2xvci5mbi5wYXJzZS5wcm90b3R5cGUgPSBjb2xvci5mbjtcblxuLy8gaHNsYSBjb252ZXJzaW9ucyBhZGFwdGVkIGZyb206XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL21hYXNoYWFjay9zb3VyY2UvYnJvd3NlL3BhY2thZ2VzL2dyYXBoaWNzL3RydW5rL3NyYy9ncmFwaGljcy9jb2xvcnMvSFVFMlJHQi5hcz9yPTUwMjFcblxuZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgaCApIHtcblx0aCA9ICggaCArIDEgKSAlIDE7XG5cdGlmICggaCAqIDYgPCAxICkge1xuXHRcdHJldHVybiBwICsgKHEgLSBwKSAqIGggKiA2O1xuXHR9XG5cdGlmICggaCAqIDIgPCAxKSB7XG5cdFx0cmV0dXJuIHE7XG5cdH1cblx0aWYgKCBoICogMyA8IDIgKSB7XG5cdFx0cmV0dXJuIHAgKyAocSAtIHApICogKCgyLzMpIC0gaCkgKiA2O1xuXHR9XG5cdHJldHVybiBwO1xufVxuXG5zcGFjZXMuaHNsYS50byA9IGZ1bmN0aW9uICggcmdiYSApIHtcblx0aWYgKCByZ2JhWyAwIF0gPT0gbnVsbCB8fCByZ2JhWyAxIF0gPT0gbnVsbCB8fCByZ2JhWyAyIF0gPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCByZ2JhWyAzIF0gXTtcblx0fVxuXHR2YXIgciA9IHJnYmFbIDAgXSAvIDI1NSxcblx0XHRnID0gcmdiYVsgMSBdIC8gMjU1LFxuXHRcdGIgPSByZ2JhWyAyIF0gLyAyNTUsXG5cdFx0YSA9IHJnYmFbIDMgXSxcblx0XHRtYXggPSBNYXRoLm1heCggciwgZywgYiApLFxuXHRcdG1pbiA9IE1hdGgubWluKCByLCBnLCBiICksXG5cdFx0ZGlmZiA9IG1heCAtIG1pbixcblx0XHRhZGQgPSBtYXggKyBtaW4sXG5cdFx0bCA9IGFkZCAqIDAuNSxcblx0XHRoLCBzO1xuXG5cdGlmICggbWluID09PSBtYXggKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAoIHIgPT09IG1heCApIHtcblx0XHRoID0gKCA2MCAqICggZyAtIGIgKSAvIGRpZmYgKSArIDM2MDtcblx0fSBlbHNlIGlmICggZyA9PT0gbWF4ICkge1xuXHRcdGggPSAoIDYwICogKCBiIC0gciApIC8gZGlmZiApICsgMTIwO1xuXHR9IGVsc2Uge1xuXHRcdGggPSAoIDYwICogKCByIC0gZyApIC8gZGlmZiApICsgMjQwO1xuXHR9XG5cblx0aWYgKCBsID09PSAwIHx8IGwgPT09IDEgKSB7XG5cdFx0cyA9IGw7XG5cdH0gZWxzZSBpZiAoIGwgPD0gMC41ICkge1xuXHRcdHMgPSBkaWZmIC8gYWRkO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkaWZmIC8gKCAyIC0gYWRkICk7XG5cdH1cblx0cmV0dXJuIFsgTWF0aC5yb3VuZChoKSAlIDM2MCwgcywgbCwgYSA9PSBudWxsID8gMSA6IGEgXTtcbn07XG5cbnNwYWNlcy5oc2xhLmZyb20gPSBmdW5jdGlvbiAoIGhzbGEgKSB7XG5cdGlmICggaHNsYVsgMCBdID09IG51bGwgfHwgaHNsYVsgMSBdID09IG51bGwgfHwgaHNsYVsgMiBdID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFsgbnVsbCwgbnVsbCwgbnVsbCwgaHNsYVsgMyBdIF07XG5cdH1cblx0dmFyIGggPSBoc2xhWyAwIF0gLyAzNjAsXG5cdFx0cyA9IGhzbGFbIDEgXSxcblx0XHRsID0gaHNsYVsgMiBdLFxuXHRcdGEgPSBoc2xhWyAzIF0sXG5cdFx0cSA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gbCAqIHMsXG5cdFx0cCA9IDIgKiBsIC0gcTtcblxuXHRyZXR1cm4gW1xuXHRcdE1hdGgucm91bmQoIGh1ZTJyZ2IoIHAsIHEsIGggKyAoIDEgLyAzICkgKSAqIDI1NSApLFxuXHRcdE1hdGgucm91bmQoIGh1ZTJyZ2IoIHAsIHEsIGggKSAqIDI1NSApLFxuXHRcdE1hdGgucm91bmQoIGh1ZTJyZ2IoIHAsIHEsIGggLSAoIDEgLyAzICkgKSAqIDI1NSApLFxuXHRcdGFcblx0XTtcbn07XG5cblxuZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0dmFyIHByb3BzID0gc3BhY2UucHJvcHMsXG5cdFx0Y2FjaGUgPSBzcGFjZS5jYWNoZSxcblx0XHR0byA9IHNwYWNlLnRvLFxuXHRcdGZyb20gPSBzcGFjZS5mcm9tO1xuXG5cdC8vIG1ha2VzIHJnYmEoKSBhbmQgaHNsYSgpXG5cdGNvbG9yLmZuWyBzcGFjZU5hbWUgXSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdC8vIGdlbmVyYXRlIGEgY2FjaGUgZm9yIHRoaXMgc3BhY2UgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRcdGlmICggdG8gJiYgIXRoaXNbIGNhY2hlIF0gKSB7XG5cdFx0XHR0aGlzWyBjYWNoZSBdID0gdG8oIHRoaXMuX3JnYmEgKTtcblx0XHR9XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXNbIGNhY2hlIF0uc2xpY2UoKTtcblx0XHR9XG5cblx0XHR2YXIgcmV0LFxuXHRcdFx0dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApLFxuXHRcdFx0YXJyID0gKCB0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJvYmplY3RcIiApID8gdmFsdWUgOiBhcmd1bWVudHMsXG5cdFx0XHRsb2NhbCA9IHRoaXNbIGNhY2hlIF0uc2xpY2UoKTtcblxuXHRcdGVhY2goIHByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXHRcdFx0dmFyIHZhbCA9IGFyclsgdHlwZSA9PT0gXCJvYmplY3RcIiA/IGtleSA6IHByb3AuaWR4IF07XG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBsb2NhbFsgcHJvcC5pZHggXTtcblx0XHRcdH1cblx0XHRcdGxvY2FsWyBwcm9wLmlkeCBdID0gY2xhbXAoIHZhbCwgcHJvcCApO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCBmcm9tICkge1xuXHRcdFx0cmV0ID0gY29sb3IoIGZyb20oIGxvY2FsICkgKTtcblx0XHRcdHJldFsgY2FjaGUgXSA9IGxvY2FsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbG9yKCBsb2NhbCApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBtYWtlcyByZWQoKSBncmVlbigpIGJsdWUoKSBhbHBoYSgpIGh1ZSgpIHNhdHVyYXRpb24oKSBsaWdodG5lc3MoKVxuXHRlYWNoKCBwcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHQvLyBhbHBoYSBpcyBpbmNsdWRlZCBpbiBtb3JlIHRoYW4gb25lIHNwYWNlXG5cdFx0aWYgKCBjb2xvci5mblsga2V5IF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbG9yLmZuWyBrZXkgXSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciB2dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApLFxuXHRcdFx0XHRmbiA9ICgga2V5ID09PSBcImFscGhhXCIgPyAoIHRoaXMuX2hzbGEgPyBcImhzbGFcIiA6IFwicmdiYVwiICkgOiBzcGFjZU5hbWUgKSxcblx0XHRcdFx0bG9jYWwgPSB0aGlzWyBmbiBdKCksXG5cdFx0XHRcdGN1ciA9IGxvY2FsWyBwcm9wLmlkeCBdLFxuXHRcdFx0XHRtYXRjaDtcblxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGN1cjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNhbGwoIHRoaXMsIGN1ciApO1xuXHRcdFx0XHR2dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsICYmIHByb3AuZW1wdHkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0bWF0Y2ggPSBycGx1c2VxdWFscy5leGVjKCB2YWx1ZSApO1xuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY3VyICsgcGFyc2VGbG9hdCggbWF0Y2hbIDIgXSApICogKCBtYXRjaFsgMSBdID09PSBcIitcIiA/IDEgOiAtMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsb2NhbFsgcHJvcC5pZHggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXNbIGZuIF0oIGxvY2FsICk7XG5cdFx0fTtcblx0fSk7XG59KTtcblxuLy8gYWRkIC5meC5zdGVwIGZ1bmN0aW9uc1xuZWFjaCggc3RlcEhvb2tzLCBmdW5jdGlvbiggaSwgaG9vayApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBob29rIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcGFyc2VkLCBjdXJFbGVtLFxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBcIlwiO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCB2YWx1ZSApICE9PSBcInN0cmluZ1wiIHx8ICggcGFyc2VkID0gc3RyaW5nUGFyc2UoIHZhbHVlICkgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBjb2xvciggcGFyc2VkIHx8IHZhbHVlICk7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmdiYSAmJiB2YWx1ZS5fcmdiYVsgMyBdICE9PSAxICkge1xuXHRcdFx0XHRcdGN1ckVsZW0gPSBob29rID09PSBcImJhY2tncm91bmRDb2xvclwiID8gZWxlbS5wYXJlbnROb2RlIDogZWxlbTtcblx0XHRcdFx0XHR3aGlsZSAoXG5cdFx0XHRcdFx0XHQoYmFja2dyb3VuZENvbG9yID09PSBcIlwiIHx8IGJhY2tncm91bmRDb2xvciA9PT0gXCJ0cmFuc3BhcmVudFwiKSAmJlxuXHRcdFx0XHRcdFx0Y3VyRWxlbSAmJiBjdXJFbGVtLnN0eWxlXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBqUXVlcnkuY3NzKCBjdXJFbGVtLCBcImJhY2tncm91bmRDb2xvclwiICk7XG5cdFx0XHRcdFx0XHRcdGN1ckVsZW0gPSBjdXJFbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmJsZW5kKCBiYWNrZ3JvdW5kQ29sb3IgJiYgYmFja2dyb3VuZENvbG9yICE9PSBcInRyYW5zcGFyZW50XCIgP1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yIDpcblx0XHRcdFx0XHRcdFwiX2RlZmF1bHRcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b1JnYmFTdHJpbmcoKTtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGVsZW0uc3R5bGVbIGhvb2sgXSA9IHZhbHVlO1xuXHRcdFx0fSBjYXRjaCggZXJyb3IgKSB7XG5cdFx0XHRcdC8vIHdyYXBwZWQgdG8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGVycm9ycyBvbiBcImludmFsaWRcIiB2YWx1ZXMgbGlrZSAnYXV0bycgb3IgJ2luaGVyaXQnXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRqUXVlcnkuZnguc3RlcFsgaG9vayBdID0gZnVuY3Rpb24oIGZ4ICkge1xuXHRcdGlmICggIWZ4LmNvbG9ySW5pdCApIHtcblx0XHRcdGZ4LnN0YXJ0ID0gY29sb3IoIGZ4LmVsZW0sIGhvb2sgKTtcblx0XHRcdGZ4LmVuZCA9IGNvbG9yKCBmeC5lbmQgKTtcblx0XHRcdGZ4LmNvbG9ySW5pdCA9IHRydWU7XG5cdFx0fVxuXHRcdGpRdWVyeS5jc3NIb29rc1sgaG9vayBdLnNldCggZnguZWxlbSwgZnguc3RhcnQudHJhbnNpdGlvbiggZnguZW5kLCBmeC5wb3MgKSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5jc3NIb29rcy5ib3JkZXJDb2xvciA9IHtcblx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGV4cGFuZGVkID0ge307XG5cblx0XHRlYWNoKCBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHBhcnQgKSB7XG5cdFx0XHRleHBhbmRlZFsgXCJib3JkZXJcIiArIHBhcnQgKyBcIkNvbG9yXCIgXSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdHJldHVybiBleHBhbmRlZDtcblx0fVxufTtcblxuLy8gQmFzaWMgY29sb3IgbmFtZXMgb25seS5cbi8vIFVzYWdlIG9mIGFueSBvZiB0aGUgb3RoZXIgY29sb3IgbmFtZXMgcmVxdWlyZXMgYWRkaW5nIHlvdXJzZWxmIG9yIGluY2x1ZGluZ1xuLy8ganF1ZXJ5LmNvbG9yLnN2Zy1uYW1lcy5qcy5cbmNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lcyA9IHtcblx0Ly8gNC4xLiBCYXNpYyBjb2xvciBrZXl3b3Jkc1xuXHRhcXVhOiBcIiMwMGZmZmZcIixcblx0YmxhY2s6IFwiIzAwMDAwMFwiLFxuXHRibHVlOiBcIiMwMDAwZmZcIixcblx0ZnVjaHNpYTogXCIjZmYwMGZmXCIsXG5cdGdyYXk6IFwiIzgwODA4MFwiLFxuXHRncmVlbjogXCIjMDA4MDAwXCIsXG5cdGxpbWU6IFwiIzAwZmYwMFwiLFxuXHRtYXJvb246IFwiIzgwMDAwMFwiLFxuXHRuYXZ5OiBcIiMwMDAwODBcIixcblx0b2xpdmU6IFwiIzgwODAwMFwiLFxuXHRwdXJwbGU6IFwiIzgwMDA4MFwiLFxuXHRyZWQ6IFwiI2ZmMDAwMFwiLFxuXHRzaWx2ZXI6IFwiI2MwYzBjMFwiLFxuXHR0ZWFsOiBcIiMwMDgwODBcIixcblx0d2hpdGU6IFwiI2ZmZmZmZlwiLFxuXHR5ZWxsb3c6IFwiI2ZmZmYwMFwiLFxuXG5cdC8vIDQuMi4zLiBcInRyYW5zcGFyZW50XCIgY29sb3Iga2V5d29yZFxuXHR0cmFuc3BhcmVudDogWyBudWxsLCBudWxsLCBudWxsLCAwIF0sXG5cblx0X2RlZmF1bHQ6IFwiI2ZmZmZmZlwiXG59O1xuXG59KSggalF1ZXJ5ICk7XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBDTEFTUyBBTklNQVRJT05TICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4oZnVuY3Rpb24oKSB7XG5cbnZhciBjbGFzc0FuaW1hdGlvbkFjdGlvbnMgPSBbIFwiYWRkXCIsIFwicmVtb3ZlXCIsIFwidG9nZ2xlXCIgXSxcblx0c2hvcnRoYW5kU3R5bGVzID0ge1xuXHRcdGJvcmRlcjogMSxcblx0XHRib3JkZXJCb3R0b206IDEsXG5cdFx0Ym9yZGVyQ29sb3I6IDEsXG5cdFx0Ym9yZGVyTGVmdDogMSxcblx0XHRib3JkZXJSaWdodDogMSxcblx0XHRib3JkZXJUb3A6IDEsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0bWFyZ2luOiAxLFxuXHRcdHBhZGRpbmc6IDFcblx0fTtcblxuJC5lYWNoKFsgXCJib3JkZXJMZWZ0U3R5bGVcIiwgXCJib3JkZXJSaWdodFN0eWxlXCIsIFwiYm9yZGVyQm90dG9tU3R5bGVcIiwgXCJib3JkZXJUb3BTdHlsZVwiIF0sIGZ1bmN0aW9uKCBfLCBwcm9wICkge1xuXHQkLmZ4LnN0ZXBbIHByb3AgXSA9IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRpZiAoIGZ4LmVuZCAhPT0gXCJub25lXCIgJiYgIWZ4LnNldEF0dHIgfHwgZngucG9zID09PSAxICYmICFmeC5zZXRBdHRyICkge1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBmeC5lbGVtLCBwcm9wLCBmeC5lbmQgKTtcblx0XHRcdGZ4LnNldEF0dHIgPSB0cnVlO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50U3R5bGVzKCkge1xuXHR2YXIgc3R5bGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgP1xuXHRcdFx0dGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIHRoaXMsIG51bGwgKSA6XG5cdFx0XHR0aGlzLmN1cnJlbnRTdHlsZSxcblx0XHRuZXdTdHlsZSA9IHt9LFxuXHRcdGtleSxcblx0XHRsZW47XG5cblx0Ly8gd2Via2l0IGVudW1lcmF0ZXMgc3R5bGUgcG9ycGVydGllc1xuXHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCAmJiBzdHlsZVsgMCBdICYmIHN0eWxlWyBzdHlsZVsgMCBdIF0gKSB7XG5cdFx0bGVuID0gc3R5bGUubGVuZ3RoO1xuXHRcdHdoaWxlICggbGVuLS0gKSB7XG5cdFx0XHRrZXkgPSBzdHlsZVsgbGVuIF07XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHlsZVsga2V5IF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdG5ld1N0eWxlWyAkLmNhbWVsQ2FzZSgga2V5ICkgXSA9IHN0eWxlWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICgga2V5IGluIHN0eWxlICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRuZXdTdHlsZVsga2V5IF0gPSBzdHlsZVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1N0eWxlO1xufVxuXG5cbmZ1bmN0aW9uIHN0eWxlRGlmZmVyZW5jZSggb2xkU3R5bGUsIG5ld1N0eWxlICkge1xuXHR2YXIgZGlmZiA9IHt9LFxuXHRcdG5hbWUsIHZhbHVlO1xuXG5cdGZvciAoIG5hbWUgaW4gbmV3U3R5bGUgKSB7XG5cdFx0dmFsdWUgPSBuZXdTdHlsZVsgbmFtZSBdO1xuXHRcdGlmICggb2xkU3R5bGVbIG5hbWUgXSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRpZiAoICFzaG9ydGhhbmRTdHlsZXNbIG5hbWUgXSApIHtcblx0XHRcdFx0aWYgKCAkLmZ4LnN0ZXBbIG5hbWUgXSB8fCAhaXNOYU4oIHBhcnNlRmxvYXQoIHZhbHVlICkgKSApIHtcblx0XHRcdFx0XHRkaWZmWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkaWZmO1xufVxuXG4kLmVmZmVjdHMuYW5pbWF0ZUNsYXNzID0gZnVuY3Rpb24oIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0dmFyIG8gPSAkLnNwZWVkKCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0ZWQgPSAkKCB0aGlzICksXG5cdFx0XHRiYXNlQ2xhc3MgPSBhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIgKSB8fCBcIlwiLFxuXHRcdFx0YXBwbHlDbGFzc0NoYW5nZSxcblx0XHRcdGFsbEFuaW1hdGlvbnMgPSBvLmNoaWxkcmVuID8gYW5pbWF0ZWQuZmluZCggXCIqXCIgKS5hbmRTZWxmKCkgOiBhbmltYXRlZDtcblxuXHRcdC8vIG1hcCB0aGUgYW5pbWF0ZWQgb2JqZWN0cyB0byBzdG9yZSB0aGUgb3JpZ2luYWwgc3R5bGVzLlxuXHRcdGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbCA9ICQoIHRoaXMgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVsOiBlbCxcblx0XHRcdFx0c3RhcnQ6IGdldEVsZW1lbnRTdHlsZXMuY2FsbCggdGhpcyApXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgY2xhc3MgY2hhbmdlXG5cdFx0YXBwbHlDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC5lYWNoKCBjbGFzc0FuaW1hdGlvbkFjdGlvbnMsIGZ1bmN0aW9uKGksIGFjdGlvbikge1xuXHRcdFx0XHRpZiAoIHZhbHVlWyBhY3Rpb24gXSApIHtcblx0XHRcdFx0XHRhbmltYXRlZFsgYWN0aW9uICsgXCJDbGFzc1wiIF0oIHZhbHVlWyBhY3Rpb24gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdGFwcGx5Q2xhc3NDaGFuZ2UoKTtcblxuXHRcdC8vIG1hcCBhbGwgYW5pbWF0ZWQgb2JqZWN0cyBhZ2FpbiAtIGNhbGN1bGF0ZSBuZXcgc3R5bGVzIGFuZCBkaWZmXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5lbmQgPSBnZXRFbGVtZW50U3R5bGVzLmNhbGwoIHRoaXMuZWxbIDAgXSApO1xuXHRcdFx0dGhpcy5kaWZmID0gc3R5bGVEaWZmZXJlbmNlKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSk7XG5cblx0XHQvLyBhcHBseSBvcmlnaW5hbCBjbGFzc1xuXHRcdGFuaW1hdGVkLmF0dHIoIFwiY2xhc3NcIiwgYmFzZUNsYXNzICk7XG5cblx0XHQvLyBtYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSB0aGlzIHRpbWUgY29sbGVjdGluZyBhIHByb21pc2Vcblx0XHRhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3R5bGVJbmZvID0gdGhpcyxcblx0XHRcdFx0ZGZkID0gJC5EZWZlcnJlZCgpLFxuXHRcdFx0XHRvcHRzID0galF1ZXJ5LmV4dGVuZCh7fSwgbywge1xuXHRcdFx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkZmQucmVzb2x2ZSggc3R5bGVJbmZvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5lbC5hbmltYXRlKCB0aGlzLmRpZmYsIG9wdHMgKTtcblx0XHRcdHJldHVybiBkZmQucHJvbWlzZSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gb25jZSBhbGwgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZDpcblx0XHQkLndoZW4uYXBwbHkoICQsIGFsbEFuaW1hdGlvbnMuZ2V0KCkgKS5kb25lKGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBzZXQgdGhlIGZpbmFsIGNsYXNzXG5cdFx0XHRhcHBseUNsYXNzQ2hhbmdlKCk7XG5cblx0XHRcdC8vIGZvciBlYWNoIGFuaW1hdGVkIGVsZW1lbnQsXG5cdFx0XHQvLyBjbGVhciBhbGwgY3NzIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFuaW1hdGVkXG5cdFx0XHQkLmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbCA9IHRoaXMuZWw7XG5cdFx0XHRcdCQuZWFjaCggdGhpcy5kaWZmLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRlbC5jc3MoIGtleSwgJycgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gdGhpcyBpcyBndWFybnRlZWQgdG8gYmUgdGhlcmUgaWYgeW91IHVzZSBqUXVlcnkuc3BlZWQoKVxuXHRcdFx0Ly8gaXQgYWxzbyBoYW5kbGVzIGRlcXVldWluZyB0aGUgbmV4dCBhbmltLi4uXG5cdFx0XHRvLmNvbXBsZXRlLmNhbGwoIGFuaW1hdGVkWyAwIF0gKTtcblx0XHR9KTtcblx0fSk7XG59O1xuXG4kLmZuLmV4dGVuZCh7XG5cdF9hZGRDbGFzczogJC5mbi5hZGRDbGFzcyxcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc05hbWVzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgP1xuXHRcdFx0JC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHR7IGFkZDogY2xhc3NOYW1lcyB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIDpcblx0XHRcdHRoaXMuX2FkZENsYXNzKCBjbGFzc05hbWVzICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiAkLmZuLnJlbW92ZUNsYXNzLFxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA/XG5cdFx0XHQkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgOlxuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZXMgKTtcblx0fSxcblxuXHRfdG9nZ2xlQ2xhc3M6ICQuZm4udG9nZ2xlQ2xhc3MsXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lcywgZm9yY2UsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIGZvcmNlID09PSBcImJvb2xlYW5cIiB8fCBmb3JjZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCAhc3BlZWQgKSB7XG5cdFx0XHRcdC8vIHdpdGhvdXQgc3BlZWQgcGFyYW1ldGVyXG5cdFx0XHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggY2xhc3NOYW1lcywgZm9yY2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0KGZvcmNlID8geyBhZGQ6IGNsYXNzTmFtZXMgfSA6IHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0pLFxuXHRcdFx0XHRcdHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHdpdGhvdXQgZm9yY2UgcGFyYW1ldGVyXG5cdFx0XHRyZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHR7IHRvZ2dsZTogY2xhc3NOYW1lcyB9LCBmb3JjZSwgc3BlZWQsIGVhc2luZyApO1xuXHRcdH1cblx0fSxcblxuXHRzd2l0Y2hDbGFzczogZnVuY3Rpb24oIHJlbW92ZSwgYWRkLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuXHRcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsIHtcblx0XHRcdGFkZDogYWRkLFxuXHRcdFx0cmVtb3ZlOiByZW1vdmVcblx0XHR9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9XG59KTtcblxufSkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRkZFQ1RTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiQuZXh0ZW5kKCAkLmVmZmVjdHMsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXG5cdC8vIFNhdmVzIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gYSBkYXRhIHN0b3JhZ2Vcblx0c2F2ZTogZnVuY3Rpb24oIGVsZW1lbnQsIHNldCApIHtcblx0XHRmb3IoIHZhciBpPTA7IGkgPCBzZXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIHNldFsgaSBdICE9PSBudWxsICkge1xuXHRcdFx0XHRlbGVtZW50LmRhdGEoIGRhdGFTcGFjZSArIHNldFsgaSBdLCBlbGVtZW50WyAwIF0uc3R5bGVbIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gUmVzdG9yZXMgYSBzZXQgb2YgcHJldmlvdXNseSBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYSBkYXRhIHN0b3JhZ2Vcblx0cmVzdG9yZTogZnVuY3Rpb24oIGVsZW1lbnQsIHNldCApIHtcblx0XHR2YXIgdmFsLCBpO1xuXHRcdGZvciggaT0wOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSApO1xuXHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgMS42LjJcblx0XHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTkxN1xuXHRcdFx0XHQvLyBqUXVlcnkgMS42LjIgaW5jb3JyZWN0bHkgcmV0dXJucyB1bmRlZmluZWQgZm9yIGFueSBmYWxzeSB2YWx1ZS5cblx0XHRcdFx0Ly8gV2UgY2FuJ3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFwiXCIgYW5kIDAgaGVyZSwgc28gd2UganVzdCBhc3N1bWVcblx0XHRcdFx0Ly8gZW1wdHkgc3RyaW5nIHNpbmNlIGl0J3MgbGlrZWx5IHRvIGJlIGEgbW9yZSBjb21tb24gdmFsdWUuLi5cblx0XHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YWwgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQuY3NzKCBzZXRbIGkgXSwgdmFsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldE1vZGU6IGZ1bmN0aW9uKCBlbCwgbW9kZSApIHtcblx0XHRpZiAobW9kZSA9PT0gXCJ0b2dnbGVcIikge1xuXHRcdFx0bW9kZSA9IGVsLmlzKCBcIjpoaWRkZW5cIiApID8gXCJzaG93XCIgOiBcImhpZGVcIjtcblx0XHR9XG5cdFx0cmV0dXJuIG1vZGU7XG5cdH0sXG5cblx0Ly8gVHJhbnNsYXRlcyBhIFt0b3AsbGVmdF0gYXJyYXkgaW50byBhIGJhc2VsaW5lIHZhbHVlXG5cdC8vIHRoaXMgc2hvdWxkIGJlIGEgbGl0dGxlIG1vcmUgZmxleGlibGUgaW4gdGhlIGZ1dHVyZSB0byBoYW5kbGUgYSBzdHJpbmcgJiBoYXNoXG5cdGdldEJhc2VsaW5lOiBmdW5jdGlvbiggb3JpZ2luLCBvcmlnaW5hbCApIHtcblx0XHR2YXIgeSwgeDtcblx0XHRzd2l0Y2ggKCBvcmlnaW5bIDAgXSApIHtcblx0XHRcdGNhc2UgXCJ0b3BcIjogeSA9IDA7IGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1pZGRsZVwiOiB5ID0gMC41OyBicmVhaztcblx0XHRcdGNhc2UgXCJib3R0b21cIjogeSA9IDE7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogeSA9IG9yaWdpblsgMCBdIC8gb3JpZ2luYWwuaGVpZ2h0O1xuXHRcdH1cblx0XHRzd2l0Y2ggKCBvcmlnaW5bIDEgXSApIHtcblx0XHRcdGNhc2UgXCJsZWZ0XCI6IHggPSAwOyBicmVhaztcblx0XHRcdGNhc2UgXCJjZW50ZXJcIjogeCA9IDAuNTsgYnJlYWs7XG5cdFx0XHRjYXNlIFwicmlnaHRcIjogeCA9IDE7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogeCA9IG9yaWdpblsgMSBdIC8gb3JpZ2luYWwud2lkdGg7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gV3JhcHMgdGhlIGVsZW1lbnQgYXJvdW5kIGEgd3JhcHBlciB0aGF0IGNvcGllcyBwb3NpdGlvbiBwcm9wZXJ0aWVzXG5cdGNyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB3cmFwcGVkLCByZXR1cm4gaXRcblx0XHRpZiAoIGVsZW1lbnQucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuXHRcdH1cblxuXHRcdC8vIHdyYXAgdGhlIGVsZW1lbnRcblx0XHR2YXIgcHJvcHMgPSB7XG5cdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm91dGVyV2lkdGgodHJ1ZSksXG5cdFx0XHRcdGhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKSxcblx0XHRcdFx0XCJmbG9hdFwiOiBlbGVtZW50LmNzcyggXCJmbG9hdFwiIClcblx0XHRcdH0sXG5cdFx0XHR3cmFwcGVyID0gJCggXCI8ZGl2PjwvZGl2PlwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtd3JhcHBlclwiIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0Zm9udFNpemU6IFwiMTAwJVwiLFxuXHRcdFx0XHRcdGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcblx0XHRcdFx0XHRib3JkZXI6IFwibm9uZVwiLFxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRwYWRkaW5nOiAwXG5cdFx0XHRcdH0pLFxuXHRcdFx0Ly8gU3RvcmUgdGhlIHNpemUgaW4gY2FzZSB3aWR0aC9oZWlnaHQgYXJlIGRlZmluZWQgaW4gJSAtIEZpeGVzICM1MjQ1XG5cdFx0XHRzaXplID0ge1xuXHRcdFx0XHR3aWR0aDogZWxlbWVudC53aWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0KClcblx0XHRcdH0sXG5cdFx0XHRhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0Ly8gc3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIEZpcmVmb3ggaW5jb3JyZWN0bHkgZXhwb3NlcyBhbm9ueW1vdXMgY29udGVudFxuXHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU2MTY2NFxuXHRcdHRyeSB7XG5cdFx0XHRhY3RpdmUuaWQ7XG5cdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdGFjdGl2ZSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0fVxuXG5cdFx0ZWxlbWVudC53cmFwKCB3cmFwcGVyICk7XG5cblx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdGlmICggZWxlbWVudFsgMCBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyggZWxlbWVudFsgMCBdLCBhY3RpdmUgKSApIHtcblx0XHRcdCQoIGFjdGl2ZSApLmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0d3JhcHBlciA9IGVsZW1lbnQucGFyZW50KCk7IC8vSG90Zml4IGZvciBqUXVlcnkgMS40IHNpbmNlIHNvbWUgY2hhbmdlIGluIHdyYXAoKSBzZWVtcyB0byBhY3R1YWxseSBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdyYXBwZWQgZWxlbWVudFxuXG5cdFx0Ly8gdHJhbnNmZXIgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgd3JhcHBlclxuXHRcdGlmICggZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0d3JhcHBlci5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuXHRcdFx0ZWxlbWVudC5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV4dGVuZCggcHJvcHMsIHtcblx0XHRcdFx0cG9zaXRpb246IGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdFx0ekluZGV4OiBlbGVtZW50LmNzcyggXCJ6LWluZGV4XCIgKVxuXHRcdFx0fSk7XG5cdFx0XHQkLmVhY2goWyBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiIF0sIGZ1bmN0aW9uKGksIHBvcykge1xuXHRcdFx0XHRwcm9wc1sgcG9zIF0gPSBlbGVtZW50LmNzcyggcG9zICk7XG5cdFx0XHRcdGlmICggaXNOYU4oIHBhcnNlSW50KCBwcm9wc1sgcG9zIF0sIDEwICkgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgcG9zIF0gPSBcImF1dG9cIjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRlbGVtZW50LmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IFwiYXV0b1wiLFxuXHRcdFx0XHRib3R0b206IFwiYXV0b1wiXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxlbWVudC5jc3Moc2l6ZSk7XG5cblx0XHRyZXR1cm4gd3JhcHBlci5jc3MoIHByb3BzICkuc2hvdygpO1xuXHR9LFxuXG5cdHJlbW92ZVdyYXBwZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0aWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuXHRcdFx0ZWxlbWVudC5wYXJlbnQoKS5yZXBsYWNlV2l0aCggZWxlbWVudCApO1xuXG5cdFx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdFx0aWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuXHRcdFx0XHQkKCBhY3RpdmUgKS5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0c2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oIGVsZW1lbnQsIGxpc3QsIGZhY3RvciwgdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSB8fCB7fTtcblx0XHQkLmVhY2goIGxpc3QsIGZ1bmN0aW9uKCBpLCB4ICkge1xuXHRcdFx0dmFyIHVuaXQgPSBlbGVtZW50LmNzc1VuaXQoIHggKTtcblx0XHRcdGlmICggdW5pdFsgMCBdID4gMCApIHtcblx0XHRcdFx0dmFsdWVbIHggXSA9IHVuaXRbIDAgXSAqIGZhY3RvciArIHVuaXRbIDEgXTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG4vLyByZXR1cm4gYW4gZWZmZWN0IG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyczpcbmZ1bmN0aW9uIF9ub3JtYWxpemVBcmd1bWVudHMoIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICkge1xuXG5cdC8vIGFsbG93IHBhc3NpbmcgYWxsIG9wdGlvbnMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggZWZmZWN0ICkgKSB7XG5cdFx0b3B0aW9ucyA9IGVmZmVjdDtcblx0XHRlZmZlY3QgPSBlZmZlY3QuZWZmZWN0O1xuXHR9XG5cblx0Ly8gY29udmVydCB0byBhbiBvYmplY3Rcblx0ZWZmZWN0ID0geyBlZmZlY3Q6IGVmZmVjdCB9O1xuXG5cdC8vIGNhdGNoIChlZmZlY3QsIG51bGwsIC4uLilcblx0aWYgKCBvcHRpb25zID09IG51bGwgKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gY2F0Y2ggKGVmZmVjdCwgY2FsbGJhY2spXG5cdGlmICggJC5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBjYXRjaCAoZWZmZWN0LCBzcGVlZCwgPylcblx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgb3B0aW9ucyBdICkge1xuXHRcdGNhbGxiYWNrID0gc3BlZWQ7XG5cdFx0c3BlZWQgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdC8vIGNhdGNoIChlZmZlY3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRpZiAoICQuaXNGdW5jdGlvbiggc3BlZWQgKSApIHtcblx0XHRjYWxsYmFjayA9IHNwZWVkO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0fVxuXG5cdC8vIGFkZCBvcHRpb25zIHRvIGVmZmVjdFxuXHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0JC5leHRlbmQoIGVmZmVjdCwgb3B0aW9ucyApO1xuXHR9XG5cblx0c3BlZWQgPSBzcGVlZCB8fCBvcHRpb25zLmR1cmF0aW9uO1xuXHRlZmZlY3QuZHVyYXRpb24gPSAkLmZ4Lm9mZiA/IDAgOlxuXHRcdHR5cGVvZiBzcGVlZCA9PT0gXCJudW1iZXJcIiA/IHNwZWVkIDpcblx0XHRzcGVlZCBpbiAkLmZ4LnNwZWVkcyA/ICQuZnguc3BlZWRzWyBzcGVlZCBdIDpcblx0XHQkLmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHRlZmZlY3QuY29tcGxldGUgPSBjYWxsYmFjayB8fCBvcHRpb25zLmNvbXBsZXRlO1xuXG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIHN0YW5kYXJkU3BlZWQoIHNwZWVkICkge1xuXHQvLyB2YWxpZCBzdGFuZGFyZCBzcGVlZHNcblx0aWYgKCAhc3BlZWQgfHwgdHlwZW9mIHNwZWVkID09PSBcIm51bWJlclwiIHx8ICQuZnguc3BlZWRzWyBzcGVlZCBdICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gaW52YWxpZCBzdHJpbmdzIC0gdHJlYXQgYXMgXCJub3JtYWxcIiBzcGVlZFxuXHRpZiAoIHR5cGVvZiBzcGVlZCA9PT0gXCJzdHJpbmdcIiAmJiAhJC5lZmZlY3RzLmVmZmVjdFsgc3BlZWQgXSApIHtcblx0XHQvLyBUT0RPOiByZW1vdmUgaW4gMi4wICgjNzExNSlcblx0XHRpZiAoIGJhY2tDb21wYXQgJiYgJC5lZmZlY3RzWyBzcGVlZCBdICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuJC5mbi5leHRlbmQoe1xuXHRlZmZlY3Q6IGZ1bmN0aW9uKCAvKiBlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjayAqLyApIHtcblx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0bW9kZSA9IGFyZ3MubW9kZSxcblx0XHRcdHF1ZXVlID0gYXJncy5xdWV1ZSxcblx0XHRcdGVmZmVjdE1ldGhvZCA9ICQuZWZmZWN0cy5lZmZlY3RbIGFyZ3MuZWZmZWN0IF0sXG5cblx0XHRcdC8vIERFUFJFQ0FURUQ6IHJlbW92ZSBpbiAyLjAgKCM3MTE1KVxuXHRcdFx0b2xkRWZmZWN0TWV0aG9kID0gIWVmZmVjdE1ldGhvZCAmJiBiYWNrQ29tcGF0ICYmICQuZWZmZWN0c1sgYXJncy5lZmZlY3QgXTtcblxuXHRcdGlmICggJC5meC5vZmYgfHwgISggZWZmZWN0TWV0aG9kIHx8IG9sZEVmZmVjdE1ldGhvZCApICkge1xuXHRcdFx0Ly8gZGVsZWdhdGUgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoZS5nLiwgLnNob3coKSkgaWYgcG9zc2libGVcblx0XHRcdGlmICggbW9kZSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXNbIG1vZGUgXSggYXJncy5kdXJhdGlvbiwgYXJncy5jb21wbGV0ZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBhcmdzLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0YXJncy5jb21wbGV0ZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW4oIG5leHQgKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0Y29tcGxldGUgPSBhcmdzLmNvbXBsZXRlLFxuXHRcdFx0XHRtb2RlID0gYXJncy5tb2RlO1xuXG5cdFx0XHRmdW5jdGlvbiBkb25lKCkge1xuXHRcdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggY29tcGxldGUgKSApIHtcblx0XHRcdFx0XHRjb21wbGV0ZS5jYWxsKCBlbGVtWzBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIG5leHQgKSApIHtcblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGRlbiBhbmQgbW9kZSBpcyBoaWRlLFxuXHRcdFx0Ly8gb3IgZWxlbWVudCBpcyB2aXNpYmxlIGFuZCBtb2RlIGlzIHNob3dcblx0XHRcdGlmICggZWxlbS5pcyggXCI6aGlkZGVuXCIgKSA/IG1vZGUgPT09IFwiaGlkZVwiIDogbW9kZSA9PT0gXCJzaG93XCIgKSB7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVmZmVjdE1ldGhvZC5jYWxsKCBlbGVtWzBdLCBhcmdzLCBkb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gMi4wLCBlZmZlY3RNZXRob2Qgd2lsbCBhbHdheXMgYmUgdHJ1ZVxuXHRcdGlmICggZWZmZWN0TWV0aG9kICkge1xuXHRcdFx0cmV0dXJuIHF1ZXVlID09PSBmYWxzZSA/IHRoaXMuZWFjaCggcnVuICkgOiB0aGlzLnF1ZXVlKCBxdWV1ZSB8fCBcImZ4XCIsIHJ1biApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBERVBSRUNBVEVEOiByZW1vdmUgaW4gMi4wICgjNzExNSlcblx0XHRcdHJldHVybiBvbGRFZmZlY3RNZXRob2QuY2FsbCh0aGlzLCB7XG5cdFx0XHRcdG9wdGlvbnM6IGFyZ3MsXG5cdFx0XHRcdGR1cmF0aW9uOiBhcmdzLmR1cmF0aW9uLFxuXHRcdFx0XHRjYWxsYmFjazogYXJncy5jb21wbGV0ZSxcblx0XHRcdFx0bW9kZTogYXJncy5tb2RlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3Nob3c6ICQuZm4uc2hvdyxcblx0c2hvdzogZnVuY3Rpb24oIHNwZWVkICkge1xuXHRcdGlmICggc3RhbmRhcmRTcGVlZCggc3BlZWQgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl9zaG93LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdGFyZ3MubW9kZSA9IFwic2hvd1wiO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHR9XG5cdH0sXG5cblx0X2hpZGU6ICQuZm4uaGlkZSxcblx0aGlkZTogZnVuY3Rpb24oIHNwZWVkICkge1xuXHRcdGlmICggc3RhbmRhcmRTcGVlZCggc3BlZWQgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl9oaWRlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdGFyZ3MubW9kZSA9IFwiaGlkZVwiO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8galF1ZXJ5IGNvcmUgb3ZlcmxvYWRzIHRvZ2dsZSBhbmQgY3JlYXRlcyBfdG9nZ2xlXG5cdF9fdG9nZ2xlOiAkLmZuLnRvZ2dsZSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3BlZWQgKSB7XG5cdFx0aWYgKCBzdGFuZGFyZFNwZWVkKCBzcGVlZCApIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgfHwgJC5pc0Z1bmN0aW9uKCBzcGVlZCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX190b2dnbGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0YXJncy5tb2RlID0gXCJ0b2dnbGVcIjtcblx0XHRcdHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0Y3NzVW5pdDogZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5jc3MoIGtleSApLFxuXHRcdFx0dmFsID0gW107XG5cblx0XHQkLmVhY2goIFsgXCJlbVwiLCBcInB4XCIsIFwiJVwiLCBcInB0XCIgXSwgZnVuY3Rpb24oIGksIHVuaXQgKSB7XG5cdFx0XHRpZiAoIHN0eWxlLmluZGV4T2YoIHVuaXQgKSA+IDAgKSB7XG5cdFx0XHRcdHZhbCA9IFsgcGFyc2VGbG9hdCggc3R5bGUgKSwgdW5pdCBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVBU0lORyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbihmdW5jdGlvbigpIHtcblxuLy8gYmFzZWQgb24gZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbnZhciBiYXNlRWFzaW5ncyA9IHt9O1xuXG4kLmVhY2goIFsgXCJRdWFkXCIsIFwiQ3ViaWNcIiwgXCJRdWFydFwiLCBcIlF1aW50XCIsIFwiRXhwb1wiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRiYXNlRWFzaW5nc1sgbmFtZSBdID0gZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KCBwLCBpICsgMiApO1xuXHR9O1xufSk7XG5cbiQuZXh0ZW5kKCBiYXNlRWFzaW5ncywge1xuXHRTaW5lOiBmdW5jdGlvbiAoIHAgKSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgLyAyICk7XG5cdH0sXG5cdENpcmM6IGZ1bmN0aW9uICggcCApIHtcblx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCggMSAtIHAgKiBwICk7XG5cdH0sXG5cdEVsYXN0aWM6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwID09PSAwIHx8IHAgPT09IDEgPyBwIDpcblx0XHRcdC1NYXRoLnBvdyggMiwgOCAqIChwIC0gMSkgKSAqIE1hdGguc2luKCAoIChwIC0gMSkgKiA4MCAtIDcuNSApICogTWF0aC5QSSAvIDE1ICk7XG5cdH0sXG5cdEJhY2s6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwICogcCAqICggMyAqIHAgLSAyICk7XG5cdH0sXG5cdEJvdW5jZTogZnVuY3Rpb24gKCBwICkge1xuXHRcdHZhciBwb3cyLFxuXHRcdFx0Ym91bmNlID0gNDtcblxuXHRcdHdoaWxlICggcCA8ICggKCBwb3cyID0gTWF0aC5wb3coIDIsIC0tYm91bmNlICkgKSAtIDEgKSAvIDExICkge31cblx0XHRyZXR1cm4gMSAvIE1hdGgucG93KCA0LCAzIC0gYm91bmNlICkgLSA3LjU2MjUgKiBNYXRoLnBvdyggKCBwb3cyICogMyAtIDIgKSAvIDIyIC0gcCwgMiApO1xuXHR9XG59KTtcblxuJC5lYWNoKCBiYXNlRWFzaW5ncywgZnVuY3Rpb24oIG5hbWUsIGVhc2VJbiApIHtcblx0JC5lYXNpbmdbIFwiZWFzZUluXCIgKyBuYW1lIF0gPSBlYXNlSW47XG5cdCQuZWFzaW5nWyBcImVhc2VPdXRcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAxIC0gZWFzZUluKCAxIC0gcCApO1xuXHR9O1xuXHQkLmVhc2luZ1sgXCJlYXNlSW5PdXRcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwIDwgMC41ID9cblx0XHRcdGVhc2VJbiggcCAqIDIgKSAvIDIgOlxuXHRcdFx0MSAtIGVhc2VJbiggcCAqIC0yICsgMiApIC8gMjtcblx0fTtcbn0pO1xuXG59KSgpO1xuXG59KShqUXVlcnkpKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgcnZlcnRpY2FsID0gL3VwfGRvd258dmVydGljYWwvLFxuXHRycG9zaXRpdmVtb3Rpb24gPSAvdXB8bGVmdHx2ZXJ0aWNhbHxob3Jpem9udGFsLztcblxuJC5lZmZlY3RzLmVmZmVjdC5ibGluZCA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJ1cFwiLFxuXHRcdHZlcnRpY2FsID0gcnZlcnRpY2FsLnRlc3QoIGRpcmVjdGlvbiApLFxuXHRcdHJlZiA9IHZlcnRpY2FsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIixcblx0XHRyZWYyID0gdmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0bW90aW9uID0gcnBvc2l0aXZlbW90aW9uLnRlc3QoIGRpcmVjdGlvbiApLFxuXHRcdGFuaW1hdGlvbiA9IHt9LFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHR3cmFwcGVyLCBkaXN0YW5jZSwgbWFyZ2luO1xuXG5cdC8vIGlmIGFscmVhZHkgd3JhcHBlZCwgdGhlIHdyYXBwZXIncyBwcm9wZXJ0aWVzIGFyZSBteSBwcm9wZXJ0eS4gIzYyNDVcblx0aWYgKCBlbC5wYXJlbnQoKS5pcyggXCIudWktZWZmZWN0cy13cmFwcGVyXCIgKSApIHtcblx0XHQkLmVmZmVjdHMuc2F2ZSggZWwucGFyZW50KCksIHByb3BzICk7XG5cdH0gZWxzZSB7XG5cdFx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHR9XG5cdGVsLnNob3coKTtcblx0d3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApLmNzcyh7XG5cdFx0b3ZlcmZsb3c6IFwiaGlkZGVuXCJcblx0fSk7XG5cblx0ZGlzdGFuY2UgPSB3cmFwcGVyWyByZWYgXSgpO1xuXHRtYXJnaW4gPSBwYXJzZUZsb2F0KCB3cmFwcGVyLmNzcyggcmVmMiApICkgfHwgMDtcblxuXHRhbmltYXRpb25bIHJlZiBdID0gc2hvdyA/IGRpc3RhbmNlIDogMDtcblx0aWYgKCAhbW90aW9uICkge1xuXHRcdGVsXG5cdFx0XHQuY3NzKCB2ZXJ0aWNhbCA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIsIDAgKVxuXHRcdFx0LmNzcyggdmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCIsIFwiYXV0b1wiIClcblx0XHRcdC5jc3MoeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0pO1xuXG5cdFx0YW5pbWF0aW9uWyByZWYyIF0gPSBzaG93ID8gbWFyZ2luIDogZGlzdGFuY2UgKyBtYXJnaW47XG5cdH1cblxuXHQvLyBzdGFydCBhdCAwIGlmIHdlIGFyZSBzaG93aW5nXG5cdGlmICggc2hvdyApIHtcblx0XHR3cmFwcGVyLmNzcyggcmVmLCAwICk7XG5cdFx0aWYgKCAhIG1vdGlvbiApIHtcblx0XHRcdHdyYXBwZXIuY3NzKCByZWYyLCBtYXJnaW4gKyBkaXN0YW5jZSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFuaW1hdGVcblx0d3JhcHBlci5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRkdXJhdGlvbjogby5kdXJhdGlvbixcblx0XHRlYXNpbmc6IG8uZWFzaW5nLFxuXHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xuXG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuYm91bmNlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblxuXHRcdC8vIGRlZmF1bHRzOlxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImVmZmVjdFwiICksXG5cdFx0aGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcInVwXCIsXG5cdFx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlLFxuXHRcdHRpbWVzID0gby50aW1lcyB8fCA1LFxuXG5cdFx0Ly8gbnVtYmVyIG9mIGludGVybmFsIGFuaW1hdGlvbnNcblx0XHRhbmltcyA9IHRpbWVzICogMiArICggc2hvdyB8fCBoaWRlID8gMSA6IDAgKSxcblx0XHRzcGVlZCA9IG8uZHVyYXRpb24gLyBhbmltcyxcblx0XHRlYXNpbmcgPSBvLmVhc2luZyxcblxuXHRcdC8vIHV0aWxpdHk6XG5cdFx0cmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0bW90aW9uID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiICksXG5cdFx0aSxcblx0XHR1cEFuaW0sXG5cdFx0ZG93bkFuaW0sXG5cblx0XHQvLyB3ZSB3aWxsIG5lZWQgdG8gcmUtYXNzZW1ibGUgdGhlIHF1ZXVlIHRvIHN0YWNrIG91ciBhbmltYXRpb25zIGluIHBsYWNlXG5cdFx0cXVldWUgPSBlbC5xdWV1ZSgpLFxuXHRcdHF1ZXVlbGVuID0gcXVldWUubGVuZ3RoO1xuXG5cdC8vIEF2b2lkIHRvdWNoaW5nIG9wYWNpdHkgdG8gcHJldmVudCBjbGVhclR5cGUgYW5kIFBORyBpc3N1ZXMgaW4gSUVcblx0aWYgKCBzaG93IHx8IGhpZGUgKSB7XG5cdFx0cHJvcHMucHVzaCggXCJvcGFjaXR5XCIgKTtcblx0fVxuXG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKTsgLy8gQ3JlYXRlIFdyYXBwZXJcblxuXHQvLyBkZWZhdWx0IGRpc3RhbmNlIGZvciB0aGUgQklHR0VTVCBib3VuY2UgaXMgdGhlIG91dGVyIERpc3RhbmNlIC8gM1xuXHRpZiAoICFkaXN0YW5jZSApIHtcblx0XHRkaXN0YW5jZSA9IGVsWyByZWYgPT09IFwidG9wXCIgPyBcIm91dGVySGVpZ2h0XCIgOiBcIm91dGVyV2lkdGhcIiBdKCkgLyAzO1xuXHR9XG5cblx0aWYgKCBzaG93ICkge1xuXHRcdGRvd25BbmltID0geyBvcGFjaXR5OiAxIH07XG5cdFx0ZG93bkFuaW1bIHJlZiBdID0gMDtcblxuXHRcdC8vIGlmIHdlIGFyZSBzaG93aW5nLCBmb3JjZSBvcGFjaXR5IDAgYW5kIHNldCB0aGUgaW5pdGlhbCBwb3NpdGlvblxuXHRcdC8vIHRoZW4gZG8gdGhlIFwiZmlyc3RcIiBhbmltYXRpb25cblx0XHRlbC5jc3MoIFwib3BhY2l0eVwiLCAwIClcblx0XHRcdC5jc3MoIHJlZiwgbW90aW9uID8gLWRpc3RhbmNlICogMiA6IGRpc3RhbmNlICogMiApXG5cdFx0XHQuYW5pbWF0ZSggZG93bkFuaW0sIHNwZWVkLCBlYXNpbmcgKTtcblx0fVxuXG5cdC8vIHN0YXJ0IGF0IHRoZSBzbWFsbGVzdCBkaXN0YW5jZSBpZiB3ZSBhcmUgaGlkaW5nXG5cdGlmICggaGlkZSApIHtcblx0XHRkaXN0YW5jZSA9IGRpc3RhbmNlIC8gTWF0aC5wb3coIDIsIHRpbWVzIC0gMSApO1xuXHR9XG5cblx0ZG93bkFuaW0gPSB7fTtcblx0ZG93bkFuaW1bIHJlZiBdID0gMDtcblx0Ly8gQm91bmNlcyB1cC9kb3duL2xlZnQvcmlnaHQgdGhlbiBiYWNrIHRvIDAgLS0gdGltZXMgKiAyIGFuaW1hdGlvbnMgaGFwcGVuIGhlcmVcblx0Zm9yICggaSA9IDA7IGkgPCB0aW1lczsgaSsrICkge1xuXHRcdHVwQW5pbSA9IHt9O1xuXHRcdHVwQW5pbVsgcmVmIF0gPSAoIG1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cblx0XHRlbC5hbmltYXRlKCB1cEFuaW0sIHNwZWVkLCBlYXNpbmcgKVxuXHRcdFx0LmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cblx0XHRkaXN0YW5jZSA9IGhpZGUgPyBkaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAvIDI7XG5cdH1cblxuXHQvLyBMYXN0IEJvdW5jZSB3aGVuIEhpZGluZ1xuXHRpZiAoIGhpZGUgKSB7XG5cdFx0dXBBbmltID0geyBvcGFjaXR5OiAwIH07XG5cdFx0dXBBbmltWyByZWYgXSA9ICggbW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcblxuXHRcdGVsLmFuaW1hdGUoIHVwQW5pbSwgc3BlZWQsIGVhc2luZyApO1xuXHR9XG5cblx0ZWwucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBoaWRlICkge1xuXHRcdFx0ZWwuaGlkZSgpO1xuXHRcdH1cblx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0ZG9uZSgpO1xuXHR9KTtcblxuXHQvLyBpbmplY3QgYWxsIHRoZSBhbmltYXRpb25zIHdlIGp1c3QgcXVldWVkIHRvIGJlIGZpcnN0IGluIGxpbmUgKGFmdGVyIFwiaW5wcm9ncmVzc1wiKVxuXHRpZiAoIHF1ZXVlbGVuID4gMSkge1xuXHRcdHF1ZXVlLnNwbGljZS5hcHBseSggcXVldWUsXG5cdFx0XHRbIDEsIDAgXS5jb25jYXQoIHF1ZXVlLnNwbGljZSggcXVldWVsZW4sIGFuaW1zICsgMSApICkgKTtcblx0fVxuXHRlbC5kZXF1ZXVlKCk7XG5cbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5jbGlwID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJ2ZXJ0aWNhbFwiLFxuXHRcdHZlcnQgPSBkaXJlY3Rpb24gPT09IFwidmVydGljYWxcIixcblx0XHRzaXplID0gdmVydCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG5cdFx0cG9zaXRpb24gPSB2ZXJ0ID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdGFuaW1hdGlvbiA9IHt9LFxuXHRcdHdyYXBwZXIsIGFuaW1hdGUsIGRpc3RhbmNlO1xuXG5cdC8vIFNhdmUgJiBTaG93XG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXG5cdC8vIENyZWF0ZSBXcmFwcGVyXG5cdHdyYXBwZXIgPSAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuXHRcdG92ZXJmbG93OiBcImhpZGRlblwiXG5cdH0pO1xuXHRhbmltYXRlID0gKCBlbFswXS50YWdOYW1lID09PSBcIklNR1wiICkgPyB3cmFwcGVyIDogZWw7XG5cdGRpc3RhbmNlID0gYW5pbWF0ZVsgc2l6ZSBdKCk7XG5cblx0Ly8gU2hpZnRcblx0aWYgKCBzaG93ICkge1xuXHRcdGFuaW1hdGUuY3NzKCBzaXplLCAwICk7XG5cdFx0YW5pbWF0ZS5jc3MoIHBvc2l0aW9uLCBkaXN0YW5jZSAvIDIgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBBbmltYXRpb24gT2JqZWN0OlxuXHRhbmltYXRpb25bIHNpemUgXSA9IHNob3cgPyBkaXN0YW5jZSA6IDA7XG5cdGFuaW1hdGlvblsgcG9zaXRpb24gXSA9IHNob3cgPyAwIDogZGlzdGFuY2UgLyAyO1xuXG5cdC8vIEFuaW1hdGVcblx0YW5pbWF0ZS5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFzaG93ICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xuXG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuZHJvcCA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcIm9wYWNpdHlcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwibGVmdFwiLFxuXHRcdHJlZiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiApID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdG1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApID8gXCJwb3NcIiA6IFwibmVnXCIsXG5cdFx0YW5pbWF0aW9uID0ge1xuXHRcdFx0b3BhY2l0eTogc2hvdyA/IDEgOiAwXG5cdFx0fSxcblx0XHRkaXN0YW5jZTtcblxuXHQvLyBBZGp1c3Rcblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApO1xuXG5cdGRpc3RhbmNlID0gby5kaXN0YW5jZSB8fCBlbFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiOiBcIm91dGVyV2lkdGhcIiBdKCB0cnVlICkgLyAyO1xuXG5cdGlmICggc2hvdyApIHtcblx0XHRlbFxuXHRcdFx0LmNzcyggXCJvcGFjaXR5XCIsIDAgKVxuXHRcdFx0LmNzcyggcmVmLCBtb3Rpb24gPT09IFwicG9zXCIgPyAtZGlzdGFuY2UgOiBkaXN0YW5jZSApO1xuXHR9XG5cblx0Ly8gQW5pbWF0aW9uXG5cdGFuaW1hdGlvblsgcmVmIF0gPSAoIHNob3cgP1xuXHRcdCggbW90aW9uID09PSBcInBvc1wiID8gXCIrPVwiIDogXCItPVwiICkgOlxuXHRcdCggbW90aW9uID09PSBcInBvc1wiID8gXCItPVwiIDogXCIrPVwiICkgKSArXG5cdFx0ZGlzdGFuY2U7XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmV4cGxvZGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHR2YXIgcm93cyA9IG8ucGllY2VzID8gTWF0aC5yb3VuZCggTWF0aC5zcXJ0KCBvLnBpZWNlcyApICkgOiAzLFxuXHRcdGNlbGxzID0gcm93cyxcblx0XHRlbCA9ICQoIHRoaXMgKSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cblx0XHQvLyBzaG93IGFuZCB0aGVuIHZpc2liaWxpdHk6aGlkZGVuIHRoZSBlbGVtZW50IGJlZm9yZSBjYWxjdWxhdGluZyBvZmZzZXRcblx0XHRvZmZzZXQgPSBlbC5zaG93KCkuY3NzKCBcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIiApLm9mZnNldCgpLFxuXG5cdFx0Ly8gd2lkdGggYW5kIGhlaWdodCBvZiBhIHBpZWNlXG5cdFx0d2lkdGggPSBNYXRoLmNlaWwoIGVsLm91dGVyV2lkdGgoKSAvIGNlbGxzICksXG5cdFx0aGVpZ2h0ID0gTWF0aC5jZWlsKCBlbC5vdXRlckhlaWdodCgpIC8gcm93cyApLFxuXHRcdHBpZWNlcyA9IFtdLFxuXG5cdFx0Ly8gbG9vcFxuXHRcdGksIGosIGxlZnQsIHRvcCwgbXgsIG15O1xuXG5cdC8vIGNoaWxkcmVuIGFuaW1hdGUgY29tcGxldGU6XG5cdGZ1bmN0aW9uIGNoaWxkQ29tcGxldGUoKSB7XG5cdFx0cGllY2VzLnB1c2goIHRoaXMgKTtcblx0XHRpZiAoIHBpZWNlcy5sZW5ndGggPT09IHJvd3MgKiBjZWxscyApIHtcblx0XHRcdGFuaW1Db21wbGV0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGNsb25lIHRoZSBlbGVtZW50IGZvciBlYWNoIHJvdyBhbmQgY2VsbC5cblx0Zm9yKCBpID0gMDsgaSA8IHJvd3MgOyBpKysgKSB7IC8vID09PT5cblx0XHR0b3AgPSBvZmZzZXQudG9wICsgaSAqIGhlaWdodDtcblx0XHRteSA9IGkgLSAoIHJvd3MgLSAxICkgLyAyIDtcblxuXHRcdGZvciggaiA9IDA7IGogPCBjZWxscyA7IGorKyApIHsgLy8gfHx8XG5cdFx0XHRsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBqICogd2lkdGg7XG5cdFx0XHRteCA9IGogLSAoIGNlbGxzIC0gMSApIC8gMiA7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBub3cgaGlkZGVuIG1haW4gZWxlbWVudCB0aGF0IHdpbGwgYmUgYWJzb2x1dGUgcG9zaXRpb25lZFxuXHRcdFx0Ly8gd2l0aGluIGEgd3JhcHBlciBkaXYgb2ZmIHRoZSAtbGVmdCBhbmQgLXRvcCBlcXVhbCB0byBzaXplIG9mIG91ciBwaWVjZXNcblx0XHRcdGVsXG5cdFx0XHRcdC5jbG9uZSgpXG5cdFx0XHRcdC5hcHBlbmRUbyggXCJib2R5XCIgKVxuXHRcdFx0XHQud3JhcCggXCI8ZGl2PjwvZGl2PlwiIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiBcInZpc2libGVcIixcblx0XHRcdFx0XHRsZWZ0OiAtaiAqIHdpZHRoLFxuXHRcdFx0XHRcdHRvcDogLWkgKiBoZWlnaHRcblx0XHRcdFx0fSlcblxuXHRcdFx0Ly8gc2VsZWN0IHRoZSB3cmFwcGVyIC0gbWFrZSBpdCBvdmVyZmxvdzogaGlkZGVuIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmVkIGJhc2VkIG9uXG5cdFx0XHQvLyB3aGVyZSB0aGUgb3JpZ2luYWwgd2FzIGxvY2F0ZWQgK2xlZnQgYW5kICt0b3AgZXF1YWwgdG8gdGhlIHNpemUgb2YgcGllY2VzXG5cdFx0XHRcdC5wYXJlbnQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZWZmZWN0cy1leHBsb2RlXCIgKVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdG92ZXJmbG93OiBcImhpZGRlblwiLFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0XHRsZWZ0OiBsZWZ0ICsgKCBzaG93ID8gbXggKiB3aWR0aCA6IDAgKSxcblx0XHRcdFx0XHR0b3A6IHRvcCArICggc2hvdyA/IG15ICogaGVpZ2h0IDogMCApLFxuXHRcdFx0XHRcdG9wYWNpdHk6IHNob3cgPyAwIDogMVxuXHRcdFx0XHR9KS5hbmltYXRlKHtcblx0XHRcdFx0XHRsZWZ0OiBsZWZ0ICsgKCBzaG93ID8gMCA6IG14ICogd2lkdGggKSxcblx0XHRcdFx0XHR0b3A6IHRvcCArICggc2hvdyA/IDAgOiBteSAqIGhlaWdodCApLFxuXHRcdFx0XHRcdG9wYWNpdHk6IHNob3cgPyAxIDogMFxuXHRcdFx0XHR9LCBvLmR1cmF0aW9uIHx8IDUwMCwgby5lYXNpbmcsIGNoaWxkQ29tcGxldGUgKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhbmltQ29tcGxldGUoKSB7XG5cdFx0ZWwuY3NzKHtcblx0XHRcdHZpc2liaWxpdHk6IFwidmlzaWJsZVwiXG5cdFx0fSk7XG5cdFx0JCggcGllY2VzICkucmVtb3ZlKCk7XG5cdFx0aWYgKCAhc2hvdyApIHtcblx0XHRcdGVsLmhpZGUoKTtcblx0XHR9XG5cdFx0ZG9uZSgpO1xuXHR9XG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuZmFkZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwidG9nZ2xlXCIgKTtcblxuXHRlbC5hbmltYXRlKHtcblx0XHRvcGFjaXR5OiBtb2RlXG5cdH0sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9KTtcbn07XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmZvbGQgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRzaXplID0gby5zaXplIHx8IDE1LFxuXHRcdHBlcmNlbnQgPSAvKFswLTldKyklLy5leGVjKCBzaXplICksXG5cdFx0aG9yaXpGaXJzdCA9ICEhby5ob3JpekZpcnN0LFxuXHRcdHdpZHRoRmlyc3QgPSBzaG93ICE9PSBob3JpekZpcnN0LFxuXHRcdHJlZiA9IHdpZHRoRmlyc3QgPyBbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdIDogWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRkdXJhdGlvbiA9IG8uZHVyYXRpb24gLyAyLFxuXHRcdHdyYXBwZXIsIGRpc3RhbmNlLFxuXHRcdGFuaW1hdGlvbjEgPSB7fSxcblx0XHRhbmltYXRpb24yID0ge307XG5cblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cblx0Ly8gQ3JlYXRlIFdyYXBwZXJcblx0d3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApLmNzcyh7XG5cdFx0b3ZlcmZsb3c6IFwiaGlkZGVuXCJcblx0fSk7XG5cdGRpc3RhbmNlID0gd2lkdGhGaXJzdCA/XG5cdFx0WyB3cmFwcGVyLndpZHRoKCksIHdyYXBwZXIuaGVpZ2h0KCkgXSA6XG5cdFx0WyB3cmFwcGVyLmhlaWdodCgpLCB3cmFwcGVyLndpZHRoKCkgXTtcblxuXHRpZiAoIHBlcmNlbnQgKSB7XG5cdFx0c2l6ZSA9IHBhcnNlSW50KCBwZXJjZW50WyAxIF0sIDEwICkgLyAxMDAgKiBkaXN0YW5jZVsgaGlkZSA/IDAgOiAxIF07XG5cdH1cblx0aWYgKCBzaG93ICkge1xuXHRcdHdyYXBwZXIuY3NzKCBob3JpekZpcnN0ID8ge1xuXHRcdFx0aGVpZ2h0OiAwLFxuXHRcdFx0d2lkdGg6IHNpemVcblx0XHR9IDoge1xuXHRcdFx0aGVpZ2h0OiBzaXplLFxuXHRcdFx0d2lkdGg6IDBcblx0XHR9KTtcblx0fVxuXG5cdC8vIEFuaW1hdGlvblxuXHRhbmltYXRpb24xWyByZWZbIDAgXSBdID0gc2hvdyA/IGRpc3RhbmNlWyAwIF0gOiBzaXplO1xuXHRhbmltYXRpb24yWyByZWZbIDEgXSBdID0gc2hvdyA/IGRpc3RhbmNlWyAxIF0gOiAwO1xuXG5cdC8vIEFuaW1hdGVcblx0d3JhcHBlclxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24xLCBkdXJhdGlvbiwgby5lYXNpbmcgKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24yLCBkdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBoaWRlICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9KTtcblxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmhpZ2hsaWdodCA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJiYWNrZ3JvdW5kSW1hZ2VcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJvcGFjaXR5XCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsZW0sIG8ubW9kZSB8fCBcInNob3dcIiApLFxuXHRcdGFuaW1hdGlvbiA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZWxlbS5jc3MoIFwiYmFja2dyb3VuZENvbG9yXCIgKVxuXHRcdH07XG5cblx0aWYgKG1vZGUgPT09IFwiaGlkZVwiKSB7XG5cdFx0YW5pbWF0aW9uLm9wYWNpdHkgPSAwO1xuXHR9XG5cblx0JC5lZmZlY3RzLnNhdmUoIGVsZW0sIHByb3BzICk7XG5cblx0ZWxlbVxuXHRcdC5zaG93KClcblx0XHQuY3NzKHtcblx0XHRcdGJhY2tncm91bmRJbWFnZTogXCJub25lXCIsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG8uY29sb3IgfHwgXCIjZmZmZjk5XCJcblx0XHR9KVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0XHRlbGVtLmhpZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWxlbSwgcHJvcHMgKTtcblx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnB1bHNhdGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbGVtLCBvLm1vZGUgfHwgXCJzaG93XCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0aGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuXHRcdHNob3doaWRlID0gKCBzaG93IHx8IG1vZGUgPT09IFwiaGlkZVwiICksXG5cblx0XHQvLyBzaG93aW5nIG9yIGhpZGluZyBsZWF2ZXMgb2YgdGhlIFwibGFzdFwiIGFuaW1hdGlvblxuXHRcdGFuaW1zID0gKCAoIG8udGltZXMgfHwgNSApICogMiApICsgKCBzaG93aGlkZSA/IDEgOiAwICksXG5cdFx0ZHVyYXRpb24gPSBvLmR1cmF0aW9uIC8gYW5pbXMsXG5cdFx0YW5pbWF0ZVRvID0gMCxcblx0XHRxdWV1ZSA9IGVsZW0ucXVldWUoKSxcblx0XHRxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aCxcblx0XHRpO1xuXG5cdGlmICggc2hvdyB8fCAhZWxlbS5pcyhcIjp2aXNpYmxlXCIpKSB7XG5cdFx0ZWxlbS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpO1xuXHRcdGFuaW1hdGVUbyA9IDE7XG5cdH1cblxuXHQvLyBhbmltcyAtIDEgb3BhY2l0eSBcInRvZ2dsZXNcIlxuXHRmb3IgKCBpID0gMTsgaSA8IGFuaW1zOyBpKysgKSB7XG5cdFx0ZWxlbS5hbmltYXRlKHtcblx0XHRcdG9wYWNpdHk6IGFuaW1hdGVUb1xuXHRcdH0sIGR1cmF0aW9uLCBvLmVhc2luZyApO1xuXHRcdGFuaW1hdGVUbyA9IDEgLSBhbmltYXRlVG87XG5cdH1cblxuXHRlbGVtLmFuaW1hdGUoe1xuXHRcdG9wYWNpdHk6IGFuaW1hdGVUb1xuXHR9LCBkdXJhdGlvbiwgby5lYXNpbmcpO1xuXG5cdGVsZW0ucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBoaWRlICkge1xuXHRcdFx0ZWxlbS5oaWRlKCk7XG5cdFx0fVxuXHRcdGRvbmUoKTtcblx0fSk7XG5cblx0Ly8gV2UganVzdCBxdWV1ZWQgdXAgXCJhbmltc1wiIGFuaW1hdGlvbnMsIHdlIG5lZWQgdG8gcHV0IHRoZW0gbmV4dCBpbiB0aGUgcXVldWVcblx0aWYgKCBxdWV1ZWxlbiA+IDEgKSB7XG5cdFx0cXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcblx0XHRcdFsgMSwgMCBdLmNvbmNhdCggcXVldWUuc3BsaWNlKCBxdWV1ZWxlbiwgYW5pbXMgKyAxICkgKSApO1xuXHR9XG5cdGVsZW0uZGVxdWV1ZSgpO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnB1ZmYgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbGVtLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRoaWRlID0gbW9kZSA9PT0gXCJoaWRlXCIsXG5cdFx0cGVyY2VudCA9IHBhcnNlSW50KCBvLnBlcmNlbnQsIDEwICkgfHwgMTUwLFxuXHRcdGZhY3RvciA9IHBlcmNlbnQgLyAxMDAsXG5cdFx0b3JpZ2luYWwgPSB7XG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHR3aWR0aDogZWxlbS53aWR0aCgpLFxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRcdG91dGVyV2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpXG5cdFx0fTtcblxuXHQkLmV4dGVuZCggbywge1xuXHRcdGVmZmVjdDogXCJzY2FsZVwiLFxuXHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRmYWRlOiB0cnVlLFxuXHRcdG1vZGU6IG1vZGUsXG5cdFx0Y29tcGxldGU6IGRvbmUsXG5cdFx0cGVyY2VudDogaGlkZSA/IHBlcmNlbnQgOiAxMDAsXG5cdFx0ZnJvbTogaGlkZSA/XG5cdFx0XHRvcmlnaW5hbCA6XG5cdFx0XHR7XG5cdFx0XHRcdGhlaWdodDogb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLFxuXHRcdFx0XHR3aWR0aDogb3JpZ2luYWwud2lkdGggKiBmYWN0b3IsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiBvcmlnaW5hbC5vdXRlckhlaWdodCAqIGZhY3Rvcixcblx0XHRcdFx0b3V0ZXJXaWR0aDogb3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3RvclxuXHRcdFx0fVxuXHR9KTtcblxuXHRlbGVtLmVmZmVjdCggbyApO1xufTtcblxuJC5lZmZlY3RzLmVmZmVjdC5zY2FsZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRvcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHt9LCBvICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiZWZmZWN0XCIgKSxcblx0XHRwZXJjZW50ID0gcGFyc2VJbnQoIG8ucGVyY2VudCwgMTAgKSB8fFxuXHRcdFx0KCBwYXJzZUludCggby5wZXJjZW50LCAxMCApID09PSAwID8gMCA6ICggbW9kZSA9PT0gXCJoaWRlXCIgPyAwIDogMTAwICkgKSxcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcImJvdGhcIixcblx0XHRvcmlnaW4gPSBvLm9yaWdpbixcblx0XHRvcmlnaW5hbCA9IHtcblx0XHRcdGhlaWdodDogZWwuaGVpZ2h0KCksXG5cdFx0XHR3aWR0aDogZWwud2lkdGgoKSxcblx0XHRcdG91dGVySGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpLFxuXHRcdFx0b3V0ZXJXaWR0aDogZWwub3V0ZXJXaWR0aCgpXG5cdFx0fSxcblx0XHRmYWN0b3IgPSB7XG5cdFx0XHR5OiBkaXJlY3Rpb24gIT09IFwiaG9yaXpvbnRhbFwiID8gKHBlcmNlbnQgLyAxMDApIDogMSxcblx0XHRcdHg6IGRpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiID8gKHBlcmNlbnQgLyAxMDApIDogMVxuXHRcdH07XG5cblx0Ly8gV2UgYXJlIGdvaW5nIHRvIHBhc3MgdGhpcyBlZmZlY3QgdG8gdGhlIHNpemUgZWZmZWN0OlxuXHRvcHRpb25zLmVmZmVjdCA9IFwic2l6ZVwiO1xuXHRvcHRpb25zLnF1ZXVlID0gZmFsc2U7XG5cdG9wdGlvbnMuY29tcGxldGUgPSBkb25lO1xuXG5cdC8vIFNldCBkZWZhdWx0IG9yaWdpbiBhbmQgcmVzdG9yZSBmb3Igc2hvdy9oaWRlXG5cdGlmICggbW9kZSAhPT0gXCJlZmZlY3RcIiApIHtcblx0XHRvcHRpb25zLm9yaWdpbiA9IG9yaWdpbiB8fCBbXCJtaWRkbGVcIixcImNlbnRlclwiXTtcblx0XHRvcHRpb25zLnJlc3RvcmUgPSB0cnVlO1xuXHR9XG5cblx0b3B0aW9ucy5mcm9tID0gby5mcm9tIHx8ICggbW9kZSA9PT0gXCJzaG93XCIgPyB7XG5cdFx0aGVpZ2h0OiAwLFxuXHRcdHdpZHRoOiAwLFxuXHRcdG91dGVySGVpZ2h0OiAwLFxuXHRcdG91dGVyV2lkdGg6IDBcblx0fSA6IG9yaWdpbmFsICk7XG5cdG9wdGlvbnMudG8gPSB7XG5cdFx0aGVpZ2h0OiBvcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IueSxcblx0XHR3aWR0aDogb3JpZ2luYWwud2lkdGggKiBmYWN0b3IueCxcblx0XHRvdXRlckhlaWdodDogb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IueSxcblx0XHRvdXRlcldpZHRoOiBvcmlnaW5hbC5vdXRlcldpZHRoICogZmFjdG9yLnhcblx0fTtcblxuXHQvLyBGYWRlIG9wdGlvbiB0byBzdXBwb3J0IHB1ZmZcblx0aWYgKCBvcHRpb25zLmZhZGUgKSB7XG5cdFx0aWYgKCBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRcdG9wdGlvbnMuZnJvbS5vcGFjaXR5ID0gMDtcblx0XHRcdG9wdGlvbnMudG8ub3BhY2l0eSA9IDE7XG5cdFx0fVxuXHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRvcHRpb25zLmZyb20ub3BhY2l0eSA9IDE7XG5cdFx0XHRvcHRpb25zLnRvLm9wYWNpdHkgPSAwO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFuaW1hdGVcblx0ZWwuZWZmZWN0KCBvcHRpb25zICk7XG5cbn07XG5cbiQuZWZmZWN0cy5lZmZlY3Quc2l6ZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBvcmlnaW5hbCwgYmFzZWxpbmUsIGZhY3Rvcixcblx0XHRlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wczAgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcIm92ZXJmbG93XCIsIFwib3BhY2l0eVwiIF0sXG5cblx0XHQvLyBBbHdheXMgcmVzdG9yZVxuXHRcdHByb3BzMSA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcIm92ZXJmbG93XCIsIFwib3BhY2l0eVwiIF0sXG5cblx0XHQvLyBDb3B5IGZvciBjaGlsZHJlblxuXHRcdHByb3BzMiA9IFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcIm92ZXJmbG93XCIgXSxcblx0XHRjUHJvcHMgPSBbIFwiZm9udFNpemVcIiBdLFxuXHRcdHZQcm9wcyA9IFsgXCJib3JkZXJUb3BXaWR0aFwiLCBcImJvcmRlckJvdHRvbVdpZHRoXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIiBdLFxuXHRcdGhQcm9wcyA9IFsgXCJib3JkZXJMZWZ0V2lkdGhcIiwgXCJib3JkZXJSaWdodFdpZHRoXCIsIFwicGFkZGluZ0xlZnRcIiwgXCJwYWRkaW5nUmlnaHRcIiBdLFxuXG5cdFx0Ly8gU2V0IG9wdGlvbnNcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJlZmZlY3RcIiApLFxuXHRcdHJlc3RvcmUgPSBvLnJlc3RvcmUgfHwgbW9kZSAhPT0gXCJlZmZlY3RcIixcblx0XHRzY2FsZSA9IG8uc2NhbGUgfHwgXCJib3RoXCIsXG5cdFx0b3JpZ2luID0gby5vcmlnaW4gfHwgWyBcIm1pZGRsZVwiLCBcImNlbnRlclwiIF0sXG5cdFx0cG9zaXRpb24gPSBlbC5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdHByb3BzID0gcmVzdG9yZSA/IHByb3BzMCA6IHByb3BzMSxcblx0XHR6ZXJvID0ge1xuXHRcdFx0aGVpZ2h0OiAwLFxuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRvdXRlckhlaWdodDogMCxcblx0XHRcdG91dGVyV2lkdGg6IDBcblx0XHR9O1xuXG5cdGlmICggbW9kZSA9PT0gXCJzaG93XCIgKSB7XG5cdFx0ZWwuc2hvdygpO1xuXHR9XG5cdG9yaWdpbmFsID0ge1xuXHRcdGhlaWdodDogZWwuaGVpZ2h0KCksXG5cdFx0d2lkdGg6IGVsLndpZHRoKCksXG5cdFx0b3V0ZXJIZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCksXG5cdFx0b3V0ZXJXaWR0aDogZWwub3V0ZXJXaWR0aCgpXG5cdH07XG5cblx0aWYgKCBvLm1vZGUgPT09IFwidG9nZ2xlXCIgJiYgbW9kZSA9PT0gXCJzaG93XCIgKSB7XG5cdFx0ZWwuZnJvbSA9IG8udG8gfHwgemVybztcblx0XHRlbC50byA9IG8uZnJvbSB8fCBvcmlnaW5hbDtcblx0fSBlbHNlIHtcblx0XHRlbC5mcm9tID0gby5mcm9tIHx8ICggbW9kZSA9PT0gXCJzaG93XCIgPyB6ZXJvIDogb3JpZ2luYWwgKTtcblx0XHRlbC50byA9IG8udG8gfHwgKCBtb2RlID09PSBcImhpZGVcIiA/IHplcm8gOiBvcmlnaW5hbCApO1xuXHR9XG5cblx0Ly8gU2V0IHNjYWxpbmcgZmFjdG9yXG5cdGZhY3RvciA9IHtcblx0XHRmcm9tOiB7XG5cdFx0XHR5OiBlbC5mcm9tLmhlaWdodCAvIG9yaWdpbmFsLmhlaWdodCxcblx0XHRcdHg6IGVsLmZyb20ud2lkdGggLyBvcmlnaW5hbC53aWR0aFxuXHRcdH0sXG5cdFx0dG86IHtcblx0XHRcdHk6IGVsLnRvLmhlaWdodCAvIG9yaWdpbmFsLmhlaWdodCxcblx0XHRcdHg6IGVsLnRvLndpZHRoIC8gb3JpZ2luYWwud2lkdGhcblx0XHR9XG5cdH07XG5cblx0Ly8gU2NhbGUgdGhlIGNzcyBib3hcblx0aWYgKCBzY2FsZSA9PT0gXCJib3hcIiB8fCBzY2FsZSA9PT0gXCJib3RoXCIgKSB7XG5cblx0XHQvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXG5cdFx0aWYgKCBmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSApIHtcblx0XHRcdHByb3BzID0gcHJvcHMuY29uY2F0KCB2UHJvcHMgKTtcblx0XHRcdGVsLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIHZQcm9wcywgZmFjdG9yLmZyb20ueSwgZWwuZnJvbSApO1xuXHRcdFx0ZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIHZQcm9wcywgZmFjdG9yLnRvLnksIGVsLnRvICk7XG5cdFx0fVxuXG5cdFx0Ly8gSG9yaXpvbnRhbCBwcm9wcyBzY2FsaW5nXG5cdFx0aWYgKCBmYWN0b3IuZnJvbS54ICE9PSBmYWN0b3IudG8ueCApIHtcblx0XHRcdHByb3BzID0gcHJvcHMuY29uY2F0KCBoUHJvcHMgKTtcblx0XHRcdGVsLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIGhQcm9wcywgZmFjdG9yLmZyb20ueCwgZWwuZnJvbSApO1xuXHRcdFx0ZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIGhQcm9wcywgZmFjdG9yLnRvLngsIGVsLnRvICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2NhbGUgdGhlIGNvbnRlbnRcblx0aWYgKCBzY2FsZSA9PT0gXCJjb250ZW50XCIgfHwgc2NhbGUgPT09IFwiYm90aFwiICkge1xuXG5cdFx0Ly8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xuXHRcdGlmICggZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkgKSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLmNvbmNhdCggY1Byb3BzICkuY29uY2F0KCBwcm9wczIgKTtcblx0XHRcdGVsLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIGNQcm9wcywgZmFjdG9yLmZyb20ueSwgZWwuZnJvbSApO1xuXHRcdFx0ZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWwsIGNQcm9wcywgZmFjdG9yLnRvLnksIGVsLnRvICk7XG5cdFx0fVxuXHR9XG5cblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApO1xuXHRlbC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIiApLmNzcyggZWwuZnJvbSApO1xuXG5cdC8vIEFkanVzdFxuXHRpZiAob3JpZ2luKSB7IC8vIENhbGN1bGF0ZSBiYXNlbGluZSBzaGlmdHNcblx0XHRiYXNlbGluZSA9ICQuZWZmZWN0cy5nZXRCYXNlbGluZSggb3JpZ2luLCBvcmlnaW5hbCApO1xuXHRcdGVsLmZyb20udG9wID0gKCBvcmlnaW5hbC5vdXRlckhlaWdodCAtIGVsLm91dGVySGVpZ2h0KCkgKSAqIGJhc2VsaW5lLnk7XG5cdFx0ZWwuZnJvbS5sZWZ0ID0gKCBvcmlnaW5hbC5vdXRlcldpZHRoIC0gZWwub3V0ZXJXaWR0aCgpICkgKiBiYXNlbGluZS54O1xuXHRcdGVsLnRvLnRvcCA9ICggb3JpZ2luYWwub3V0ZXJIZWlnaHQgLSBlbC50by5vdXRlckhlaWdodCApICogYmFzZWxpbmUueTtcblx0XHRlbC50by5sZWZ0ID0gKCBvcmlnaW5hbC5vdXRlcldpZHRoIC0gZWwudG8ub3V0ZXJXaWR0aCApICogYmFzZWxpbmUueDtcblx0fVxuXHRlbC5jc3MoIGVsLmZyb20gKTsgLy8gc2V0IHRvcCAmIGxlZnRcblxuXHQvLyBBbmltYXRlXG5cdGlmICggc2NhbGUgPT09IFwiY29udGVudFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHsgLy8gU2NhbGUgdGhlIGNoaWxkcmVuXG5cblx0XHQvLyBBZGQgbWFyZ2lucy9mb250LXNpemVcblx0XHR2UHJvcHMgPSB2UHJvcHMuY29uY2F0KFsgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIiBdKS5jb25jYXQoY1Byb3BzKTtcblx0XHRoUHJvcHMgPSBoUHJvcHMuY29uY2F0KFsgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luUmlnaHRcIiBdKTtcblx0XHRwcm9wczIgPSBwcm9wczAuY29uY2F0KHZQcm9wcykuY29uY2F0KGhQcm9wcyk7XG5cblx0XHRlbC5maW5kKCBcIipbd2lkdGhdXCIgKS5lYWNoKCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGNoaWxkID0gJCggdGhpcyApLFxuXHRcdFx0XHRjX29yaWdpbmFsID0ge1xuXHRcdFx0XHRcdGhlaWdodDogY2hpbGQuaGVpZ2h0KCksXG5cdFx0XHRcdFx0d2lkdGg6IGNoaWxkLndpZHRoKCksXG5cdFx0XHRcdFx0b3V0ZXJIZWlnaHQ6IGNoaWxkLm91dGVySGVpZ2h0KCksXG5cdFx0XHRcdFx0b3V0ZXJXaWR0aDogY2hpbGQub3V0ZXJXaWR0aCgpXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocmVzdG9yZSkge1xuXHRcdFx0XHQkLmVmZmVjdHMuc2F2ZShjaGlsZCwgcHJvcHMyKTtcblx0XHRcdH1cblxuXHRcdFx0Y2hpbGQuZnJvbSA9IHtcblx0XHRcdFx0aGVpZ2h0OiBjX29yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci5mcm9tLnksXG5cdFx0XHRcdHdpZHRoOiBjX29yaWdpbmFsLndpZHRoICogZmFjdG9yLmZyb20ueCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6IGNfb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IuZnJvbS55LFxuXHRcdFx0XHRvdXRlcldpZHRoOiBjX29yaWdpbmFsLm91dGVyV2lkdGggKiBmYWN0b3IuZnJvbS54XG5cdFx0XHR9O1xuXHRcdFx0Y2hpbGQudG8gPSB7XG5cdFx0XHRcdGhlaWdodDogY19vcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcblx0XHRcdFx0d2lkdGg6IGNfb3JpZ2luYWwud2lkdGggKiBmYWN0b3IudG8ueCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6IGNfb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLnRvLnksXG5cdFx0XHRcdG91dGVyV2lkdGg6IGNfb3JpZ2luYWwud2lkdGggKiBmYWN0b3IudG8ueFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xuXHRcdFx0aWYgKCBmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSApIHtcblx0XHRcdFx0Y2hpbGQuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgdlByb3BzLCBmYWN0b3IuZnJvbS55LCBjaGlsZC5mcm9tICk7XG5cdFx0XHRcdGNoaWxkLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCB2UHJvcHMsIGZhY3Rvci50by55LCBjaGlsZC50byApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb3Jpem9udGFsIHByb3BzIHNjYWxpbmdcblx0XHRcdGlmICggZmFjdG9yLmZyb20ueCAhPT0gZmFjdG9yLnRvLnggKSB7XG5cdFx0XHRcdGNoaWxkLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggY2hpbGQsIGhQcm9wcywgZmFjdG9yLmZyb20ueCwgY2hpbGQuZnJvbSApO1xuXHRcdFx0XHRjaGlsZC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgaFByb3BzLCBmYWN0b3IudG8ueCwgY2hpbGQudG8gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQW5pbWF0ZSBjaGlsZHJlblxuXHRcdFx0Y2hpbGQuY3NzKCBjaGlsZC5mcm9tICk7XG5cdFx0XHRjaGlsZC5hbmltYXRlKCBjaGlsZC50bywgby5kdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgY2hpbGRyZW5cblx0XHRcdFx0aWYgKCByZXN0b3JlICkge1xuXHRcdFx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBjaGlsZCwgcHJvcHMyICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbC5hbmltYXRlKCBlbC50bywge1xuXHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRkdXJhdGlvbjogby5kdXJhdGlvbixcblx0XHRlYXNpbmc6IG8uZWFzaW5nLFxuXHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggZWwudG8ub3BhY2l0eSA9PT0gMCApIHtcblx0XHRcdFx0ZWwuY3NzKCBcIm9wYWNpdHlcIiwgZWwuZnJvbS5vcGFjaXR5ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdGlmICggIXJlc3RvcmUgKSB7XG5cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBjYWxjdWxhdGUgb3VyIG5ldyBwb3NpdGlvbmluZyBiYXNlZCBvbiB0aGUgc2NhbGluZ1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRcdGVsLmNzcyh7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuXHRcdFx0XHRcdFx0dG9wOiBlbC50by50b3AsXG5cdFx0XHRcdFx0XHRsZWZ0OiBlbC50by5sZWZ0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5lYWNoKFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGlkeCwgcG9zICkge1xuXHRcdFx0XHRcdFx0ZWwuY3NzKCBwb3MsIGZ1bmN0aW9uKCBfLCBzdHIgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWwgPSBwYXJzZUludCggc3RyLCAxMCApLFxuXHRcdFx0XHRcdFx0XHRcdHRvUmVmID0gaWR4ID8gZWwudG8ubGVmdCA6IGVsLnRvLnRvcDtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiBvcmlnaW5hbCB3YXMgXCJhdXRvXCIsIHJlY2FsY3VsYXRlIHRoZSBuZXcgdmFsdWUgZnJvbSB3cmFwcGVyXG5cdFx0XHRcdFx0XHRcdGlmICggc3RyID09PSBcImF1dG9cIiApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9SZWYgKyBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsICsgdG9SZWYgKyBcInB4XCI7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xuXG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3Quc2hha2UgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiZWZmZWN0XCIgKSxcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcblx0XHRkaXN0YW5jZSA9IG8uZGlzdGFuY2UgfHwgMjAsXG5cdFx0dGltZXMgPSBvLnRpbWVzIHx8IDMsXG5cdFx0YW5pbXMgPSB0aW1lcyAqIDIgKyAxLFxuXHRcdHNwZWVkID0gTWF0aC5yb3VuZChvLmR1cmF0aW9uL2FuaW1zKSxcblx0XHRyZWYgPSAoZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIikgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0cG9zaXRpdmVNb3Rpb24gPSAoZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiksXG5cdFx0YW5pbWF0aW9uID0ge30sXG5cdFx0YW5pbWF0aW9uMSA9IHt9LFxuXHRcdGFuaW1hdGlvbjIgPSB7fSxcblx0XHRpLFxuXG5cdFx0Ly8gd2Ugd2lsbCBuZWVkIHRvIHJlLWFzc2VtYmxlIHRoZSBxdWV1ZSB0byBzdGFjayBvdXIgYW5pbWF0aW9ucyBpbiBwbGFjZVxuXHRcdHF1ZXVlID0gZWwucXVldWUoKSxcblx0XHRxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICk7XG5cblx0Ly8gQW5pbWF0aW9uXG5cdGFuaW1hdGlvblsgcmVmIF0gPSAoIHBvc2l0aXZlTW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcblx0YW5pbWF0aW9uMVsgcmVmIF0gPSAoIHBvc2l0aXZlTW90aW9uID8gXCIrPVwiIDogXCItPVwiICkgKyBkaXN0YW5jZSAqIDI7XG5cdGFuaW1hdGlvbjJbIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2UgKiAyO1xuXG5cdC8vIEFuaW1hdGVcblx0ZWwuYW5pbWF0ZSggYW5pbWF0aW9uLCBzcGVlZCwgby5lYXNpbmcgKTtcblxuXHQvLyBTaGFrZXNcblx0Zm9yICggaSA9IDE7IGkgPCB0aW1lczsgaSsrICkge1xuXHRcdGVsLmFuaW1hdGUoIGFuaW1hdGlvbjEsIHNwZWVkLCBvLmVhc2luZyApLmFuaW1hdGUoIGFuaW1hdGlvbjIsIHNwZWVkLCBvLmVhc2luZyApO1xuXHR9XG5cdGVsXG5cdFx0LmFuaW1hdGUoIGFuaW1hdGlvbjEsIHNwZWVkLCBvLmVhc2luZyApXG5cdFx0LmFuaW1hdGUoIGFuaW1hdGlvbiwgc3BlZWQgLyAyLCBvLmVhc2luZyApXG5cdFx0LnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fSk7XG5cblx0Ly8gaW5qZWN0IGFsbCB0aGUgYW5pbWF0aW9ucyB3ZSBqdXN0IHF1ZXVlZCB0byBiZSBmaXJzdCBpbiBsaW5lIChhZnRlciBcImlucHJvZ3Jlc3NcIilcblx0aWYgKCBxdWV1ZWxlbiA+IDEpIHtcblx0XHRxdWV1ZS5zcGxpY2UuYXBwbHkoIHF1ZXVlLFxuXHRcdFx0WyAxLCAwIF0uY29uY2F0KCBxdWV1ZS5zcGxpY2UoIHF1ZXVlbGVuLCBhbmltcyArIDEgKSApICk7XG5cdH1cblx0ZWwuZGVxdWV1ZSgpO1xuXG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3Quc2xpZGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwic2hvd1wiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwibGVmdFwiLFxuXHRcdHJlZiA9IChkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiKSA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRwb3NpdGl2ZU1vdGlvbiA9IChkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiKSxcblx0XHRkaXN0YW5jZSxcblx0XHRhbmltYXRpb24gPSB7fTtcblxuXHQvLyBBZGp1c3Rcblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdGRpc3RhbmNlID0gby5kaXN0YW5jZSB8fCBlbFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApO1xuXG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApLmNzcyh7XG5cdFx0b3ZlcmZsb3c6IFwiaGlkZGVuXCJcblx0fSk7XG5cblx0aWYgKCBzaG93ICkge1xuXHRcdGVsLmNzcyggcmVmLCBwb3NpdGl2ZU1vdGlvbiA/IChpc05hTihkaXN0YW5jZSkgPyBcIi1cIiArIGRpc3RhbmNlIDogLWRpc3RhbmNlKSA6IGRpc3RhbmNlICk7XG5cdH1cblxuXHQvLyBBbmltYXRpb25cblx0YW5pbWF0aW9uWyByZWYgXSA9ICggc2hvdyA/XG5cdFx0KCBwb3NpdGl2ZU1vdGlvbiA/IFwiKz1cIiA6IFwiLT1cIikgOlxuXHRcdCggcG9zaXRpdmVNb3Rpb24gPyBcIi09XCIgOiBcIis9XCIpKSArXG5cdFx0ZGlzdGFuY2U7XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnRyYW5zZmVyID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdHRhcmdldCA9ICQoIG8udG8gKSxcblx0XHR0YXJnZXRGaXhlZCA9IHRhcmdldC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIsXG5cdFx0Ym9keSA9ICQoXCJib2R5XCIpLFxuXHRcdGZpeFRvcCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxUb3AoKSA6IDAsXG5cdFx0Zml4TGVmdCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxMZWZ0KCkgOiAwLFxuXHRcdGVuZFBvc2l0aW9uID0gdGFyZ2V0Lm9mZnNldCgpLFxuXHRcdGFuaW1hdGlvbiA9IHtcblx0XHRcdHRvcDogZW5kUG9zaXRpb24udG9wIC0gZml4VG9wICxcblx0XHRcdGxlZnQ6IGVuZFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0ICxcblx0XHRcdGhlaWdodDogdGFyZ2V0LmlubmVySGVpZ2h0KCksXG5cdFx0XHR3aWR0aDogdGFyZ2V0LmlubmVyV2lkdGgoKVxuXHRcdH0sXG5cdFx0c3RhcnRQb3NpdGlvbiA9IGVsZW0ub2Zmc2V0KCksXG5cdFx0dHJhbnNmZXIgPSAkKCAnPGRpdiBjbGFzcz1cInVpLWVmZmVjdHMtdHJhbnNmZXJcIj48L2Rpdj4nIClcblx0XHRcdC5hcHBlbmRUbyggZG9jdW1lbnQuYm9keSApXG5cdFx0XHQuYWRkQ2xhc3MoIG8uY2xhc3NOYW1lIClcblx0XHRcdC5jc3Moe1xuXHRcdFx0XHR0b3A6IHN0YXJ0UG9zaXRpb24udG9wIC0gZml4VG9wICxcblx0XHRcdFx0bGVmdDogc3RhcnRQb3NpdGlvbi5sZWZ0IC0gZml4TGVmdCAsXG5cdFx0XHRcdGhlaWdodDogZWxlbS5pbm5lckhlaWdodCgpLFxuXHRcdFx0XHR3aWR0aDogZWxlbS5pbm5lcldpZHRoKCksXG5cdFx0XHRcdHBvc2l0aW9uOiB0YXJnZXRGaXhlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIlxuXHRcdFx0fSlcblx0XHRcdC5hbmltYXRlKCBhbmltYXRpb24sIG8uZHVyYXRpb24sIG8uZWFzaW5nLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJhbnNmZXIucmVtb3ZlKCk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgbW91c2VIYW5kbGVkID0gZmFsc2U7XG5cbiQud2lkZ2V0KCBcInVpLm1lbnVcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjx1bD5cIixcblx0ZGVsYXk6IDMwMCxcblx0b3B0aW9uczoge1xuXHRcdGljb25zOiB7XG5cdFx0XHRzdWJtZW51OiBcInVpLWljb24tY2FyYXQtMS1lXCJcblx0XHR9LFxuXHRcdG1lbnVzOiBcInVsXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRhdDogXCJyaWdodCB0b3BcIlxuXHRcdH0sXG5cdFx0cm9sZTogXCJtZW51XCIsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRibHVyOiBudWxsLFxuXHRcdGZvY3VzOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmlxdWVJZCgpXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdC50b2dnbGVDbGFzcyggXCJ1aS1tZW51LWljb25zXCIsICEhdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLWljb25cIiApLmxlbmd0aCApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLFxuXHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0fSlcblx0XHRcdC8vIG5lZWQgdG8gY2F0Y2ggYWxsIGNsaWNrcyBvbiBkaXNhYmxlZCBtZW51XG5cdFx0XHQvLyBub3QgcG9zc2libGUgdGhyb3VnaCBfb25cblx0XHRcdC5iaW5kKCBcImNsaWNrXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCAkLnByb3h5KGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyApKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiIClcblx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXHRcdH1cblxuXHRcdHRoaXMuX29uKHtcblx0XHRcdC8vIFByZXZlbnQgZm9jdXMgZnJvbSBzdGlja2luZyB0byBsaW5rcyBpbnNpZGUgbWVudSBhZnRlciBjbGlja2luZ1xuXHRcdFx0Ly8gdGhlbSAoZm9jdXMgc2hvdWxkIGFsd2F5cyBzdGF5IG9uIFVMIGR1cmluZyBuYXZpZ2F0aW9uKS5cblx0XHRcdFwibW91c2Vkb3duIC51aS1tZW51LWl0ZW0gPiBhXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1zdGF0ZS1kaXNhYmxlZCA+IGFcIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSxcblx0XHRcdFwiY2xpY2sgLnVpLW1lbnUtaXRlbTpoYXMoYSlcIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKTtcblx0XHRcdFx0aWYgKCAhbW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bW91c2VIYW5kbGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRoaXMuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0XHRcdC8vIE9wZW4gc3VibWVudSBvbiBjbGlja1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0LmhhcyggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIXRoaXMuZWxlbWVudC5pcyggXCI6Zm9jdXNcIiApICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVkaXJlY3QgZm9jdXMgdG8gdGhlIG1lbnVcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImZvY3VzXCIsIFsgdHJ1ZSBdICk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBhY3RpdmUgaXRlbSBpcyBvbiB0aGUgdG9wIGxldmVsLCBsZXQgaXQgc3RheSBhY3RpdmUuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGJsdXIgdGhlIGFjdGl2ZSBpdGVtIHNpbmNlIGl0IGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFwibW91c2VlbnRlciAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKTtcblx0XHRcdFx0Ly8gUmVtb3ZlIHVpLXN0YXRlLWFjdGl2ZSBjbGFzcyBmcm9tIHNpYmxpbmdzIG9mIHRoZSBuZXdseSBmb2N1c2VkIG1lbnUgaXRlbVxuXHRcdFx0XHQvLyB0byBhdm9pZCBhIGp1bXAgY2F1c2VkIGJ5IGFkamFjZW50IGVsZW1lbnRzIGJvdGggaGF2aW5nIGEgY2xhc3Mgd2l0aCBhIGJvcmRlclxuXHRcdFx0XHR0YXJnZXQuc2libGluZ3MoKS5jaGlsZHJlbiggXCIudWktc3RhdGUtYWN0aXZlXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGFyZ2V0ICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogXCJjb2xsYXBzZUFsbFwiLFxuXHRcdFx0XCJtb3VzZWxlYXZlIC51aS1tZW51XCI6IFwiY29sbGFwc2VBbGxcIixcblx0XHRcdGZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIGtlZXBBY3RpdmVJdGVtICkge1xuXHRcdFx0XHQvLyBJZiB0aGVyZSdzIGFscmVhZHkgYW4gYWN0aXZlIGl0ZW0sIGtlZXAgaXQgYWN0aXZlXG5cdFx0XHRcdC8vIElmIG5vdCwgYWN0aXZhdGUgdGhlIGZpcnN0IGl0ZW1cblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZSB8fCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZXEoIDAgKTtcblxuXHRcdFx0XHRpZiAoICFrZWVwQWN0aXZlSXRlbSApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbMF0sIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGtleWRvd246IFwiX2tleWRvd25cIlxuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0XHQvLyBDbGlja3Mgb3V0c2lkZSBvZiBhIG1lbnUgY29sbGFwc2UgYW55IG9wZW4gbWVudXNcblx0XHR0aGlzLl9vbiggdGhpcy5kb2N1bWVudCwge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWdcblx0XHRcdFx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIERlc3Ryb3kgKHN1YiltZW51c1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIgKVxuXHRcdFx0LmZpbmQoIFwiLnVpLW1lbnVcIiApLmFuZFNlbGYoKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktbWVudSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1tZW51LWljb25zXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWV4cGFuZGVkXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdFx0LnJlbW92ZVVuaXF1ZUlkKClcblx0XHRcdFx0LnNob3coKTtcblxuXHRcdC8vIERlc3Ryb3kgbWVudSBpdGVtc1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHQuY2hpbGRyZW4oIFwiYVwiIClcblx0XHRcdFx0LnJlbW92ZVVuaXF1ZUlkKClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1hbGwgdWktc3RhdGUtaG92ZXJcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhhc3BvcHVwXCIgKVxuXHRcdFx0XHQuY2hpbGRyZW4oKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0XHRpZiAoIGVsZW0uZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcIiApICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gRGVzdHJveSBtZW51IGRpdmlkZXJzXG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnUtZGl2aWRlclwiICkucmVtb3ZlQ2xhc3MoIFwidWktbWVudS1kaXZpZGVyIHVpLXdpZGdldC1jb250ZW50XCIgKTtcblx0fSxcblxuXHRfa2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBtYXRjaCwgcHJldiwgY2hhcmFjdGVyLCBza2lwLCByZWdleCxcblx0XHRcdHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuXHRcdGZ1bmN0aW9uIGVzY2FwZSggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSggL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiICk7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0dGhpcy5wcmV2aW91c1BhZ2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHR0aGlzLm5leHRQYWdlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdHRoaXMuX21vdmUoIFwiZmlyc3RcIiwgXCJmaXJzdFwiLCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0dGhpcy5fbW92ZSggXCJsYXN0XCIsIFwibGFzdFwiLCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHR0aGlzLnByZXZpb3VzKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdHRoaXMubmV4dCggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHR0aGlzLmNvbGxhcHNlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRpZiAoIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHR0aGlzLmV4cGFuZCggZXZlbnQgKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlNQQUNFOlxuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FU0NBUEU6XG5cdFx0XHR0aGlzLmNvbGxhcHNlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG5cdFx0XHRwcmV2ID0gdGhpcy5wcmV2aW91c0ZpbHRlciB8fCBcIlwiO1xuXHRcdFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQua2V5Q29kZSApO1xuXHRcdFx0c2tpcCA9IGZhbHNlO1xuXG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuZmlsdGVyVGltZXIgKTtcblxuXHRcdFx0aWYgKCBjaGFyYWN0ZXIgPT09IHByZXYgKSB7XG5cdFx0XHRcdHNraXAgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhcmFjdGVyID0gcHJldiArIGNoYXJhY3Rlcjtcblx0XHRcdH1cblxuXHRcdFx0cmVnZXggPSBuZXcgUmVnRXhwKCBcIl5cIiArIGVzY2FwZSggY2hhcmFjdGVyICksIFwiaVwiICk7XG5cdFx0XHRtYXRjaCA9IHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiByZWdleC50ZXN0KCAkKCB0aGlzICkuY2hpbGRyZW4oIFwiYVwiICkudGV4dCgpICk7XG5cdFx0XHR9KTtcblx0XHRcdG1hdGNoID0gc2tpcCAmJiBtYXRjaC5pbmRleCggdGhpcy5hY3RpdmUubmV4dCgpICkgIT09IC0xID9cblx0XHRcdFx0dGhpcy5hY3RpdmUubmV4dEFsbCggXCIudWktbWVudS1pdGVtXCIgKSA6XG5cdFx0XHRcdG1hdGNoO1xuXG5cdFx0XHQvLyBJZiBubyBtYXRjaGVzIG9uIHRoZSBjdXJyZW50IGZpbHRlciwgcmVzZXQgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIHByZXNzZWRcblx0XHRcdC8vIHRvIG1vdmUgZG93biB0aGUgbWVudSB0byB0aGUgZmlyc3QgaXRlbSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgY2hhcmFjdGVyXG5cdFx0XHRpZiAoICFtYXRjaC5sZW5ndGggKSB7XG5cdFx0XHRcdGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGV2ZW50LmtleUNvZGUgKTtcblx0XHRcdFx0cmVnZXggPSBuZXcgUmVnRXhwKCBcIl5cIiArIGVzY2FwZSggY2hhcmFjdGVyICksIFwiaVwiICk7XG5cdFx0XHRcdG1hdGNoID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVnZXgudGVzdCggJCggdGhpcyApLmNoaWxkcmVuKCBcImFcIiApLnRleHQoKSApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRjaC5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBtYXRjaCApO1xuXHRcdFx0XHRpZiAoIG1hdGNoLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c0ZpbHRlciA9IGNoYXJhY3Rlcjtcblx0XHRcdFx0XHR0aGlzLmZpbHRlclRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdFx0XHR9LCAxMDAwICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggcHJldmVudERlZmF1bHQgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLmFjdGl2ZS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0aWYgKCB0aGlzLmFjdGl2ZS5jaGlsZHJlbiggXCJhW2FyaWEtaGFzcG9wdXA9J3RydWUnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmV4cGFuZCggZXZlbnQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWVudXMsXG5cdFx0XHRpY29uID0gdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUsXG5cdFx0XHRzdWJtZW51cyA9IHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMubWVudXMgKTtcblxuXHRcdC8vIEluaXRpYWxpemUgbmVzdGVkIG1lbnVzXG5cdFx0c3VibWVudXMuZmlsdGVyKCBcIjpub3QoLnVpLW1lbnUpXCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLFxuXHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiXG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZW51ID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdGl0ZW0gPSBtZW51LnByZXYoIFwiYVwiICksXG5cdFx0XHRcdFx0c3VibWVudUNhcmF0ID0gJCggXCI8c3Bhbj5cIiApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudS1pY29uIHVpLWljb24gXCIgKyBpY29uIClcblx0XHRcdFx0XHRcdC5kYXRhKCBcInVpLW1lbnUtc3VibWVudS1jYXJhdFwiLCB0cnVlICk7XG5cblx0XHRcdFx0aXRlbVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtaGFzcG9wdXBcIiwgXCJ0cnVlXCIgKVxuXHRcdFx0XHRcdC5wcmVwZW5kKCBzdWJtZW51Q2FyYXQgKTtcblx0XHRcdFx0bWVudS5hdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiLCBpdGVtLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0XHR9KTtcblxuXHRcdG1lbnVzID0gc3VibWVudXMuYWRkKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdC8vIERvbid0IHJlZnJlc2ggbGlzdCBpdGVtcyB0aGF0IGFyZSBhbHJlYWR5IGFkYXB0ZWRcblx0XHRtZW51cy5jaGlsZHJlbiggXCI6bm90KC51aS1tZW51LWl0ZW0pOmhhcyhhKVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImFcIiApXG5cdFx0XHRcdC51bmlxdWVJZCgpXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0dGFiSW5kZXg6IC0xLFxuXHRcdFx0XHRcdHJvbGU6IHRoaXMuX2l0ZW1Sb2xlKClcblx0XHRcdFx0fSk7XG5cblx0XHQvLyBJbml0aWFsaXplIHVubGlua2VkIG1lbnUtaXRlbXMgY29udGFpbmluZyBzcGFjZXMgYW5kL29yIGRhc2hlcyBvbmx5IGFzIGRpdmlkZXJzXG5cdFx0bWVudXMuY2hpbGRyZW4oIFwiOm5vdCgudWktbWVudS1pdGVtKVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0Ly8gaHlwaGVuLCBlbSBkYXNoLCBlbiBkYXNoXG5cdFx0XHRpZiAoICEvW15cXC3igJTigJNcXHNdLy50ZXN0KCBpdGVtLnRleHQoKSApICkge1xuXHRcdFx0XHRpdGVtLmFkZENsYXNzKCBcInVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtZGl2aWRlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHQvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZCwgYmx1ciB0aGUgbWVudVxuXHRcdGlmICggdGhpcy5hY3RpdmUgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHR0aGlzLmJsdXIoKTtcblx0XHR9XG5cdH0sXG5cblx0X2l0ZW1Sb2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVudTogXCJtZW51aXRlbVwiLFxuXHRcdFx0bGlzdGJveDogXCJvcHRpb25cIlxuXHRcdH1bIHRoaXMub3B0aW9ucy5yb2xlIF07XG5cdH0sXG5cblx0Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwgaXRlbSApIHtcblx0XHR2YXIgbmVzdGVkLCBmb2N1c2VkO1xuXHRcdHRoaXMuYmx1ciggZXZlbnQsIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZm9jdXNcIiApO1xuXG5cdFx0dGhpcy5fc2Nyb2xsSW50b1ZpZXcoIGl0ZW0gKTtcblxuXHRcdHRoaXMuYWN0aXZlID0gaXRlbS5maXJzdCgpO1xuXHRcdGZvY3VzZWQgPSB0aGlzLmFjdGl2ZS5jaGlsZHJlbiggXCJhXCIgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0Ly8gT25seSB1cGRhdGUgYXJpYS1hY3RpdmVkZXNjZW5kYW50IGlmIHRoZXJlJ3MgYSByb2xlXG5cdFx0Ly8gb3RoZXJ3aXNlIHdlIGFzc3VtZSBmb2N1cyBpcyBtYW5hZ2VkIGVsc2V3aGVyZVxuXHRcdGlmICggdGhpcy5vcHRpb25zLnJvbGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgZm9jdXNlZC5hdHRyKCBcImlkXCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIEhpZ2hsaWdodCBhY3RpdmUgcGFyZW50IG1lbnUgaXRlbSwgaWYgYW55XG5cdFx0dGhpcy5hY3RpdmVcblx0XHRcdC5wYXJlbnQoKVxuXHRcdFx0LmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhOmZpcnN0XCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cblx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiICkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0fSwgdGhpcy5kZWxheSApO1xuXHRcdH1cblxuXHRcdG5lc3RlZCA9IGl0ZW0uY2hpbGRyZW4oIFwiLnVpLW1lbnVcIiApO1xuXHRcdGlmICggbmVzdGVkLmxlbmd0aCAmJiAoIC9ebW91c2UvLnRlc3QoIGV2ZW50LnR5cGUgKSApICkge1xuXHRcdFx0dGhpcy5fc3RhcnRPcGVuaW5nKG5lc3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuYWN0aXZlTWVudSA9IGl0ZW0ucGFyZW50KCk7XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImZvY3VzXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApO1xuXHR9LFxuXG5cdF9zY3JvbGxJbnRvVmlldzogZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0dmFyIGJvcmRlclRvcCwgcGFkZGluZ1RvcCwgb2Zmc2V0LCBzY3JvbGwsIGVsZW1lbnRIZWlnaHQsIGl0ZW1IZWlnaHQ7XG5cdFx0aWYgKCB0aGlzLl9oYXNTY3JvbGwoKSApIHtcblx0XHRcdGJvcmRlclRvcCA9IHBhcnNlRmxvYXQoICQuY3NzKCB0aGlzLmFjdGl2ZU1lbnVbMF0sIFwiYm9yZGVyVG9wV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KCAkLmNzcyggdGhpcy5hY3RpdmVNZW51WzBdLCBcInBhZGRpbmdUb3BcIiApICkgfHwgMDtcblx0XHRcdG9mZnNldCA9IGl0ZW0ub2Zmc2V0KCkudG9wIC0gdGhpcy5hY3RpdmVNZW51Lm9mZnNldCgpLnRvcCAtIGJvcmRlclRvcCAtIHBhZGRpbmdUb3A7XG5cdFx0XHRzY3JvbGwgPSB0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCk7XG5cdFx0XHRlbGVtZW50SGVpZ2h0ID0gdGhpcy5hY3RpdmVNZW51LmhlaWdodCgpO1xuXHRcdFx0aXRlbUhlaWdodCA9IGl0ZW0uaGVpZ2h0KCk7XG5cblx0XHRcdGlmICggb2Zmc2V0IDwgMCApIHtcblx0XHRcdFx0dGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcCggc2Nyb2xsICsgb2Zmc2V0ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBvZmZzZXQgKyBpdGVtSGVpZ2h0ID4gZWxlbWVudEhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcCggc2Nyb2xsICsgb2Zmc2V0IC0gZWxlbWVudEhlaWdodCArIGl0ZW1IZWlnaHQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50LCBmcm9tRm9jdXMgKSB7XG5cdFx0aWYgKCAhZnJvbUZvY3VzICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiYVwiICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdHRoaXMuYWN0aXZlID0gbnVsbDtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiYmx1clwiLCBldmVudCwgeyBpdGVtOiB0aGlzLmFjdGl2ZSB9ICk7XG5cdH0sXG5cblx0X3N0YXJ0T3BlbmluZzogZnVuY3Rpb24oIHN1Ym1lbnUgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cblx0XHQvLyBEb24ndCBvcGVuIGlmIGFscmVhZHkgb3BlbiBmaXhlcyBhIEZpcmVmb3ggYnVnIHRoYXQgY2F1c2VkIGEgLjUgcGl4ZWxcblx0XHQvLyBzaGlmdCBpbiB0aGUgc3VibWVudSBwb3NpdGlvbiB3aGVuIG1vdXNpbmcgb3ZlciB0aGUgY2FyYXQgaWNvblxuXHRcdGlmICggc3VibWVudS5hdHRyKCBcImFyaWEtaGlkZGVuXCIgKSAhPT0gXCJ0cnVlXCIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHRcdHRoaXMuX29wZW4oIHN1Ym1lbnUgKTtcblx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdH0sXG5cblx0X29wZW46IGZ1bmN0aW9uKCBzdWJtZW51ICkge1xuXHRcdHZhciBwb3NpdGlvbiA9ICQuZXh0ZW5kKHtcblx0XHRcdG9mOiB0aGlzLmFjdGl2ZVxuXHRcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnVcIiApLm5vdCggc3VibWVudS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKSApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApO1xuXG5cdFx0c3VibWVudVxuXHRcdFx0LnNob3coKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHQuYXR0ciggXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiIClcblx0XHRcdC5wb3NpdGlvbiggcG9zaXRpb24gKTtcblx0fSxcblxuXHRjb2xsYXBzZUFsbDogZnVuY3Rpb24oIGV2ZW50LCBhbGwgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSWYgd2Ugd2VyZSBwYXNzZWQgYW4gZXZlbnQsIGxvb2sgZm9yIHRoZSBzdWJtZW51IHRoYXQgY29udGFpbnMgdGhlIGV2ZW50XG5cdFx0XHR2YXIgY3VycmVudE1lbnUgPSBhbGwgPyB0aGlzLmVsZW1lbnQgOlxuXHRcdFx0XHQkKCBldmVudCAmJiBldmVudC50YXJnZXQgKS5jbG9zZXN0KCB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudVwiICkgKTtcblxuXHRcdFx0Ly8gSWYgd2UgZm91bmQgbm8gdmFsaWQgc3VibWVudSBhbmNlc3RvciwgdXNlIHRoZSBtYWluIG1lbnUgdG8gY2xvc2UgYWxsIHN1YiBtZW51cyBhbnl3YXlcblx0XHRcdGlmICggIWN1cnJlbnRNZW51Lmxlbmd0aCApIHtcblx0XHRcdFx0Y3VycmVudE1lbnUgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2Nsb3NlKCBjdXJyZW50TWVudSApO1xuXG5cdFx0XHR0aGlzLmJsdXIoIGV2ZW50ICk7XG5cdFx0XHR0aGlzLmFjdGl2ZU1lbnUgPSBjdXJyZW50TWVudTtcblx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdH0sXG5cblx0Ly8gV2l0aCBubyBhcmd1bWVudHMsIGNsb3NlcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBtZW51IC0gaWYgbm90aGluZyBpcyBhY3RpdmVcblx0Ly8gaXQgY2xvc2VzIGFsbCBtZW51cy4gIElmIHBhc3NlZCBhbiBhcmd1bWVudCwgaXQgd2lsbCBzZWFyY2ggZm9yIG1lbnVzIEJFTE9XXG5cdF9jbG9zZTogZnVuY3Rpb24oIHN0YXJ0TWVudSApIHtcblx0XHRpZiAoICFzdGFydE1lbnUgKSB7XG5cdFx0XHRzdGFydE1lbnUgPSB0aGlzLmFjdGl2ZSA/IHRoaXMuYWN0aXZlLnBhcmVudCgpIDogdGhpcy5lbGVtZW50O1xuXHRcdH1cblxuXHRcdHN0YXJ0TWVudVxuXHRcdFx0LmZpbmQoIFwiLnVpLW1lbnVcIiApXG5cdFx0XHRcdC5oaWRlKClcblx0XHRcdFx0LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIgKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIiApXG5cdFx0XHQuZW5kKClcblx0XHRcdC5maW5kKCBcImEudWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0fSxcblxuXHRjb2xsYXBzZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBuZXdJdGVtID0gdGhpcy5hY3RpdmUgJiZcblx0XHRcdHRoaXMuYWN0aXZlLnBhcmVudCgpLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiLCB0aGlzLmVsZW1lbnQgKTtcblx0XHRpZiAoIG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5ld0l0ZW0gKTtcblx0XHR9XG5cdH0sXG5cblx0ZXhwYW5kOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG5ld0l0ZW0gPSB0aGlzLmFjdGl2ZSAmJlxuXHRcdFx0dGhpcy5hY3RpdmVcblx0XHRcdFx0LmNoaWxkcmVuKCBcIi51aS1tZW51IFwiIClcblx0XHRcdFx0LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdC5maXJzdCgpO1xuXG5cdFx0aWYgKCBuZXdJdGVtICYmIG5ld0l0ZW0ubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fb3BlbiggbmV3SXRlbS5wYXJlbnQoKSApO1xuXG5cdFx0XHQvLyBEZWxheSBzbyBGaXJlZm94IHdpbGwgbm90IGhpZGUgYWN0aXZlZGVzY2VuZGFudCBjaGFuZ2UgaW4gZXhwYW5kaW5nIHN1Ym1lbnUgZnJvbSBBVFxuXHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXdJdGVtICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0bmV4dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX21vdmUoIFwibmV4dFwiLCBcImZpcnN0XCIsIGV2ZW50ICk7XG5cdH0sXG5cblx0cHJldmlvdXM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9tb3ZlKCBcInByZXZcIiwgXCJsYXN0XCIsIGV2ZW50ICk7XG5cdH0sXG5cblx0aXNGaXJzdEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUucHJldkFsbCggXCIudWktbWVudS1pdGVtXCIgKS5sZW5ndGg7XG5cdH0sXG5cblx0aXNMYXN0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aDtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24oIGRpcmVjdGlvbiwgZmlsdGVyLCBldmVudCApIHtcblx0XHR2YXIgbmV4dDtcblx0XHRpZiAoIHRoaXMuYWN0aXZlICkge1xuXHRcdFx0aWYgKCBkaXJlY3Rpb24gPT09IFwiZmlyc3RcIiB8fCBkaXJlY3Rpb24gPT09IFwibGFzdFwiICkge1xuXHRcdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVcblx0XHRcdFx0XHRbIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiID8gXCJwcmV2QWxsXCIgOiBcIm5leHRBbGxcIiBdKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFx0LmVxKCAtMSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV4dCA9IHRoaXMuYWN0aXZlXG5cdFx0XHRcdFx0WyBkaXJlY3Rpb24gKyBcIkFsbFwiIF0oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0XHQuZXEoIDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAhbmV4dCB8fCAhbmV4dC5sZW5ndGggfHwgIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0bmV4dCA9IHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKVsgZmlsdGVyIF0oKTtcblx0XHR9XG5cblx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV4dCApO1xuXHR9LFxuXG5cdG5leHRQYWdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGl0ZW0sIGJhc2UsIGhlaWdodDtcblxuXHRcdGlmICggIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0dGhpcy5uZXh0KCBldmVudCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaXNMYXN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW0ub2Zmc2V0KCkudG9wIC0gYmFzZSAtIGhlaWdodCA8IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRbICF0aGlzLmFjdGl2ZSA/IFwiZmlyc3RcIiA6IFwibGFzdFwiIF0oKSApO1xuXHRcdH1cblx0fSxcblxuXHRwcmV2aW91c1BhZ2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaXRlbSwgYmFzZSwgaGVpZ2h0O1xuXHRcdGlmICggIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0dGhpcy5uZXh0KCBldmVudCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaXNGaXJzdEl0ZW0oKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9oYXNTY3JvbGwoKSApIHtcblx0XHRcdGJhc2UgPSB0aGlzLmFjdGl2ZS5vZmZzZXQoKS50b3A7XG5cdFx0XHRoZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCk7XG5cdFx0XHR0aGlzLmFjdGl2ZS5wcmV2QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGl0ZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgKyBoZWlnaHQgPiAwO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBpdGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZmlyc3QoKSApO1xuXHRcdH1cblx0fSxcblxuXHRfaGFzU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgPCB0aGlzLmVsZW1lbnQucHJvcCggXCJzY3JvbGxIZWlnaHRcIiApO1xuXHR9LFxuXG5cdHNlbGVjdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdC8vIFRPRE86IEl0IHNob3VsZCBuZXZlciBiZSBwb3NzaWJsZSB0byBub3QgaGF2ZSBhbiBhY3RpdmUgaXRlbSBhdCB0aGlzXG5cdFx0Ly8gcG9pbnQsIGJ1dCB0aGUgdGVzdHMgZG9uJ3QgdHJpZ2dlciBtb3VzZWVudGVyIGJlZm9yZSBjbGljay5cblx0XHR0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlIHx8ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0dmFyIHVpID0geyBpdGVtOiB0aGlzLmFjdGl2ZSB9O1xuXHRcdGlmICggIXRoaXMuYWN0aXZlLmhhcyggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQsIHRydWUgKTtcblx0XHR9XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHVpICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwidWkucHJvZ3Jlc3NiYXJcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdG9wdGlvbnM6IHtcblx0XHR2YWx1ZTogMCxcblx0XHRtYXg6IDEwMFxuXHR9LFxuXG5cdG1pbjogMCxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1wcm9ncmVzc2JhciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0cm9sZTogXCJwcm9ncmVzc2JhclwiLFxuXHRcdFx0XHRcImFyaWEtdmFsdWVtaW5cIjogdGhpcy5taW4sXG5cdFx0XHRcdFwiYXJpYS12YWx1ZW1heFwiOiB0aGlzLm9wdGlvbnMubWF4LFxuXHRcdFx0XHRcImFyaWEtdmFsdWVub3dcIjogdGhpcy5fdmFsdWUoKVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnZhbHVlRGl2ID0gJCggXCI8ZGl2IGNsYXNzPSd1aS1wcm9ncmVzc2Jhci12YWx1ZSB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1sZWZ0Jz48L2Rpdj5cIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlKCk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtaW5cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbWF4XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW5vd1wiICk7XG5cblx0XHR0aGlzLnZhbHVlRGl2LnJlbW92ZSgpO1xuXHR9LFxuXG5cdHZhbHVlOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XG5cdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcInZhbHVlXCIsIG5ld1ZhbHVlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwidmFsdWVcIiApIHtcblx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRpZiAoIHRoaXMuX3ZhbHVlKCkgPT09IHRoaXMub3B0aW9ucy5tYXggKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdH0sXG5cblx0X3ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuXHRcdC8vIG5vcm1hbGl6ZSBpbnZhbGlkIHZhbHVlXG5cdFx0aWYgKCB0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0dmFsID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWluKCB0aGlzLm9wdGlvbnMubWF4LCBNYXRoLm1heCggdGhpcy5taW4sIHZhbCApICk7XG5cdH0sXG5cblx0X3BlcmNlbnRhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxMDAgKiB0aGlzLl92YWx1ZSgpIC8gdGhpcy5vcHRpb25zLm1heDtcblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCksXG5cdFx0XHRwZXJjZW50YWdlID0gdGhpcy5fcGVyY2VudGFnZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9sZFZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdHRoaXMub2xkVmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLnZhbHVlRGl2XG5cdFx0XHQudG9nZ2xlKCB2YWx1ZSA+IHRoaXMubWluIClcblx0XHRcdC50b2dnbGVDbGFzcyggXCJ1aS1jb3JuZXItcmlnaHRcIiwgdmFsdWUgPT09IHRoaXMub3B0aW9ucy5tYXggKVxuXHRcdFx0LndpZHRoKCBwZXJjZW50YWdlLnRvRml4ZWQoMCkgKyBcIiVcIiApO1xuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImFyaWEtdmFsdWVub3dcIiwgdmFsdWUgKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldChcInVpLnJlc2l6YWJsZVwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwicmVzaXplXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhbHNvUmVzaXplOiBmYWxzZSxcblx0XHRhbmltYXRlOiBmYWxzZSxcblx0XHRhbmltYXRlRHVyYXRpb246IFwic2xvd1wiLFxuXHRcdGFuaW1hdGVFYXNpbmc6IFwic3dpbmdcIixcblx0XHRhc3BlY3RSYXRpbzogZmFsc2UsXG5cdFx0YXV0b0hpZGU6IGZhbHNlLFxuXHRcdGNvbnRhaW5tZW50OiBmYWxzZSxcblx0XHRnaG9zdDogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlczogXCJlLHMsc2VcIixcblx0XHRoZWxwZXI6IGZhbHNlLFxuXHRcdG1heEhlaWdodDogbnVsbCxcblx0XHRtYXhXaWR0aDogbnVsbCxcblx0XHRtaW5IZWlnaHQ6IDEwLFxuXHRcdG1pbldpZHRoOiAxMCxcblx0XHR6SW5kZXg6IDEwMDBcblx0fSxcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktcmVzaXphYmxlXCIpO1xuXG5cdFx0JC5leHRlbmQodGhpcywge1xuXHRcdFx0X2FzcGVjdFJhdGlvOiAhIShvLmFzcGVjdFJhdGlvKSxcblx0XHRcdGFzcGVjdFJhdGlvOiBvLmFzcGVjdFJhdGlvLFxuXHRcdFx0b3JpZ2luYWxFbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRfcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50czogW10sXG5cdFx0XHRfaGVscGVyOiBvLmhlbHBlciB8fCBvLmdob3N0IHx8IG8uYW5pbWF0ZSA/IG8uaGVscGVyIHx8ICd1aS1yZXNpemFibGUtaGVscGVyJyA6IG51bGxcblx0XHR9KTtcblxuXHRcdC8vV3JhcCB0aGUgZWxlbWVudCBpZiBpdCBjYW5ub3QgaG9sZCBjaGlsZCBub2Rlc1xuXHRcdGlmKHRoaXMuZWxlbWVudFswXS5ub2RlTmFtZS5tYXRjaCgvY2FudmFzfHRleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b258aW1nL2kpKSB7XG5cblx0XHRcdC8vQ3JlYXRlIGEgd3JhcHBlciBlbGVtZW50IGFuZCBzZXQgdGhlIHdyYXBwZXIgdG8gdGhlIG5ldyBjdXJyZW50IGludGVybmFsIGVsZW1lbnRcblx0XHRcdHRoaXMuZWxlbWVudC53cmFwKFxuXHRcdFx0XHQkKCc8ZGl2IGNsYXNzPVwidWktd3JhcHBlclwiIHN0eWxlPVwib3ZlcmZsb3c6IGhpZGRlbjtcIj48L2Rpdj4nKS5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiB0aGlzLmVsZW1lbnQuY3NzKCdwb3NpdGlvbicpLFxuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRcdFx0dG9wOiB0aGlzLmVsZW1lbnQuY3NzKCd0b3AnKSxcblx0XHRcdFx0XHRsZWZ0OiB0aGlzLmVsZW1lbnQuY3NzKCdsZWZ0Jylcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdC8vT3ZlcndyaXRlIHRoZSBvcmlnaW5hbCB0aGlzLmVsZW1lbnRcblx0XHRcdHRoaXMuZWxlbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKS5kYXRhKFxuXHRcdFx0XHRcInJlc2l6YWJsZVwiLCB0aGlzLmVsZW1lbnQuZGF0YSgncmVzaXphYmxlJylcblx0XHRcdCk7XG5cblx0XHRcdHRoaXMuZWxlbWVudElzV3JhcHBlciA9IHRydWU7XG5cblx0XHRcdC8vTW92ZSBtYXJnaW5zIHRvIHRoZSB3cmFwcGVyXG5cdFx0XHR0aGlzLmVsZW1lbnQuY3NzKHsgbWFyZ2luTGVmdDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwgbWFyZ2luVG9wOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5Ub3BcIiksIG1hcmdpblJpZ2h0OiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwgbWFyZ2luQm90dG9tOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIikgfSk7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoeyBtYXJnaW5MZWZ0OiAwLCBtYXJnaW5Ub3A6IDAsIG1hcmdpblJpZ2h0OiAwLCBtYXJnaW5Cb3R0b206IDB9KTtcblxuXHRcdFx0Ly9QcmV2ZW50IFNhZmFyaSB0ZXh0YXJlYSByZXNpemVcblx0XHRcdHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSA9IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcygncmVzaXplJyk7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoJ3Jlc2l6ZScsICdub25lJyk7XG5cblx0XHRcdC8vUHVzaCB0aGUgYWN0dWFsIGVsZW1lbnQgdG8gb3VyIHByb3BvcnRpb25hbGx5UmVzaXplIGludGVybmFsIGFycmF5XG5cdFx0XHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLnB1c2godGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHsgcG9zaXRpb246ICdzdGF0aWMnLCB6b29tOiAxLCBkaXNwbGF5OiAnYmxvY2snIH0pKTtcblxuXHRcdFx0Ly8gYXZvaWQgSUUganVtcCAoaGFyZCBzZXQgdGhlIG1hcmdpbilcblx0XHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyh7IG1hcmdpbjogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCdtYXJnaW4nKSB9KTtcblxuXHRcdFx0Ly8gZml4IGhhbmRsZXJzIG9mZnNldFxuXHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlcyA9IG8uaGFuZGxlcyB8fCAoISQoJy51aS1yZXNpemFibGUtaGFuZGxlJywgdGhpcy5lbGVtZW50KS5sZW5ndGggPyBcImUscyxzZVwiIDogeyBuOiAnLnVpLXJlc2l6YWJsZS1uJywgZTogJy51aS1yZXNpemFibGUtZScsIHM6ICcudWktcmVzaXphYmxlLXMnLCB3OiAnLnVpLXJlc2l6YWJsZS13Jywgc2U6ICcudWktcmVzaXphYmxlLXNlJywgc3c6ICcudWktcmVzaXphYmxlLXN3JywgbmU6ICcudWktcmVzaXphYmxlLW5lJywgbnc6ICcudWktcmVzaXphYmxlLW53JyB9KTtcblx0XHRpZih0aGlzLmhhbmRsZXMuY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XG5cblx0XHRcdGlmKHRoaXMuaGFuZGxlcyA9PSAnYWxsJykgdGhpcy5oYW5kbGVzID0gJ24sZSxzLHcsc2Usc3csbmUsbncnO1xuXHRcdFx0dmFyIG4gPSB0aGlzLmhhbmRsZXMuc3BsaXQoXCIsXCIpOyB0aGlzLmhhbmRsZXMgPSB7fTtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHR2YXIgaGFuZGxlID0gJC50cmltKG5baV0pLCBobmFtZSA9ICd1aS1yZXNpemFibGUtJytoYW5kbGU7XG5cdFx0XHRcdHZhciBheGlzID0gJCgnPGRpdiBjbGFzcz1cInVpLXJlc2l6YWJsZS1oYW5kbGUgJyArIGhuYW1lICsgJ1wiPjwvZGl2PicpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IHpJbmRleCB0byBhbGwgaGFuZGxlcyAtIHNlZSAjNzk2MFxuXHRcdFx0XHRheGlzLmNzcyh7IHpJbmRleDogby56SW5kZXggfSk7XG5cblx0XHRcdFx0Ly9UT0RPIDogV2hhdCdzIGdvaW5nIG9uIGhlcmU/XG5cdFx0XHRcdGlmICgnc2UnID09IGhhbmRsZSkge1xuXHRcdFx0XHRcdGF4aXMuYWRkQ2xhc3MoJ3VpLWljb24gdWktaWNvbi1ncmlwc21hbGwtZGlhZ29uYWwtc2UnKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvL0luc2VydCBpbnRvIGludGVybmFsIGhhbmRsZXMgb2JqZWN0IGFuZCBhcHBlbmQgdG8gZWxlbWVudFxuXHRcdFx0XHR0aGlzLmhhbmRsZXNbaGFuZGxlXSA9ICcudWktcmVzaXphYmxlLScraGFuZGxlO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYXBwZW5kKGF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVuZGVyQXhpcyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5lbGVtZW50O1xuXG5cdFx0XHRmb3IodmFyIGkgaW4gdGhpcy5oYW5kbGVzKSB7XG5cblx0XHRcdFx0aWYodGhpcy5oYW5kbGVzW2ldLmNvbnN0cnVjdG9yID09IFN0cmluZylcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXNbaV0gPSAkKHRoaXMuaGFuZGxlc1tpXSwgdGhpcy5lbGVtZW50KS5zaG93KCk7XG5cblx0XHRcdFx0Ly9BcHBseSBwYWQgdG8gd3JhcHBlciBlbGVtZW50LCBuZWVkZWQgdG8gZml4IGF4aXMgcG9zaXRpb24gKHRleHRhcmVhLCBpbnB1dHMsIHNjcm9sbHMpXG5cdFx0XHRcdGlmICh0aGlzLmVsZW1lbnRJc1dyYXBwZXIgJiYgdGhpcy5vcmlnaW5hbEVsZW1lbnRbMF0ubm9kZU5hbWUubWF0Y2goL3RleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b24vaSkpIHtcblxuXHRcdFx0XHRcdHZhciBheGlzID0gJCh0aGlzLmhhbmRsZXNbaV0sIHRoaXMuZWxlbWVudCksIHBhZFdyYXBwZXIgPSAwO1xuXG5cdFx0XHRcdFx0Ly9DaGVja2luZyB0aGUgY29ycmVjdCBwYWQgYW5kIGJvcmRlclxuXHRcdFx0XHRcdHBhZFdyYXBwZXIgPSAvc3d8bmV8bnd8c2V8bnxzLy50ZXN0KGkpID8gYXhpcy5vdXRlckhlaWdodCgpIDogYXhpcy5vdXRlcldpZHRoKCk7XG5cblx0XHRcdFx0XHQvL1RoZSBwYWRkaW5nIHR5cGUgaSBoYXZlIHRvIGFwcGx5Li4uXG5cdFx0XHRcdFx0dmFyIHBhZFBvcyA9IFsgJ3BhZGRpbmcnLFxuXHRcdFx0XHRcdFx0L25lfG53fG4vLnRlc3QoaSkgPyAnVG9wJyA6XG5cdFx0XHRcdFx0XHQvc2V8c3d8cy8udGVzdChpKSA/ICdCb3R0b20nIDpcblx0XHRcdFx0XHRcdC9eZSQvLnRlc3QoaSkgPyAnUmlnaHQnIDogJ0xlZnQnIF0uam9pbihcIlwiKTtcblxuXHRcdFx0XHRcdHRhcmdldC5jc3MocGFkUG9zLCBwYWRXcmFwcGVyKTtcblxuXHRcdFx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vVE9ETzogV2hhdCdzIHRoYXQgZ29vZCBmb3I/IFRoZXJlJ3Mgbm90IGFueXRoaW5nIHRvIGJlIGV4ZWN1dGVkIGxlZnRcblx0XHRcdFx0aWYoISQodGhpcy5oYW5kbGVzW2ldKS5sZW5ndGgpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHJlbmRlckF4aXMgYSBwcm90b3R5cGUgZnVuY3Rpb25cblx0XHR0aGlzLl9yZW5kZXJBeGlzKHRoaXMuZWxlbWVudCk7XG5cblx0XHR0aGlzLl9oYW5kbGVzID0gJCgnLnVpLXJlc2l6YWJsZS1oYW5kbGUnLCB0aGlzLmVsZW1lbnQpXG5cdFx0XHQuZGlzYWJsZVNlbGVjdGlvbigpO1xuXG5cdFx0Ly9NYXRjaGluZyBheGlzIG5hbWVcblx0XHR0aGlzLl9oYW5kbGVzLm1vdXNlb3ZlcihmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhhdC5yZXNpemluZykge1xuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUpXG5cdFx0XHRcdFx0dmFyIGF4aXMgPSB0aGlzLmNsYXNzTmFtZS5tYXRjaCgvdWktcmVzaXphYmxlLShzZXxzd3xuZXxud3xufGV8c3x3KS9pKTtcblx0XHRcdFx0Ly9BeGlzLCBkZWZhdWx0ID0gc2Vcblx0XHRcdFx0dGhhdC5heGlzID0gYXhpcyAmJiBheGlzWzFdID8gYXhpc1sxXSA6ICdzZSc7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvL0lmIHdlIHdhbnQgdG8gYXV0byBoaWRlIHRoZSBlbGVtZW50c1xuXHRcdGlmIChvLmF1dG9IaWRlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVzLmhpZGUoKTtcblx0XHRcdCQodGhpcy5lbGVtZW50KVxuXHRcdFx0XHQuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcIilcblx0XHRcdFx0Lm1vdXNlZW50ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKG8uZGlzYWJsZWQpIHJldHVybjtcblx0XHRcdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktcmVzaXphYmxlLWF1dG9oaWRlXCIpO1xuXHRcdFx0XHRcdHRoYXQuX2hhbmRsZXMuc2hvdygpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQubW91c2VsZWF2ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmIChvLmRpc2FibGVkKSByZXR1cm47XG5cdFx0XHRcdFx0aWYgKCF0aGF0LnJlc2l6aW5nKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktcmVzaXphYmxlLWF1dG9oaWRlXCIpO1xuXHRcdFx0XHRcdFx0dGhhdC5faGFuZGxlcy5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvL0luaXRpYWxpemUgdGhlIG1vdXNlIGludGVyYWN0aW9uXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblxuXHRcdHZhciBfZGVzdHJveSA9IGZ1bmN0aW9uKGV4cCkge1xuXHRcdFx0JChleHApLnJlbW92ZUNsYXNzKFwidWktcmVzaXphYmxlIHVpLXJlc2l6YWJsZS1kaXNhYmxlZCB1aS1yZXNpemFibGUtcmVzaXppbmdcIilcblx0XHRcdFx0LnJlbW92ZURhdGEoXCJyZXNpemFibGVcIikucmVtb3ZlRGF0YShcInVpLXJlc2l6YWJsZVwiKS51bmJpbmQoXCIucmVzaXphYmxlXCIpLmZpbmQoJy51aS1yZXNpemFibGUtaGFuZGxlJykucmVtb3ZlKCk7XG5cdFx0fTtcblxuXHRcdC8vVE9ETzogVW53cmFwIGF0IHNhbWUgRE9NIHBvc2l0aW9uXG5cdFx0aWYgKHRoaXMuZWxlbWVudElzV3JhcHBlcikge1xuXHRcdFx0X2Rlc3Ryb3kodGhpcy5lbGVtZW50KTtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHtcblx0XHRcdFx0cG9zaXRpb246IHdyYXBwZXIuY3NzKCdwb3NpdGlvbicpLFxuXHRcdFx0XHR3aWR0aDogd3JhcHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRcdGhlaWdodDogd3JhcHBlci5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHR0b3A6IHdyYXBwZXIuY3NzKCd0b3AnKSxcblx0XHRcdFx0bGVmdDogd3JhcHBlci5jc3MoJ2xlZnQnKVxuXHRcdFx0fSkuaW5zZXJ0QWZ0ZXIoIHdyYXBwZXIgKTtcblx0XHRcdHdyYXBwZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCdyZXNpemUnLCB0aGlzLm9yaWdpbmFsUmVzaXplU3R5bGUpO1xuXHRcdF9kZXN0cm95KHRoaXMub3JpZ2luYWxFbGVtZW50KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZSA9IGZhbHNlO1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5oYW5kbGVzKSB7XG5cdFx0XHRpZiAoJCh0aGlzLmhhbmRsZXNbaV0pWzBdID09IGV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIGhhbmRsZTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBpbmlQb3MgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKSwgZWwgPSB0aGlzLmVsZW1lbnQ7XG5cblx0XHR0aGlzLnJlc2l6aW5nID0gdHJ1ZTtcblx0XHR0aGlzLmRvY3VtZW50U2Nyb2xsID0geyB0b3A6ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpLCBsZWZ0OiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgfTtcblxuXHRcdC8vIGJ1Z2ZpeCBmb3IgaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC8xNzQ5XG5cdFx0aWYgKGVsLmlzKCcudWktZHJhZ2dhYmxlJykgfHwgKC9hYnNvbHV0ZS8pLnRlc3QoZWwuY3NzKCdwb3NpdGlvbicpKSkge1xuXHRcdFx0ZWwuY3NzKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogaW5pUG9zLnRvcCwgbGVmdDogaW5pUG9zLmxlZnQgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVuZGVyUHJveHkoKTtcblxuXHRcdHZhciBjdXJsZWZ0ID0gbnVtKHRoaXMuaGVscGVyLmNzcygnbGVmdCcpKSwgY3VydG9wID0gbnVtKHRoaXMuaGVscGVyLmNzcygndG9wJykpO1xuXG5cdFx0aWYgKG8uY29udGFpbm1lbnQpIHtcblx0XHRcdGN1cmxlZnQgKz0gJChvLmNvbnRhaW5tZW50KS5zY3JvbGxMZWZ0KCkgfHwgMDtcblx0XHRcdGN1cnRvcCArPSAkKG8uY29udGFpbm1lbnQpLnNjcm9sbFRvcCgpIHx8IDA7XG5cdFx0fVxuXG5cdFx0Ly9TdG9yZSBuZWVkZWQgdmFyaWFibGVzXG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcblx0XHR0aGlzLnBvc2l0aW9uID0geyBsZWZ0OiBjdXJsZWZ0LCB0b3A6IGN1cnRvcCB9O1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMuX2hlbHBlciA/IHsgd2lkdGg6IGVsLm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpIH0gOiB7IHdpZHRoOiBlbC53aWR0aCgpLCBoZWlnaHQ6IGVsLmhlaWdodCgpIH07XG5cdFx0dGhpcy5vcmlnaW5hbFNpemUgPSB0aGlzLl9oZWxwZXIgPyB7IHdpZHRoOiBlbC5vdXRlcldpZHRoKCksIGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSB9IDogeyB3aWR0aDogZWwud2lkdGgoKSwgaGVpZ2h0OiBlbC5oZWlnaHQoKSB9O1xuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHsgbGVmdDogY3VybGVmdCwgdG9wOiBjdXJ0b3AgfTtcblx0XHR0aGlzLnNpemVEaWZmID0geyB3aWR0aDogZWwub3V0ZXJXaWR0aCgpIC0gZWwud2lkdGgoKSwgaGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpIC0gZWwuaGVpZ2h0KCkgfTtcblx0XHR0aGlzLm9yaWdpbmFsTW91c2VQb3NpdGlvbiA9IHsgbGVmdDogZXZlbnQucGFnZVgsIHRvcDogZXZlbnQucGFnZVkgfTtcblxuXHRcdC8vQXNwZWN0IFJhdGlvXG5cdFx0dGhpcy5hc3BlY3RSYXRpbyA9ICh0eXBlb2Ygby5hc3BlY3RSYXRpbyA9PSAnbnVtYmVyJykgPyBvLmFzcGVjdFJhdGlvIDogKCh0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCAvIHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCkgfHwgMSk7XG5cblx0XHR2YXIgY3Vyc29yID0gJCgnLnVpLXJlc2l6YWJsZS0nICsgdGhpcy5heGlzKS5jc3MoJ2N1cnNvcicpO1xuXHRcdCQoJ2JvZHknKS5jc3MoJ2N1cnNvcicsIGN1cnNvciA9PSAnYXV0bycgPyB0aGlzLmF4aXMgKyAnLXJlc2l6ZScgOiBjdXJzb3IpO1xuXG5cdFx0ZWwuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcIik7XG5cdFx0dGhpcy5fcHJvcGFnYXRlKFwic3RhcnRcIiwgZXZlbnQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHQvL0luY3JlYXNlIHBlcmZvcm1hbmNlLCBhdm9pZCByZWdleFxuXHRcdHZhciBlbCA9IHRoaXMuaGVscGVyLCBvID0gdGhpcy5vcHRpb25zLCBwcm9wcyA9IHt9LFxuXHRcdFx0dGhhdCA9IHRoaXMsIHNtcCA9IHRoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uLCBhID0gdGhpcy5heGlzO1xuXG5cdFx0dmFyIGR4ID0gKGV2ZW50LnBhZ2VYLXNtcC5sZWZ0KXx8MCwgZHkgPSAoZXZlbnQucGFnZVktc21wLnRvcCl8fDA7XG5cdFx0dmFyIHRyaWdnZXIgPSB0aGlzLl9jaGFuZ2VbYV07XG5cdFx0aWYgKCF0cmlnZ2VyKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIGF0dHJzIHRoYXQgd2lsbCBiZSBjaGFuZ2Vcblx0XHR2YXIgZGF0YSA9IHRyaWdnZXIuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKTtcblxuXHRcdC8vIFB1dCB0aGlzIGluIHRoZSBtb3VzZURyYWcgaGFuZGxlciBzaW5jZSB0aGUgdXNlciBjYW4gc3RhcnQgcHJlc3Npbmcgc2hpZnQgd2hpbGUgcmVzaXppbmdcblx0XHR0aGlzLl91cGRhdGVWaXJ0dWFsQm91bmRhcmllcyhldmVudC5zaGlmdEtleSk7XG5cdFx0aWYgKHRoaXMuX2FzcGVjdFJhdGlvIHx8IGV2ZW50LnNoaWZ0S2V5KVxuXHRcdFx0ZGF0YSA9IHRoaXMuX3VwZGF0ZVJhdGlvKGRhdGEsIGV2ZW50KTtcblxuXHRcdGRhdGEgPSB0aGlzLl9yZXNwZWN0U2l6ZShkYXRhLCBldmVudCk7XG5cblx0XHQvLyBwbHVnaW5zIGNhbGxiYWNrcyBuZWVkIHRvIGJlIGNhbGxlZCBmaXJzdFxuXHRcdHRoaXMuX3Byb3BhZ2F0ZShcInJlc2l6ZVwiLCBldmVudCk7XG5cblx0XHRlbC5jc3Moe1xuXHRcdFx0dG9wOiB0aGlzLnBvc2l0aW9uLnRvcCArIFwicHhcIiwgbGVmdDogdGhpcy5wb3NpdGlvbi5sZWZ0ICsgXCJweFwiLFxuXHRcdFx0d2lkdGg6IHRoaXMuc2l6ZS53aWR0aCArIFwicHhcIiwgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0ICsgXCJweFwiXG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMuX2hlbHBlciAmJiB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aClcblx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cblx0XHR0aGlzLl91cGRhdGVDYWNoZShkYXRhKTtcblxuXHRcdC8vIGNhbGxpbmcgdGhlIHVzZXIgY2FsbGJhY2sgYXQgdGhlIGVuZFxuXHRcdHRoaXMuX3RyaWdnZXIoJ3Jlc2l6ZScsIGV2ZW50LCB0aGlzLnVpKCkpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR0aGlzLnJlc2l6aW5nID0gZmFsc2U7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYodGhpcy5faGVscGVyKSB7XG5cdFx0XHR2YXIgcHIgPSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLCBpc3RhID0gcHIubGVuZ3RoICYmICgvdGV4dGFyZWEvaSkudGVzdChwclswXS5ub2RlTmFtZSksXG5cdFx0XHRcdHNvZmZzZXRoID0gaXN0YSAmJiAkLnVpLmhhc1Njcm9sbChwclswXSwgJ2xlZnQnKSAvKiBUT0RPIC0ganVtcCBoZWlnaHQgKi8gPyAwIDogdGhhdC5zaXplRGlmZi5oZWlnaHQsXG5cdFx0XHRcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoO1xuXG5cdFx0XHR2YXIgcyA9IHsgd2lkdGg6ICh0aGF0LmhlbHBlci53aWR0aCgpICAtIHNvZmZzZXR3KSwgaGVpZ2h0OiAodGhhdC5oZWxwZXIuaGVpZ2h0KCkgLSBzb2Zmc2V0aCkgfSxcblx0XHRcdFx0bGVmdCA9IChwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCdsZWZ0JyksIDEwKSArICh0aGF0LnBvc2l0aW9uLmxlZnQgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24ubGVmdCkpIHx8IG51bGwsXG5cdFx0XHRcdHRvcCA9IChwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCd0b3AnKSwgMTApICsgKHRoYXQucG9zaXRpb24udG9wIC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLnRvcCkpIHx8IG51bGw7XG5cblx0XHRcdGlmICghby5hbmltYXRlKVxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuY3NzKCQuZXh0ZW5kKHMsIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSkpO1xuXG5cdFx0XHR0aGF0LmhlbHBlci5oZWlnaHQodGhhdC5zaXplLmhlaWdodCk7XG5cdFx0XHR0aGF0LmhlbHBlci53aWR0aCh0aGF0LnNpemUud2lkdGgpO1xuXG5cdFx0XHRpZiAodGhpcy5faGVscGVyICYmICFvLmFuaW1hdGUpIHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cdFx0fVxuXG5cdFx0JCgnYm9keScpLmNzcygnY3Vyc29yJywgJ2F1dG8nKTtcblxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXJlc2l6YWJsZS1yZXNpemluZ1wiKTtcblxuXHRcdHRoaXMuX3Byb3BhZ2F0ZShcInN0b3BcIiwgZXZlbnQpO1xuXG5cdFx0aWYgKHRoaXMuX2hlbHBlcikgdGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0X3VwZGF0ZVZpcnR1YWxCb3VuZGFyaWVzOiBmdW5jdGlvbihmb3JjZUFzcGVjdFJhdGlvKSB7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIHBNaW5XaWR0aCwgcE1heFdpZHRoLCBwTWluSGVpZ2h0LCBwTWF4SGVpZ2h0LCBiO1xuXG5cdFx0YiA9IHtcblx0XHRcdG1pbldpZHRoOiBpc051bWJlcihvLm1pbldpZHRoKSA/IG8ubWluV2lkdGggOiAwLFxuXHRcdFx0bWF4V2lkdGg6IGlzTnVtYmVyKG8ubWF4V2lkdGgpID8gby5tYXhXaWR0aCA6IEluZmluaXR5LFxuXHRcdFx0bWluSGVpZ2h0OiBpc051bWJlcihvLm1pbkhlaWdodCkgPyBvLm1pbkhlaWdodCA6IDAsXG5cdFx0XHRtYXhIZWlnaHQ6IGlzTnVtYmVyKG8ubWF4SGVpZ2h0KSA/IG8ubWF4SGVpZ2h0IDogSW5maW5pdHlcblx0XHR9O1xuXG5cdFx0aWYodGhpcy5fYXNwZWN0UmF0aW8gfHwgZm9yY2VBc3BlY3RSYXRpbykge1xuXHRcdFx0Ly8gV2Ugd2FudCB0byBjcmVhdGUgYW4gZW5jbG9zaW5nIGJveCB3aG9zZSBhc3BlY3QgcmF0aW9uIGlzIHRoZSByZXF1ZXN0ZWQgb25lXG5cdFx0XHQvLyBGaXJzdCwgY29tcHV0ZSB0aGUgXCJwcm9qZWN0ZWRcIiBzaXplIGZvciBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiB0aGUgYXNwZWN0IHJhdGlvIGFuZCBvdGhlciBkaW1lbnNpb25cblx0XHRcdHBNaW5XaWR0aCA9IGIubWluSGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNaW5IZWlnaHQgPSBiLm1pbldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNYXhXaWR0aCA9IGIubWF4SGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNYXhIZWlnaHQgPSBiLm1heFdpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcblxuXHRcdFx0aWYocE1pbldpZHRoID4gYi5taW5XaWR0aCkgYi5taW5XaWR0aCA9IHBNaW5XaWR0aDtcblx0XHRcdGlmKHBNaW5IZWlnaHQgPiBiLm1pbkhlaWdodCkgYi5taW5IZWlnaHQgPSBwTWluSGVpZ2h0O1xuXHRcdFx0aWYocE1heFdpZHRoIDwgYi5tYXhXaWR0aCkgYi5tYXhXaWR0aCA9IHBNYXhXaWR0aDtcblx0XHRcdGlmKHBNYXhIZWlnaHQgPCBiLm1heEhlaWdodCkgYi5tYXhIZWlnaHQgPSBwTWF4SGVpZ2h0O1xuXHRcdH1cblx0XHR0aGlzLl92Qm91bmRhcmllcyA9IGI7XG5cdH0sXG5cblx0X3VwZGF0ZUNhY2hlOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcblx0XHRpZiAoaXNOdW1iZXIoZGF0YS5sZWZ0KSkgdGhpcy5wb3NpdGlvbi5sZWZ0ID0gZGF0YS5sZWZ0O1xuXHRcdGlmIChpc051bWJlcihkYXRhLnRvcCkpIHRoaXMucG9zaXRpb24udG9wID0gZGF0YS50b3A7XG5cdFx0aWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkgdGhpcy5zaXplLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xuXHRcdGlmIChpc051bWJlcihkYXRhLndpZHRoKSkgdGhpcy5zaXplLndpZHRoID0gZGF0YS53aWR0aDtcblx0fSxcblxuXHRfdXBkYXRlUmF0aW86IGZ1bmN0aW9uKGRhdGEsIGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgY3BvcyA9IHRoaXMucG9zaXRpb24sIGNzaXplID0gdGhpcy5zaXplLCBhID0gdGhpcy5heGlzO1xuXG5cdFx0aWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkgZGF0YS53aWR0aCA9IChkYXRhLmhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW8pO1xuXHRcdGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSBkYXRhLmhlaWdodCA9IChkYXRhLndpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbyk7XG5cblx0XHRpZiAoYSA9PSAnc3cnKSB7XG5cdFx0XHRkYXRhLmxlZnQgPSBjcG9zLmxlZnQgKyAoY3NpemUud2lkdGggLSBkYXRhLndpZHRoKTtcblx0XHRcdGRhdGEudG9wID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKGEgPT0gJ253Jykge1xuXHRcdFx0ZGF0YS50b3AgPSBjcG9zLnRvcCArIChjc2l6ZS5oZWlnaHQgLSBkYXRhLmhlaWdodCk7XG5cdFx0XHRkYXRhLmxlZnQgPSBjcG9zLmxlZnQgKyAoY3NpemUud2lkdGggLSBkYXRhLndpZHRoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRfcmVzcGVjdFNpemU6IGZ1bmN0aW9uKGRhdGEsIGV2ZW50KSB7XG5cblx0XHR2YXIgZWwgPSB0aGlzLmhlbHBlciwgbyA9IHRoaXMuX3ZCb3VuZGFyaWVzLCBwUmF0aW8gPSB0aGlzLl9hc3BlY3RSYXRpbyB8fCBldmVudC5zaGlmdEtleSwgYSA9IHRoaXMuYXhpcyxcblx0XHRcdFx0aXNtYXh3ID0gaXNOdW1iZXIoZGF0YS53aWR0aCkgJiYgby5tYXhXaWR0aCAmJiAoby5tYXhXaWR0aCA8IGRhdGEud2lkdGgpLCBpc21heGggPSBpc051bWJlcihkYXRhLmhlaWdodCkgJiYgby5tYXhIZWlnaHQgJiYgKG8ubWF4SGVpZ2h0IDwgZGF0YS5oZWlnaHQpLFxuXHRcdFx0XHRcdGlzbWludyA9IGlzTnVtYmVyKGRhdGEud2lkdGgpICYmIG8ubWluV2lkdGggJiYgKG8ubWluV2lkdGggPiBkYXRhLndpZHRoKSwgaXNtaW5oID0gaXNOdW1iZXIoZGF0YS5oZWlnaHQpICYmIG8ubWluSGVpZ2h0ICYmIChvLm1pbkhlaWdodCA+IGRhdGEuaGVpZ2h0KTtcblxuXHRcdGlmIChpc21pbncpIGRhdGEud2lkdGggPSBvLm1pbldpZHRoO1xuXHRcdGlmIChpc21pbmgpIGRhdGEuaGVpZ2h0ID0gby5taW5IZWlnaHQ7XG5cdFx0aWYgKGlzbWF4dykgZGF0YS53aWR0aCA9IG8ubWF4V2lkdGg7XG5cdFx0aWYgKGlzbWF4aCkgZGF0YS5oZWlnaHQgPSBvLm1heEhlaWdodDtcblxuXHRcdHZhciBkdyA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbi5sZWZ0ICsgdGhpcy5vcmlnaW5hbFNpemUud2lkdGgsIGRoID0gdGhpcy5wb3NpdGlvbi50b3AgKyB0aGlzLnNpemUuaGVpZ2h0O1xuXHRcdHZhciBjdyA9IC9zd3xud3x3Ly50ZXN0KGEpLCBjaCA9IC9ud3xuZXxuLy50ZXN0KGEpO1xuXG5cdFx0aWYgKGlzbWludyAmJiBjdykgZGF0YS5sZWZ0ID0gZHcgLSBvLm1pbldpZHRoO1xuXHRcdGlmIChpc21heHcgJiYgY3cpIGRhdGEubGVmdCA9IGR3IC0gby5tYXhXaWR0aDtcblx0XHRpZiAoaXNtaW5oICYmIGNoKVx0ZGF0YS50b3AgPSBkaCAtIG8ubWluSGVpZ2h0O1xuXHRcdGlmIChpc21heGggJiYgY2gpXHRkYXRhLnRvcCA9IGRoIC0gby5tYXhIZWlnaHQ7XG5cblx0XHQvLyBmaXhpbmcganVtcCBlcnJvciBvbiB0b3AvbGVmdCAtIGJ1ZyAjMjMzMFxuXHRcdHZhciBpc05vdHdoID0gIWRhdGEud2lkdGggJiYgIWRhdGEuaGVpZ2h0O1xuXHRcdGlmIChpc05vdHdoICYmICFkYXRhLmxlZnQgJiYgZGF0YS50b3ApIGRhdGEudG9wID0gbnVsbDtcblx0XHRlbHNlIGlmIChpc05vdHdoICYmICFkYXRhLnRvcCAmJiBkYXRhLmxlZnQpIGRhdGEubGVmdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRfcHJvcG9ydGlvbmFsbHlSZXNpemU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0aWYgKCF0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aCkgcmV0dXJuO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5oZWxwZXIgfHwgdGhpcy5lbGVtZW50O1xuXG5cdFx0Zm9yICh2YXIgaT0wOyBpIDwgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHR2YXIgcHJlbCA9IHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHNbaV07XG5cblx0XHRcdGlmICghdGhpcy5ib3JkZXJEaWYpIHtcblx0XHRcdFx0dmFyIGIgPSBbcHJlbC5jc3MoJ2JvcmRlclRvcFdpZHRoJyksIHByZWwuY3NzKCdib3JkZXJSaWdodFdpZHRoJyksIHByZWwuY3NzKCdib3JkZXJCb3R0b21XaWR0aCcpLCBwcmVsLmNzcygnYm9yZGVyTGVmdFdpZHRoJyldLFxuXHRcdFx0XHRcdHAgPSBbcHJlbC5jc3MoJ3BhZGRpbmdUb3AnKSwgcHJlbC5jc3MoJ3BhZGRpbmdSaWdodCcpLCBwcmVsLmNzcygncGFkZGluZ0JvdHRvbScpLCBwcmVsLmNzcygncGFkZGluZ0xlZnQnKV07XG5cblx0XHRcdFx0dGhpcy5ib3JkZXJEaWYgPSAkLm1hcChiLCBmdW5jdGlvbih2LCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJvcmRlciA9IHBhcnNlSW50KHYsMTApfHwwLCBwYWRkaW5nID0gcGFyc2VJbnQocFtpXSwxMCl8fDA7XG5cdFx0XHRcdFx0cmV0dXJuIGJvcmRlciArIHBhZGRpbmc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmVsLmNzcyh7XG5cdFx0XHRcdGhlaWdodDogKGVsZW1lbnQuaGVpZ2h0KCkgLSB0aGlzLmJvcmRlckRpZlswXSAtIHRoaXMuYm9yZGVyRGlmWzJdKSB8fCAwLFxuXHRcdFx0XHR3aWR0aDogKGVsZW1lbnQud2lkdGgoKSAtIHRoaXMuYm9yZGVyRGlmWzFdIC0gdGhpcy5ib3JkZXJEaWZbM10pIHx8IDBcblx0XHRcdH0pO1xuXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9yZW5kZXJQcm94eTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZWwgPSB0aGlzLmVsZW1lbnQsIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5lbGVtZW50T2Zmc2V0ID0gZWwub2Zmc2V0KCk7XG5cblx0XHRpZih0aGlzLl9oZWxwZXIpIHtcblxuXHRcdFx0dGhpcy5oZWxwZXIgPSB0aGlzLmhlbHBlciB8fCAkKCc8ZGl2IHN0eWxlPVwib3ZlcmZsb3c6aGlkZGVuO1wiPjwvZGl2PicpO1xuXG5cdFx0XHQvLyBmaXggaWU2IG9mZnNldCBUT0RPOiBUaGlzIHNlZW1zIGJyb2tlblxuXHRcdFx0dmFyIGllNm9mZnNldCA9ICgkLnVpLmllNiA/IDEgOiAwKSxcblx0XHRcdHB4eW9mZnNldCA9ICggJC51aS5pZTYgPyAyIDogLTEgKTtcblxuXHRcdFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3ModGhpcy5faGVscGVyKS5jc3Moe1xuXHRcdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSArIHB4eW9mZnNldCxcblx0XHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSArIHB4eW9mZnNldCxcblx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdGxlZnQ6IHRoaXMuZWxlbWVudE9mZnNldC5sZWZ0IC0gaWU2b2Zmc2V0ICsncHgnLFxuXHRcdFx0XHR0b3A6IHRoaXMuZWxlbWVudE9mZnNldC50b3AgLSBpZTZvZmZzZXQgKydweCcsXG5cdFx0XHRcdHpJbmRleDogKytvLnpJbmRleCAvL1RPRE86IERvbid0IG1vZGlmeSBvcHRpb25cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmhlbHBlclxuXHRcdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpXG5cdFx0XHRcdC5kaXNhYmxlU2VsZWN0aW9uKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5oZWxwZXIgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdH0sXG5cblx0X2NoYW5nZToge1xuXHRcdGU6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcblx0XHRcdHJldHVybiB7IHdpZHRoOiB0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCArIGR4IH07XG5cdFx0fSxcblx0XHR3OiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSwgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG5cdFx0XHRyZXR1cm4geyBsZWZ0OiBzcC5sZWZ0ICsgZHgsIHdpZHRoOiBjcy53aWR0aCAtIGR4IH07XG5cdFx0fSxcblx0XHRuOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSwgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG5cdFx0XHRyZXR1cm4geyB0b3A6IHNwLnRvcCArIGR5LCBoZWlnaHQ6IGNzLmhlaWdodCAtIGR5IH07XG5cdFx0fSxcblx0XHRzOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4geyBoZWlnaHQ6IHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCArIGR5IH07XG5cdFx0fSxcblx0XHRzZTogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS5lLmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xuXHRcdH0sXG5cdFx0c3c6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcblx0XHR9LFxuXHRcdG5lOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQodGhpcy5fY2hhbmdlLm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcy5fY2hhbmdlLmUuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKSk7XG5cdFx0fSxcblx0XHRudzogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS53LmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcHJvcGFnYXRlOiBmdW5jdGlvbihuLCBldmVudCkge1xuXHRcdCQudWkucGx1Z2luLmNhbGwodGhpcywgbiwgW2V2ZW50LCB0aGlzLnVpKCldKTtcblx0XHQobiAhPSBcInJlc2l6ZVwiICYmIHRoaXMuX3RyaWdnZXIobiwgZXZlbnQsIHRoaXMudWkoKSkpO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdHVpOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0b3JpZ2luYWxFbGVtZW50OiB0aGlzLm9yaWdpbmFsRWxlbWVudCxcblx0XHRcdGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcblx0XHRcdGhlbHBlcjogdGhpcy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcblx0XHRcdHNpemU6IHRoaXMuc2l6ZSxcblx0XHRcdG9yaWdpbmFsU2l6ZTogdGhpcy5vcmlnaW5hbFNpemUsXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb25cblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4vKlxuICogUmVzaXphYmxlIEV4dGVuc2lvbnNcbiAqL1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIiwgXCJhbHNvUmVzaXplXCIsIHtcblxuXHRzdGFydDogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLCBvID0gdGhhdC5vcHRpb25zO1xuXG5cdFx0dmFyIF9zdG9yZSA9IGZ1bmN0aW9uIChleHApIHtcblx0XHRcdCQoZXhwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWwgPSAkKHRoaXMpO1xuXHRcdFx0XHRlbC5kYXRhKFwicmVzaXphYmxlLWFsc29yZXNpemVcIiwge1xuXHRcdFx0XHRcdHdpZHRoOiBwYXJzZUludChlbC53aWR0aCgpLCAxMCksIGhlaWdodDogcGFyc2VJbnQoZWwuaGVpZ2h0KCksIDEwKSxcblx0XHRcdFx0XHRsZWZ0OiBwYXJzZUludChlbC5jc3MoJ2xlZnQnKSwgMTApLCB0b3A6IHBhcnNlSW50KGVsLmNzcygndG9wJyksIDEwKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRpZiAodHlwZW9mKG8uYWxzb1Jlc2l6ZSkgPT0gJ29iamVjdCcgJiYgIW8uYWxzb1Jlc2l6ZS5wYXJlbnROb2RlKSB7XG5cdFx0XHRpZiAoby5hbHNvUmVzaXplLmxlbmd0aCkgeyBvLmFsc29SZXNpemUgPSBvLmFsc29SZXNpemVbMF07IF9zdG9yZShvLmFsc29SZXNpemUpOyB9XG5cdFx0XHRlbHNlIHsgJC5lYWNoKG8uYWxzb1Jlc2l6ZSwgZnVuY3Rpb24gKGV4cCkgeyBfc3RvcmUoZXhwKTsgfSk7IH1cblx0XHR9ZWxzZXtcblx0XHRcdF9zdG9yZShvLmFsc29SZXNpemUpO1xuXHRcdH1cblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucywgb3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSwgb3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb247XG5cblx0XHR2YXIgZGVsdGEgPSB7XG5cdFx0XHRoZWlnaHQ6ICh0aGF0LnNpemUuaGVpZ2h0IC0gb3MuaGVpZ2h0KSB8fCAwLCB3aWR0aDogKHRoYXQuc2l6ZS53aWR0aCAtIG9zLndpZHRoKSB8fCAwLFxuXHRcdFx0dG9wOiAodGhhdC5wb3NpdGlvbi50b3AgLSBvcC50b3ApIHx8IDAsIGxlZnQ6ICh0aGF0LnBvc2l0aW9uLmxlZnQgLSBvcC5sZWZ0KSB8fCAwXG5cdFx0fSxcblxuXHRcdF9hbHNvUmVzaXplID0gZnVuY3Rpb24gKGV4cCwgYykge1xuXHRcdFx0JChleHApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbCA9ICQodGhpcyksIHN0YXJ0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlLWFsc29yZXNpemVcIiksIHN0eWxlID0ge30sXG5cdFx0XHRcdFx0Y3NzID0gYyAmJiBjLmxlbmd0aCA/IGMgOiBlbC5wYXJlbnRzKHVpLm9yaWdpbmFsRWxlbWVudFswXSkubGVuZ3RoID8gWyd3aWR0aCcsICdoZWlnaHQnXSA6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdsZWZ0J107XG5cblx0XHRcdFx0JC5lYWNoKGNzcywgZnVuY3Rpb24gKGksIHByb3ApIHtcblx0XHRcdFx0XHR2YXIgc3VtID0gKHN0YXJ0W3Byb3BdfHwwKSArIChkZWx0YVtwcm9wXXx8MCk7XG5cdFx0XHRcdFx0aWYgKHN1bSAmJiBzdW0gPj0gMClcblx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gc3VtIHx8IG51bGw7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGVsLmNzcyhzdHlsZSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYgKHR5cGVvZihvLmFsc29SZXNpemUpID09ICdvYmplY3QnICYmICFvLmFsc29SZXNpemUubm9kZVR5cGUpIHtcblx0XHRcdCQuZWFjaChvLmFsc29SZXNpemUsIGZ1bmN0aW9uIChleHAsIGMpIHsgX2Fsc29SZXNpemUoZXhwLCBjKTsgfSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRfYWxzb1Jlc2l6ZShvLmFsc29SZXNpemUpO1xuXHRcdH1cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG5cdFx0JCh0aGlzKS5yZW1vdmVEYXRhKFwicmVzaXphYmxlLWFsc29yZXNpemVcIik7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIiwgXCJhbmltYXRlXCIsIHtcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucztcblxuXHRcdHZhciBwciA9IHRoYXQuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMsIGlzdGEgPSBwci5sZW5ndGggJiYgKC90ZXh0YXJlYS9pKS50ZXN0KHByWzBdLm5vZGVOYW1lKSxcblx0XHRcdFx0XHRzb2Zmc2V0aCA9IGlzdGEgJiYgJC51aS5oYXNTY3JvbGwocHJbMF0sICdsZWZ0JykgLyogVE9ETyAtIGp1bXAgaGVpZ2h0ICovID8gMCA6IHRoYXQuc2l6ZURpZmYuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0c29mZnNldHcgPSBpc3RhID8gMCA6IHRoYXQuc2l6ZURpZmYud2lkdGg7XG5cblx0XHR2YXIgc3R5bGUgPSB7IHdpZHRoOiAodGhhdC5zaXplLndpZHRoIC0gc29mZnNldHcpLCBoZWlnaHQ6ICh0aGF0LnNpemUuaGVpZ2h0IC0gc29mZnNldGgpIH0sXG5cdFx0XHRcdFx0bGVmdCA9IChwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCdsZWZ0JyksIDEwKSArICh0aGF0LnBvc2l0aW9uLmxlZnQgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24ubGVmdCkpIHx8IG51bGwsXG5cdFx0XHRcdFx0XHR0b3AgPSAocGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygndG9wJyksIDEwKSArICh0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3ApKSB8fCBudWxsO1xuXG5cdFx0dGhhdC5lbGVtZW50LmFuaW1hdGUoXG5cdFx0XHQkLmV4dGVuZChzdHlsZSwgdG9wICYmIGxlZnQgPyB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gOiB7fSksIHtcblx0XHRcdFx0ZHVyYXRpb246IG8uYW5pbWF0ZUR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IG8uYW5pbWF0ZUVhc2luZyxcblx0XHRcdFx0c3RlcDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCd3aWR0aCcpLCAxMCksXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoJ2hlaWdodCcpLCAxMCksXG5cdFx0XHRcdFx0XHR0b3A6IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoJ3RvcCcpLCAxMCksXG5cdFx0XHRcdFx0XHRsZWZ0OiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCdsZWZ0JyksIDEwKVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAocHIgJiYgcHIubGVuZ3RoKSAkKHByWzBdKS5jc3MoeyB3aWR0aDogZGF0YS53aWR0aCwgaGVpZ2h0OiBkYXRhLmhlaWdodCB9KTtcblxuXHRcdFx0XHRcdC8vIHByb3BhZ2F0aW5nIHJlc2l6ZSwgYW5kIHVwZGF0aW5nIHZhbHVlcyBmb3IgZWFjaCBhbmltYXRpb24gc3RlcFxuXHRcdFx0XHRcdHRoYXQuX3VwZGF0ZUNhY2hlKGRhdGEpO1xuXHRcdFx0XHRcdHRoYXQuX3Byb3BhZ2F0ZShcInJlc2l6ZVwiLCBldmVudCk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImNvbnRhaW5tZW50XCIsIHtcblxuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsIGVsID0gdGhhdC5lbGVtZW50O1xuXHRcdHZhciBvYyA9IG8uY29udGFpbm1lbnQsXHRjZSA9IChvYyBpbnN0YW5jZW9mICQpID8gb2MuZ2V0KDApIDogKC9wYXJlbnQvLnRlc3Qob2MpKSA/IGVsLnBhcmVudCgpLmdldCgwKSA6IG9jO1xuXHRcdGlmICghY2UpIHJldHVybjtcblxuXHRcdHRoYXQuY29udGFpbmVyRWxlbWVudCA9ICQoY2UpO1xuXG5cdFx0aWYgKC9kb2N1bWVudC8udGVzdChvYykgfHwgb2MgPT0gZG9jdW1lbnQpIHtcblx0XHRcdHRoYXQuY29udGFpbmVyT2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcblx0XHRcdHRoYXQuY29udGFpbmVyUG9zaXRpb24gPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuXG5cdFx0XHR0aGF0LnBhcmVudERhdGEgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6ICQoZG9jdW1lbnQpLCBsZWZ0OiAwLCB0b3A6IDAsXG5cdFx0XHRcdHdpZHRoOiAkKGRvY3VtZW50KS53aWR0aCgpLCBoZWlnaHQ6ICQoZG9jdW1lbnQpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gaSdtIGEgbm9kZSwgc28gY29tcHV0ZSB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b21cblx0XHRlbHNlIHtcblx0XHRcdHZhciBlbGVtZW50ID0gJChjZSksIHAgPSBbXTtcblx0XHRcdCQoWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiTGVmdFwiLCBcIkJvdHRvbVwiIF0pLmVhY2goZnVuY3Rpb24oaSwgbmFtZSkgeyBwW2ldID0gbnVtKGVsZW1lbnQuY3NzKFwicGFkZGluZ1wiICsgbmFtZSkpOyB9KTtcblxuXHRcdFx0dGhhdC5jb250YWluZXJPZmZzZXQgPSBlbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0dGhhdC5jb250YWluZXJQb3NpdGlvbiA9IGVsZW1lbnQucG9zaXRpb24oKTtcblx0XHRcdHRoYXQuY29udGFpbmVyU2l6ZSA9IHsgaGVpZ2h0OiAoZWxlbWVudC5pbm5lckhlaWdodCgpIC0gcFszXSksIHdpZHRoOiAoZWxlbWVudC5pbm5lcldpZHRoKCkgLSBwWzFdKSB9O1xuXG5cdFx0XHR2YXIgY28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCwgY2ggPSB0aGF0LmNvbnRhaW5lclNpemUuaGVpZ2h0LFx0Y3cgPSB0aGF0LmNvbnRhaW5lclNpemUud2lkdGgsXG5cdFx0XHRcdFx0XHR3aWR0aCA9ICgkLnVpLmhhc1Njcm9sbChjZSwgXCJsZWZ0XCIpID8gY2Uuc2Nyb2xsV2lkdGggOiBjdyApLCBoZWlnaHQgPSAoJC51aS5oYXNTY3JvbGwoY2UpID8gY2Uuc2Nyb2xsSGVpZ2h0IDogY2gpO1xuXG5cdFx0XHR0aGF0LnBhcmVudERhdGEgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGNlLCBsZWZ0OiBjby5sZWZ0LCB0b3A6IGNvLnRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucyxcblx0XHRcdFx0cHMgPSB0aGF0LmNvbnRhaW5lclNpemUsIGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsIGNzID0gdGhhdC5zaXplLCBjcCA9IHRoYXQucG9zaXRpb24sXG5cdFx0XHRcdHBSYXRpbyA9IHRoYXQuX2FzcGVjdFJhdGlvIHx8IGV2ZW50LnNoaWZ0S2V5LCBjb3AgPSB7IHRvcDowLCBsZWZ0OjAgfSwgY2UgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQ7XG5cblx0XHRpZiAoY2VbMF0gIT0gZG9jdW1lbnQgJiYgKC9zdGF0aWMvKS50ZXN0KGNlLmNzcygncG9zaXRpb24nKSkpIGNvcCA9IGNvO1xuXG5cdFx0aWYgKGNwLmxlZnQgPCAodGhhdC5faGVscGVyID8gY28ubGVmdCA6IDApKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUud2lkdGggKyAodGhhdC5faGVscGVyID8gKHRoYXQucG9zaXRpb24ubGVmdCAtIGNvLmxlZnQpIDogKHRoYXQucG9zaXRpb24ubGVmdCAtIGNvcC5sZWZ0KSk7XG5cdFx0XHRpZiAocFJhdGlvKSB0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLndpZHRoIC8gdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IG8uaGVscGVyID8gY28ubGVmdCA6IDA7XG5cdFx0fVxuXG5cdFx0aWYgKGNwLnRvcCA8ICh0aGF0Ll9oZWxwZXIgPyBjby50b3AgOiAwKSkge1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS5oZWlnaHQgKyAodGhhdC5faGVscGVyID8gKHRoYXQucG9zaXRpb24udG9wIC0gY28udG9wKSA6IHRoYXQucG9zaXRpb24udG9wKTtcblx0XHRcdGlmIChwUmF0aW8pIHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS5oZWlnaHQgKiB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSB0aGF0Ll9oZWxwZXIgPyBjby50b3AgOiAwO1xuXHRcdH1cblxuXHRcdHRoYXQub2Zmc2V0LmxlZnQgPSB0aGF0LnBhcmVudERhdGEubGVmdCt0aGF0LnBvc2l0aW9uLmxlZnQ7XG5cdFx0dGhhdC5vZmZzZXQudG9wID0gdGhhdC5wYXJlbnREYXRhLnRvcCt0aGF0LnBvc2l0aW9uLnRvcDtcblxuXHRcdHZhciB3b3NldCA9IE1hdGguYWJzKCAodGhhdC5faGVscGVyID8gdGhhdC5vZmZzZXQubGVmdCAtIGNvcC5sZWZ0IDogKHRoYXQub2Zmc2V0LmxlZnQgLSBjb3AubGVmdCkpICsgdGhhdC5zaXplRGlmZi53aWR0aCApLFxuXHRcdFx0XHRcdGhvc2V0ID0gTWF0aC5hYnMoICh0aGF0Ll9oZWxwZXIgPyB0aGF0Lm9mZnNldC50b3AgLSBjb3AudG9wIDogKHRoYXQub2Zmc2V0LnRvcCAtIGNvLnRvcCkpICsgdGhhdC5zaXplRGlmZi5oZWlnaHQgKTtcblxuXHRcdHZhciBpc1BhcmVudCA9IHRoYXQuY29udGFpbmVyRWxlbWVudC5nZXQoMCkgPT0gdGhhdC5lbGVtZW50LnBhcmVudCgpLmdldCgwKSxcblx0XHRcdGlzT2Zmc2V0UmVsYXRpdmUgPSAvcmVsYXRpdmV8YWJzb2x1dGUvLnRlc3QodGhhdC5jb250YWluZXJFbGVtZW50LmNzcygncG9zaXRpb24nKSk7XG5cblx0XHRpZihpc1BhcmVudCAmJiBpc09mZnNldFJlbGF0aXZlKSB3b3NldCAtPSB0aGF0LnBhcmVudERhdGEubGVmdDtcblxuXHRcdGlmICh3b3NldCArIHRoYXQuc2l6ZS53aWR0aCA+PSB0aGF0LnBhcmVudERhdGEud2lkdGgpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQucGFyZW50RGF0YS53aWR0aCAtIHdvc2V0O1xuXHRcdFx0aWYgKHBSYXRpbykgdGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS53aWR0aCAvIHRoYXQuYXNwZWN0UmF0aW87XG5cdFx0fVxuXG5cdFx0aWYgKGhvc2V0ICsgdGhhdC5zaXplLmhlaWdodCA+PSB0aGF0LnBhcmVudERhdGEuaGVpZ2h0KSB7XG5cdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5wYXJlbnREYXRhLmhlaWdodCAtIGhvc2V0O1xuXHRcdFx0aWYgKHBSYXRpbykgdGhhdC5zaXplLndpZHRoID0gdGhhdC5zaXplLmhlaWdodCAqIHRoYXQuYXNwZWN0UmF0aW87XG5cdFx0fVxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsIGNwID0gdGhhdC5wb3NpdGlvbixcblx0XHRcdFx0Y28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCwgY29wID0gdGhhdC5jb250YWluZXJQb3NpdGlvbiwgY2UgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQ7XG5cblx0XHR2YXIgaGVscGVyID0gJCh0aGF0LmhlbHBlciksIGhvID0gaGVscGVyLm9mZnNldCgpLCB3ID0gaGVscGVyLm91dGVyV2lkdGgoKSAtIHRoYXQuc2l6ZURpZmYud2lkdGgsIGggPSBoZWxwZXIub3V0ZXJIZWlnaHQoKSAtIHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xuXG5cdFx0aWYgKHRoYXQuX2hlbHBlciAmJiAhby5hbmltYXRlICYmICgvcmVsYXRpdmUvKS50ZXN0KGNlLmNzcygncG9zaXRpb24nKSkpXG5cdFx0XHQkKHRoaXMpLmNzcyh7IGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSk7XG5cblx0XHRpZiAodGhhdC5faGVscGVyICYmICFvLmFuaW1hdGUgJiYgKC9zdGF0aWMvKS50ZXN0KGNlLmNzcygncG9zaXRpb24nKSkpXG5cdFx0XHQkKHRoaXMpLmNzcyh7IGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSk7XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImdob3N0XCIsIHtcblxuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucywgY3MgPSB0aGF0LnNpemU7XG5cblx0XHR0aGF0Lmdob3N0ID0gdGhhdC5vcmlnaW5hbEVsZW1lbnQuY2xvbmUoKTtcblx0XHR0aGF0Lmdob3N0XG5cdFx0XHQuY3NzKHsgb3BhY2l0eTogLjI1LCBkaXNwbGF5OiAnYmxvY2snLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgaGVpZ2h0OiBjcy5oZWlnaHQsIHdpZHRoOiBjcy53aWR0aCwgbWFyZ2luOiAwLCBsZWZ0OiAwLCB0b3A6IDAgfSlcblx0XHRcdC5hZGRDbGFzcygndWktcmVzaXphYmxlLWdob3N0Jylcblx0XHRcdC5hZGRDbGFzcyh0eXBlb2Ygby5naG9zdCA9PSAnc3RyaW5nJyA/IG8uZ2hvc3QgOiAnJyk7XG5cblx0XHR0aGF0Lmdob3N0LmFwcGVuZFRvKHRoYXQuaGVscGVyKTtcblxuXHR9LFxuXG5cdHJlc2l6ZTogZnVuY3Rpb24oZXZlbnQsIHVpKXtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucztcblx0XHRpZiAodGhhdC5naG9zdCkgdGhhdC5naG9zdC5jc3MoeyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgaGVpZ2h0OiB0aGF0LnNpemUuaGVpZ2h0LCB3aWR0aDogdGhhdC5zaXplLndpZHRoIH0pO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnM7XG5cdFx0aWYgKHRoYXQuZ2hvc3QgJiYgdGhhdC5oZWxwZXIpIHRoYXQuaGVscGVyLmdldCgwKS5yZW1vdmVDaGlsZCh0aGF0Lmdob3N0LmdldCgwKSk7XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImdyaWRcIiwge1xuXG5cdHJlc2l6ZTogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsIGNzID0gdGhhdC5zaXplLCBvcyA9IHRoYXQub3JpZ2luYWxTaXplLCBvcCA9IHRoYXQub3JpZ2luYWxQb3NpdGlvbiwgYSA9IHRoYXQuYXhpcywgcmF0aW8gPSBvLl9hc3BlY3RSYXRpbyB8fCBldmVudC5zaGlmdEtleTtcblx0XHRvLmdyaWQgPSB0eXBlb2Ygby5ncmlkID09IFwibnVtYmVyXCIgPyBbby5ncmlkLCBvLmdyaWRdIDogby5ncmlkO1xuXHRcdHZhciBveCA9IE1hdGgucm91bmQoKGNzLndpZHRoIC0gb3Mud2lkdGgpIC8gKG8uZ3JpZFswXXx8MSkpICogKG8uZ3JpZFswXXx8MSksIG95ID0gTWF0aC5yb3VuZCgoY3MuaGVpZ2h0IC0gb3MuaGVpZ2h0KSAvIChvLmdyaWRbMV18fDEpKSAqIChvLmdyaWRbMV18fDEpO1xuXG5cdFx0aWYgKC9eKHNlfHN8ZSkkLy50ZXN0KGEpKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBvcy53aWR0aCArIG94O1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG9zLmhlaWdodCArIG95O1xuXHRcdH1cblx0XHRlbHNlIGlmICgvXihuZSkkLy50ZXN0KGEpKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBvcy53aWR0aCArIG94O1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG9zLmhlaWdodCArIG95O1xuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSBvcC50b3AgLSBveTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoL14oc3cpJC8udGVzdChhKSkge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gb3Mud2lkdGggKyBveDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBvcy5oZWlnaHQgKyBveTtcblx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IG9wLmxlZnQgLSBveDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBvcy53aWR0aCArIG94O1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG9zLmhlaWdodCArIG95O1xuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSBvcC50b3AgLSBveTtcblx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IG9wLmxlZnQgLSBveDtcblx0XHR9XG5cdH1cblxufSk7XG5cbnZhciBudW0gPSBmdW5jdGlvbih2KSB7XG5cdHJldHVybiBwYXJzZUludCh2LCAxMCkgfHwgMDtcbn07XG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSk7XG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuc2VsZWN0YWJsZVwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiAnYm9keScsXG5cdFx0YXV0b1JlZnJlc2g6IHRydWUsXG5cdFx0ZGlzdGFuY2U6IDAsXG5cdFx0ZmlsdGVyOiAnKicsXG5cdFx0dG9sZXJhbmNlOiAndG91Y2gnXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLXNlbGVjdGFibGVcIik7XG5cblx0XHR0aGlzLmRyYWdnZWQgPSBmYWxzZTtcblxuXHRcdC8vIGNhY2hlIHNlbGVjdGVlIGNoaWxkcmVuIGJhc2VkIG9uIGZpbHRlclxuXHRcdHZhciBzZWxlY3RlZXM7XG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxlY3RlZXMgPSAkKHRoYXQub3B0aW9ucy5maWx0ZXIsIHRoYXQuZWxlbWVudFswXSk7XG5cdFx0XHRzZWxlY3RlZXMuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RlZVwiKTtcblx0XHRcdHNlbGVjdGVlcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XHR2YXIgcG9zID0gJHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRcdCQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiLCB7XG5cdFx0XHRcdFx0ZWxlbWVudDogdGhpcyxcblx0XHRcdFx0XHQkZWxlbWVudDogJHRoaXMsXG5cdFx0XHRcdFx0bGVmdDogcG9zLmxlZnQsXG5cdFx0XHRcdFx0dG9wOiBwb3MudG9wLFxuXHRcdFx0XHRcdHJpZ2h0OiBwb3MubGVmdCArICR0aGlzLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRib3R0b206IHBvcy50b3AgKyAkdGhpcy5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHN0YXJ0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdHNlbGVjdGVkOiAkdGhpcy5oYXNDbGFzcygndWktc2VsZWN0ZWQnKSxcblx0XHRcdFx0XHRzZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKCd1aS1zZWxlY3RpbmcnKSxcblx0XHRcdFx0XHR1bnNlbGVjdGluZzogJHRoaXMuaGFzQ2xhc3MoJ3VpLXVuc2VsZWN0aW5nJylcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0dGhpcy5zZWxlY3RlZXMgPSBzZWxlY3RlZXMuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RlZVwiKTtcblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0dGhpcy5oZWxwZXIgPSAkKFwiPGRpdiBjbGFzcz0ndWktc2VsZWN0YWJsZS1oZWxwZXInPjwvZGl2PlwiKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZWxlY3RlZXNcblx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGVlXCIpXG5cdFx0XHQucmVtb3ZlRGF0YShcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGFibGUgdWktc2VsZWN0YWJsZS1kaXNhYmxlZFwiKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLm9wb3MgPSBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuc2VsZWN0ZWVzID0gJChvcHRpb25zLmZpbHRlciwgdGhpcy5lbGVtZW50WzBdKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoXCJzdGFydFwiLCBldmVudCk7XG5cblx0XHQkKG9wdGlvbnMuYXBwZW5kVG8pLmFwcGVuZCh0aGlzLmhlbHBlcik7XG5cdFx0Ly8gcG9zaXRpb24gaGVscGVyIChsYXNzbylcblx0XHR0aGlzLmhlbHBlci5jc3Moe1xuXHRcdFx0XCJsZWZ0XCI6IGV2ZW50LmNsaWVudFgsXG5cdFx0XHRcInRvcFwiOiBldmVudC5jbGllbnRZLFxuXHRcdFx0XCJ3aWR0aFwiOiAwLFxuXHRcdFx0XCJoZWlnaHRcIjogMFxuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdGlvbnMuYXV0b1JlZnJlc2gpIHtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2VsZWN0ZWVzLmZpbHRlcignLnVpLXNlbGVjdGVkJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5KSB7XG5cdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RlZCcpO1xuXHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5hZGRDbGFzcygndWktdW5zZWxlY3RpbmcnKTtcblx0XHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0JChldmVudC50YXJnZXQpLnBhcmVudHMoKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdGlmIChzZWxlY3RlZSkge1xuXHRcdFx0XHR2YXIgZG9TZWxlY3QgPSAoIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmN0cmxLZXkpIHx8ICFzZWxlY3RlZS4kZWxlbWVudC5oYXNDbGFzcygndWktc2VsZWN0ZWQnKTtcblx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoZG9TZWxlY3QgPyBcInVpLXVuc2VsZWN0aW5nXCIgOiBcInVpLXNlbGVjdGVkXCIpXG5cdFx0XHRcdFx0LmFkZENsYXNzKGRvU2VsZWN0ID8gXCJ1aS1zZWxlY3RpbmdcIiA6IFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gIWRvU2VsZWN0O1xuXHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBkb1NlbGVjdDtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBkb1NlbGVjdDtcblx0XHRcdFx0Ly8gc2VsZWN0YWJsZSAoVU4pU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdGlmIChkb1NlbGVjdCkge1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJzZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdHNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR0aGlzLmRyYWdnZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dmFyIHgxID0gdGhpcy5vcG9zWzBdLCB5MSA9IHRoaXMub3Bvc1sxXSwgeDIgPSBldmVudC5wYWdlWCwgeTIgPSBldmVudC5wYWdlWTtcblx0XHRpZiAoeDEgPiB4MikgeyB2YXIgdG1wID0geDI7IHgyID0geDE7IHgxID0gdG1wOyB9XG5cdFx0aWYgKHkxID4geTIpIHsgdmFyIHRtcCA9IHkyOyB5MiA9IHkxOyB5MSA9IHRtcDsgfVxuXHRcdHRoaXMuaGVscGVyLmNzcyh7bGVmdDogeDEsIHRvcDogeTEsIHdpZHRoOiB4Mi14MSwgaGVpZ2h0OiB5Mi15MX0pO1xuXG5cdFx0dGhpcy5zZWxlY3RlZXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdC8vcHJldmVudCBoZWxwZXIgZnJvbSBiZWluZyBzZWxlY3RlZCBpZiBhcHBlbmRUbzogc2VsZWN0YWJsZVxuXHRcdFx0aWYgKCFzZWxlY3RlZSB8fCBzZWxlY3RlZS5lbGVtZW50ID09IHRoYXQuZWxlbWVudFswXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIGhpdCA9IGZhbHNlO1xuXHRcdFx0aWYgKG9wdGlvbnMudG9sZXJhbmNlID09ICd0b3VjaCcpIHtcblx0XHRcdFx0aGl0ID0gKCAhKHNlbGVjdGVlLmxlZnQgPiB4MiB8fCBzZWxlY3RlZS5yaWdodCA8IHgxIHx8IHNlbGVjdGVlLnRvcCA+IHkyIHx8IHNlbGVjdGVlLmJvdHRvbSA8IHkxKSApO1xuXHRcdFx0fSBlbHNlIGlmIChvcHRpb25zLnRvbGVyYW5jZSA9PSAnZml0Jykge1xuXHRcdFx0XHRoaXQgPSAoc2VsZWN0ZWUubGVmdCA+IHgxICYmIHNlbGVjdGVlLnJpZ2h0IDwgeDIgJiYgc2VsZWN0ZWUudG9wID4geTEgJiYgc2VsZWN0ZWUuYm90dG9tIDwgeTIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGl0KSB7XG5cdFx0XHRcdC8vIFNFTEVDVFxuXHRcdFx0XHRpZiAoc2VsZWN0ZWUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktc2VsZWN0ZWQnKTtcblx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxlY3RlZS51bnNlbGVjdGluZykge1xuXHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS11bnNlbGVjdGluZycpO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzZWxlY3RlZS5zZWxlY3RpbmcpIHtcblx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5hZGRDbGFzcygndWktc2VsZWN0aW5nJyk7XG5cdFx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFNFTEVDVElORyBjYWxsYmFja1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJzZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdHNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBVTlNFTEVDVFxuXHRcdFx0XHRpZiAoc2VsZWN0ZWUuc2VsZWN0aW5nKSB7XG5cdFx0XHRcdFx0aWYgKChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmIHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RpbmcnKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RpbmcnKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXVuc2VsZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0XHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxlY3RlZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5hZGRDbGFzcygndWktdW5zZWxlY3RpbmcnKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0XHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmRyYWdnZWQgPSBmYWxzZTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0JCgnLnVpLXVuc2VsZWN0aW5nJywgdGhpcy5lbGVtZW50WzBdKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIpO1xuXHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3VpLXVuc2VsZWN0aW5nJyk7XG5cdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlcihcInVuc2VsZWN0ZWRcIiwgZXZlbnQsIHtcblx0XHRcdFx0dW5zZWxlY3RlZDogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0JCgnLnVpLXNlbGVjdGluZycsIHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RpbmcnKS5hZGRDbGFzcygndWktc2VsZWN0ZWQnKTtcblx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IHRydWU7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKFwic2VsZWN0ZWRcIiwgZXZlbnQsIHtcblx0XHRcdFx0c2VsZWN0ZWQ6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KTtcblxuXHRcdHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbn0pO1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIG51bWJlciBvZiBwYWdlcyBpbiBhIHNsaWRlclxuLy8gKGhvdyBtYW55IHRpbWVzIGNhbiB5b3UgcGFnZSB1cC9kb3duIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHJhbmdlKVxudmFyIG51bVBhZ2VzID0gNTtcblxuJC53aWRnZXQoIFwidWkuc2xpZGVyXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzbGlkZVwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRhbmltYXRlOiBmYWxzZSxcblx0XHRkaXN0YW5jZTogMCxcblx0XHRtYXg6IDEwMCxcblx0XHRtaW46IDAsXG5cdFx0b3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuXHRcdHJhbmdlOiBmYWxzZSxcblx0XHRzdGVwOiAxLFxuXHRcdHZhbHVlOiAwLFxuXHRcdHZhbHVlczogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpLCBoYW5kbGVDb3VudCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRleGlzdGluZ0hhbmRsZXMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktc2xpZGVyLWhhbmRsZVwiICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgKSxcblx0XHRcdGhhbmRsZSA9IFwiPGEgY2xhc3M9J3VpLXNsaWRlci1oYW5kbGUgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsJyBocmVmPScjJz48L2E+XCIsXG5cdFx0XHRoYW5kbGVzID0gW107XG5cblx0XHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zbGlkZXJcIiArXG5cdFx0XHRcdFwiIHVpLXNsaWRlci1cIiArIHRoaXMub3JpZW50YXRpb24gK1xuXHRcdFx0XHRcIiB1aS13aWRnZXRcIiArXG5cdFx0XHRcdFwiIHVpLXdpZGdldC1jb250ZW50XCIgK1xuXHRcdFx0XHRcIiB1aS1jb3JuZXItYWxsXCIgK1xuXHRcdFx0XHQoIG8uZGlzYWJsZWQgPyBcIiB1aS1zbGlkZXItZGlzYWJsZWQgdWktZGlzYWJsZWRcIiA6IFwiXCIgKSApO1xuXG5cdFx0dGhpcy5yYW5nZSA9ICQoW10pO1xuXG5cdFx0aWYgKCBvLnJhbmdlICkge1xuXHRcdFx0aWYgKCBvLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0XHRpZiAoICFvLnZhbHVlcyApIHtcblx0XHRcdFx0XHRvLnZhbHVlcyA9IFsgdGhpcy5fdmFsdWVNaW4oKSwgdGhpcy5fdmFsdWVNaW4oKSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggby52YWx1ZXMubGVuZ3RoICYmIG8udmFsdWVzLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRvLnZhbHVlcyA9IFsgby52YWx1ZXNbMF0sIG8udmFsdWVzWzBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYW5nZSA9ICQoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGhpcy5lbGVtZW50IClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXNsaWRlci1yYW5nZVwiICtcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBpc24ndCB0aGUgbW9zdCBmaXR0aW5nbHkgc2VtYW50aWMgZnJhbWV3b3JrIGNsYXNzIGZvciB0aGlzIGVsZW1lbnQsXG5cdFx0XHRcdC8vIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcblx0XHRcdFx0XCIgdWktd2lkZ2V0LWhlYWRlclwiICtcblx0XHRcdFx0KCAoIG8ucmFuZ2UgPT09IFwibWluXCIgfHwgby5yYW5nZSA9PT0gXCJtYXhcIiApID8gXCIgdWktc2xpZGVyLXJhbmdlLVwiICsgby5yYW5nZSA6IFwiXCIgKSApO1xuXHRcdH1cblxuXHRcdGhhbmRsZUNvdW50ID0gKCBvLnZhbHVlcyAmJiBvLnZhbHVlcy5sZW5ndGggKSB8fCAxO1xuXG5cdFx0Zm9yICggaSA9IGV4aXN0aW5nSGFuZGxlcy5sZW5ndGg7IGkgPCBoYW5kbGVDb3VudDsgaSsrICkge1xuXHRcdFx0aGFuZGxlcy5wdXNoKCBoYW5kbGUgKTtcblx0XHR9XG5cblx0XHR0aGlzLmhhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuYWRkKCAkKCBoYW5kbGVzLmpvaW4oIFwiXCIgKSApLmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKSApO1xuXG5cdFx0dGhpcy5oYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoIDAgKTtcblxuXHRcdHRoaXMuaGFuZGxlcy5hZGQoIHRoaXMucmFuZ2UgKS5maWx0ZXIoIFwiYVwiIClcblx0XHRcdC5jbGljayhmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm1vdXNlZW50ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIW8uZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5tb3VzZWxlYXZlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSlcblx0XHRcdC5mb2N1cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhby5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHQkKCBcIi51aS1zbGlkZXIgLnVpLXN0YXRlLWZvY3VzXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmJsdXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuaGFuZGxlcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0JCggdGhpcyApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiLCBpICk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5oYW5kbGVzLCB7XG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciBhbGxvd2VkLCBjdXJWYWwsIG5ld1ZhbCwgc3RlcCxcblx0XHRcdFx0XHRpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0aWYgKCAhdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggYWxsb3dlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcDtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1heCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgKyAoICh0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSkgLyBudW1QYWdlcyApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsIC0gKCAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gbnVtUGFnZXMgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdFx0XHRpZiAoIGN1clZhbCA9PT0gdGhpcy5fdmFsdWVNYXgoKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCArIHN0ZXAgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdFx0XHRcdGlmICggY3VyVmFsID09PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsIC0gc3RlcCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIGluZGV4LCBuZXdWYWwgKTtcblx0XHRcdH0sXG5cdFx0XHRrZXl1cDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0XHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVzLnJlbW92ZSgpO1xuXHRcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXJcIiArXG5cdFx0XHRcdFwiIHVpLXNsaWRlci1ob3Jpem9udGFsXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItdmVydGljYWxcIiArXG5cdFx0XHRcdFwiIHVpLXNsaWRlci1kaXNhYmxlZFwiICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0XCIgK1xuXHRcdFx0XHRcIiB1aS13aWRnZXQtY29udGVudFwiICtcblx0XHRcdFx0XCIgdWktY29ybmVyLWFsbFwiICk7XG5cblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uLCBub3JtVmFsdWUsIGRpc3RhbmNlLCBjbG9zZXN0SGFuZGxlLCBpbmRleCwgYWxsb3dlZCwgb2Zmc2V0LCBtb3VzZU92ZXJIYW5kbGUsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIG8uZGlzYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdFx0dGhpcy5lbGVtZW50T2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXG5cdFx0cG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xuXHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblx0XHRkaXN0YW5jZSA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICsgMTtcblx0XHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB0aGlzRGlzdGFuY2UgPSBNYXRoLmFicyggbm9ybVZhbHVlIC0gdGhhdC52YWx1ZXMoaSkgKTtcblx0XHRcdGlmICggZGlzdGFuY2UgPiB0aGlzRGlzdGFuY2UgKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpc0Rpc3RhbmNlO1xuXHRcdFx0XHRjbG9zZXN0SGFuZGxlID0gJCggdGhpcyApO1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyB3b3JrYXJvdW5kIGZvciBidWcgIzM3MzYgKGlmIGJvdGggaGFuZGxlcyBvZiBhIHJhbmdlIGFyZSBhdCAwLFxuXHRcdC8vIHRoZSBmaXJzdCBpcyBhbHdheXMgdXNlZCBhcyB0aGUgb25lIHdpdGggbGVhc3QgZGlzdGFuY2UsXG5cdFx0Ly8gYW5kIG1vdmluZyBpdCBpcyBvYnZpb3VzbHkgcHJldmVudGVkIGJ5IHByZXZlbnRpbmcgbmVnYXRpdmUgcmFuZ2VzKVxuXHRcdGlmKCBvLnJhbmdlID09PSB0cnVlICYmIHRoaXMudmFsdWVzKDEpID09PSBvLm1pbiApIHtcblx0XHRcdGluZGV4ICs9IDE7XG5cdFx0XHRjbG9zZXN0SGFuZGxlID0gJCggdGhpcy5oYW5kbGVzW2luZGV4XSApO1xuXHRcdH1cblxuXHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gaW5kZXg7XG5cblx0XHRjbG9zZXN0SGFuZGxlXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0LmZvY3VzKCk7XG5cblx0XHRvZmZzZXQgPSBjbG9zZXN0SGFuZGxlLm9mZnNldCgpO1xuXHRcdG1vdXNlT3ZlckhhbmRsZSA9ICEkKCBldmVudC50YXJnZXQgKS5wYXJlbnRzKCkuYW5kU2VsZigpLmlzKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKTtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG1vdXNlT3ZlckhhbmRsZSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiB7XG5cdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gKCBjbG9zZXN0SGFuZGxlLndpZHRoKCkgLyAyICksXG5cdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gb2Zmc2V0LnRvcCAtXG5cdFx0XHRcdCggY2xvc2VzdEhhbmRsZS5oZWlnaHQoKSAvIDIgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoXCJib3JkZXJCb3R0b21XaWR0aFwiKSwgMTAgKSB8fCAwKSArXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKFwibWFyZ2luVG9wXCIpLCAxMCApIHx8IDApXG5cdFx0fTtcblxuXHRcdGlmICggIXRoaXMuaGFuZGxlcy5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICkgKSB7XG5cdFx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIGluZGV4LCBub3JtVmFsdWUgKTtcblx0XHR9XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgcG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9LFxuXHRcdFx0bm9ybVZhbHVlID0gdGhpcy5fbm9ybVZhbHVlRnJvbU1vdXNlKCBwb3NpdGlvbiApO1xuXG5cdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCwgbm9ybVZhbHVlICk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuaGFuZGxlcy5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fc3RvcCggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4ICk7XG5cdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblxuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9jbGlja09mZnNldCA9IG51bGw7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9kZXRlY3RPcmllbnRhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmllbnRhdGlvbiA9ICggdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiO1xuXHR9LFxuXG5cdF9ub3JtVmFsdWVGcm9tTW91c2U6IGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcblx0XHR2YXIgcGl4ZWxUb3RhbCxcblx0XHRcdHBpeGVsTW91c2UsXG5cdFx0XHRwZXJjZW50TW91c2UsXG5cdFx0XHR2YWx1ZVRvdGFsLFxuXHRcdFx0dmFsdWVNb3VzZTtcblxuXHRcdGlmICggdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS53aWR0aDtcblx0XHRcdHBpeGVsTW91c2UgPSBwb3NpdGlvbi54IC0gdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgLSAoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQubGVmdCA6IDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUuaGVpZ2h0O1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnkgLSB0aGlzLmVsZW1lbnRPZmZzZXQudG9wIC0gKCB0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LnRvcCA6IDAgKTtcblx0XHR9XG5cblx0XHRwZXJjZW50TW91c2UgPSAoIHBpeGVsTW91c2UgLyBwaXhlbFRvdGFsICk7XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPiAxICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMTtcblx0XHR9XG5cdFx0aWYgKCBwZXJjZW50TW91c2UgPCAwICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMDtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxIC0gcGVyY2VudE1vdXNlO1xuXHRcdH1cblxuXHRcdHZhbHVlVG90YWwgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHR2YWx1ZU1vdXNlID0gdGhpcy5fdmFsdWVNaW4oKSArIHBlcmNlbnRNb3VzZSAqIHZhbHVlVG90YWw7XG5cblx0XHRyZXR1cm4gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbHVlTW91c2UgKTtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0dmFyIHVpSGFzaCA9IHtcblx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUoKVxuXHRcdH07XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0dWlIYXNoLnZhbHVlID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHR1aUhhc2gudmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQsIHVpSGFzaCApO1xuXHR9LFxuXG5cdF9zbGlkZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCwgbmV3VmFsICkge1xuXHRcdHZhciBvdGhlclZhbCxcblx0XHRcdG5ld1ZhbHVlcyxcblx0XHRcdGFsbG93ZWQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCA/IDAgOiAxICk7XG5cblx0XHRcdGlmICggKCB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSAmJlxuXHRcdFx0XHRcdCggKCBpbmRleCA9PT0gMCAmJiBuZXdWYWwgPiBvdGhlclZhbCkgfHwgKCBpbmRleCA9PT0gMSAmJiBuZXdWYWwgPCBvdGhlclZhbCApIClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdG5ld1ZhbCA9IG90aGVyVmFsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1ZhbCAhPT0gdGhpcy52YWx1ZXMoIGluZGV4ICkgKSB7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0XHRcdG5ld1ZhbHVlc1sgaW5kZXggXSA9IG5ld1ZhbDtcblx0XHRcdFx0Ly8gQSBzbGlkZSBjYW4gYmUgY2FuY2VsZWQgYnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIHNsaWRlIGNhbGxiYWNrXG5cdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl90cmlnZ2VyKCBcInNsaWRlXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRcdFx0dmFsdWU6IG5ld1ZhbCxcblx0XHRcdFx0XHR2YWx1ZXM6IG5ld1ZhbHVlc1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG90aGVyVmFsID0gdGhpcy52YWx1ZXMoIGluZGV4ID8gMCA6IDEgKTtcblx0XHRcdFx0aWYgKCBhbGxvd2VkICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyggaW5kZXgsIG5ld1ZhbCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggbmV3VmFsICE9PSB0aGlzLnZhbHVlKCkgKSB7XG5cdFx0XHRcdC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xuXHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlciggXCJzbGlkZVwiLCBldmVudCwge1xuXHRcdFx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0XHRcdHZhbHVlOiBuZXdWYWxcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGFsbG93ZWQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUoIG5ld1ZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9zdG9wOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdHZhciB1aUhhc2ggPSB7XG5cdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlKClcblx0XHR9O1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIsIGV2ZW50LCB1aUhhc2ggKTtcblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgJiYgIXRoaXMuX21vdXNlU2xpZGluZyApIHtcblx0XHRcdHZhciB1aUhhc2ggPSB7XG5cdFx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSgpXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHR1aUhhc2gudmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB1aUhhc2ggKTtcblx0XHR9XG5cdH0sXG5cblx0dmFsdWU6IGZ1bmN0aW9uKCBuZXdWYWx1ZSApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWUgKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlKCk7XG5cdH0sXG5cblx0dmFsdWVzOiBmdW5jdGlvbiggaW5kZXgsIG5ld1ZhbHVlICkge1xuXHRcdHZhciB2YWxzLFxuXHRcdFx0bmV3VmFsdWVzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoICQuaXNBcnJheSggYXJndW1lbnRzWyAwIF0gKSApIHtcblx0XHRcdFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dmFsc1sgaSBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlc1sgaSBdICk7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR2YWxzTGVuZ3RoID0gMDtcblxuXHRcdGlmICggJC5pc0FycmF5KCB0aGlzLm9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHR2YWxzTGVuZ3RoID0gdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0c3dpdGNoICgga2V5ICkge1xuXHRcdFx0Y2FzZSBcImRpc2FibGVkXCI6XG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVzLmZpbHRlciggXCIudWktc3RhdGUtZm9jdXNcIiApLmJsdXIoKTtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXMucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcy5wcm9wKCBcImRpc2FibGVkXCIsIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktZGlzYWJsZWRcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcy5wcm9wKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWRpc2FibGVkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJvcmllbnRhdGlvblwiOlxuXHRcdFx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZhbHVlc1wiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmFsc0xlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibWluXCI6XG5cdFx0XHRjYXNlIFwibWF4XCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0Ly9pbnRlcm5hbCB2YWx1ZSBnZXR0ZXJcblx0Ly8gX3ZhbHVlKCkgcmV0dXJucyB2YWx1ZSB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0X3ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuXHRcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWwgKTtcblxuXHRcdHJldHVybiB2YWw7XG5cdH0sXG5cblx0Ly9pbnRlcm5hbCB2YWx1ZXMgZ2V0dGVyXG5cdC8vIF92YWx1ZXMoKSByZXR1cm5zIGFycmF5IG9mIHZhbHVlcyB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0Ly8gX3ZhbHVlcyggaW5kZXggKSByZXR1cm5zIHNpbmdsZSB2YWx1ZSB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcblx0X3ZhbHVlczogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciB2YWwsXG5cdFx0XHR2YWxzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZXNbIGluZGV4IF07XG5cdFx0XHR2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsICk7XG5cblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIC5zbGljZSgpIGNyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcnJheVxuXHRcdFx0Ly8gdGhpcyBjb3B5IGdldHMgdHJpbW1lZCBieSBtaW4gYW5kIG1heCBhbmQgdGhlbiByZXR1cm5lZFxuXHRcdFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXMuc2xpY2UoKTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrPSAxKSB7XG5cdFx0XHRcdHZhbHNbIGkgXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWxzWyBpIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHM7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHJldHVybnMgdGhlIHN0ZXAtYWxpZ25lZCB2YWx1ZSB0aGF0IHZhbCBpcyBjbG9zZXN0IHRvLCBiZXR3ZWVuIChpbmNsdXNpdmUpIG1pbiBhbmQgbWF4XG5cdF90cmltQWxpZ25WYWx1ZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHZhbCA8PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0fVxuXHRcdGlmICggdmFsID49IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHR9XG5cdFx0dmFyIHN0ZXAgPSAoIHRoaXMub3B0aW9ucy5zdGVwID4gMCApID8gdGhpcy5vcHRpb25zLnN0ZXAgOiAxLFxuXHRcdFx0dmFsTW9kU3RlcCA9ICh2YWwgLSB0aGlzLl92YWx1ZU1pbigpKSAlIHN0ZXAsXG5cdFx0XHRhbGlnblZhbHVlID0gdmFsIC0gdmFsTW9kU3RlcDtcblxuXHRcdGlmICggTWF0aC5hYnModmFsTW9kU3RlcCkgKiAyID49IHN0ZXAgKSB7XG5cdFx0XHRhbGlnblZhbHVlICs9ICggdmFsTW9kU3RlcCA+IDAgKSA/IHN0ZXAgOiAoIC1zdGVwICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luY2UgSmF2YVNjcmlwdCBoYXMgcHJvYmxlbXMgd2l0aCBsYXJnZSBmbG9hdHMsIHJvdW5kXG5cdFx0Ly8gdGhlIGZpbmFsIHZhbHVlIHRvIDUgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IChzZWUgIzQxMjQpXG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoIGFsaWduVmFsdWUudG9GaXhlZCg1KSApO1xuXHR9LFxuXG5cdF92YWx1ZU1pbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW47XG5cdH0sXG5cblx0X3ZhbHVlTWF4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heDtcblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdFZhbFBlcmNlbnQsIHZhbFBlcmNlbnQsIHZhbHVlLCB2YWx1ZU1pbiwgdmFsdWVNYXgsXG5cdFx0XHRvUmFuZ2UgPSB0aGlzLm9wdGlvbnMucmFuZ2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRhbmltYXRlID0gKCAhdGhpcy5fYW5pbWF0ZU9mZiApID8gby5hbmltYXRlIDogZmFsc2UsXG5cdFx0XHRfc2V0ID0ge307XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFsUGVyY2VudCA9ICggdGhhdC52YWx1ZXMoaSkgLSB0aGF0Ll92YWx1ZU1pbigpICkgLyAoIHRoYXQuX3ZhbHVlTWF4KCkgLSB0aGF0Ll92YWx1ZU1pbigpICkgKiAxMDA7XG5cdFx0XHRcdF9zZXRbIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIF0gPSB2YWxQZXJjZW50ICsgXCIlXCI7XG5cdFx0XHRcdCQoIHRoaXMgKS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggX3NldCwgby5hbmltYXRlICk7XG5cdFx0XHRcdGlmICggdGhhdC5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0XHRcdGlmICggdGhhdC5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgbGVmdDogdmFsUGVyY2VudCArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6ICggdmFsUGVyY2VudCAtIGxhc3RWYWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBib3R0b206ICggdmFsUGVyY2VudCApICsgXCIlXCIgfSwgby5hbmltYXRlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2VbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBoZWlnaHQ6ICggdmFsUGVyY2VudCAtIGxhc3RWYWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RWYWxQZXJjZW50ID0gdmFsUGVyY2VudDtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWUoKTtcblx0XHRcdHZhbHVlTWluID0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHRcdHZhbHVlTWF4ID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdHZhbFBlcmNlbnQgPSAoIHZhbHVlTWF4ICE9PSB2YWx1ZU1pbiApID9cblx0XHRcdFx0XHQoIHZhbHVlIC0gdmFsdWVNaW4gKSAvICggdmFsdWVNYXggLSB2YWx1ZU1pbiApICogMTAwIDpcblx0XHRcdFx0XHQwO1xuXHRcdFx0X3NldFsgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIgXSA9IHZhbFBlcmNlbnQgKyBcIiVcIjtcblx0XHRcdHRoaXMuaGFuZGxlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCBfc2V0LCBvLmFuaW1hdGUgKTtcblxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6ICggMTAwIC0gdmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGhlaWdodDogdmFsUGVyY2VudCArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgaGVpZ2h0OiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIHsgcXVldWU6IGZhbHNlLCBkdXJhdGlvbjogby5hbmltYXRlIH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSk7XG5cbn0oalF1ZXJ5KSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5zb3J0YWJsZVwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic29ydFwiLFxuXHRyZWFkeTogZmFsc2UsXG5cdG9wdGlvbnM6IHtcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0V2l0aDogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogJ2F1dG8nLFxuXHRcdGN1cnNvckF0OiBmYWxzZSxcblx0XHRkcm9wT25FbXB0eTogdHJ1ZSxcblx0XHRmb3JjZVBsYWNlaG9sZGVyU2l6ZTogZmFsc2UsXG5cdFx0Zm9yY2VIZWxwZXJTaXplOiBmYWxzZSxcblx0XHRncmlkOiBmYWxzZSxcblx0XHRoYW5kbGU6IGZhbHNlLFxuXHRcdGhlbHBlcjogXCJvcmlnaW5hbFwiLFxuXHRcdGl0ZW1zOiAnPiAqJyxcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRwbGFjZWhvbGRlcjogZmFsc2UsXG5cdFx0cmV2ZXJ0OiBmYWxzZSxcblx0XHRzY3JvbGw6IHRydWUsXG5cdFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxuXHRcdHNjcm9sbFNwZWVkOiAyMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0dG9sZXJhbmNlOiBcImludGVyc2VjdFwiLFxuXHRcdHpJbmRleDogMTAwMFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuY29udGFpbmVyQ2FjaGUgPSB7fTtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zb3J0YWJsZVwiKTtcblxuXHRcdC8vR2V0IHRoZSBpdGVtc1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0Ly9MZXQncyBkZXRlcm1pbmUgaWYgdGhlIGl0ZW1zIGFyZSBiZWluZyBkaXNwbGF5ZWQgaG9yaXpvbnRhbGx5XG5cdFx0dGhpcy5mbG9hdGluZyA9IHRoaXMuaXRlbXMubGVuZ3RoID8gby5heGlzID09PSAneCcgfHwgKC9sZWZ0fHJpZ2h0LykudGVzdCh0aGlzLml0ZW1zWzBdLml0ZW0uY3NzKCdmbG9hdCcpKSB8fCAoL2lubGluZXx0YWJsZS1jZWxsLykudGVzdCh0aGlzLml0ZW1zWzBdLml0ZW0uY3NzKCdkaXNwbGF5JykpIDogZmFsc2U7XG5cblx0XHQvL0xldCdzIGRldGVybWluZSB0aGUgcGFyZW50J3Mgb2Zmc2V0XG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cblx0XHQvL0luaXRpYWxpemUgbW91c2UgZXZlbnRzIGZvciBpbnRlcmFjdGlvblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0Ly9XZSdyZSByZWFkeSB0byBnb1xuXHRcdHRoaXMucmVhZHkgPSB0cnVlXG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZSB1aS1zb3J0YWJsZS1kaXNhYmxlZFwiKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApXG5cdFx0XHR0aGlzLml0ZW1zW2ldLml0ZW0ucmVtb3ZlRGF0YSh0aGlzLndpZGdldE5hbWUgKyBcIi1pdGVtXCIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy53aWRnZXQoKS50b2dnbGVDbGFzcyggXCJ1aS1zb3J0YWJsZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERvbid0IGNhbGwgd2lkZ2V0IGJhc2UgX3NldE9wdGlvbiBmb3IgZGlzYWJsZSBhcyBpdCBhZGRzIHVpLXN0YXRlLWRpc2FibGVkIGNsYXNzXG5cdFx0XHQkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCwgb3ZlcnJpZGVIYW5kbGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5yZXZlcnRpbmcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5vcHRpb25zLnR5cGUgPT0gJ3N0YXRpYycpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vV2UgaGF2ZSB0byByZWZyZXNoIHRoZSBpdGVtcyBkYXRhIG9uY2UgZmlyc3Rcblx0XHR0aGlzLl9yZWZyZXNoSXRlbXMoZXZlbnQpO1xuXG5cdFx0Ly9GaW5kIG91dCBpZiB0aGUgY2xpY2tlZCBub2RlIChvciBvbmUgb2YgaXRzIHBhcmVudHMpIGlzIGEgYWN0dWFsIGl0ZW0gaW4gdGhpcy5pdGVtc1xuXHRcdHZhciBjdXJyZW50SXRlbSA9IG51bGwsIG5vZGVzID0gJChldmVudC50YXJnZXQpLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoJC5kYXRhKHRoaXMsIHRoYXQud2lkZ2V0TmFtZSArICctaXRlbScpID09IHRoYXQpIHtcblx0XHRcdFx0Y3VycmVudEl0ZW0gPSAkKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYoJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgJy1pdGVtJykgPT0gdGhhdCkgY3VycmVudEl0ZW0gPSAkKGV2ZW50LnRhcmdldCk7XG5cblx0XHRpZighY3VycmVudEl0ZW0pIHJldHVybiBmYWxzZTtcblx0XHRpZih0aGlzLm9wdGlvbnMuaGFuZGxlICYmICFvdmVycmlkZUhhbmRsZSkge1xuXHRcdFx0dmFyIHZhbGlkSGFuZGxlID0gZmFsc2U7XG5cblx0XHRcdCQodGhpcy5vcHRpb25zLmhhbmRsZSwgY3VycmVudEl0ZW0pLmZpbmQoXCIqXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKCkgeyBpZih0aGlzID09IGV2ZW50LnRhcmdldCkgdmFsaWRIYW5kbGUgPSB0cnVlOyB9KTtcblx0XHRcdGlmKCF2YWxpZEhhbmRsZSkgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuY3VycmVudEl0ZW0gPSBjdXJyZW50SXRlbTtcblx0XHR0aGlzLl9yZW1vdmVDdXJyZW50c0Zyb21JdGVtcygpO1xuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCBvdmVycmlkZUhhbmRsZSwgbm9BY3RpdmF0aW9uKSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzO1xuXG5cdFx0Ly9XZSBvbmx5IG5lZWQgdG8gY2FsbCByZWZyZXNoUG9zaXRpb25zLCBiZWNhdXNlIHRoZSByZWZyZXNoSXRlbXMgY2FsbCBoYXMgYmVlbiBtb3ZlZCB0byBtb3VzZUNhcHR1cmVcblx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcblxuXHRcdC8vQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHZpc2libGUgaGVscGVyXG5cdFx0dGhpcy5oZWxwZXIgPSB0aGlzLl9jcmVhdGVIZWxwZXIoZXZlbnQpO1xuXG5cdFx0Ly9DYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9HZXQgdGhlIG5leHQgc2Nyb2xsaW5nIHBhcmVudFxuXHRcdHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KCk7XG5cblx0XHQvL1RoZSBlbGVtZW50J3MgYWJzb2x1dGUgcG9zaXRpb24gb24gdGhlIHBhZ2UgbWludXMgbWFyZ2luc1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5jdXJyZW50SXRlbS5vZmZzZXQoKTtcblx0XHR0aGlzLm9mZnNldCA9IHtcblx0XHRcdHRvcDogdGhpcy5vZmZzZXQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdFxuXHRcdH07XG5cblx0XHQkLmV4dGVuZCh0aGlzLm9mZnNldCwge1xuXHRcdFx0Y2xpY2s6IHsgLy9XaGVyZSB0aGUgY2xpY2sgaGFwcGVuZWQsIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQubGVmdCxcblx0XHRcdFx0dG9wOiBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LnRvcFxuXHRcdFx0fSxcblx0XHRcdHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXG5cdFx0XHRyZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKSAvL1RoaXMgaXMgYSByZWxhdGl2ZSB0byBhYnNvbHV0ZSBwb3NpdGlvbiBtaW51cyB0aGUgYWN0dWFsIHBvc2l0aW9uIGNhbGN1bGF0aW9uIC0gb25seSB1c2VkIGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIGhlbHBlclxuXHRcdH0pO1xuXG5cdFx0Ly8gT25seSBhZnRlciB3ZSBnb3QgdGhlIG9mZnNldCwgd2UgY2FuIGNoYW5nZSB0aGUgaGVscGVyJ3MgcG9zaXRpb24gdG8gYWJzb2x1dGVcblx0XHQvLyBUT0RPOiBTdGlsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgYSB3YXkgdG8gbWFrZSByZWxhdGl2ZSBzb3J0aW5nIHBvc3NpYmxlXG5cdFx0dGhpcy5oZWxwZXIuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcblx0XHR0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKFwicG9zaXRpb25cIik7XG5cblx0XHQvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmICdjdXJzb3JBdCcgaXMgc3VwcGxpZWRcblx0XHQoby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKG8uY3Vyc29yQXQpKTtcblxuXHRcdC8vQ2FjaGUgdGhlIGZvcm1lciBET00gcG9zaXRpb25cblx0XHR0aGlzLmRvbVBvc2l0aW9uID0geyBwcmV2OiB0aGlzLmN1cnJlbnRJdGVtLnByZXYoKVswXSwgcGFyZW50OiB0aGlzLmN1cnJlbnRJdGVtLnBhcmVudCgpWzBdIH07XG5cblx0XHQvL0lmIHRoZSBoZWxwZXIgaXMgbm90IHRoZSBvcmlnaW5hbCwgaGlkZSB0aGUgb3JpZ2luYWwgc28gaXQncyBub3QgcGxheWluZyBhbnkgcm9sZSBkdXJpbmcgdGhlIGRyYWcsIHdvbid0IGNhdXNlIGFueXRoaW5nIGJhZCB0aGlzIHdheVxuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcblx0XHRcdHRoaXMuY3VycmVudEl0ZW0uaGlkZSgpO1xuXHRcdH1cblxuXHRcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoaXMuX2NyZWF0ZVBsYWNlaG9sZGVyKCk7XG5cblx0XHQvL1NldCBhIGNvbnRhaW5tZW50IGlmIGdpdmVuIGluIHRoZSBvcHRpb25zXG5cdFx0aWYoby5jb250YWlubWVudClcblx0XHRcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XG5cblx0XHRpZihvLmN1cnNvcikgeyAvLyBjdXJzb3Igb3B0aW9uXG5cdFx0XHRpZiAoJCgnYm9keScpLmNzcyhcImN1cnNvclwiKSkgdGhpcy5fc3RvcmVkQ3Vyc29yID0gJCgnYm9keScpLmNzcyhcImN1cnNvclwiKTtcblx0XHRcdCQoJ2JvZHknKS5jc3MoXCJjdXJzb3JcIiwgby5jdXJzb3IpO1xuXHRcdH1cblxuXHRcdGlmKG8ub3BhY2l0eSkgeyAvLyBvcGFjaXR5IG9wdGlvblxuXHRcdFx0aWYgKHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIikpIHRoaXMuX3N0b3JlZE9wYWNpdHkgPSB0aGlzLmhlbHBlci5jc3MoXCJvcGFjaXR5XCIpO1xuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiLCBvLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdGlmKG8uekluZGV4KSB7IC8vIHpJbmRleCBvcHRpb25cblx0XHRcdGlmICh0aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIikpIHRoaXMuX3N0b3JlZFpJbmRleCA9IHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiKTtcblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiLCBvLnpJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHNjcm9sbGluZ1xuXHRcdGlmKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT0gJ0hUTUwnKVxuXHRcdFx0dGhpcy5vdmVyZmxvd09mZnNldCA9IHRoaXMuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly9DYWxsIGNhbGxiYWNrc1xuXHRcdHRoaXMuX3RyaWdnZXIoXCJzdGFydFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdGlmKCF0aGlzLl9wcmVzZXJ2ZUhlbHBlclByb3BvcnRpb25zKVxuXHRcdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cblx0XHQvL1Bvc3QgJ2FjdGl2YXRlJyBldmVudHMgdG8gcG9zc2libGUgY29udGFpbmVyc1xuXHRcdGlmKCFub0FjdGl2YXRpb24pIHtcblx0XHRcdCBmb3IgKHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcImFjdGl2YXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyB9XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHBvc3NpYmxlIGRyb3BwYWJsZXNcblx0XHRpZigkLnVpLmRkbWFuYWdlcilcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xuXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpXG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuaGVscGVyLmFkZENsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO1xuXHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblxuXHRcdGlmICghdGhpcy5sYXN0UG9zaXRpb25BYnMpIHtcblx0XHRcdHRoaXMubGFzdFBvc2l0aW9uQWJzID0gdGhpcy5wb3NpdGlvbkFicztcblx0XHR9XG5cblx0XHQvL0RvIHNjcm9sbGluZ1xuXHRcdGlmKHRoaXMub3B0aW9ucy5zY3JvbGwpIHtcblx0XHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBzY3JvbGxlZCA9IGZhbHNlO1xuXHRcdFx0aWYodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPSAnSFRNTCcpIHtcblxuXHRcdFx0XHRpZigodGhpcy5vdmVyZmxvd09mZnNldC50b3AgKyB0aGlzLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQpIC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0ZWxzZSBpZihldmVudC5wYWdlWSAtIHRoaXMub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdCArIHRoaXMuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoKSAtIGV2ZW50LnBhZ2VYIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0ZWxzZSBpZihldmVudC5wYWdlWCAtIHRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0ZWxzZSBpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgby5zY3JvbGxTcGVlZCk7XG5cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0ZWxzZSBpZigkKHdpbmRvdykud2lkdGgoKSAtIChldmVudC5wYWdlWCAtICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZihzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cilcblx0XHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8vUmVnZW5lcmF0ZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gdXNlZCBmb3IgcG9zaXRpb24gY2hlY2tzXG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cblx0XHQvL1NldCB0aGUgaGVscGVyIHBvc2l0aW9uXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9IFwieVwiKSB0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0KydweCc7XG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9IFwieFwiKSB0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCsncHgnO1xuXG5cdFx0Ly9SZWFycmFuZ2Vcblx0XHRmb3IgKHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXG5cdFx0XHQvL0NhY2hlIHZhcmlhYmxlcyBhbmQgaW50ZXJzZWN0aW9uLCBjb250aW51ZSBpZiBubyBpbnRlcnNlY3Rpb25cblx0XHRcdHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXSwgaXRlbUVsZW1lbnQgPSBpdGVtLml0ZW1bMF0sIGludGVyc2VjdGlvbiA9IHRoaXMuX2ludGVyc2VjdHNXaXRoUG9pbnRlcihpdGVtKTtcblx0XHRcdGlmICghaW50ZXJzZWN0aW9uKSBjb250aW51ZTtcblxuXHRcdFx0Ly8gT25seSBwdXQgdGhlIHBsYWNlaG9sZGVyIGluc2lkZSB0aGUgY3VycmVudCBDb250YWluZXIsIHNraXAgYWxsXG5cdFx0XHQvLyBpdGVtcyBmb3JtIG90aGVyIGNvbnRhaW5lcnMuIFRoaXMgd29ya3MgYmVjYXVzZSB3aGVuIG1vdmluZ1xuXHRcdFx0Ly8gYW4gaXRlbSBmcm9tIG9uZSBjb250YWluZXIgdG8gYW5vdGhlciB0aGVcblx0XHRcdC8vIGN1cnJlbnRDb250YWluZXIgaXMgc3dpdGNoZWQgYmVmb3JlIHRoZSBwbGFjZWhvbGRlciBpcyBtb3ZlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMgbW92aW5nIGl0ZW1zIGluIFwic3ViLXNvcnRhYmxlc1wiIGNhbiBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gaml0dGVyXG5cdFx0XHQvLyBiZWV0d2VlbiB0aGUgb3V0ZXIgYW5kIGlubmVyIGNvbnRhaW5lci5cblx0XHRcdGlmIChpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoaXRlbUVsZW1lbnQgIT0gdGhpcy5jdXJyZW50SXRlbVswXSAvL2Nhbm5vdCBpbnRlcnNlY3Qgd2l0aCBpdHNlbGZcblx0XHRcdFx0JiZcdHRoaXMucGxhY2Vob2xkZXJbaW50ZXJzZWN0aW9uID09IDEgPyBcIm5leHRcIiA6IFwicHJldlwiXSgpWzBdICE9IGl0ZW1FbGVtZW50IC8vbm8gdXNlbGVzcyBhY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGRvbmUgYmVmb3JlXG5cdFx0XHRcdCYmXHQhJC5jb250YWlucyh0aGlzLnBsYWNlaG9sZGVyWzBdLCBpdGVtRWxlbWVudCkgLy9ubyBhY3Rpb24gaWYgdGhlIGl0ZW0gbW92ZWQgaXMgdGhlIHBhcmVudCBvZiB0aGUgaXRlbSBjaGVja2VkXG5cdFx0XHRcdCYmICh0aGlzLm9wdGlvbnMudHlwZSA9PSAnc2VtaS1keW5hbWljJyA/ICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgaXRlbUVsZW1lbnQpIDogdHJ1ZSlcblx0XHRcdFx0Ly8mJiBpdGVtRWxlbWVudC5wYXJlbnROb2RlID09IHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZSAvLyBvbmx5IHJlYXJyYW5nZSBpdGVtcyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyXG5cdFx0XHQpIHtcblxuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbiA9IGludGVyc2VjdGlvbiA9PSAxID8gXCJkb3duXCIgOiBcInVwXCI7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy50b2xlcmFuY2UgPT0gXCJwb2ludGVyXCIgfHwgdGhpcy5faW50ZXJzZWN0c1dpdGhTaWRlcyhpdGVtKSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlYXJyYW5nZShldmVudCwgaXRlbSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vUG9zdCBldmVudHMgdG8gY29udGFpbmVyc1xuXHRcdHRoaXMuX2NvbnRhY3RDb250YWluZXJzKGV2ZW50KTtcblxuXHRcdC8vSW50ZXJjb25uZWN0IHdpdGggZHJvcHBhYmxlc1xuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSAkLnVpLmRkbWFuYWdlci5kcmFnKHRoaXMsIGV2ZW50KTtcblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKCdzb3J0JywgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblxuXHRcdHRoaXMubGFzdFBvc2l0aW9uQWJzID0gdGhpcy5wb3NpdGlvbkFicztcblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXG5cdFx0aWYoIWV2ZW50KSByZXR1cm47XG5cblx0XHQvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3Bcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKVxuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJvcCh0aGlzLCBldmVudCk7XG5cblx0XHRpZih0aGlzLm9wdGlvbnMucmV2ZXJ0KSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR2YXIgY3VyID0gdGhpcy5wbGFjZWhvbGRlci5vZmZzZXQoKTtcblxuXHRcdFx0dGhpcy5yZXZlcnRpbmcgPSB0cnVlO1xuXG5cdFx0XHQkKHRoaXMuaGVscGVyKS5hbmltYXRlKHtcblx0XHRcdFx0bGVmdDogY3VyLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0ICsgKHRoaXMub2Zmc2V0UGFyZW50WzBdID09IGRvY3VtZW50LmJvZHkgPyAwIDogdGhpcy5vZmZzZXRQYXJlbnRbMF0uc2Nyb2xsTGVmdCksXG5cdFx0XHRcdHRvcDogY3VyLnRvcCAtIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgLSB0aGlzLm1hcmdpbnMudG9wICsgKHRoaXMub2Zmc2V0UGFyZW50WzBdID09IGRvY3VtZW50LmJvZHkgPyAwIDogdGhpcy5vZmZzZXRQYXJlbnRbMF0uc2Nyb2xsVG9wKVxuXHRcdFx0fSwgcGFyc2VJbnQodGhpcy5vcHRpb25zLnJldmVydCwgMTApIHx8IDUwMCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuX2NsZWFyKGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhcihldmVudCwgbm9Qcm9wYWdhdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuZHJhZ2dpbmcpIHtcblxuXHRcdFx0dGhpcy5fbW91c2VVcCh7IHRhcmdldDogbnVsbCB9KTtcblxuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhlbHBlciA9PSBcIm9yaWdpbmFsXCIpXG5cdFx0XHRcdHRoaXMuY3VycmVudEl0ZW0uY3NzKHRoaXMuX3N0b3JlZENTUykucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIik7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRoaXMuY3VycmVudEl0ZW0uc2hvdygpO1xuXG5cdFx0XHQvL1Bvc3QgZGVhY3RpdmF0aW5nIGV2ZW50cyB0byBjb250YWluZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRpZih0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcIm91dFwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcblx0XHRcdC8vJCh0aGlzLnBsYWNlaG9sZGVyWzBdKS5yZW1vdmUoKTsgd291bGQgaGF2ZSBiZWVuIHRoZSBqUXVlcnkgd2F5IC0gdW5mb3J0dW5hdGVseSwgaXQgdW5iaW5kcyBBTEwgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUhXG5cdFx0XHRpZih0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUpIHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKTtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5oZWxwZXIgIT0gXCJvcmlnaW5hbFwiICYmIHRoaXMuaGVscGVyICYmIHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGUpIHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXG5cdFx0XHQkLmV4dGVuZCh0aGlzLCB7XG5cdFx0XHRcdGhlbHBlcjogbnVsbCxcblx0XHRcdFx0ZHJhZ2dpbmc6IGZhbHNlLFxuXHRcdFx0XHRyZXZlcnRpbmc6IGZhbHNlLFxuXHRcdFx0XHRfbm9GaW5hbFNvcnQ6IG51bGxcblx0XHRcdH0pO1xuXG5cdFx0XHRpZih0aGlzLmRvbVBvc2l0aW9uLnByZXYpIHtcblx0XHRcdFx0JCh0aGlzLmRvbVBvc2l0aW9uLnByZXYpLmFmdGVyKHRoaXMuY3VycmVudEl0ZW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCh0aGlzLmRvbVBvc2l0aW9uLnBhcmVudCkucHJlcGVuZCh0aGlzLmN1cnJlbnRJdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24obykge1xuXG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNBc2pRdWVyeShvICYmIG8uY29ubmVjdGVkKTtcblx0XHR2YXIgc3RyID0gW107IG8gPSBvIHx8IHt9O1xuXG5cdFx0JChpdGVtcykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSAoJChvLml0ZW0gfHwgdGhpcykuYXR0cihvLmF0dHJpYnV0ZSB8fCAnaWQnKSB8fCAnJykubWF0Y2goby5leHByZXNzaW9uIHx8ICgvKC4rKVstPV9dKC4rKS8pKTtcblx0XHRcdGlmKHJlcykgc3RyLnB1c2goKG8ua2V5IHx8IHJlc1sxXSsnW10nKSsnPScrKG8ua2V5ICYmIG8uZXhwcmVzc2lvbiA/IHJlc1sxXSA6IHJlc1syXSkpO1xuXHRcdH0pO1xuXG5cdFx0aWYoIXN0ci5sZW5ndGggJiYgby5rZXkpIHtcblx0XHRcdHN0ci5wdXNoKG8ua2V5ICsgJz0nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyLmpvaW4oJyYnKTtcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKG8pIHtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkobyAmJiBvLmNvbm5lY3RlZCk7XG5cdFx0dmFyIHJldCA9IFtdOyBvID0gbyB8fCB7fTtcblxuXHRcdGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7IHJldC5wdXNoKCQoby5pdGVtIHx8IHRoaXMpLmF0dHIoby5hdHRyaWJ1dGUgfHwgJ2lkJykgfHwgJycpOyB9KTtcblx0XHRyZXR1cm4gcmV0O1xuXG5cdH0sXG5cblx0LyogQmUgY2FyZWZ1bCB3aXRoIHRoZSBmb2xsb3dpbmcgY29yZSBmdW5jdGlvbnMgKi9cblx0X2ludGVyc2VjdHNXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHR2YXIgeDEgPSB0aGlzLnBvc2l0aW9uQWJzLmxlZnQsXG5cdFx0XHR4MiA9IHgxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcblx0XHRcdHkxID0gdGhpcy5wb3NpdGlvbkFicy50b3AsXG5cdFx0XHR5MiA9IHkxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0XHR2YXIgbCA9IGl0ZW0ubGVmdCxcblx0XHRcdHIgPSBsICsgaXRlbS53aWR0aCxcblx0XHRcdHQgPSBpdGVtLnRvcCxcblx0XHRcdGIgPSB0ICsgaXRlbS5oZWlnaHQ7XG5cblx0XHR2YXIgZHlDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLnRvcCxcblx0XHRcdGR4Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXG5cdFx0dmFyIGlzT3ZlckVsZW1lbnQgPSAoeTEgKyBkeUNsaWNrKSA+IHQgJiYgKHkxICsgZHlDbGljaykgPCBiICYmICh4MSArIGR4Q2xpY2spID4gbCAmJiAoeDEgKyBkeENsaWNrKSA8IHI7XG5cblx0XHRpZihcdCAgIHRoaXMub3B0aW9ucy50b2xlcmFuY2UgPT0gXCJwb2ludGVyXCJcblx0XHRcdHx8IHRoaXMub3B0aW9ucy5mb3JjZVBvaW50ZXJGb3JDb250YWluZXJzXG5cdFx0XHR8fCAodGhpcy5vcHRpb25zLnRvbGVyYW5jZSAhPSBcInBvaW50ZXJcIiAmJiB0aGlzLmhlbHBlclByb3BvcnRpb25zW3RoaXMuZmxvYXRpbmcgPyAnd2lkdGgnIDogJ2hlaWdodCddID4gaXRlbVt0aGlzLmZsb2F0aW5nID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSlcblx0XHQpIHtcblx0XHRcdHJldHVybiBpc092ZXJFbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiAobCA8IHgxICsgKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSAvLyBSaWdodCBIYWxmXG5cdFx0XHRcdCYmIHgyIC0gKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSA8IHIgLy8gTGVmdCBIYWxmXG5cdFx0XHRcdCYmIHQgPCB5MSArICh0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIpIC8vIEJvdHRvbSBIYWxmXG5cdFx0XHRcdCYmIHkyIC0gKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMikgPCBiICk7IC8vIFRvcCBIYWxmXG5cblx0XHR9XG5cdH0sXG5cblx0X2ludGVyc2VjdHNXaXRoUG9pbnRlcjogZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0dmFyIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSAodGhpcy5vcHRpb25zLmF4aXMgPT09ICd4JykgfHwgJC51aS5pc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMudG9wICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wLCBpdGVtLnRvcCwgaXRlbS5oZWlnaHQpLFxuXHRcdFx0aXNPdmVyRWxlbWVudFdpZHRoID0gKHRoaXMub3B0aW9ucy5heGlzID09PSAneScpIHx8ICQudWkuaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQsIGl0ZW0ud2lkdGgpLFxuXHRcdFx0aXNPdmVyRWxlbWVudCA9IGlzT3ZlckVsZW1lbnRIZWlnaHQgJiYgaXNPdmVyRWxlbWVudFdpZHRoLFxuXHRcdFx0dmVydGljYWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSxcblx0XHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0aWYgKCFpc092ZXJFbGVtZW50KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmxvYXRpbmcgP1xuXHRcdFx0KCAoKGhvcml6b250YWxEaXJlY3Rpb24gJiYgaG9yaXpvbnRhbERpcmVjdGlvbiA9PSBcInJpZ2h0XCIpIHx8IHZlcnRpY2FsRGlyZWN0aW9uID09IFwiZG93blwiKSA/IDIgOiAxIClcblx0XHRcdDogKCB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAodmVydGljYWxEaXJlY3Rpb24gPT0gXCJkb3duXCIgPyAyIDogMSkgKTtcblxuXHR9LFxuXG5cdF9pbnRlcnNlY3RzV2l0aFNpZGVzOiBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHR2YXIgaXNPdmVyQm90dG9tSGFsZiA9ICQudWkuaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLnRvcCArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCwgaXRlbS50b3AgKyAoaXRlbS5oZWlnaHQvMiksIGl0ZW0uaGVpZ2h0KSxcblx0XHRcdGlzT3ZlclJpZ2h0SGFsZiA9ICQudWkuaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQgKyAoaXRlbS53aWR0aC8yKSwgaXRlbS53aWR0aCksXG5cdFx0XHR2ZXJ0aWNhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpLFxuXHRcdFx0aG9yaXpvbnRhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uKCk7XG5cblx0XHRpZiAodGhpcy5mbG9hdGluZyAmJiBob3Jpem9udGFsRGlyZWN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gKChob3Jpem9udGFsRGlyZWN0aW9uID09IFwicmlnaHRcIiAmJiBpc092ZXJSaWdodEhhbGYpIHx8IChob3Jpem9udGFsRGlyZWN0aW9uID09IFwibGVmdFwiICYmICFpc092ZXJSaWdodEhhbGYpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZlcnRpY2FsRGlyZWN0aW9uICYmICgodmVydGljYWxEaXJlY3Rpb24gPT0gXCJkb3duXCIgJiYgaXNPdmVyQm90dG9tSGFsZikgfHwgKHZlcnRpY2FsRGlyZWN0aW9uID09IFwidXBcIiAmJiAhaXNPdmVyQm90dG9tSGFsZikpO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9nZXREcmFnVmVydGljYWxEaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWx0YSA9IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5sYXN0UG9zaXRpb25BYnMudG9wO1xuXHRcdHJldHVybiBkZWx0YSAhPSAwICYmIChkZWx0YSA+IDAgPyBcImRvd25cIiA6IFwidXBcIik7XG5cdH0sXG5cblx0X2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLnBvc2l0aW9uQWJzLmxlZnQgLSB0aGlzLmxhc3RQb3NpdGlvbkFicy5sZWZ0O1xuXHRcdHJldHVybiBkZWx0YSAhPSAwICYmIChkZWx0YSA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR0aGlzLl9yZWZyZXNoSXRlbXMoZXZlbnQpO1xuXHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9jb25uZWN0V2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0cmV0dXJuIG9wdGlvbnMuY29ubmVjdFdpdGguY29uc3RydWN0b3IgPT0gU3RyaW5nXG5cdFx0XHQ/IFtvcHRpb25zLmNvbm5lY3RXaXRoXVxuXHRcdFx0OiBvcHRpb25zLmNvbm5lY3RXaXRoO1xuXHR9LFxuXG5cdF9nZXRJdGVtc0FzalF1ZXJ5OiBmdW5jdGlvbihjb25uZWN0ZWQpIHtcblxuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdHZhciBxdWVyaWVzID0gW107XG5cdFx0dmFyIGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcblxuXHRcdGlmKGNvbm5lY3RXaXRoICYmIGNvbm5lY3RlZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGNvbm5lY3RXaXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dmFyIGN1ciA9ICQoY29ubmVjdFdpdGhbaV0pO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKXtcblx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0TmFtZSk7XG5cdFx0XHRcdFx0aWYoaW5zdCAmJiBpbnN0ICE9IHRoaXMgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCkge1xuXHRcdFx0XHRcdFx0cXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLml0ZW1zKSA/IGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKGluc3QuZWxlbWVudCkgOiAkKGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50KS5ub3QoXCIudWktc29ydGFibGUtaGVscGVyXCIpLm5vdCgnLnVpLXNvcnRhYmxlLXBsYWNlaG9sZGVyJyksIGluc3RdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnQsIG51bGwsIHsgb3B0aW9uczogdGhpcy5vcHRpb25zLCBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJCh0aGlzLm9wdGlvbnMuaXRlbXMsIHRoaXMuZWxlbWVudCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKS5ub3QoJy51aS1zb3J0YWJsZS1wbGFjZWhvbGRlcicpLCB0aGlzXSk7XG5cblx0XHRmb3IgKHZhciBpID0gcXVlcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRxdWVyaWVzW2ldWzBdLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2godGhpcyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuICQoaXRlbXMpO1xuXG5cdH0sXG5cblx0X3JlbW92ZUN1cnJlbnRzRnJvbUl0ZW1zOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsaXN0ID0gdGhpcy5jdXJyZW50SXRlbS5maW5kKFwiOmRhdGEoXCIgKyB0aGlzLndpZGdldE5hbWUgKyBcIi1pdGVtKVwiKTtcblxuXHRcdHRoaXMuaXRlbXMgPSAkLmdyZXAodGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGZvciAodmFyIGo9MDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYobGlzdFtqXSA9PSBpdGVtLml0ZW1bMF0pXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXG5cdH0sXG5cblx0X3JlZnJlc2hJdGVtczogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHRoaXMuaXRlbXMgPSBbXTtcblx0XHR0aGlzLmNvbnRhaW5lcnMgPSBbdGhpc107XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcblx0XHR2YXIgcXVlcmllcyA9IFtbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50KSwgdGhpc11dO1xuXHRcdHZhciBjb25uZWN0V2l0aCA9IHRoaXMuX2Nvbm5lY3RXaXRoKCk7XG5cblx0XHRpZihjb25uZWN0V2l0aCAmJiB0aGlzLnJlYWR5KSB7IC8vU2hvdWxkbid0IGJlIHJ1biB0aGUgZmlyc3QgdGltZSB0aHJvdWdoIGR1ZSB0byBtYXNzaXZlIHNsb3ctZG93blxuXHRcdFx0Zm9yICh2YXIgaSA9IGNvbm5lY3RXaXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dmFyIGN1ciA9ICQoY29ubmVjdFdpdGhbaV0pO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKXtcblx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0TmFtZSk7XG5cdFx0XHRcdFx0aWYoaW5zdCAmJiBpbnN0ICE9IHRoaXMgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCkge1xuXHRcdFx0XHRcdFx0cXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLml0ZW1zKSA/IGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKGluc3QuZWxlbWVudFswXSwgZXZlbnQsIHsgaXRlbTogdGhpcy5jdXJyZW50SXRlbSB9KSA6ICQoaW5zdC5vcHRpb25zLml0ZW1zLCBpbnN0LmVsZW1lbnQpLCBpbnN0XSk7XG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnMucHVzaChpbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBxdWVyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgdGFyZ2V0RGF0YSA9IHF1ZXJpZXNbaV1bMV07XG5cdFx0XHR2YXIgX3F1ZXJpZXMgPSBxdWVyaWVzW2ldWzBdO1xuXG5cdFx0XHRmb3IgKHZhciBqPTAsIHF1ZXJpZXNMZW5ndGggPSBfcXVlcmllcy5sZW5ndGg7IGogPCBxdWVyaWVzTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSAkKF9xdWVyaWVzW2pdKTtcblxuXHRcdFx0XHRpdGVtLmRhdGEodGhpcy53aWRnZXROYW1lICsgJy1pdGVtJywgdGFyZ2V0RGF0YSk7IC8vIERhdGEgZm9yIHRhcmdldCBjaGVja2luZyAobW91c2UgbWFuYWdlcilcblxuXHRcdFx0XHRpdGVtcy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRcdGluc3RhbmNlOiB0YXJnZXREYXRhLFxuXHRcdFx0XHRcdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCwgdG9wOiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdH0sXG5cblx0cmVmcmVzaFBvc2l0aW9uczogZnVuY3Rpb24oZmFzdCkge1xuXG5cdFx0Ly9UaGlzIGhhcyB0byBiZSByZWRvbmUgYmVjYXVzZSBkdWUgdG8gdGhlIGl0ZW0gYmVpbmcgbW92ZWQgb3V0L2ludG8gdGhlIG9mZnNldFBhcmVudCwgdGhlIG9mZnNldFBhcmVudCdzIHBvc2l0aW9uIHdpbGwgY2hhbmdlXG5cdFx0aWYodGhpcy5vZmZzZXRQYXJlbnQgJiYgdGhpcy5oZWxwZXIpIHtcblx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuXHRcdFx0Ly9XZSBpZ25vcmUgY2FsY3VsYXRpbmcgcG9zaXRpb25zIG9mIGFsbCBjb25uZWN0ZWQgY29udGFpbmVycyB3aGVuIHdlJ3JlIG5vdCBvdmVyIHRoZW1cblx0XHRcdGlmKGl0ZW0uaW5zdGFuY2UgIT0gdGhpcy5jdXJyZW50Q29udGFpbmVyICYmIHRoaXMuY3VycmVudENvbnRhaW5lciAmJiBpdGVtLml0ZW1bMF0gIT0gdGhpcy5jdXJyZW50SXRlbVswXSlcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciB0ID0gdGhpcy5vcHRpb25zLnRvbGVyYW5jZUVsZW1lbnQgPyAkKHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50LCBpdGVtLml0ZW0pIDogaXRlbS5pdGVtO1xuXG5cdFx0XHRpZiAoIWZhc3QpIHtcblx0XHRcdFx0aXRlbS53aWR0aCA9IHQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHRpdGVtLmhlaWdodCA9IHQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHAgPSB0Lm9mZnNldCgpO1xuXHRcdFx0aXRlbS5sZWZ0ID0gcC5sZWZ0O1xuXHRcdFx0aXRlbS50b3AgPSBwLnRvcDtcblx0XHR9O1xuXG5cdFx0aWYodGhpcy5vcHRpb25zLmN1c3RvbSAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tLnJlZnJlc2hDb250YWluZXJzKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuY3VzdG9tLnJlZnJlc2hDb250YWluZXJzLmNhbGwodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHR2YXIgcCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUubGVmdCA9IHAubGVmdDtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLnRvcCA9IHAudG9wO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUud2lkdGhcdD0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2NyZWF0ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbih0aGF0KSB7XG5cdFx0dGhhdCA9IHRoYXQgfHwgdGhpcztcblx0XHR2YXIgbyA9IHRoYXQub3B0aW9ucztcblxuXHRcdGlmKCFvLnBsYWNlaG9sZGVyIHx8IG8ucGxhY2Vob2xkZXIuY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gby5wbGFjZWhvbGRlcjtcblx0XHRcdG8ucGxhY2Vob2xkZXIgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0dmFyIGVsID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoYXQuY3VycmVudEl0ZW1bMF0ubm9kZU5hbWUpKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKGNsYXNzTmFtZSB8fCB0aGF0LmN1cnJlbnRJdGVtWzBdLmNsYXNzTmFtZStcIiB1aS1zb3J0YWJsZS1wbGFjZWhvbGRlclwiKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpWzBdO1xuXG5cdFx0XHRcdFx0aWYoIWNsYXNzTmFtZSlcblx0XHRcdFx0XHRcdGVsLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcCkge1xuXG5cdFx0XHRcdFx0Ly8gMS4gSWYgYSBjbGFzc05hbWUgaXMgc2V0IGFzICdwbGFjZWhvbGRlciBvcHRpb24sIHdlIGRvbid0IGZvcmNlIHNpemVzIC0gdGhlIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0XG5cdFx0XHRcdFx0Ly8gMi4gVGhlIG9wdGlvbiAnZm9yY2VQbGFjZWhvbGRlclNpemUgY2FuIGJlIGVuYWJsZWQgdG8gZm9yY2UgaXQgZXZlbiBpZiBhIGNsYXNzIG5hbWUgaXMgc3BlY2lmaWVkXG5cdFx0XHRcdFx0aWYoY2xhc3NOYW1lICYmICFvLmZvcmNlUGxhY2Vob2xkZXJTaXplKSByZXR1cm47XG5cblx0XHRcdFx0XHQvL0lmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIGFjdHVhbCBoZWlnaHQgYnkgaXRzZWxmICh3aXRob3V0IHN0eWxlcyBjb21pbmcgZnJvbSBhIHN0eWxlc2hlZXQpLCBpdCByZWNlaXZlcyB0aGUgaW5saW5lIGhlaWdodCBmcm9tIHRoZSBkcmFnZ2VkIGl0ZW1cblx0XHRcdFx0XHRpZighcC5oZWlnaHQoKSkgeyBwLmhlaWdodCh0aGF0LmN1cnJlbnRJdGVtLmlubmVySGVpZ2h0KCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcygncGFkZGluZ1RvcCcpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcygncGFkZGluZ0JvdHRvbScpfHwwLCAxMCkpOyB9O1xuXHRcdFx0XHRcdGlmKCFwLndpZHRoKCkpIHsgcC53aWR0aCh0aGF0LmN1cnJlbnRJdGVtLmlubmVyV2lkdGgoKSAtIHBhcnNlSW50KHRoYXQuY3VycmVudEl0ZW0uY3NzKCdwYWRkaW5nTGVmdCcpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcygncGFkZGluZ1JpZ2h0Jyl8fDAsIDEwKSk7IH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly9DcmVhdGUgdGhlIHBsYWNlaG9sZGVyXG5cdFx0dGhhdC5wbGFjZWhvbGRlciA9ICQoby5wbGFjZWhvbGRlci5lbGVtZW50LmNhbGwodGhhdC5lbGVtZW50LCB0aGF0LmN1cnJlbnRJdGVtKSk7XG5cblx0XHQvL0FwcGVuZCBpdCBhZnRlciB0aGUgYWN0dWFsIGN1cnJlbnQgaXRlbVxuXHRcdHRoYXQuY3VycmVudEl0ZW0uYWZ0ZXIodGhhdC5wbGFjZWhvbGRlcik7XG5cblx0XHQvL1VwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgcGxhY2Vob2xkZXIgKFRPRE86IExvZ2ljIHRvIGZ1enp5LCBzZWUgbGluZSAzMTYvMzE3KVxuXHRcdG8ucGxhY2Vob2xkZXIudXBkYXRlKHRoYXQsIHRoYXQucGxhY2Vob2xkZXIpO1xuXG5cdH0sXG5cblx0X2NvbnRhY3RDb250YWluZXJzOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gZ2V0IGlubmVybW9zdCBjb250YWluZXIgdGhhdCBpbnRlcnNlY3RzIHdpdGggaXRlbVxuXHRcdHZhciBpbm5lcm1vc3RDb250YWluZXIgPSBudWxsLCBpbm5lcm1vc3RJbmRleCA9IG51bGw7XG5cblxuXHRcdGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXG5cdFx0XHQvLyBuZXZlciBjb25zaWRlciBhIGNvbnRhaW5lciB0aGF0J3MgbG9jYXRlZCB3aXRoaW4gdGhlIGl0ZW0gaXRzZWxmXG5cdFx0XHRpZigkLmNvbnRhaW5zKHRoaXMuY3VycmVudEl0ZW1bMF0sIHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50WzBdKSlcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdGlmKHRoaXMuX2ludGVyc2VjdHNXaXRoKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZSkpIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGZvdW5kIGEgY29udGFpbmVyIGFuZCBpdCdzIG1vcmUgXCJpbm5lclwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxuXHRcdFx0XHRpZihpbm5lcm1vc3RDb250YWluZXIgJiYgJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSwgaW5uZXJtb3N0Q29udGFpbmVyLmVsZW1lbnRbMF0pKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlubmVybW9zdENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyc1tpXTtcblx0XHRcdFx0aW5uZXJtb3N0SW5kZXggPSBpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjb250YWluZXIgZG9lc24ndCBpbnRlcnNlY3QuIHRyaWdnZXIgXCJvdXRcIiBldmVudCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0aWYodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXCJvdXRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBpZiBubyBpbnRlcnNlY3RpbmcgY29udGFpbmVycyBmb3VuZCwgcmV0dXJuXG5cdFx0aWYoIWlubmVybW9zdENvbnRhaW5lcikgcmV0dXJuO1xuXG5cdFx0Ly8gbW92ZSB0aGUgaXRlbSBpbnRvIHRoZSBjb250YWluZXIgaWYgaXQncyBub3QgdGhlcmUgYWxyZWFkeVxuXHRcdGlmKHRoaXMuY29udGFpbmVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXCJvdmVyXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvL1doZW4gZW50ZXJpbmcgYSBuZXcgY29udGFpbmVyLCB3ZSB3aWxsIGZpbmQgdGhlIGl0ZW0gd2l0aCB0aGUgbGVhc3QgZGlzdGFuY2UgYW5kIGFwcGVuZCBvdXIgaXRlbSBuZWFyIGl0XG5cdFx0XHR2YXIgZGlzdCA9IDEwMDAwOyB2YXIgaXRlbVdpdGhMZWFzdERpc3RhbmNlID0gbnVsbDtcblx0XHRcdHZhciBwb3NQcm9wZXJ0eSA9IHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uZmxvYXRpbmcgPyAnbGVmdCcgOiAndG9wJztcblx0XHRcdHZhciBzaXplUHJvcGVydHkgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmZsb2F0aW5nID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLnBvc2l0aW9uQWJzW3Bvc1Byb3BlcnR5XSArIHRoaXMub2Zmc2V0LmNsaWNrW3Bvc1Byb3BlcnR5XTtcblx0XHRcdGZvciAodmFyIGogPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdGlmKCEkLmNvbnRhaW5zKHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uZWxlbWVudFswXSwgdGhpcy5pdGVtc1tqXS5pdGVtWzBdKSkgY29udGludWU7XG5cdFx0XHRcdGlmKHRoaXMuaXRlbXNbal0uaXRlbVswXSA9PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSBjb250aW51ZTtcblx0XHRcdFx0dmFyIGN1ciA9IHRoaXMuaXRlbXNbal0uaXRlbS5vZmZzZXQoKVtwb3NQcm9wZXJ0eV07XG5cdFx0XHRcdHZhciBuZWFyQm90dG9tID0gZmFsc2U7XG5cdFx0XHRcdGlmKE1hdGguYWJzKGN1ciAtIGJhc2UpID4gTWF0aC5hYnMoY3VyICsgdGhpcy5pdGVtc1tqXVtzaXplUHJvcGVydHldIC0gYmFzZSkpe1xuXHRcdFx0XHRcdG5lYXJCb3R0b20gPSB0cnVlO1xuXHRcdFx0XHRcdGN1ciArPSB0aGlzLml0ZW1zW2pdW3NpemVQcm9wZXJ0eV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihNYXRoLmFicyhjdXIgLSBiYXNlKSA8IGRpc3QpIHtcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5hYnMoY3VyIC0gYmFzZSk7IGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA9IHRoaXMuaXRlbXNbal07XG5cdFx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSBuZWFyQm90dG9tID8gXCJ1cFwiOiBcImRvd25cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighaXRlbVdpdGhMZWFzdERpc3RhbmNlICYmICF0aGlzLm9wdGlvbnMuZHJvcE9uRW1wdHkpIC8vQ2hlY2sgaWYgZHJvcE9uRW1wdHkgaXMgZW5hYmxlZFxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdHRoaXMuY3VycmVudENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF07XG5cdFx0XHRpdGVtV2l0aExlYXN0RGlzdGFuY2UgPyB0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIGl0ZW1XaXRoTGVhc3REaXN0YW5jZSwgbnVsbCwgdHJ1ZSkgOiB0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIG51bGwsIHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uZWxlbWVudCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXG5cdFx0XHQvL1VwZGF0ZSB0aGUgcGxhY2Vob2xkZXJcblx0XHRcdHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlci51cGRhdGUodGhpcy5jdXJyZW50Q29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcblxuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xuXHRcdH1cblxuXG5cdH0sXG5cblx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBoZWxwZXIgPSAkLmlzRnVuY3Rpb24oby5oZWxwZXIpID8gJChvLmhlbHBlci5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudCwgdGhpcy5jdXJyZW50SXRlbV0pKSA6IChvLmhlbHBlciA9PSAnY2xvbmUnID8gdGhpcy5jdXJyZW50SXRlbS5jbG9uZSgpIDogdGhpcy5jdXJyZW50SXRlbSk7XG5cblx0XHRpZighaGVscGVyLnBhcmVudHMoJ2JvZHknKS5sZW5ndGgpIC8vQWRkIHRoZSBoZWxwZXIgdG8gdGhlIERPTSBpZiB0aGF0IGRpZG4ndCBoYXBwZW4gYWxyZWFkeVxuXHRcdFx0JChvLmFwcGVuZFRvICE9ICdwYXJlbnQnID8gby5hcHBlbmRUbyA6IHRoaXMuY3VycmVudEl0ZW1bMF0ucGFyZW50Tm9kZSlbMF0uYXBwZW5kQ2hpbGQoaGVscGVyWzBdKTtcblxuXHRcdGlmKGhlbHBlclswXSA9PSB0aGlzLmN1cnJlbnRJdGVtWzBdKVxuXHRcdFx0dGhpcy5fc3RvcmVkQ1NTID0geyB3aWR0aDogdGhpcy5jdXJyZW50SXRlbVswXS5zdHlsZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN1cnJlbnRJdGVtWzBdLnN0eWxlLmhlaWdodCwgcG9zaXRpb246IHRoaXMuY3VycmVudEl0ZW0uY3NzKFwicG9zaXRpb25cIiksIHRvcDogdGhpcy5jdXJyZW50SXRlbS5jc3MoXCJ0b3BcIiksIGxlZnQ6IHRoaXMuY3VycmVudEl0ZW0uY3NzKFwibGVmdFwiKSB9O1xuXG5cdFx0aWYoaGVscGVyWzBdLnN0eWxlLndpZHRoID09ICcnIHx8IG8uZm9yY2VIZWxwZXJTaXplKSBoZWxwZXIud2lkdGgodGhpcy5jdXJyZW50SXRlbS53aWR0aCgpKTtcblx0XHRpZihoZWxwZXJbMF0uc3R5bGUuaGVpZ2h0ID09ICcnIHx8IG8uZm9yY2VIZWxwZXJTaXplKSBoZWxwZXIuaGVpZ2h0KHRoaXMuY3VycmVudEl0ZW0uaGVpZ2h0KCkpO1xuXG5cdFx0cmV0dXJuIGhlbHBlcjtcblxuXHR9LFxuXG5cdF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbihvYmopIHtcblx0XHRpZiAodHlwZW9mIG9iaiA9PSAnc3RyaW5nJykge1xuXHRcdFx0b2JqID0gb2JqLnNwbGl0KCcgJyk7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKCdsZWZ0JyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoJ3JpZ2h0JyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gb2JqLnJpZ2h0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmICgndG9wJyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoJ2JvdHRvbScgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXG5cdFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXG5cdFx0dGhpcy5vZmZzZXRQYXJlbnQgPSB0aGlzLmhlbHBlci5vZmZzZXRQYXJlbnQoKTtcblx0XHR2YXIgcG8gPSB0aGlzLm9mZnNldFBhcmVudC5vZmZzZXQoKTtcblxuXHRcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBtb2RpZnkgYSBvZmZzZXQgY2FsY3VsYXRlZCBvbiBzdGFydCwgc2luY2UgdGhlIGZvbGxvd2luZyBoYXBwZW5lZDpcblx0XHQvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XG5cdFx0Ly8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndCB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoYXRcblx0XHQvLyAgICB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCwgYW5kIG5ldmVyIHJlY2FsY3VsYXRlZCB1cG9uIGRyYWdcblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09ICdhYnNvbHV0ZScgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHRpZigodGhpcy5vZmZzZXRQYXJlbnRbMF0gPT0gZG9jdW1lbnQuYm9keSkgLy9UaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpcyBpbmZvcm1hdGlvblxuXHRcdHx8ICh0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lICYmIHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnaHRtbCcgJiYgJC51aS5pZSkpIC8vVWdseSBJRSBmaXhcblx0XHRcdHBvID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT0gXCJyZWxhdGl2ZVwiKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuY3VycmVudEl0ZW0ucG9zaXRpb24oKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwidG9wXCIpLDEwKSB8fCAwKSArIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiBwLmxlZnQgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwibGVmdFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWFyZ2lucyA9IHtcblx0XHRcdGxlZnQ6IChwYXJzZUludCh0aGlzLmN1cnJlbnRJdGVtLmNzcyhcIm1hcmdpbkxlZnRcIiksMTApIHx8IDApLFxuXHRcdFx0dG9wOiAocGFyc2VJbnQodGhpcy5jdXJyZW50SXRlbS5jc3MoXCJtYXJnaW5Ub3BcIiksMTApIHx8IDApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblx0XHRpZihvLmNvbnRhaW5tZW50ID09ICdwYXJlbnQnKSBvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZTtcblx0XHRpZihvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgfHwgby5jb250YWlubWVudCA9PSAnd2luZG93JykgdGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdDAgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdCQoby5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gZG9jdW1lbnQgOiB3aW5kb3cpLndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHQoJChvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgPyBkb2N1bWVudCA6IHdpbmRvdykuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRdO1xuXG5cdFx0aWYoISgvXihkb2N1bWVudHx3aW5kb3d8cGFyZW50KSQvKS50ZXN0KG8uY29udGFpbm1lbnQpKSB7XG5cdFx0XHR2YXIgY2UgPSAkKG8uY29udGFpbm1lbnQpWzBdO1xuXHRcdFx0dmFyIGNvID0gJChvLmNvbnRhaW5tZW50KS5vZmZzZXQoKTtcblx0XHRcdHZhciBvdmVyID0gKCQoY2UpLmNzcyhcIm92ZXJmbG93XCIpICE9ICdoaWRkZW4nKTtcblxuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdFx0Y28ubGVmdCArIChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdMZWZ0XCIpLDEwKSB8fCAwKSAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHRjby50b3AgKyAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdUb3BcIiksMTApIHx8IDApIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdFx0Y28ubGVmdCsob3ZlciA/IE1hdGgubWF4KGNlLnNjcm9sbFdpZHRoLGNlLm9mZnNldFdpZHRoKSA6IGNlLm9mZnNldFdpZHRoKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdSaWdodFwiKSwxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRcdGNvLnRvcCsob3ZlciA/IE1hdGgubWF4KGNlLnNjcm9sbEhlaWdodCxjZS5vZmZzZXRIZWlnaHQpIDogY2Uub2Zmc2V0SGVpZ2h0KSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwicGFkZGluZ0JvdHRvbVwiKSwxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRcdF07XG5cdFx0fVxuXG5cdH0sXG5cblx0X2NvbnZlcnRQb3NpdGlvblRvOiBmdW5jdGlvbihkLCBwb3MpIHtcblxuXHRcdGlmKCFwb3MpIHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0dmFyIG1vZCA9IGQgPT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xO1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09ICdhYnNvbHV0ZScgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCwgc2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBvcy50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdCsgdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0KyB0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdC0gKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6ICggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkgKSApICogbW9kKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cG9zLmxlZnRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2RcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdC0gKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCkgKSAqIG1vZClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dlbmVyYXRlUG9zaXRpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgc2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PSAnYWJzb2x1dGUnICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQsIHNjcm9sbElzUm9vdE5vZGUgPSAoLyhodG1sfGJvZHkpL2kpLnRlc3Qoc2Nyb2xsWzBdLnRhZ05hbWUpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhbm90aGVyIHZlcnkgd2VpcmQgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBoYXBwZW5zIGZvciByZWxhdGl2ZSBlbGVtZW50czpcblx0XHQvLyAxLiBJZiB0aGUgY3NzIHBvc2l0aW9uIGlzIHJlbGF0aXZlXG5cdFx0Ly8gMi4gYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzIHRoZSBkb2N1bWVudCBvciBzaW1pbGFyIHRvIHRoZSBvZmZzZXQgcGFyZW50XG5cdFx0Ly8gd2UgaGF2ZSB0byByZWZyZXNoIHRoZSByZWxhdGl2ZSBvZmZzZXQgZHVyaW5nIHRoZSBzY3JvbGwgc28gdGhlcmUgYXJlIG5vIGp1bXBzXG5cdFx0aWYodGhpcy5jc3NQb3NpdGlvbiA9PSAncmVsYXRpdmUnICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZSA9IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cblx0XHQgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxuXHRcdCAqL1xuXG5cdFx0aWYodGhpcy5vcmlnaW5hbFBvc2l0aW9uKSB7IC8vSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXG5cblx0XHRcdGlmKHRoaXMuY29udGFpbm1lbnQpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgdGhpcy5jb250YWlubWVudFswXSkgcGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCB0aGlzLmNvbnRhaW5tZW50WzFdKSBwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IHRoaXMuY29udGFpbm1lbnRbMl0pIHBhZ2VYID0gdGhpcy5jb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gdGhpcy5jb250YWlubWVudFszXSkgcGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvLmdyaWQpIHtcblx0XHRcdFx0dmFyIHRvcCA9IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV07XG5cdFx0XHRcdHBhZ2VZID0gdGhpcy5jb250YWlubWVudCA/ICghKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IHRoaXMuY29udGFpbm1lbnRbMV0gfHwgdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gdGhpcy5jb250YWlubWVudFszXSkgPyB0b3AgOiAoISh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCB0aGlzLmNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdHZhciBsZWZ0ID0gdGhpcy5vcmlnaW5hbFBhZ2VYICsgTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVgpIC8gby5ncmlkWzBdKSAqIG8uZ3JpZFswXTtcblx0XHRcdFx0cGFnZVggPSB0aGlzLmNvbnRhaW5tZW50ID8gKCEobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCB0aGlzLmNvbnRhaW5tZW50WzBdIHx8IGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gdGhpcy5jb250YWlubWVudFsyXSkgPyBsZWZ0IDogKCEobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCB0aGlzLmNvbnRhaW5tZW50WzBdKSA/IGxlZnQgLSBvLmdyaWRbMF0gOiBsZWZ0ICsgby5ncmlkWzBdKSkgOiBsZWZ0O1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwYWdlWVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LnBhcmVudC50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQrICggKCB0aGlzLmNzc1Bvc2l0aW9uID09ICdmaXhlZCcgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpICkgKSlcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0LSB0aGlzLm9mZnNldC5jbGljay5sZWZ0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQrICggKCB0aGlzLmNzc1Bvc2l0aW9uID09ICdmaXhlZCcgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpICkpXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9yZWFycmFuZ2U6IGZ1bmN0aW9uKGV2ZW50LCBpLCBhLCBoYXJkUmVmcmVzaCkge1xuXG5cdFx0YSA/IGFbMF0uYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSkgOiBpLml0ZW1bMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5wbGFjZWhvbGRlclswXSwgKHRoaXMuZGlyZWN0aW9uID09ICdkb3duJyA/IGkuaXRlbVswXSA6IGkuaXRlbVswXS5uZXh0U2libGluZykpO1xuXG5cdFx0Ly9WYXJpb3VzIHRoaW5ncyBkb25lIGhlcmUgdG8gaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2U6XG5cdFx0Ly8gMS4gd2UgY3JlYXRlIGEgc2V0VGltZW91dCwgdGhhdCBjYWxscyByZWZyZXNoUG9zaXRpb25zXG5cdFx0Ly8gMi4gb24gdGhlIGluc3RhbmNlLCB3ZSBoYXZlIGEgY291bnRlciB2YXJpYWJsZSwgdGhhdCBnZXQncyBoaWdoZXIgYWZ0ZXIgZXZlcnkgYXBwZW5kXG5cdFx0Ly8gMy4gb24gdGhlIGxvY2FsIHNjb3BlLCB3ZSBjb3B5IHRoZSBjb3VudGVyIHZhcmlhYmxlLCBhbmQgY2hlY2sgaW4gdGhlIHRpbWVvdXQsIGlmIGl0J3Mgc3RpbGwgdGhlIHNhbWVcblx0XHQvLyA0LiB0aGlzIGxldHMgb25seSB0aGUgbGFzdCBhZGRpdGlvbiB0byB0aGUgdGltZW91dCBzdGFjayB0aHJvdWdoXG5cdFx0dGhpcy5jb3VudGVyID0gdGhpcy5jb3VudGVyID8gKyt0aGlzLmNvdW50ZXIgOiAxO1xuXHRcdHZhciBjb3VudGVyID0gdGhpcy5jb3VudGVyO1xuXG5cdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihjb3VudGVyID09IHRoaXMuY291bnRlcikgdGhpcy5yZWZyZXNoUG9zaXRpb25zKCFoYXJkUmVmcmVzaCk7IC8vUHJlY29tcHV0ZSBhZnRlciBlYWNoIERPTSBpbnNlcnRpb24sIE5PVCBvbiBtb3VzZW1vdmVcblx0XHR9KTtcblxuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24oZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcblxuXHRcdHRoaXMucmV2ZXJ0aW5nID0gZmFsc2U7XG5cdFx0Ly8gV2UgZGVsYXkgYWxsIGV2ZW50cyB0aGF0IGhhdmUgdG8gYmUgdHJpZ2dlcmVkIHRvIGFmdGVyIHRoZSBwb2ludCB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgaGFzIGJlZW4gcmVtb3ZlZCBhbmRcblx0XHQvLyBldmVyeXRoaW5nIGVsc2Ugbm9ybWFsaXplZCBhZ2FpblxuXHRcdHZhciBkZWxheWVkVHJpZ2dlcnMgPSBbXTtcblxuXHRcdC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxuXHRcdC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzIHJlYXBwZW5kZWQgKHNlZSAjNDA4OClcblx0XHRpZighdGhpcy5fbm9GaW5hbFNvcnQgJiYgdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKS5sZW5ndGgpIHRoaXMucGxhY2Vob2xkZXIuYmVmb3JlKHRoaXMuY3VycmVudEl0ZW0pO1xuXHRcdHRoaXMuX25vRmluYWxTb3J0ID0gbnVsbDtcblxuXHRcdGlmKHRoaXMuaGVscGVyWzBdID09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcblx0XHRcdGZvcih2YXIgaSBpbiB0aGlzLl9zdG9yZWRDU1MpIHtcblx0XHRcdFx0aWYodGhpcy5fc3RvcmVkQ1NTW2ldID09ICdhdXRvJyB8fCB0aGlzLl9zdG9yZWRDU1NbaV0gPT0gJ3N0YXRpYycpIHRoaXMuX3N0b3JlZENTU1tpXSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5jc3ModGhpcy5fc3RvcmVkQ1NTKS5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5mcm9tT3V0c2lkZSAmJiAhbm9Qcm9wYWdhdGlvbikgZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24oZXZlbnQpIHsgdGhpcy5fdHJpZ2dlcihcInJlY2VpdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzLmZyb21PdXRzaWRlKSk7IH0pO1xuXHRcdGlmKCh0aGlzLmZyb21PdXRzaWRlIHx8IHRoaXMuZG9tUG9zaXRpb24ucHJldiAhPSB0aGlzLmN1cnJlbnRJdGVtLnByZXYoKS5ub3QoXCIudWktc29ydGFibGUtaGVscGVyXCIpWzBdIHx8IHRoaXMuZG9tUG9zaXRpb24ucGFyZW50ICE9IHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbMF0pICYmICFub1Byb3BhZ2F0aW9uKSBkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbihldmVudCkgeyB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7IH0pOyAvL1RyaWdnZXIgdXBkYXRlIGNhbGxiYWNrIGlmIHRoZSBET00gcG9zaXRpb24gaGFzIGNoYW5nZWRcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBpdGVtcyBDb250YWluZXIgaGFzIENoYW5nZWQgYW5kIHRyaWdnZXIgYXBwcm9wcmlhdGVcblx0XHQvLyBldmVudHMuXG5cdFx0aWYgKHRoaXMgIT09IHRoaXMuY3VycmVudENvbnRhaW5lcikge1xuXHRcdFx0aWYoIW5vUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24oZXZlbnQpIHsgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpOyB9KTtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7IGMuX3RyaWdnZXIoXCJyZWNlaXZlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyB9OyAgfSkuY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIpKTtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7IGMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7ICB9OyB9KS5jYWxsKHRoaXMsIHRoaXMuY3VycmVudENvbnRhaW5lcikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly9Qb3N0IGV2ZW50cyB0byBjb250YWluZXJzXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRpZighbm9Qcm9wYWdhdGlvbikgZGVsYXllZFRyaWdnZXJzLnB1c2goKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7IGMuX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyB9OyAgfSkuY2FsbCh0aGlzLCB0aGlzLmNvbnRhaW5lcnNbaV0pKTtcblx0XHRcdGlmKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyB9OyAgfSkuY2FsbCh0aGlzLCB0aGlzLmNvbnRhaW5lcnNbaV0pKTtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vRG8gd2hhdCB3YXMgb3JpZ2luYWxseSBpbiBwbHVnaW5zXG5cdFx0aWYodGhpcy5fc3RvcmVkQ3Vyc29yKSAkKCdib2R5JykuY3NzKFwiY3Vyc29yXCIsIHRoaXMuX3N0b3JlZEN1cnNvcik7IC8vUmVzZXQgY3Vyc29yXG5cdFx0aWYodGhpcy5fc3RvcmVkT3BhY2l0eSkgdGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiLCB0aGlzLl9zdG9yZWRPcGFjaXR5KTsgLy9SZXNldCBvcGFjaXR5XG5cdFx0aWYodGhpcy5fc3RvcmVkWkluZGV4KSB0aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIiwgdGhpcy5fc3RvcmVkWkluZGV4ID09ICdhdXRvJyA/ICcnIDogdGhpcy5fc3RvcmVkWkluZGV4KTsgLy9SZXNldCB6LWluZGV4XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0aWYodGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsKSB7XG5cdFx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKFwiYmVmb3JlU3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGkgPCBkZWxheWVkVHJpZ2dlcnMubGVuZ3RoOyBpKyspIHsgZGVsYXllZFRyaWdnZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpOyB9OyAvL1RyaWdnZXIgYWxsIGRlbGF5ZWQgZXZlbnRzXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZnJvbU91dHNpZGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZighbm9Qcm9wYWdhdGlvbikgdGhpcy5fdHJpZ2dlcihcImJlZm9yZVN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblxuXHRcdC8vJCh0aGlzLnBsYWNlaG9sZGVyWzBdKS5yZW1vdmUoKTsgd291bGQgaGF2ZSBiZWVuIHRoZSBqUXVlcnkgd2F5IC0gdW5mb3J0dW5hdGVseSwgaXQgdW5iaW5kcyBBTEwgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUhXG5cdFx0dGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pO1xuXG5cdFx0aWYodGhpcy5oZWxwZXJbMF0gIT0gdGhpcy5jdXJyZW50SXRlbVswXSkgdGhpcy5oZWxwZXIucmVtb3ZlKCk7IHRoaXMuaGVscGVyID0gbnVsbDtcblxuXHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGkgPCBkZWxheWVkVHJpZ2dlcnMubGVuZ3RoOyBpKyspIHsgZGVsYXllZFRyaWdnZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpOyB9OyAvL1RyaWdnZXIgYWxsIGRlbGF5ZWQgZXZlbnRzXG5cdFx0XHR0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZnJvbU91dHNpZGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLmNhbmNlbCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdWlIYXNoOiBmdW5jdGlvbihfaW5zdCkge1xuXHRcdHZhciBpbnN0ID0gX2luc3QgfHwgdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVscGVyOiBpbnN0LmhlbHBlcixcblx0XHRcdHBsYWNlaG9sZGVyOiBpbnN0LnBsYWNlaG9sZGVyIHx8ICQoW10pLFxuXHRcdFx0cG9zaXRpb246IGluc3QucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiBpbnN0Lm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IGluc3QucG9zaXRpb25BYnMsXG5cdFx0XHRpdGVtOiBpbnN0LmN1cnJlbnRJdGVtLFxuXHRcdFx0c2VuZGVyOiBfaW5zdCA/IF9pbnN0LmVsZW1lbnQgOiBudWxsXG5cdFx0fTtcblx0fVxuXG59KTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCApIHtcblxuZnVuY3Rpb24gbW9kaWZpZXIoIGZuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0aWYgKCBwcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuJC53aWRnZXQoIFwidWkuc3Bpbm5lclwiLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGlucHV0PlwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzcGluXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjdWx0dXJlOiBudWxsLFxuXHRcdGljb25zOiB7XG5cdFx0XHRkb3duOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCIsXG5cdFx0XHR1cDogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtblwiXG5cdFx0fSxcblx0XHRpbmNyZW1lbnRhbDogdHJ1ZSxcblx0XHRtYXg6IG51bGwsXG5cdFx0bWluOiBudWxsLFxuXHRcdG51bWJlckZvcm1hdDogbnVsbCxcblx0XHRwYWdlOiAxMCxcblx0XHRzdGVwOiAxLFxuXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdHNwaW46IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIGhhbmRsZSBzdHJpbmcgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBwYXJzZWRcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwibWF4XCIsIHRoaXMub3B0aW9ucy5tYXggKTtcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwibWluXCIsIHRoaXMub3B0aW9ucy5taW4gKTtcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwic3RlcFwiLCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXG5cdFx0Ly8gZm9ybWF0IHRoZSB2YWx1ZSwgYnV0IGRvbid0IGNvbnN0cmFpblxuXHRcdHRoaXMuX3ZhbHVlKCB0aGlzLmVsZW1lbnQudmFsKCksIHRydWUgKTtcblxuXHRcdHRoaXMuX2RyYXcoKTtcblx0XHR0aGlzLl9vbiggdGhpcy5fZXZlbnRzICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXG5cdFx0Ly8gdHVybmluZyBvZmYgYXV0b2NvbXBsZXRlIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gcmVtZW1iZXJpbmcgdGhlXG5cdFx0Ly8gdmFsdWUgd2hlbiBuYXZpZ2F0aW5nIHRocm91Z2ggaGlzdG9yeSwgc28gd2UgcmUtZW5hYmxlIGF1dG9jb21wbGV0ZVxuXHRcdC8vIGlmIHRoZSBwYWdlIGlzIHVubG9hZGVkIGJlZm9yZSB0aGUgd2lkZ2V0IGlzIGRlc3Ryb3llZC4gIzc3OTBcblx0XHR0aGlzLl9vbiggdGhpcy53aW5kb3csIHtcblx0XHRcdGJlZm9yZXVubG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZVwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0ge30sXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0JC5lYWNoKCBbIFwibWluXCIsIFwibWF4XCIsIFwic3RlcFwiIF0sIGZ1bmN0aW9uKCBpLCBvcHRpb24gKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBlbGVtZW50LmF0dHIoIG9wdGlvbiApO1xuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9uc1sgb3B0aW9uIF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9LFxuXG5cdF9ldmVudHM6IHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX3N0YXJ0KCBldmVudCApICYmIHRoaXMuX2tleWRvd24oIGV2ZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRrZXl1cDogXCJfc3RvcFwiLFxuXHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucHJldmlvdXMgPSB0aGlzLmVsZW1lbnQudmFsKCk7XG5cdFx0fSxcblx0XHRibHVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRpZiAoIHRoaXMuY2FuY2VsQmx1ciApIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0XHRpZiAoIHRoaXMucHJldmlvdXMgIT09IHRoaXMuZWxlbWVudC52YWwoKSApIHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1vdXNld2hlZWw6IGZ1bmN0aW9uKCBldmVudCwgZGVsdGEgKSB7XG5cdFx0XHRpZiAoICFkZWx0YSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdGhpcy5zcGlubmluZyAmJiAhdGhpcy5fc3RhcnQoIGV2ZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3BpbiggKGRlbHRhID4gMCA/IDEgOiAtMSkgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQgKTtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5tb3VzZXdoZWVsVGltZXIgKTtcblx0XHRcdHRoaXMubW91c2V3aGVlbFRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zcGlubmluZyApIHtcblx0XHRcdFx0XHR0aGlzLl9zdG9wKCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxMDAgKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSxcblx0XHRcIm1vdXNlZG93biAudWktc3Bpbm5lci1idXR0b25cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHByZXZpb3VzO1xuXG5cdFx0XHQvLyBXZSBuZXZlciB3YW50IHRoZSBidXR0b25zIHRvIGhhdmUgZm9jdXM7IHdoZW5ldmVyIHRoZSB1c2VyIGlzXG5cdFx0XHQvLyBpbnRlcmFjdGluZyB3aXRoIHRoZSBzcGlubmVyLCB0aGUgZm9jdXMgc2hvdWxkIGJlIG9uIHRoZSBpbnB1dC5cblx0XHRcdC8vIElmIHRoZSBpbnB1dCBpcyBmb2N1c2VkIHRoZW4gdGhpcy5wcmV2aW91cyBpcyBwcm9wZXJseSBzZXQgZnJvbVxuXHRcdFx0Ly8gd2hlbiB0aGUgaW5wdXQgZmlyc3QgcmVjZWl2ZWQgZm9jdXMuIElmIHRoZSBpbnB1dCBpcyBub3QgZm9jdXNlZFxuXHRcdFx0Ly8gdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGlzLnByZXZpb3VzIGJhc2VkIG9uIHRoZSB2YWx1ZSBiZWZvcmUgc3Bpbm5pbmcuXG5cdFx0XHRwcmV2aW91cyA9IHRoaXMuZWxlbWVudFswXSA9PT0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ID9cblx0XHRcdFx0dGhpcy5wcmV2aW91cyA6IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHRcdGZ1bmN0aW9uIGNoZWNrRm9jdXMoKSB7XG5cdFx0XHRcdHZhciBpc0FjdGl2ZSA9IHRoaXMuZWxlbWVudFswXSA9PT0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50O1xuXHRcdFx0XHRpZiAoICFpc0FjdGl2ZSApIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogSUVcblx0XHRcdFx0XHQvLyBJRSBzZXRzIGZvY3VzIGFzeW5jaHJvbm91c2x5LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGZvY3VzXG5cdFx0XHRcdFx0Ly8gbW92ZWQgb2ZmIG9mIHRoZSBpbnB1dCBiZWNhdXNlIHRoZSB1c2VyIGNsaWNrZWQgb24gdGhlIGJ1dHRvbi5cblx0XHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlbnN1cmUgZm9jdXMgaXMgb24gKG9yIHN0YXlzIG9uKSB0aGUgdGV4dCBmaWVsZFxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNoZWNrRm9jdXMuY2FsbCggdGhpcyApO1xuXG5cdFx0XHQvLyBzdXBwb3J0OiBJRVxuXHRcdFx0Ly8gSUUgZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdFx0Ly8gc28gd2Ugc2V0IGEgZmxhZyB0byBrbm93IHdoZW4gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgYmx1ciBldmVudFxuXHRcdFx0Ly8gYW5kIGNoZWNrIChhZ2FpbikgaWYgZm9jdXMgbW92ZWQgb2ZmIG9mIHRoZSBpbnB1dC5cblx0XHRcdHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XG5cdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0Y2hlY2tGb2N1cy5jYWxsKCB0aGlzICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCggZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuaGFzQ2xhc3MoIFwidWktc3Bpbm5lci11cFwiICkgPyAxIDogLTEsIGV2ZW50ICk7XG5cdFx0fSxcblx0XHRcIm1vdXNldXAgLnVpLXNwaW5uZXItYnV0dG9uXCI6IFwiX3N0b3BcIixcblx0XHRcIm1vdXNlZW50ZXIgLnVpLXNwaW5uZXItYnV0dG9uXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8vIGJ1dHRvbiB3aWxsIGFkZCB1aS1zdGF0ZS1hY3RpdmUgaWYgbW91c2Ugd2FzIGRvd24gd2hpbGUgbW91c2VsZWF2ZSBhbmQga2VwdCBkb3duXG5cdFx0XHRpZiAoICEkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuX3N0YXJ0KCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuaGFzQ2xhc3MoIFwidWktc3Bpbm5lci11cFwiICkgPyAxIDogLTEsIGV2ZW50ICk7XG5cdFx0fSxcblx0XHQvLyBUT0RPOiBkbyB3ZSByZWFsbHkgd2FudCB0byBjb25zaWRlciB0aGlzIGEgc3RvcD9cblx0XHQvLyBzaG91bGRuJ3Qgd2UganVzdCBzdG9wIHRoZSByZXBlYXRlciBhbmQgd2FpdCB1bnRpbCBtb3VzZXVwIGJlZm9yZVxuXHRcdC8vIHdlIHRyaWdnZXIgdGhlIHN0b3AgZXZlbnQ/XG5cdFx0XCJtb3VzZWxlYXZlIC51aS1zcGlubmVyLWJ1dHRvblwiOiBcIl9zdG9wXCJcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVpU3Bpbm5lciA9IHRoaXMudWlTcGlubmVyID0gdGhpcy5lbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3Bpbm5lci1pbnB1dFwiIClcblx0XHRcdC5hdHRyKCBcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiIClcblx0XHRcdC53cmFwKCB0aGlzLl91aVNwaW5uZXJIdG1sKCkgKVxuXHRcdFx0LnBhcmVudCgpXG5cdFx0XHRcdC8vIGFkZCBidXR0b25zXG5cdFx0XHRcdC5hcHBlbmQoIHRoaXMuX2J1dHRvbkh0bWwoKSApO1xuXG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwicm9sZVwiLCBcInNwaW5idXR0b25cIiApO1xuXG5cdFx0Ly8gYnV0dG9uIGJpbmRpbmdzXG5cdFx0dGhpcy5idXR0b25zID0gdWlTcGlubmVyLmZpbmQoIFwiLnVpLXNwaW5uZXItYnV0dG9uXCIgKVxuXHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKVxuXHRcdFx0LmJ1dHRvbigpXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiICk7XG5cblx0XHQvLyBJRSA2IGRvZXNuJ3QgdW5kZXJzdGFuZCBoZWlnaHQ6IDUwJSBmb3IgdGhlIGJ1dHRvbnNcblx0XHQvLyB1bmxlc3MgdGhlIHdyYXBwZXIgaGFzIGFuIGV4cGxpY2l0IGhlaWdodFxuXHRcdGlmICggdGhpcy5idXR0b25zLmhlaWdodCgpID4gTWF0aC5jZWlsKCB1aVNwaW5uZXIuaGVpZ2h0KCkgKiAwLjUgKSAmJlxuXHRcdFx0XHR1aVNwaW5uZXIuaGVpZ2h0KCkgPiAwICkge1xuXHRcdFx0dWlTcGlubmVyLmhlaWdodCggdWlTcGlubmVyLmhlaWdodCgpICk7XG5cdFx0fVxuXG5cdFx0Ly8gZGlzYWJsZSBzcGlubmVyIGlmIGVsZW1lbnQgd2FzIGFscmVhZHkgZGlzYWJsZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfa2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0a2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCAxLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSBrZXlDb2RlLkRPV046XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIC0xLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIG9wdGlvbnMucGFnZSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIC1vcHRpb25zLnBhZ2UsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3VpU3Bpbm5lckh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIjxzcGFuIGNsYXNzPSd1aS1zcGlubmVyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJz48L3NwYW4+XCI7XG5cdH0sXG5cblx0X2J1dHRvbkh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIlwiICtcblx0XHRcdFwiPGEgY2xhc3M9J3VpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItdXAgdWktY29ybmVyLXRyJz5cIiArXG5cdFx0XHRcdFwiPHNwYW4gY2xhc3M9J3VpLWljb24gXCIgKyB0aGlzLm9wdGlvbnMuaWNvbnMudXAgKyBcIic+JiM5NjUwOzwvc3Bhbj5cIiArXG5cdFx0XHRcIjwvYT5cIiArXG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLWRvd24gdWktY29ybmVyLWJyJz5cIiArXG5cdFx0XHRcdFwiPHNwYW4gY2xhc3M9J3VpLWljb24gXCIgKyB0aGlzLm9wdGlvbnMuaWNvbnMuZG93biArIFwiJz4mIzk2NjA7PC9zcGFuPlwiICtcblx0XHRcdFwiPC9hPlwiO1xuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgJiYgdGhpcy5fdHJpZ2dlciggXCJzdGFydFwiLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmNvdW50ZXIgKSB7XG5cdFx0XHR0aGlzLmNvdW50ZXIgPSAxO1xuXHRcdH1cblx0XHR0aGlzLnNwaW5uaW5nID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfcmVwZWF0OiBmdW5jdGlvbiggaSwgc3RlcHMsIGV2ZW50ICkge1xuXHRcdGkgPSBpIHx8IDUwMDtcblxuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3JlcGVhdCggNDAsIHN0ZXBzLCBldmVudCApO1xuXHRcdH0sIGkgKTtcblxuXHRcdHRoaXMuX3NwaW4oIHN0ZXBzICogdGhpcy5vcHRpb25zLnN0ZXAsIGV2ZW50ICk7XG5cdH0sXG5cblx0X3NwaW46IGZ1bmN0aW9uKCBzdGVwLCBldmVudCApIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMuY291bnRlciApIHtcblx0XHRcdHRoaXMuY291bnRlciA9IDE7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSB0aGlzLl9hZGp1c3RWYWx1ZSggdmFsdWUgKyBzdGVwICogdGhpcy5faW5jcmVtZW50KCB0aGlzLmNvdW50ZXIgKSApO1xuXG5cdFx0aWYgKCAhdGhpcy5zcGlubmluZyB8fCB0aGlzLl90cmlnZ2VyKCBcInNwaW5cIiwgZXZlbnQsIHsgdmFsdWU6IHZhbHVlIH0gKSAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuX3ZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5jb3VudGVyKys7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbmNyZW1lbnQ6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBpbmNyZW1lbnRhbCA9IHRoaXMub3B0aW9ucy5pbmNyZW1lbnRhbDtcblxuXHRcdGlmICggaW5jcmVtZW50YWwgKSB7XG5cdFx0XHRyZXR1cm4gJC5pc0Z1bmN0aW9uKCBpbmNyZW1lbnRhbCApID9cblx0XHRcdFx0aW5jcmVtZW50YWwoIGkgKSA6XG5cdFx0XHRcdE1hdGguZmxvb3IoIGkqaSppLzUwMDAwIC0gaSppLzUwMCArIDE3KmkvMjAwICsgMSApO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9LFxuXG5cdF9wcmVjaXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmVjaXNpb24gPSB0aGlzLl9wcmVjaXNpb25PZiggdGhpcy5vcHRpb25zLnN0ZXAgKTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5taW4gIT09IG51bGwgKSB7XG5cdFx0XHRwcmVjaXNpb24gPSBNYXRoLm1heCggcHJlY2lzaW9uLCB0aGlzLl9wcmVjaXNpb25PZiggdGhpcy5vcHRpb25zLm1pbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBwcmVjaXNpb247XG5cdH0sXG5cblx0X3ByZWNpc2lvbk9mOiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHZhciBzdHIgPSBudW0udG9TdHJpbmcoKSxcblx0XHRcdGRlY2ltYWwgPSBzdHIuaW5kZXhPZiggXCIuXCIgKTtcblx0XHRyZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xuXHR9LFxuXG5cdF9hZGp1c3RWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBiYXNlLCBhYm92ZU1pbixcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBtYWtlIHN1cmUgd2UncmUgYXQgYSB2YWxpZCBzdGVwXG5cdFx0Ly8gLSBmaW5kIG91dCB3aGVyZSB3ZSBhcmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgKG1pbiBvciAwKVxuXHRcdGJhc2UgPSBvcHRpb25zLm1pbiAhPT0gbnVsbCA/IG9wdGlvbnMubWluIDogMDtcblx0XHRhYm92ZU1pbiA9IHZhbHVlIC0gYmFzZTtcblx0XHQvLyAtIHJvdW5kIHRvIHRoZSBuZWFyZXN0IHN0ZXBcblx0XHRhYm92ZU1pbiA9IE1hdGgucm91bmQoYWJvdmVNaW4gLyBvcHRpb25zLnN0ZXApICogb3B0aW9ucy5zdGVwO1xuXHRcdC8vIC0gcm91bmRpbmcgaXMgYmFzZWQgb24gMCwgc28gYWRqdXN0IGJhY2sgdG8gb3VyIGJhc2Vcblx0XHR2YWx1ZSA9IGJhc2UgKyBhYm92ZU1pbjtcblxuXHRcdC8vIGZpeCBwcmVjaXNpb24gZnJvbSBiYWQgSlMgZmxvYXRpbmcgcG9pbnQgbWF0aFxuXHRcdHZhbHVlID0gcGFyc2VGbG9hdCggdmFsdWUudG9GaXhlZCggdGhpcy5fcHJlY2lzaW9uKCkgKSApO1xuXG5cdFx0Ly8gY2xhbXAgdGhlIHZhbHVlXG5cdFx0aWYgKCBvcHRpb25zLm1heCAhPT0gbnVsbCAmJiB2YWx1ZSA+IG9wdGlvbnMubWF4KSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXg7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5taW4gIT09IG51bGwgJiYgdmFsdWUgPCBvcHRpb25zLm1pbiApIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cblx0X3N0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5tb3VzZXdoZWVsVGltZXIgKTtcblx0XHR0aGlzLmNvdW50ZXIgPSAwO1xuXHRcdHRoaXMuc3Bpbm5pbmcgPSBmYWxzZTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjdWx0dXJlXCIgfHwga2V5ID09PSBcIm51bWJlckZvcm1hdFwiICkge1xuXHRcdFx0dmFyIHByZXZWYWx1ZSA9IHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKTtcblx0XHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdHRoaXMuZWxlbWVudC52YWwoIHRoaXMuX2Zvcm1hdCggcHJldlZhbHVlICkgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJtYXhcIiB8fCBrZXkgPT09IFwibWluXCIgfHwga2V5ID09PSBcInN0ZXBcIiApIHtcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX3BhcnNlKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbnMuYnV0dG9uKCBcImRpc2FibGVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0XHRcdFx0dGhpcy5idXR0b25zLmJ1dHRvbiggXCJlbmFibGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogbW9kaWZpZXIoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl92YWx1ZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdH0pLFxuXG5cdF9wYXJzZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgdmFsICE9PSBcIlwiICkge1xuXHRcdFx0dmFsID0gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID9cblx0XHRcdFx0R2xvYmFsaXplLnBhcnNlRmxvYXQoIHZhbCwgMTAsIHRoaXMub3B0aW9ucy5jdWx0dXJlICkgOiArdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsID09PSBcIlwiIHx8IGlzTmFOKCB2YWwgKSA/IG51bGwgOiB2YWw7XG5cdH0sXG5cblx0X2Zvcm1hdDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/XG5cdFx0XHRHbG9iYWxpemUuZm9ybWF0KCB2YWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCwgdGhpcy5vcHRpb25zLmN1bHR1cmUgKSA6XG5cdFx0XHR2YWx1ZTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoe1xuXHRcdFx0XCJhcmlhLXZhbHVlbWluXCI6IHRoaXMub3B0aW9ucy5taW4sXG5cdFx0XHRcImFyaWEtdmFsdWVtYXhcIjogdGhpcy5vcHRpb25zLm1heCxcblx0XHRcdC8vIFRPRE86IHdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdmFsdWVzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkP1xuXHRcdFx0XCJhcmlhLXZhbHVlbm93XCI6IHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aG91dCB0cmlnZ2VyaW5nIGNoYW5nZVxuXHRfdmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSwgYWxsb3dBbnkgKSB7XG5cdFx0dmFyIHBhcnNlZDtcblx0XHRpZiAoIHZhbHVlICE9PSBcIlwiICkge1xuXHRcdFx0cGFyc2VkID0gdGhpcy5fcGFyc2UoIHZhbHVlICk7XG5cdFx0XHRpZiAoIHBhcnNlZCAhPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dBbnkgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gdGhpcy5fYWRqdXN0VmFsdWUoIHBhcnNlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZm9ybWF0KCBwYXJzZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5lbGVtZW50LnZhbCggdmFsdWUgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXNwaW5uZXItaW5wdXRcIiApXG5cdFx0XHQucHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW1pblwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtYXhcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbm93XCIgKTtcblx0XHR0aGlzLnVpU3Bpbm5lci5yZXBsYWNlV2l0aCggdGhpcy5lbGVtZW50ICk7XG5cdH0sXG5cblx0c3RlcFVwOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCBzdGVwcyApO1xuXHR9KSxcblx0X3N0ZXBVcDogZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdHRoaXMuX3NwaW4oIChzdGVwcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cdH0sXG5cblx0c3RlcERvd246IG1vZGlmaWVyKGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHR0aGlzLl9zdGVwRG93biggc3RlcHMgKTtcblx0fSksXG5cdF9zdGVwRG93bjogZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdHRoaXMuX3NwaW4oIChzdGVwcyB8fCAxKSAqIC10aGlzLm9wdGlvbnMuc3RlcCApO1xuXHR9LFxuXG5cdHBhZ2VVcDogbW9kaWZpZXIoZnVuY3Rpb24oIHBhZ2VzICkge1xuXHRcdHRoaXMuX3N0ZXBVcCggKHBhZ2VzIHx8IDEpICogdGhpcy5vcHRpb25zLnBhZ2UgKTtcblx0fSksXG5cblx0cGFnZURvd246IG1vZGlmaWVyKGZ1bmN0aW9uKCBwYWdlcyApIHtcblx0XHR0aGlzLl9zdGVwRG93biggKHBhZ2VzIHx8IDEpICogdGhpcy5vcHRpb25zLnBhZ2UgKTtcblx0fSksXG5cblx0dmFsdWU6IGZ1bmN0aW9uKCBuZXdWYWwgKSB7XG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXJzZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdFx0fVxuXHRcdG1vZGlmaWVyKCB0aGlzLl92YWx1ZSApLmNhbGwoIHRoaXMsIG5ld1ZhbCApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudWlTcGlubmVyO1xuXHR9XG59KTtcblxufSggalF1ZXJ5ICkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdGFiSWQgPSAwLFxuXHRyaGFzaCA9IC8jLiokLztcblxuZnVuY3Rpb24gZ2V0TmV4dFRhYklkKCkge1xuXHRyZXR1cm4gKyt0YWJJZDtcbn1cblxuZnVuY3Rpb24gaXNMb2NhbCggYW5jaG9yICkge1xuXHRyZXR1cm4gYW5jaG9yLmhhc2gubGVuZ3RoID4gMSAmJlxuXHRcdGFuY2hvci5ocmVmLnJlcGxhY2UoIHJoYXNoLCBcIlwiICkgPT09XG5cdFx0XHRsb2NhdGlvbi5ocmVmLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdFx0Ly8gc3VwcG9ydDogU2FmYXJpIDUuMVxuXHRcdFx0XHQvLyBTYWZhcmkgNS4xIGRvZXNuJ3QgZW5jb2RlIHNwYWNlcyBpbiB3aW5kb3cubG9jYXRpb25cblx0XHRcdFx0Ly8gYnV0IGl0IGRvZXMgZW5jb2RlIHNwYWNlcyBmcm9tIGFuY2hvcnMgKCM4Nzc3KVxuXHRcdFx0XHQucmVwbGFjZSggL1xccy9nLCBcIiUyMFwiICk7XG59XG5cbiQud2lkZ2V0KCBcInVpLnRhYnNcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdGRlbGF5OiAzMDAsXG5cdG9wdGlvbnM6IHtcblx0XHRhY3RpdmU6IG51bGwsXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVpZ2h0U3R5bGU6IFwiY29udGVudFwiLFxuXHRcdGhpZGU6IG51bGwsXG5cdFx0c2hvdzogbnVsbCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUxvYWQ6IG51bGwsXG5cdFx0bG9hZDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRhY3RpdmUgPSBvcHRpb25zLmFjdGl2ZSxcblx0XHRcdGxvY2F0aW9uSGFzaCA9IGxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKCAxICk7XG5cblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktdGFicy1jb2xsYXBzaWJsZVwiLCBvcHRpb25zLmNvbGxhcHNpYmxlIClcblx0XHRcdC8vIFByZXZlbnQgdXNlcnMgZnJvbSBmb2N1c2luZyBkaXNhYmxlZCB0YWJzIHZpYSBjbGlja1xuXHRcdFx0LmRlbGVnYXRlKCBcIi51aS10YWJzLW5hdiA+IGxpXCIsIFwibW91c2Vkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC8vIHN1cHBvcnQ6IElFIDw5XG5cdFx0XHQvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGFjdGlvbiBpbiBtb3VzZWRvd24gZG9lc24ndCBwcmV2ZW50IElFXG5cdFx0XHQvLyBmcm9tIGZvY3VzaW5nIHRoZSBlbGVtZW50LCBzbyBpZiB0aGUgYW5jaG9yIGdldHMgZm9jdXNlZCwgYmx1ci5cblx0XHRcdC8vIFdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZm9jdXNpbmcgdGhlIHByZXZpb3VzbHkgZm9jdXNlZFxuXHRcdFx0Ly8gZWxlbWVudCBzaW5jZSBjbGlja2luZyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudCBzaG91bGQgZm9jdXNcblx0XHRcdC8vIHRoZSBib2R5IGFueXdheS5cblx0XHRcdC5kZWxlZ2F0ZSggXCIudWktdGFicy1hbmNob3JcIiwgXCJmb2N1c1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmNsb3Nlc3QoIFwibGlcIiApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblxuXHRcdGlmICggYWN0aXZlID09PSBudWxsICkge1xuXHRcdFx0Ly8gY2hlY2sgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaW4gdGhlIFVSTFxuXHRcdFx0aWYgKCBsb2NhdGlvbkhhc2ggKSB7XG5cdFx0XHRcdHRoaXMudGFicy5lYWNoKGZ1bmN0aW9uKCBpLCB0YWIgKSB7XG5cdFx0XHRcdFx0aWYgKCAkKCB0YWIgKS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApID09PSBsb2NhdGlvbkhhc2ggKSB7XG5cdFx0XHRcdFx0XHRhY3RpdmUgPSBpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGZvciBhIHRhYiBtYXJrZWQgYWN0aXZlIHZpYSBhIGNsYXNzXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZmlsdGVyKCBcIi51aS10YWJzLWFjdGl2ZVwiICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm8gYWN0aXZlIHRhYiwgc2V0IHRvIGZhbHNlXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMubGVuZ3RoID8gMCA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBudW1iZXJzOiBuZWdhdGl2ZSwgb3V0IG9mIHJhbmdlXG5cdFx0aWYgKCBhY3RpdmUgIT09IGZhbHNlICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZXEoIGFjdGl2ZSApICk7XG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gLTEgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IG9wdGlvbnMuY29sbGFwc2libGUgPyBmYWxzZSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG9wdGlvbnMuYWN0aXZlID0gYWN0aXZlO1xuXG5cdFx0Ly8gZG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlXG5cdFx0aWYgKCAhb3B0aW9ucy5jb2xsYXBzaWJsZSAmJiBvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gMDtcblx0XHR9XG5cblx0XHQvLyBUYWtlIGRpc2FibGluZyB0YWJzIHZpYSBjbGFzcyBhdHRyaWJ1dGUgZnJvbSBIVE1MXG5cdFx0Ly8gaW50byBhY2NvdW50IGFuZCB1cGRhdGUgb3B0aW9uIHByb3Blcmx5LlxuXHRcdGlmICggJC5pc0FycmF5KCBvcHRpb25zLmRpc2FibGVkICkgKSB7XG5cdFx0XHRvcHRpb25zLmRpc2FibGVkID0gJC51bmlxdWUoIG9wdGlvbnMuZGlzYWJsZWQuY29uY2F0KFxuXHRcdFx0XHQkLm1hcCggdGhpcy50YWJzLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLCBmdW5jdGlvbiggbGkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXQudGFicy5pbmRleCggbGkgKTtcblx0XHRcdFx0fSlcblx0XHRcdCkgKS5zb3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgZm9yIGxlbmd0aCBhdm9pZHMgZXJyb3Igd2hlbiBpbml0aWFsaXppbmcgZW1wdHkgbGlzdFxuXHRcdGlmICggdGhpcy5vcHRpb25zLmFjdGl2ZSAhPT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggdGhpcy5vcHRpb25zLmFjdGl2ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHRpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggb3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldENyZWF0ZUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhYjogdGhpcy5hY3RpdmUsXG5cdFx0XHRwYW5lbDogIXRoaXMuYWN0aXZlLmxlbmd0aCA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApXG5cdFx0fTtcblx0fSxcblxuXHRfdGFiS2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBmb2N1c2VkVGFiID0gJCggdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICkuY2xvc2VzdCggXCJsaVwiICksXG5cdFx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy50YWJzLmluZGV4KCBmb2N1c2VkVGFiICksXG5cdFx0XHRnb2luZ0ZvcndhcmQgPSB0cnVlO1xuXG5cdFx0aWYgKCB0aGlzLl9oYW5kbGVQYWdlTmF2KCBldmVudCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdHNlbGVjdGVkSW5kZXgrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdGdvaW5nRm9yd2FyZCA9IGZhbHNlO1xuXHRcdFx0XHRzZWxlY3RlZEluZGV4LS07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0c2VsZWN0ZWRJbmRleCA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XG5cdFx0XHRcdC8vIEFjdGl2YXRlIG9ubHksIG5vIGNvbGxhcHNpbmdcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5URVI6XG5cdFx0XHRcdC8vIFRvZ2dsZSAoY2FuY2VsIGRlbGF5ZWQgYWN0aXZhdGlvbiwgYWxsb3cgY29sbGFwc2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvciBhY3RpdmF0ZVxuXHRcdFx0XHR0aGlzLl9hY3RpdmF0ZSggc2VsZWN0ZWRJbmRleCA9PT0gdGhpcy5vcHRpb25zLmFjdGl2ZSA/IGZhbHNlIDogc2VsZWN0ZWRJbmRleCApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRm9jdXMgdGhlIGFwcHJvcHJpYXRlIHRhYiwgYmFzZWQgb24gd2hpY2gga2V5IHdhcyBwcmVzc2VkXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMuYWN0aXZhdGluZyApO1xuXHRcdHNlbGVjdGVkSW5kZXggPSB0aGlzLl9mb2N1c05leHRUYWIoIHNlbGVjdGVkSW5kZXgsIGdvaW5nRm9yd2FyZCApO1xuXG5cdFx0Ly8gTmF2aWdhdGluZyB3aXRoIGNvbnRyb2wga2V5IHdpbGwgcHJldmVudCBhdXRvbWF0aWMgYWN0aXZhdGlvblxuXHRcdGlmICggIWV2ZW50LmN0cmxLZXkgKSB7XG5cdFx0XHQvLyBVcGRhdGUgYXJpYS1zZWxlY3RlZCBpbW1lZGlhdGVseSBzbyB0aGF0IEFUIHRoaW5rIHRoZSB0YWIgaXMgYWxyZWFkeSBzZWxlY3RlZC5cblx0XHRcdC8vIE90aGVyd2lzZSBBVCBtYXkgY29uZnVzZSB0aGUgdXNlciBieSBzdGF0aW5nIHRoYXQgdGhleSBuZWVkIHRvIGFjdGl2YXRlIHRoZSB0YWIsXG5cdFx0XHQvLyBidXQgdGhlIHRhYiB3aWxsIGFscmVhZHkgYmUgYWN0aXZhdGVkIGJ5IHRoZSB0aW1lIHRoZSBhbm5vdW5jZW1lbnQgZmluaXNoZXMuXG5cdFx0XHRmb2N1c2VkVGFiLmF0dHIoIFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIgKTtcblx0XHRcdHRoaXMudGFicy5lcSggc2VsZWN0ZWRJbmRleCApLmF0dHIoIFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIiApO1xuXG5cdFx0XHR0aGlzLmFjdGl2YXRpbmcgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vcHRpb24oIFwiYWN0aXZlXCIsIHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3BhbmVsS2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDdHJsK3VwIG1vdmVzIGZvY3VzIHRvIHRoZSBjdXJyZW50IHRhYlxuXHRcdGlmICggZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuVVAgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUuZm9jdXMoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQWx0K3BhZ2UgdXAvZG93biBtb3ZlcyBmb2N1cyB0byB0aGUgcHJldmlvdXMvbmV4dCB0YWIgKGFuZCBhY3RpdmF0ZXMpXG5cdF9oYW5kbGVQYWdlTmF2OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudC5hbHRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlBBR0VfVVAgKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggdGhpcy5fZm9jdXNOZXh0VGFiKCB0aGlzLm9wdGlvbnMuYWN0aXZlIC0gMSwgZmFsc2UgKSApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX0RPV04gKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggdGhpcy5fZm9jdXNOZXh0VGFiKCB0aGlzLm9wdGlvbnMuYWN0aXZlICsgMSwgdHJ1ZSApICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpbmROZXh0VGFiOiBmdW5jdGlvbiggaW5kZXgsIGdvaW5nRm9yd2FyZCApIHtcblx0XHR2YXIgbGFzdFRhYkluZGV4ID0gdGhpcy50YWJzLmxlbmd0aCAtIDE7XG5cblx0XHRmdW5jdGlvbiBjb25zdHJhaW4oKSB7XG5cdFx0XHRpZiAoIGluZGV4ID4gbGFzdFRhYkluZGV4ICkge1xuXHRcdFx0XHRpbmRleCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0aW5kZXggPSBsYXN0VGFiSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCAkLmluQXJyYXkoIGNvbnN0cmFpbigpLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRpbmRleCA9IGdvaW5nRm9yd2FyZCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH0sXG5cblx0X2ZvY3VzTmV4dFRhYjogZnVuY3Rpb24oIGluZGV4LCBnb2luZ0ZvcndhcmQgKSB7XG5cdFx0aW5kZXggPSB0aGlzLl9maW5kTmV4dFRhYiggaW5kZXgsIGdvaW5nRm9yd2FyZCApO1xuXHRcdHRoaXMudGFicy5lcSggaW5kZXggKS5mb2N1cygpO1xuXHRcdHJldHVybiBpbmRleDtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJhY3RpdmVcIiApIHtcblx0XHRcdC8vIF9hY3RpdmF0ZSgpIHdpbGwgaGFuZGxlIGludmFsaWQgdmFsdWVzIGFuZCB1cGRhdGUgdGhpcy5vcHRpb25zXG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggdmFsdWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0Ly8gZG9uJ3QgdXNlIHRoZSB3aWRnZXQgZmFjdG9yeSdzIGRpc2FibGVkIGhhbmRsaW5nXG5cdFx0XHR0aGlzLl9zZXR1cERpc2FibGVkKCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlKTtcblxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIFwidWktdGFicy1jb2xsYXBzaWJsZVwiLCB2YWx1ZSApO1xuXHRcdFx0Ly8gU2V0dGluZyBjb2xsYXBzaWJsZTogZmFsc2Ugd2hpbGUgY29sbGFwc2VkOyBvcGVuIGZpcnN0IHBhbmVsXG5cdFx0XHRpZiAoICF2YWx1ZSAmJiB0aGlzLm9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJldmVudFwiICkge1xuXHRcdFx0dGhpcy5fc2V0dXBFdmVudHMoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiaGVpZ2h0U3R5bGVcIiApIHtcblx0XHRcdHRoaXMuX3NldHVwSGVpZ2h0U3R5bGUoIHZhbHVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF90YWJJZDogZnVuY3Rpb24oIHRhYiApIHtcblx0XHRyZXR1cm4gdGFiLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgfHwgXCJ1aS10YWJzLVwiICsgZ2V0TmV4dFRhYklkKCk7XG5cdH0sXG5cblx0X3Nhbml0aXplU2VsZWN0b3I6IGZ1bmN0aW9uKCBoYXNoICkge1xuXHRcdHJldHVybiBoYXNoID8gaGFzaC5yZXBsYWNlKCAvWyFcIiQlJicoKSorLC5cXC86Ozw9Pj9AXFxbXFxdXFxeYHt8fX5dL2csIFwiXFxcXCQmXCIgKSA6IFwiXCI7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRsaXMgPSB0aGlzLnRhYmxpc3QuY2hpbGRyZW4oIFwiOmhhcyhhW2hyZWZdKVwiICk7XG5cblx0XHQvLyBnZXQgZGlzYWJsZWQgdGFicyBmcm9tIGNsYXNzIGF0dHJpYnV0ZSBmcm9tIEhUTUxcblx0XHQvLyB0aGlzIHdpbGwgZ2V0IGNvbnZlcnRlZCB0byBhIGJvb2xlYW4gaWYgbmVlZGVkIGluIF9yZWZyZXNoKClcblx0XHRvcHRpb25zLmRpc2FibGVkID0gJC5tYXAoIGxpcy5maWx0ZXIoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSwgZnVuY3Rpb24oIHRhYiApIHtcblx0XHRcdHJldHVybiBsaXMuaW5kZXgoIHRhYiApO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblxuXHRcdC8vIHdhcyBjb2xsYXBzZWQgb3Igbm8gdGFic1xuXHRcdGlmICggb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlIHx8ICF0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXHRcdC8vIHdhcyBhY3RpdmUsIGJ1dCBhY3RpdmUgdGFiIGlzIGdvbmVcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgISQuY29udGFpbnMoIHRoaXMudGFibGlzdFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHQvLyBhbGwgcmVtYWluaW5nIHRhYnMgYXJlIGRpc2FibGVkXG5cdFx0XHRpZiAoIHRoaXMudGFicy5sZW5ndGggPT09IG9wdGlvbnMuZGlzYWJsZWQubGVuZ3RoICkge1xuXHRcdFx0XHRvcHRpb25zLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHRcdC8vIGFjdGl2YXRlIHByZXZpb3VzIHRhYlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZpbmROZXh0VGFiKCBNYXRoLm1heCggMCwgb3B0aW9ucy5hY3RpdmUgLSAxICksIGZhbHNlICkgKTtcblx0XHRcdH1cblx0XHQvLyB3YXMgYWN0aXZlLCBhY3RpdmUgdGFiIHN0aWxsIGV4aXN0c1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtYWtlIHN1cmUgYWN0aXZlIGluZGV4IGlzIGNvcnJlY3Rcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLmFjdGl2ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2V0dXBEaXNhYmxlZCggdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0dGhpcy5fc2V0dXBFdmVudHMoIHRoaXMub3B0aW9ucy5ldmVudCApO1xuXHRcdHRoaXMuX3NldHVwSGVpZ2h0U3R5bGUoIHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSApO1xuXG5cdFx0dGhpcy50YWJzLm5vdCggdGhpcy5hY3RpdmUgKS5hdHRyKHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHR0YWJJbmRleDogLTFcblx0XHR9KTtcblx0XHR0aGlzLnBhbmVscy5ub3QoIHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdFx0fSk7XG5cblx0XHQvLyBNYWtlIHN1cmUgb25lIHRhYiBpcyBpbiB0aGUgdGFiIG9yZGVyXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUubGVuZ3RoICkge1xuXHRcdFx0dGhpcy50YWJzLmVxKCAwICkuYXR0ciggXCJ0YWJJbmRleFwiLCAwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYWN0aXZlXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKVxuXHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wcm9jZXNzVGFiczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy50YWJsaXN0ID0gdGhpcy5fZ2V0TGlzdCgpXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFibGlzdFwiICk7XG5cblx0XHR0aGlzLnRhYnMgPSB0aGlzLnRhYmxpc3QuZmluZCggXCI+IGxpOmhhcyhhW2hyZWZdKVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci10b3BcIiApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IFwidGFiXCIsXG5cdFx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmFuY2hvcnMgPSB0aGlzLnRhYnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggXCJhXCIsIHRoaXMgKVsgMCBdO1xuXHRcdFx0fSlcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLWFuY2hvclwiIClcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0cm9sZTogXCJwcmVzZW50YXRpb25cIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9KTtcblxuXHRcdHRoaXMucGFuZWxzID0gJCgpO1xuXG5cdFx0dGhpcy5hbmNob3JzLmVhY2goZnVuY3Rpb24oIGksIGFuY2hvciApIHtcblx0XHRcdHZhciBzZWxlY3RvciwgcGFuZWwsIHBhbmVsSWQsXG5cdFx0XHRcdGFuY2hvcklkID0gJCggYW5jaG9yICkudW5pcXVlSWQoKS5hdHRyKCBcImlkXCIgKSxcblx0XHRcdFx0dGFiID0gJCggYW5jaG9yICkuY2xvc2VzdCggXCJsaVwiICksXG5cdFx0XHRcdG9yaWdpbmFsQXJpYUNvbnRyb2xzID0gdGFiLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICk7XG5cblx0XHRcdC8vIGlubGluZSB0YWJcblx0XHRcdGlmICggaXNMb2NhbCggYW5jaG9yICkgKSB7XG5cdFx0XHRcdHNlbGVjdG9yID0gYW5jaG9yLmhhc2g7XG5cdFx0XHRcdHBhbmVsID0gdGhhdC5lbGVtZW50LmZpbmQoIHRoYXQuX3Nhbml0aXplU2VsZWN0b3IoIHNlbGVjdG9yICkgKTtcblx0XHRcdC8vIHJlbW90ZSB0YWJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhbmVsSWQgPSB0aGF0Ll90YWJJZCggdGFiICk7XG5cdFx0XHRcdHNlbGVjdG9yID0gXCIjXCIgKyBwYW5lbElkO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRpZiAoICFwYW5lbC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cGFuZWwgPSB0aGF0Ll9jcmVhdGVQYW5lbCggcGFuZWxJZCApO1xuXHRcdFx0XHRcdHBhbmVsLmluc2VydEFmdGVyKCB0aGF0LnBhbmVsc1sgaSAtIDEgXSB8fCB0aGF0LnRhYmxpc3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFuZWwubGVuZ3RoKSB7XG5cdFx0XHRcdHRoYXQucGFuZWxzID0gdGhhdC5wYW5lbHMuYWRkKCBwYW5lbCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcmlnaW5hbEFyaWFDb250cm9scyApIHtcblx0XHRcdFx0dGFiLmRhdGEoIFwidWktdGFicy1hcmlhLWNvbnRyb2xzXCIsIG9yaWdpbmFsQXJpYUNvbnRyb2xzICk7XG5cdFx0XHR9XG5cdFx0XHR0YWIuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1jb250cm9sc1wiOiBzZWxlY3Rvci5zdWJzdHJpbmcoIDEgKSxcblx0XHRcdFx0XCJhcmlhLWxhYmVsbGVkYnlcIjogYW5jaG9ySWRcblx0XHRcdH0pO1xuXHRcdFx0cGFuZWwuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgYW5jaG9ySWQgKTtcblx0XHR9KTtcblxuXHRcdHRoaXMucGFuZWxzXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYnBhbmVsXCIgKTtcblx0fSxcblxuXHQvLyBhbGxvdyBvdmVycmlkaW5nIGhvdyB0byBmaW5kIHRoZSBsaXN0IGZvciByYXJlIHVzYWdlIHNjZW5hcmlvcyAoIzc3MTUpXG5cdF9nZXRMaXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoIFwib2wsdWxcIiApLmVxKCAwICk7XG5cdH0sXG5cblx0X2NyZWF0ZVBhbmVsOiBmdW5jdGlvbiggaWQgKSB7XG5cdFx0cmV0dXJuICQoIFwiPGRpdj5cIiApXG5cdFx0XHQuYXR0ciggXCJpZFwiLCBpZCApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIgKVxuXHRcdFx0LmRhdGEoIFwidWktdGFicy1kZXN0cm95XCIsIHRydWUgKTtcblx0fSxcblxuXHRfc2V0dXBEaXNhYmxlZDogZnVuY3Rpb24oIGRpc2FibGVkICkge1xuXHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0aWYgKCAhZGlzYWJsZWQubGVuZ3RoICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggZGlzYWJsZWQubGVuZ3RoID09PSB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZGlzYWJsZSB0YWJzXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsaTsgKCBsaSA9IHRoaXMudGFic1sgaSBdICk7IGkrKyApIHtcblx0XHRcdGlmICggZGlzYWJsZWQgPT09IHRydWUgfHwgJC5pbkFycmF5KCBpLCBkaXNhYmxlZCApICE9PSAtMSApIHtcblx0XHRcdFx0JCggbGkgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiIClcblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBsaSApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuXHR9LFxuXG5cdF9zZXR1cEV2ZW50czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKCBldmVudCApIHtcblx0XHRcdCQuZWFjaCggZXZlbnQuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaW5kZXgsIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0ZXZlbnRzWyBldmVudE5hbWUgXSA9IFwiX2V2ZW50SGFuZGxlclwiO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fb2ZmKCB0aGlzLmFuY2hvcnMuYWRkKCB0aGlzLnRhYnMgKS5hZGQoIHRoaXMucGFuZWxzICkgKTtcblx0XHR0aGlzLl9vbiggdGhpcy5hbmNob3JzLCBldmVudHMgKTtcblx0XHR0aGlzLl9vbiggdGhpcy50YWJzLCB7IGtleWRvd246IFwiX3RhYktleWRvd25cIiB9ICk7XG5cdFx0dGhpcy5fb24oIHRoaXMucGFuZWxzLCB7IGtleWRvd246IFwiX3BhbmVsS2V5ZG93blwiIH0gKTtcblxuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdGhpcy50YWJzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLnRhYnMgKTtcblx0fSxcblxuXHRfc2V0dXBIZWlnaHRTdHlsZTogZnVuY3Rpb24oIGhlaWdodFN0eWxlICkge1xuXHRcdHZhciBtYXhIZWlnaHQsIG92ZXJmbG93LFxuXHRcdFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudCgpO1xuXG5cdFx0aWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJmaWxsXCIgKSB7XG5cdFx0XHQvLyBJRSA2IHRyZWF0cyBoZWlnaHQgbGlrZSBtaW5IZWlnaHQsIHNvIHdlIG5lZWQgdG8gdHVybiBvZmYgb3ZlcmZsb3dcblx0XHRcdC8vIGluIG9yZGVyIHRvIGdldCBhIHJlbGlhYmxlIGhlaWdodFxuXHRcdFx0Ly8gd2UgdXNlIHRoZSBtaW5IZWlnaHQgc3VwcG9ydCB0ZXN0IGJlY2F1c2Ugd2UgYXNzdW1lIHRoYXQgb25seVxuXHRcdFx0Ly8gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG1pbkhlaWdodCB3aWxsIHRyZWF0IGhlaWdodCBhcyBtaW5IZWlnaHRcblx0XHRcdGlmICggISQuc3VwcG9ydC5taW5IZWlnaHQgKSB7XG5cdFx0XHRcdG92ZXJmbG93ID0gcGFyZW50LmNzcyggXCJvdmVyZmxvd1wiICk7XG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIik7XG5cdFx0XHR9XG5cdFx0XHRtYXhIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwiOnZpc2libGVcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXhIZWlnaHQgLT0gZWxlbS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIG92ZXJmbG93ICkge1xuXHRcdFx0XHRwYXJlbnQuY3NzKCBcIm92ZXJmbG93XCIsIG92ZXJmbG93ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWxlbWVudC5jaGlsZHJlbigpLm5vdCggdGhpcy5wYW5lbHMgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgLT0gJCggdGhpcyApLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5wYW5lbHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmhlaWdodCggTWF0aC5tYXgoIDAsIG1heEhlaWdodCAtXG5cdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0fSlcblx0XHRcdC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIgKTtcblx0XHR9IGVsc2UgaWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHRtYXhIZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5wYW5lbHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gTWF0aC5tYXgoIG1heEhlaWdodCwgJCggdGhpcyApLmhlaWdodCggXCJcIiApLmhlaWdodCgpICk7XG5cdFx0XHR9KS5oZWlnaHQoIG1heEhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfZXZlbnRIYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRhY3RpdmUgPSB0aGlzLmFjdGl2ZSxcblx0XHRcdGFuY2hvciA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSxcblx0XHRcdHRhYiA9IGFuY2hvci5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdGNsaWNrZWRJc0FjdGl2ZSA9IHRhYlsgMCBdID09PSBhY3RpdmVbIDAgXSxcblx0XHRcdGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcblx0XHRcdHRvU2hvdyA9IGNvbGxhcHNpbmcgPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGFiICksXG5cdFx0XHR0b0hpZGUgPSAhYWN0aXZlLmxlbmd0aCA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKCBhY3RpdmUgKSxcblx0XHRcdGV2ZW50RGF0YSA9IHtcblx0XHRcdFx0b2xkVGFiOiBhY3RpdmUsXG5cdFx0XHRcdG9sZFBhbmVsOiB0b0hpZGUsXG5cdFx0XHRcdG5ld1RhYjogY29sbGFwc2luZyA/ICQoKSA6IHRhYixcblx0XHRcdFx0bmV3UGFuZWw6IHRvU2hvd1xuXHRcdFx0fTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoIHRhYi5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgfHxcblx0XHRcdFx0Ly8gdGFiIGlzIGFscmVhZHkgbG9hZGluZ1xuXHRcdFx0XHR0YWIuaGFzQ2xhc3MoIFwidWktdGFicy1sb2FkaW5nXCIgKSB8fFxuXHRcdFx0XHQvLyBjYW4ndCBzd2l0Y2ggZHVybmluZyBhbiBhbmltYXRpb25cblx0XHRcdFx0dGhpcy5ydW5uaW5nIHx8XG5cdFx0XHRcdC8vIGNsaWNrIG9uIGFjdGl2ZSBoZWFkZXIsIGJ1dCBub3QgY29sbGFwc2libGVcblx0XHRcdFx0KCBjbGlja2VkSXNBY3RpdmUgJiYgIW9wdGlvbnMuY29sbGFwc2libGUgKSB8fFxuXHRcdFx0XHQvLyBhbGxvdyBjYW5jZWxpbmcgYWN0aXZhdGlvblxuXHRcdFx0XHQoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQWN0aXZhdGVcIiwgZXZlbnQsIGV2ZW50RGF0YSApID09PSBmYWxzZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuYWN0aXZlID0gY29sbGFwc2luZyA/IGZhbHNlIDogdGhpcy50YWJzLmluZGV4KCB0YWIgKTtcblxuXHRcdHRoaXMuYWN0aXZlID0gY2xpY2tlZElzQWN0aXZlID8gJCgpIDogdGFiO1xuXHRcdGlmICggdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdGlmICggIXRvSGlkZS5sZW5ndGggJiYgIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHQkLmVycm9yKCBcImpRdWVyeSBVSSBUYWJzOiBNaXNtYXRjaGluZyBmcmFnbWVudCBpZGVudGlmaWVyLlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5sb2FkKCB0aGlzLnRhYnMuaW5kZXgoIHRhYiApLCBldmVudCApO1xuXHRcdH1cblx0XHR0aGlzLl90b2dnbGUoIGV2ZW50LCBldmVudERhdGEgKTtcblx0fSxcblxuXHQvLyBoYW5kbGVzIHNob3cvaGlkZSBmb3Igc2VsZWN0aW5nIHRhYnNcblx0X3RvZ2dsZTogZnVuY3Rpb24oIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dG9TaG93ID0gZXZlbnREYXRhLm5ld1BhbmVsLFxuXHRcdFx0dG9IaWRlID0gZXZlbnREYXRhLm9sZFBhbmVsO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0dGhhdC5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaG93KCkge1xuXHRcdFx0ZXZlbnREYXRhLm5ld1RhYi5jbG9zZXN0KCBcImxpXCIgKS5hZGRDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdGhhdC5vcHRpb25zLnNob3cgKSB7XG5cdFx0XHRcdHRoYXQuX3Nob3coIHRvU2hvdywgdGhhdC5vcHRpb25zLnNob3csIGNvbXBsZXRlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1Nob3cuc2hvdygpO1xuXHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG91dCBieSBoaWRpbmcsIHRoZW4gc2hvd2luZywgdGhlbiBjb21wbGV0aW5nXG5cdFx0aWYgKCB0b0hpZGUubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5oaWRlICkge1xuXHRcdFx0dGhpcy5faGlkZSggdG9IaWRlLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0c2hvdygpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdHRvSGlkZS5oaWRlKCk7XG5cdFx0XHRzaG93KCk7XG5cdFx0fVxuXG5cdFx0dG9IaWRlLmF0dHIoe1xuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0XHR9KTtcblx0XHRldmVudERhdGEub2xkVGFiLmF0dHIoIFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIgKTtcblx0XHQvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgdGFicywgcmVtb3ZlIHRoZSBvbGQgdGFiIGZyb20gdGhlIHRhYiBvcmRlci5cblx0XHQvLyBJZiB3ZSdyZSBvcGVuaW5nIGZyb20gY29sbGFwc2VkIHN0YXRlLCByZW1vdmUgdGhlIHByZXZpb3VzIHRhYiBmcm9tIHRoZSB0YWIgb3JkZXIuXG5cdFx0Ly8gSWYgd2UncmUgY29sbGFwc2luZywgdGhlbiBrZWVwIHRoZSBjb2xsYXBzaW5nIHRhYiBpbiB0aGUgdGFiIG9yZGVyLlxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiB0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fSBlbHNlIGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICkgPT09IDA7XG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3cuYXR0cih7XG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdH0pO1xuXHRcdGV2ZW50RGF0YS5uZXdUYWIuYXR0cih7XG5cdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHR0YWJJbmRleDogMFxuXHRcdH0pO1xuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBhbmNob3IsXG5cdFx0XHRhY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBpbmRleCApO1xuXG5cdFx0Ly8gdHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlWyAwIF0gPT09IHRoaXMuYWN0aXZlWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gdHJ5aW5nIHRvIGNvbGxhcHNlLCBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBjdXJyZW50IGFjdGl2ZSBoZWFkZXJcblx0XHRpZiAoICFhY3RpdmUubGVuZ3RoICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmU7XG5cdFx0fVxuXG5cdFx0YW5jaG9yID0gYWN0aXZlLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdO1xuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcih7XG5cdFx0XHR0YXJnZXQ6IGFuY2hvcixcblx0XHRcdGN1cnJlbnRUYXJnZXQ6IGFuY2hvcixcblx0XHRcdHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0XHR9KTtcblx0fSxcblxuXHRfZmluZEFjdGl2ZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHJldHVybiBpbmRleCA9PT0gZmFsc2UgPyAkKCkgOiB0aGlzLnRhYnMuZXEoIGluZGV4ICk7XG5cdH0sXG5cblx0X2dldEluZGV4OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0Ly8gbWV0YS1mdW5jdGlvbiB0byBnaXZlIHVzZXJzIG9wdGlvbiB0byBwcm92aWRlIGEgaHJlZiBzdHJpbmcgaW5zdGVhZCBvZiBhIG51bWVyaWNhbCBpbmRleC5cblx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGluZGV4ID0gdGhpcy5hbmNob3JzLmluZGV4KCB0aGlzLmFuY2hvcnMuZmlsdGVyKCBcIltocmVmJD0nXCIgKyBpbmRleCArIFwiJ11cIiApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS10YWJzLWNvbGxhcHNpYmxlXCIgKTtcblxuXHRcdHRoaXMudGFibGlzdFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtbmF2IHVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cblx0XHR0aGlzLmFuY2hvcnNcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWFuY2hvclwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdC5yZW1vdmVEYXRhKCBcImhyZWYudGFic1wiIClcblx0XHRcdC5yZW1vdmVEYXRhKCBcImxvYWQudGFic1wiIClcblx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpO1xuXG5cdFx0dGhpcy50YWJzLmFkZCggdGhpcy5wYW5lbHMgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAkLmRhdGEoIHRoaXMsIFwidWktdGFicy1kZXN0cm95XCIgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XHRcdFwidWktY29ybmVyLXRvcCB1aS1jb3JuZXItYm90dG9tIHVpLXdpZGdldC1jb250ZW50IHVpLXRhYnMtYWN0aXZlIHVpLXRhYnMtcGFuZWxcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1saXZlXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXNlbGVjdGVkXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWV4cGFuZGVkXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy50YWJzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGkgPSAkKCB0aGlzICksXG5cdFx0XHRcdHByZXYgPSBsaS5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiICk7XG5cdFx0XHRpZiAoIHByZXYgKSB7XG5cdFx0XHRcdGxpLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiLCBwcmV2ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaS5yZW1vdmVBdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5wYW5lbHMuc2hvdygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0dGhpcy5wYW5lbHMuY3NzKCBcImhlaWdodFwiLCBcIlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcblx0XHRpZiAoIGRpc2FibGVkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0aWYgKCAkLmlzQXJyYXkoIGRpc2FibGVkICkgKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gJC5tYXAoIGRpc2FibGVkLCBmdW5jdGlvbiggbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW0gIT09IGluZGV4ID8gbnVtIDogbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCB0aGlzLnRhYnMsIGZ1bmN0aW9uKCBsaSwgbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW0gIT09IGluZGV4ID8gbnVtIDogbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIGRpc2FibGVkICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcblx0XHRpZiAoIGRpc2FibGVkID09PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGRpc2FibGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleCggaW5kZXggKTtcblx0XHRcdGlmICggJC5pbkFycmF5KCBpbmRleCwgZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWVyZ2UoIFsgaW5kZXggXSwgZGlzYWJsZWQgKS5zb3J0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlZCA9IFsgaW5kZXggXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fc2V0dXBEaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbiggaW5kZXgsIGV2ZW50ICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFiID0gdGhpcy50YWJzLmVxKCBpbmRleCApLFxuXHRcdFx0YW5jaG9yID0gdGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKSxcblx0XHRcdHBhbmVsID0gdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHR0YWI6IHRhYixcblx0XHRcdFx0cGFuZWw6IHBhbmVsXG5cdFx0XHR9O1xuXG5cdFx0Ly8gbm90IHJlbW90ZVxuXHRcdGlmICggaXNMb2NhbCggYW5jaG9yWyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnhociA9ICQuYWpheCggdGhpcy5fYWpheFNldHRpbmdzKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSApO1xuXG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHQvLyBqUXVlcnkgPDEuOCByZXR1cm5zIGZhbHNlIGlmIHRoZSByZXF1ZXN0IGlzIGNhbmNlbGVkIGluIGJlZm9yZVNlbmQsXG5cdFx0Ly8gYnV0IGFzIG9mIDEuOCwgJC5hamF4KCkgYWx3YXlzIHJldHVybnMgYSBqcVhIUiBvYmplY3QuXG5cdFx0aWYgKCB0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcImNhbmNlbGVkXCIgKSB7XG5cdFx0XHR0YWIuYWRkQ2xhc3MoIFwidWktdGFicy1sb2FkaW5nXCIgKTtcblx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1idXN5XCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdHRoaXMueGhyXG5cdFx0XHRcdC5zdWNjZXNzKGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHBhbmVsLmh0bWwoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImxvYWRcIiwgZXZlbnQsIGV2ZW50RGF0YSApO1xuXHRcdFx0XHRcdH0sIDEgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNvbXBsZXRlKGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0XHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0XHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTE3Nzhcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5wYW5lbHMuc3RvcCggZmFsc2UsIHRydWUgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGFiLnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRcdFx0XHRwYW5lbC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiICk7XG5cblx0XHRcdFx0XHRcdGlmICgganFYSFIgPT09IHRoYXQueGhyICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdGhhdC54aHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVE9ETzogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gaW4gMS4xMCB3aGVuIGFqYXhPcHRpb25zIGlzIHJlbW92ZWRcblx0X2FqYXhTZXR0aW5nczogZnVuY3Rpb24oIGFuY2hvciwgZXZlbnQsIGV2ZW50RGF0YSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVybDogYW5jaG9yLmF0dHIoIFwiaHJlZlwiICksXG5cdFx0XHRiZWZvcmVTZW5kOiBmdW5jdGlvbigganFYSFIsIHNldHRpbmdzICkge1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5fdHJpZ2dlciggXCJiZWZvcmVMb2FkXCIsIGV2ZW50LFxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB7IGpxWEhSIDoganFYSFIsIGFqYXhTZXR0aW5nczogc2V0dGluZ3MgfSwgZXZlbnREYXRhICkgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdF9nZXRQYW5lbEZvclRhYjogZnVuY3Rpb24oIHRhYiApIHtcblx0XHR2YXIgaWQgPSAkKCB0YWIgKS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5fc2FuaXRpemVTZWxlY3RvciggXCIjXCIgKyBpZCApICk7XG5cdH1cbn0pO1xuXG4vLyBERVBSRUNBVEVEXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblxuXHQvLyBoZWxwZXIgbWV0aG9kIGZvciBhIGxvdCBvZiB0aGUgYmFjayBjb21wYXQgZXh0ZW5zaW9uc1xuXHQkLnVpLnRhYnMucHJvdG90eXBlLl91aSA9IGZ1bmN0aW9uKCB0YWIsIHBhbmVsICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0YWI6IHRhYixcblx0XHRcdHBhbmVsOiBwYW5lbCxcblx0XHRcdGluZGV4OiB0aGlzLmFuY2hvcnMuaW5kZXgoIHRhYiApXG5cdFx0fTtcblx0fTtcblxuXHQvLyB1cmwgbWV0aG9kXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0dXJsOiBmdW5jdGlvbiggaW5kZXgsIHVybCApIHtcblx0XHRcdHRoaXMuYW5jaG9ycy5lcSggaW5kZXggKS5hdHRyKCBcImhyZWZcIiwgdXJsICk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUT0RPOiBSZW1vdmUgX2FqYXhTZXR0aW5ncygpIG1ldGhvZCB3aGVuIHJlbW92aW5nIHRoaXMgZXh0ZW5zaW9uXG5cdC8vIGFqYXhPcHRpb25zIGFuZCBjYWNoZSBvcHRpb25zXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0YWpheE9wdGlvbnM6IG51bGwsXG5cdFx0XHRjYWNoZTogZmFsc2Vcblx0XHR9LFxuXG5cdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRcdHRoaXMuX29uKHsgdGFic2JlZm9yZWxvYWQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdC8vIHRhYiBpcyBhbHJlYWR5IGNhY2hlZFxuXHRcdFx0XHRpZiAoICQuZGF0YSggdWkudGFiWyAwIF0sIFwiY2FjaGUudGFic1wiICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1aS5qcVhIUi5zdWNjZXNzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhhdC5vcHRpb25zLmNhY2hlICkge1xuXHRcdFx0XHRcdFx0JC5kYXRhKCB1aS50YWJbIDAgXSwgXCJjYWNoZS50YWJzXCIsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fX0pO1xuXHRcdH0sXG5cblx0XHRfYWpheFNldHRpbmdzOiBmdW5jdGlvbiggYW5jaG9yLCBldmVudCwgdWkgKSB7XG5cdFx0XHR2YXIgYWpheE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYWpheE9wdGlvbnM7XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQoIHt9LCBhamF4T3B0aW9ucywge1xuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oIHhociwgc3RhdHVzICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQvLyBQYXNzaW5nIGluZGV4IGF2b2lkIGEgcmFjZSBjb25kaXRpb24gd2hlbiB0aGlzIG1ldGhvZCBpc1xuXHRcdFx0XHRcdFx0Ly8gY2FsbGVkIGFmdGVyIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCBhbm90aGVyIHRhYi5cblx0XHRcdFx0XHRcdC8vIFBhc3MgdGhlIGFuY2hvciB0aGF0IGluaXRpYXRlZCB0aGlzIHJlcXVlc3QgYWxsb3dzXG5cdFx0XHRcdFx0XHQvLyBsb2FkRXJyb3IgdG8gbWFuaXB1bGF0ZSB0aGUgdGFiIGNvbnRlbnQgcGFuZWwgdmlhICQoYS5oYXNoKVxuXHRcdFx0XHRcdFx0YWpheE9wdGlvbnMuZXJyb3IoXG5cdFx0XHRcdFx0XHRcdHhociwgc3RhdHVzLCB1aS50YWIuY2xvc2VzdCggXCJsaVwiICkuaW5kZXgoKSwgdWkudGFiWyAwIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKCBlcnJvciApIHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApICk7XG5cdFx0fSxcblxuXHRcdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gcmVzZXQgY2FjaGUgaWYgc3dpdGNoaW5nIGZyb20gY2FjaGVkIHRvIG5vdCBjYWNoZWRcblx0XHRcdGlmICgga2V5ID09PSBcImNhY2hlXCIgJiYgdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHR0aGlzLmFuY2hvcnMucmVtb3ZlRGF0YSggXCJjYWNoZS50YWJzXCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuYW5jaG9ycy5yZW1vdmVEYXRhKCBcImNhY2hlLnRhYnNcIiApO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0dXJsOiBmdW5jdGlvbiggaW5kZXggKXtcblx0XHRcdHRoaXMuYW5jaG9ycy5lcSggaW5kZXggKS5yZW1vdmVEYXRhKCBcImNhY2hlLnRhYnNcIiApO1xuXHRcdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBhYm9ydCBtZXRob2Rcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Ly8gc3Bpbm5lclxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHNwaW5uZXI6IFwiPGVtPkxvYWRpbmcmIzgyMzA7PC9lbT5cIlxuXHRcdH0sXG5cdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0dGhpcy5fb24oe1xuXHRcdFx0XHR0YWJzYmVmb3JlbG9hZDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0XHQvLyBEb24ndCByZWFjdCB0byBuZXN0ZWQgdGFicyBvciB0YWJzIHRoYXQgZG9uJ3QgdXNlIGEgc3Bpbm5lclxuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnRbIDAgXSB8fFxuXHRcdFx0XHRcdFx0XHQhdGhpcy5vcHRpb25zLnNwaW5uZXIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHNwYW4gPSB1aS50YWIuZmluZCggXCJzcGFuXCIgKSxcblx0XHRcdFx0XHRcdGh0bWwgPSBzcGFuLmh0bWwoKTtcblx0XHRcdFx0XHRzcGFuLmh0bWwoIHRoaXMub3B0aW9ucy5zcGlubmVyICk7XG5cdFx0XHRcdFx0dWkuanFYSFIuY29tcGxldGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzcGFuLmh0bWwoIGh0bWwgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBlbmFibGUvZGlzYWJsZSBldmVudHNcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRlbmFibGU6IG51bGwsXG5cdFx0XHRkaXNhYmxlOiBudWxsXG5cdFx0fSxcblxuXHRcdGVuYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRyaWdnZXI7XG5cblx0XHRcdGlmICggaW5kZXggJiYgb3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHRcdCggJC5pc0FycmF5KCBvcHRpb25zLmRpc2FibGVkICkgJiYgJC5pbkFycmF5KCBpbmRleCwgb3B0aW9ucy5kaXNhYmxlZCApICE9PSAtMSApICkge1xuXHRcdFx0XHR0cmlnZ2VyID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cblx0XHRcdGlmICggdHJpZ2dlciApIHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlciggXCJlbmFibGVcIiwgbnVsbCwgdGhpcy5fdWkoIHRoaXMuYW5jaG9yc1sgaW5kZXggXSwgdGhpcy5wYW5lbHNbIGluZGV4IF0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkaXNhYmxlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dHJpZ2dlcjtcblxuXHRcdFx0aWYgKCBpbmRleCAmJiBvcHRpb25zLmRpc2FibGVkID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdCggJC5pc0FycmF5KCBvcHRpb25zLmRpc2FibGVkICkgJiYgJC5pbkFycmF5KCBpbmRleCwgb3B0aW9ucy5kaXNhYmxlZCApID09PSAtMSApICkge1xuXHRcdFx0XHR0cmlnZ2VyID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cblx0XHRcdGlmICggdHJpZ2dlciApIHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlciggXCJkaXNhYmxlXCIsIG51bGwsIHRoaXMuX3VpKCB0aGlzLmFuY2hvcnNbIGluZGV4IF0sIHRoaXMucGFuZWxzWyBpbmRleCBdICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIGFkZC9yZW1vdmUgbWV0aG9kcyBhbmQgZXZlbnRzXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0YWRkOiBudWxsLFxuXHRcdFx0cmVtb3ZlOiBudWxsLFxuXHRcdFx0dGFiVGVtcGxhdGU6IFwiPGxpPjxhIGhyZWY9JyN7aHJlZn0nPjxzcGFuPiN7bGFiZWx9PC9zcGFuPjwvYT48L2xpPlwiXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oIHVybCwgbGFiZWwsIGluZGV4ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpbmRleCA9IHRoaXMuYW5jaG9ycy5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkb0luc2VydEFmdGVyLCBwYW5lbCxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0bGkgPSAkKCBvcHRpb25zLnRhYlRlbXBsYXRlXG5cdFx0XHRcdFx0LnJlcGxhY2UoIC8jXFx7aHJlZlxcfS9nLCB1cmwgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvI1xce2xhYmVsXFx9L2csIGxhYmVsICkgKSxcblx0XHRcdFx0aWQgPSAhdXJsLmluZGV4T2YoIFwiI1wiICkgP1xuXHRcdFx0XHRcdHVybC5yZXBsYWNlKCBcIiNcIiwgXCJcIiApIDpcblx0XHRcdFx0XHR0aGlzLl90YWJJZCggbGkgKTtcblxuXHRcdFx0bGkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItdG9wXCIgKS5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdFx0XHRsaS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiwgaWQgKTtcblxuXHRcdFx0ZG9JbnNlcnRBZnRlciA9IGluZGV4ID49IHRoaXMudGFicy5sZW5ndGg7XG5cblx0XHRcdC8vIHRyeSB0byBmaW5kIGFuIGV4aXN0aW5nIGVsZW1lbnQgYmVmb3JlIGNyZWF0aW5nIGEgbmV3IG9uZVxuXHRcdFx0cGFuZWwgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIjXCIgKyBpZCApO1xuXHRcdFx0aWYgKCAhcGFuZWwubGVuZ3RoICkge1xuXHRcdFx0XHRwYW5lbCA9IHRoaXMuX2NyZWF0ZVBhbmVsKCBpZCApO1xuXHRcdFx0XHRpZiAoIGRvSW5zZXJ0QWZ0ZXIgKSB7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCA+IDAgKSB7XG5cdFx0XHRcdFx0XHRwYW5lbC5pbnNlcnRBZnRlciggdGhpcy5wYW5lbHMuZXEoIC0xICkgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGFuZWwuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYW5lbC5pbnNlcnRCZWZvcmUoIHRoaXMucGFuZWxzWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhbmVsLmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiICkuaGlkZSgpO1xuXG5cdFx0XHRpZiAoIGRvSW5zZXJ0QWZ0ZXIgKSB7XG5cdFx0XHRcdGxpLmFwcGVuZFRvKCB0aGlzLnRhYmxpc3QgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpLmluc2VydEJlZm9yZSggdGhpcy50YWJzWyBpbmRleCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdG9wdGlvbnMuZGlzYWJsZWQgPSAkLm1hcCggb3B0aW9ucy5kaXNhYmxlZCwgZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdHJldHVybiBuID49IGluZGV4ID8gKytuIDogbjtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHRcdGlmICggdGhpcy50YWJzLmxlbmd0aCA9PT0gMSAmJiBvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9uKCBcImFjdGl2ZVwiLCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiYWRkXCIsIG51bGwsIHRoaXMuX3VpKCB0aGlzLmFuY2hvcnNbIGluZGV4IF0sIHRoaXMucGFuZWxzWyBpbmRleCBdICkgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dGFiID0gdGhpcy50YWJzLmVxKCBpbmRleCApLnJlbW92ZSgpLFxuXHRcdFx0XHRwYW5lbCA9IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0YWIgKS5yZW1vdmUoKTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0ZWQgdGFiIHdhcyByZW1vdmVkIGZvY3VzIHRhYiB0byB0aGUgcmlnaHQgb3Jcblx0XHRcdC8vIGluIGNhc2UgdGhlIGxhc3QgdGFiIHdhcyByZW1vdmVkIHRoZSB0YWIgdG8gdGhlIGxlZnQuXG5cdFx0XHQvLyBXZSBjaGVjayBmb3IgbW9yZSB0aGFuIDIgdGFicywgYmVjYXVzZSBpZiB0aGVyZSBhcmUgb25seSAyLFxuXHRcdFx0Ly8gdGhlbiB3aGVuIHdlIHJlbW92ZSB0aGlzIHRhYiwgdGhlcmUgd2lsbCBvbmx5IGJlIG9uZSB0YWIgbGVmdFxuXHRcdFx0Ly8gc28gd2UgZG9uJ3QgbmVlZCB0byBkZXRlY3Qgd2hpY2ggdGFiIHRvIGFjdGl2YXRlLlxuXHRcdFx0aWYgKCB0YWIuaGFzQ2xhc3MoIFwidWktdGFicy1hY3RpdmVcIiApICYmIHRoaXMuYW5jaG9ycy5sZW5ndGggPiAyICkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmF0ZSggaW5kZXggKyAoIGluZGV4ICsgMSA8IHRoaXMuYW5jaG9ycy5sZW5ndGggPyAxIDogLTEgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zLmRpc2FibGVkID0gJC5tYXAoXG5cdFx0XHRcdCQuZ3JlcCggb3B0aW9ucy5kaXNhYmxlZCwgZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG4gIT09IGluZGV4O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0ZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG4gPj0gaW5kZXggPyAtLW4gOiBuO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwicmVtb3ZlXCIsIG51bGwsIHRoaXMuX3VpKCB0YWIuZmluZCggXCJhXCIgKVsgMCBdLCBwYW5lbFsgMCBdICkgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gbGVuZ3RoIG1ldGhvZFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbmNob3JzLmxlbmd0aDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIHBhbmVsIGlkcyAoaWRQcmVmaXggb3B0aW9uICsgdGl0bGUgYXR0cmlidXRlKVxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGlkUHJlZml4OiBcInVpLXRhYnMtXCJcblx0XHR9LFxuXG5cdFx0X3RhYklkOiBmdW5jdGlvbiggdGFiICkge1xuXHRcdFx0dmFyIGEgPSB0YWIuaXMoIFwibGlcIiApID8gdGFiLmZpbmQoIFwiYVtocmVmXVwiICkgOiB0YWI7XG5cdFx0XHRhID0gYVswXTtcblx0XHRcdHJldHVybiAkKCBhICkuY2xvc2VzdCggXCJsaVwiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKSB8fFxuXHRcdFx0XHRhLnRpdGxlICYmIGEudGl0bGUucmVwbGFjZSggL1xccy9nLCBcIl9cIiApLnJlcGxhY2UoIC9bXlxcd1xcdTAwYzAtXFx1RkZGRlxcLV0vZywgXCJcIiApIHx8XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pZFByZWZpeCArIGdldE5leHRUYWJJZCgpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gX2NyZWF0ZVBhbmVsIG1ldGhvZFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHBhbmVsVGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIlxuXHRcdH0sXG5cblx0XHRfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHJldHVybiAkKCB0aGlzLm9wdGlvbnMucGFuZWxUZW1wbGF0ZSApXG5cdFx0XHRcdC5hdHRyKCBcImlkXCIsIGlkIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiIClcblx0XHRcdFx0LmRhdGEoIFwidWktdGFicy1kZXN0cm95XCIsIHRydWUgKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIHNlbGVjdGVkIG9wdGlvblxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlID09PSBudWxsICYmIG9wdGlvbnMuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBvcHRpb25zLnNlbGVjdGVkID09PSAtMSA/IGZhbHNlIDogb3B0aW9ucy5zZWxlY3RlZDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRvcHRpb25zLnNlbGVjdGVkID0gb3B0aW9ucy5hY3RpdmU7XG5cdFx0XHRpZiAoIG9wdGlvbnMuc2VsZWN0ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRvcHRpb25zLnNlbGVjdGVkID0gLTE7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0aWYgKCBrZXkgIT09IFwic2VsZWN0ZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdFx0dGhpcy5fc3VwZXIoIFwiYWN0aXZlXCIsIHZhbHVlID09PSAtMSA/IGZhbHNlIDogdmFsdWUgKTtcblx0XHRcdG9wdGlvbnMuc2VsZWN0ZWQgPSBvcHRpb25zLmFjdGl2ZTtcblx0XHRcdGlmICggb3B0aW9ucy5zZWxlY3RlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdG9wdGlvbnMuc2VsZWN0ZWQgPSAtMTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHRcdHRoaXMub3B0aW9ucy5zZWxlY3RlZCA9IHRoaXMub3B0aW9ucy5hY3RpdmU7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zZWxlY3RlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zZWxlY3RlZCA9IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Ly8gc2hvdyBhbmQgc2VsZWN0IGV2ZW50XG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0c2hvdzogbnVsbCxcblx0XHRcdHNlbGVjdDogbnVsbFxuXHRcdH0sXG5cdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuYWN0aXZlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlciggXCJzaG93XCIsIG51bGwsIHRoaXMuX3VpKFxuXHRcdFx0XHRcdHRoaXMuYWN0aXZlLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdLFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApWyAwIF0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHRcdHZhciB0YWIsIHBhbmVsLFxuXHRcdFx0XHRyZXQgPSB0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblxuXHRcdFx0aWYgKCAhcmV0ICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJiZWZvcmVBY3RpdmF0ZVwiICkge1xuXHRcdFx0XHR0YWIgPSBkYXRhLm5ld1RhYi5sZW5ndGggPyBkYXRhLm5ld1RhYiA6IGRhdGEub2xkVGFiO1xuXHRcdFx0XHRwYW5lbCA9IGRhdGEubmV3UGFuZWwubGVuZ3RoID8gZGF0YS5uZXdQYW5lbCA6IGRhdGEub2xkUGFuZWw7XG5cdFx0XHRcdHJldCA9IHRoaXMuX3N1cGVyKCBcInNlbGVjdFwiLCBldmVudCwge1xuXHRcdFx0XHRcdHRhYjogdGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMF0sXG5cdFx0XHRcdFx0cGFuZWw6IHBhbmVsWyAwIF0sXG5cdFx0XHRcdFx0aW5kZXg6IHRhYi5jbG9zZXN0KCBcImxpXCIgKS5pbmRleCgpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJhY3RpdmF0ZVwiICYmIGRhdGEubmV3VGFiLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0ID0gdGhpcy5fc3VwZXIoIFwic2hvd1wiLCBldmVudCwge1xuXHRcdFx0XHRcdHRhYjogZGF0YS5uZXdUYWIuZmluZCggXCIudWktdGFicy1hbmNob3JcIiApWyAwIF0sXG5cdFx0XHRcdFx0cGFuZWw6IGRhdGEubmV3UGFuZWxbIDAgXSxcblx0XHRcdFx0XHRpbmRleDogZGF0YS5uZXdUYWIuY2xvc2VzdCggXCJsaVwiICkuaW5kZXgoKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBzZWxlY3QgbWV0aG9kXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0c2VsZWN0OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNvbGxhcHNpYmxlICYmIHRoaXMub3B0aW9ucy5zZWxlY3RlZCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0aW5kZXggPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFuY2hvcnMuZXEoIGluZGV4ICkudHJpZ2dlciggdGhpcy5vcHRpb25zLmV2ZW50ICsgdGhpcy5ldmVudE5hbWVzcGFjZSApO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gY29va2llIG9wdGlvblxuXHQoZnVuY3Rpb24oKSB7XG5cblx0dmFyIGxpc3RJZCA9IDA7XG5cblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRjb29raWU6IG51bGwgLy8gZS5nLiB7IGV4cGlyZXM6IDcsIHBhdGg6ICcvJywgZG9tYWluOiAnanF1ZXJ5LmNvbScsIHNlY3VyZTogdHJ1ZSB9XG5cdFx0fSxcblx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRhY3RpdmU7XG5cdFx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlID09IG51bGwgJiYgb3B0aW9ucy5jb29raWUgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IHBhcnNlSW50KCB0aGlzLl9jb29raWUoKSwgMTAgKTtcblx0XHRcdFx0aWYgKCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRcdGFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnMuYWN0aXZlID0gYWN0aXZlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdF9jb29raWU6IGZ1bmN0aW9uKCBhY3RpdmUgKSB7XG5cdFx0XHR2YXIgY29va2llID0gWyB0aGlzLmNvb2tpZSB8fFxuXHRcdFx0XHQoIHRoaXMuY29va2llID0gdGhpcy5vcHRpb25zLmNvb2tpZS5uYW1lIHx8IFwidWktdGFicy1cIiArICgrK2xpc3RJZCkgKSBdO1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb29raWUucHVzaCggYWN0aXZlID09PSBmYWxzZSA/IC0xIDogYWN0aXZlICk7XG5cdFx0XHRcdGNvb2tpZS5wdXNoKCB0aGlzLm9wdGlvbnMuY29va2llICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJC5jb29raWUuYXBwbHkoIG51bGwsIGNvb2tpZSApO1xuXHRcdH0sXG5cdFx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNvb2tpZSApIHtcblx0XHRcdFx0dGhpcy5fY29va2llKCB0aGlzLm9wdGlvbnMuYWN0aXZlLCB0aGlzLm9wdGlvbnMuY29va2llICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZXZlbnRIYW5kbGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY29va2llICkge1xuXHRcdFx0XHR0aGlzLl9jb29raWUoIHRoaXMub3B0aW9ucy5hY3RpdmUsIHRoaXMub3B0aW9ucy5jb29raWUgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jb29raWUgKSB7XG5cdFx0XHRcdHRoaXMuX2Nvb2tpZSggbnVsbCwgdGhpcy5vcHRpb25zLmNvb2tpZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0fSkoKTtcblxuXHQvLyBsb2FkIGV2ZW50XG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHRcdHZhciBfZGF0YSA9ICQuZXh0ZW5kKCB7fSwgZGF0YSApO1xuXHRcdFx0aWYgKCB0eXBlID09PSBcImxvYWRcIiApIHtcblx0XHRcdFx0X2RhdGEucGFuZWwgPSBfZGF0YS5wYW5lbFsgMCBdO1xuXHRcdFx0XHRfZGF0YS50YWIgPSBfZGF0YS50YWIuZmluZCggXCIudWktdGFicy1hbmNob3JcIiApWyAwIF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoIHR5cGUsIGV2ZW50LCBfZGF0YSApO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gZnggb3B0aW9uXG5cdC8vIFRoZSBuZXcgYW5pbWF0aW9uIG9wdGlvbnMgKHNob3csIGhpZGUpIGNvbmZsaWN0IHdpdGggdGhlIG9sZCBzaG93IGNhbGxiYWNrLlxuXHQvLyBUaGUgb2xkIGZ4IG9wdGlvbiB3aW5zIG92ZXIgc2hvdy9oaWRlIGFueXdheSAoYWx3YXlzIGZhdm9yIGJhY2stY29tcGF0KS5cblx0Ly8gSWYgYSB1c2VyIHdhbnRzIHRvIHVzZSB0aGUgbmV3IGFuaW1hdGlvbiBBUEksIHRoZXkgbXVzdCBnaXZlIHVwIHRoZSBvbGQgQVBJLlxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGZ4OiBudWxsIC8vIGUuZy4geyBoZWlnaHQ6IFwidG9nZ2xlXCIsIG9wYWNpdHk6IFwidG9nZ2xlXCIsIGR1cmF0aW9uOiAyMDAgfVxuXHRcdH0sXG5cblx0XHRfZ2V0Rng6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhpZGUsIHNob3csXG5cdFx0XHRcdGZ4ID0gdGhpcy5vcHRpb25zLmZ4O1xuXG5cdFx0XHRpZiAoIGZ4ICkge1xuXHRcdFx0XHRpZiAoICQuaXNBcnJheSggZnggKSApIHtcblx0XHRcdFx0XHRoaWRlID0gZnhbIDAgXTtcblx0XHRcdFx0XHRzaG93ID0gZnhbIDEgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoaWRlID0gc2hvdyA9IGZ4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmeCA/IHsgc2hvdzogc2hvdywgaGlkZTogaGlkZSB9IDogbnVsbDtcblx0XHR9LFxuXG5cdFx0X3RvZ2dsZTogZnVuY3Rpb24oIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdHRvU2hvdyA9IGV2ZW50RGF0YS5uZXdQYW5lbCxcblx0XHRcdFx0dG9IaWRlID0gZXZlbnREYXRhLm9sZFBhbmVsLFxuXHRcdFx0XHRmeCA9IHRoaXMuX2dldEZ4KCk7XG5cblx0XHRcdGlmICggIWZ4ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5ydW5uaW5nID0gdHJ1ZTtcblxuXHRcdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7XG5cdFx0XHRcdHRoYXQucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc2hvdygpIHtcblx0XHRcdFx0ZXZlbnREYXRhLm5ld1RhYi5jbG9zZXN0KCBcImxpXCIgKS5hZGRDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0XHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiBmeC5zaG93ICkge1xuXHRcdFx0XHRcdHRvU2hvd1xuXHRcdFx0XHRcdFx0LmFuaW1hdGUoIGZ4LnNob3csIGZ4LnNob3cuZHVyYXRpb24sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG9TaG93LnNob3coKTtcblx0XHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IG91dCBieSBoaWRpbmcsIHRoZW4gc2hvd2luZywgdGhlbiBjb21wbGV0aW5nXG5cdFx0XHRpZiAoIHRvSGlkZS5sZW5ndGggJiYgZnguaGlkZSApIHtcblx0XHRcdFx0dG9IaWRlLmFuaW1hdGUoIGZ4LmhpZGUsIGZ4LmhpZGUuZHVyYXRpb24sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHRzaG93KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXZlbnREYXRhLm9sZFRhYi5jbG9zZXN0KCBcImxpXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0b0hpZGUuaGlkZSgpO1xuXHRcdFx0XHRzaG93KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxufSkoIGpRdWVyeSApO1xuKGZ1bmN0aW9uKCAkICkge1xuXG52YXIgaW5jcmVtZW50cyA9IDA7XG5cbmZ1bmN0aW9uIGFkZERlc2NyaWJlZEJ5KCBlbGVtLCBpZCApIHtcblx0dmFyIGRlc2NyaWJlZGJ5ID0gKGVsZW0uYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIgKSB8fCBcIlwiKS5zcGxpdCggL1xccysvICk7XG5cdGRlc2NyaWJlZGJ5LnB1c2goIGlkICk7XG5cdGVsZW1cblx0XHQuZGF0YSggXCJ1aS10b29sdGlwLWlkXCIsIGlkIClcblx0XHQuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsICQudHJpbSggZGVzY3JpYmVkYnkuam9pbiggXCIgXCIgKSApICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlc2NyaWJlZEJ5KCBlbGVtICkge1xuXHR2YXIgaWQgPSBlbGVtLmRhdGEoIFwidWktdG9vbHRpcC1pZFwiICksXG5cdFx0ZGVzY3JpYmVkYnkgPSAoZWxlbS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApIHx8IFwiXCIpLnNwbGl0KCAvXFxzKy8gKSxcblx0XHRpbmRleCA9ICQuaW5BcnJheSggaWQsIGRlc2NyaWJlZGJ5ICk7XG5cdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdGRlc2NyaWJlZGJ5LnNwbGljZSggaW5kZXgsIDEgKTtcblx0fVxuXG5cdGVsZW0ucmVtb3ZlRGF0YSggXCJ1aS10b29sdGlwLWlkXCIgKTtcblx0ZGVzY3JpYmVkYnkgPSAkLnRyaW0oIGRlc2NyaWJlZGJ5LmpvaW4oIFwiIFwiICkgKTtcblx0aWYgKCBkZXNjcmliZWRieSApIHtcblx0XHRlbGVtLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiLCBkZXNjcmliZWRieSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIgKTtcblx0fVxufVxuXG4kLndpZGdldCggXCJ1aS50b29sdGlwXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApLmF0dHIoIFwidGl0bGVcIiApO1xuXHRcdH0sXG5cdFx0aGlkZTogdHJ1ZSxcblx0XHQvLyBEaXNhYmxlZCBlbGVtZW50cyBoYXZlIGluY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMgKCM4NjYxKVxuXHRcdGl0ZW1zOiBcIlt0aXRsZV06bm90KFtkaXNhYmxlZF0pXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wKzE1XCIsXG5cdFx0XHRhdDogXCJsZWZ0IGJvdHRvbVwiLFxuXHRcdFx0Y29sbGlzaW9uOiBcImZsaXBmaXQgZmxpcFwiXG5cdFx0fSxcblx0XHRzaG93OiB0cnVlLFxuXHRcdHRvb2x0aXBDbGFzczogbnVsbCxcblx0XHR0cmFjazogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjbG9zZTogbnVsbCxcblx0XHRvcGVuOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fb24oe1xuXHRcdFx0bW91c2VvdmVyOiBcIm9wZW5cIixcblx0XHRcdGZvY3VzaW46IFwib3BlblwiXG5cdFx0fSk7XG5cblx0XHQvLyBJRHMgb2YgZ2VuZXJhdGVkIHRvb2x0aXBzLCBuZWVkZWQgZm9yIGRlc3Ryb3lcblx0XHR0aGlzLnRvb2x0aXBzID0ge307XG5cdFx0Ly8gSURzIG9mIHBhcmVudCB0b29sdGlwcyB3aGVyZSB3ZSByZW1vdmVkIHRoZSB0aXRsZSBhdHRyaWJ1dGVcblx0XHR0aGlzLnBhcmVudHMgPSB7fTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpc1sgdmFsdWUgPyBcIl9kaXNhYmxlXCIgOiBcIl9lbmFibGVcIiBdKCk7XG5cdFx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHQvLyBkaXNhYmxlIGVsZW1lbnQgc3R5bGUgY2hhbmdlc1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHQkLmVhY2goIHRoaXMudG9vbHRpcHMsIGZ1bmN0aW9uKCBpZCwgZWxlbWVudCApIHtcblx0XHRcdFx0dGhhdC5fdXBkYXRlQ29udGVudCggZWxlbWVudCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHQvLyBjbG9zZSBvcGVuIHRvb2x0aXBzXG5cdFx0JC5lYWNoKCB0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiggaWQsIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnRbMF07XG5cdFx0XHR0aGF0LmNsb3NlKCBldmVudCwgdHJ1ZSApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcmVtb3ZlIHRpdGxlIGF0dHJpYnV0ZXMgdG8gcHJldmVudCBuYXRpdmUgdG9vbHRpcHNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zICkuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9ICQoIHRoaXMgKTtcblx0XHRcdGlmICggZWxlbWVudC5pcyggXCJbdGl0bGVdXCIgKSApIHtcblx0XHRcdFx0ZWxlbWVudFxuXHRcdFx0XHRcdC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiwgZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKSApXG5cdFx0XHRcdFx0LmF0dHIoIFwidGl0bGVcIiwgXCJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9lbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHJlc3RvcmUgdGl0bGUgYXR0cmlidXRlc1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaXRlbXMgKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gJCggdGhpcyApO1xuXHRcdFx0aWYgKCBlbGVtZW50LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICkgKSB7XG5cdFx0XHRcdGVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiLCBlbGVtZW50LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRvcGVuOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFyZ2V0ID0gJCggZXZlbnQgPyBldmVudC50YXJnZXQgOiB0aGlzLmVsZW1lbnQgKVxuXHRcdFx0XHQvLyB3ZSBuZWVkIGNsb3Nlc3QgaGVyZSBkdWUgdG8gbW91c2VvdmVyIGJ1YmJsaW5nLFxuXHRcdFx0XHQvLyBidXQgYWx3YXlzIHBvaW50aW5nIGF0IHRoZSBzYW1lIGV2ZW50IHRhcmdldFxuXHRcdFx0XHQuY2xvc2VzdCggdGhpcy5vcHRpb25zLml0ZW1zICk7XG5cblx0XHQvLyBObyBlbGVtZW50IHRvIHNob3cgYSB0b29sdGlwIGZvciBvciB0aGUgdG9vbHRpcCBpcyBhbHJlYWR5IG9wZW5cblx0XHRpZiAoICF0YXJnZXQubGVuZ3RoIHx8IHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtaWRcIiApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGFyZ2V0LmF0dHIoIFwidGl0bGVcIiApICkge1xuXHRcdFx0dGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiLCB0YXJnZXQuYXR0ciggXCJ0aXRsZVwiICkgKTtcblx0XHR9XG5cblx0XHR0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLW9wZW5cIiwgdHJ1ZSApO1xuXG5cdFx0Ly8ga2lsbCBwYXJlbnQgdG9vbHRpcHMsIGN1c3RvbSBvciBuYXRpdmUsIGZvciBob3ZlclxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJtb3VzZW92ZXJcIiApIHtcblx0XHRcdHRhcmdldC5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRibHVyRXZlbnQ7XG5cdFx0XHRcdGlmICggcGFyZW50LmRhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKSApIHtcblx0XHRcdFx0XHRibHVyRXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0XHRcdGJsdXJFdmVudC50YXJnZXQgPSBibHVyRXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0XHRcdFx0dGhhdC5jbG9zZSggYmx1ckV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwYXJlbnQuYXR0ciggXCJ0aXRsZVwiICkgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnVuaXF1ZUlkKCk7XG5cdFx0XHRcdFx0dGhhdC5wYXJlbnRzWyB0aGlzLmlkIF0gPSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLFxuXHRcdFx0XHRcdFx0dGl0bGU6IHBhcmVudC5hdHRyKCBcInRpdGxlXCIgKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cGFyZW50LmF0dHIoIFwidGl0bGVcIiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCB0YXJnZXQsIGV2ZW50ICk7XG5cdH0sXG5cblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKCB0YXJnZXQsIGV2ZW50ICkge1xuXHRcdHZhciBjb250ZW50LFxuXHRcdFx0Y29udGVudE9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50LFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRldmVudFR5cGUgPSBldmVudCA/IGV2ZW50LnR5cGUgOiBudWxsO1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGVudE9wdGlvbiA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCBjb250ZW50T3B0aW9uICk7XG5cdFx0fVxuXG5cdFx0Y29udGVudCA9IGNvbnRlbnRPcHRpb24uY2FsbCggdGFyZ2V0WzBdLCBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHQvLyBpZ25vcmUgYXN5bmMgcmVzcG9uc2UgaWYgdG9vbHRpcCB3YXMgY2xvc2VkIGFscmVhZHlcblx0XHRcdGlmICggIXRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtb3BlblwiICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElFIG1heSBpbnN0YW50bHkgc2VydmUgYSBjYWNoZWQgcmVzcG9uc2UgZm9yIGFqYXggcmVxdWVzdHNcblx0XHRcdC8vIGRlbGF5IHRoaXMgY2FsbCB0byBfb3BlbiBzbyB0aGUgb3RoZXIgY2FsbCB0byBfb3BlbiBydW5zIGZpcnN0XG5cdFx0XHR0aGF0Ll9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8galF1ZXJ5IGNyZWF0ZXMgYSBzcGVjaWFsIGV2ZW50IGZvciBmb2N1c2luIHdoZW4gaXQgZG9lc24ndFxuXHRcdFx0XHQvLyBleGlzdCBuYXRpdmVseS4gVG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHQvLyBvYmplY3QgaXMgcmV1c2VkIGFuZCB0aGUgdHlwZSBpcyBjaGFuZ2VkLiBUaGVyZWZvcmUsIHdlIGNhbid0XG5cdFx0XHRcdC8vIHJlbHkgb24gdGhlIHR5cGUgYmVpbmcgY29ycmVjdCBhZnRlciB0aGUgZXZlbnQgZmluaXNoZWRcblx0XHRcdFx0Ly8gYnViYmxpbmcsIHNvIHdlIHNldCBpdCBiYWNrIHRvIHRoZSBwcmV2aW91cyB2YWx1ZS4gKCM4NzQwKVxuXHRcdFx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50LnR5cGUgPSBldmVudFR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fb3BlbiggZXZlbnQsIHRhcmdldCwgcmVzcG9uc2UgKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGlmICggY29udGVudCApIHtcblx0XHRcdHRoaXMuX29wZW4oIGV2ZW50LCB0YXJnZXQsIGNvbnRlbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0X29wZW46IGZ1bmN0aW9uKCBldmVudCwgdGFyZ2V0LCBjb250ZW50ICkge1xuXHRcdHZhciB0b29sdGlwLCBldmVudHMsIGRlbGF5ZWRTaG93LFxuXHRcdFx0cG9zaXRpb25PcHRpb24gPSAkLmV4dGVuZCgge30sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApO1xuXG5cdFx0aWYgKCAhY29udGVudCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDb250ZW50IGNhbiBiZSB1cGRhdGVkIG11bHRpcGxlIHRpbWVzLiBJZiB0aGUgdG9vbHRpcCBhbHJlYWR5XG5cdFx0Ly8gZXhpc3RzLCB0aGVuIGp1c3QgdXBkYXRlIHRoZSBjb250ZW50IGFuZCBiYWlsLlxuXHRcdHRvb2x0aXAgPSB0aGlzLl9maW5kKCB0YXJnZXQgKTtcblx0XHRpZiAoIHRvb2x0aXAubGVuZ3RoICkge1xuXHRcdFx0dG9vbHRpcC5maW5kKCBcIi51aS10b29sdGlwLWNvbnRlbnRcIiApLmh0bWwoIGNvbnRlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSBoYXZlIGEgdGl0bGUsIGNsZWFyIGl0IHRvIHByZXZlbnQgdGhlIG5hdGl2ZSB0b29sdGlwXG5cdFx0Ly8gd2UgaGF2ZSB0byBjaGVjayBmaXJzdCB0byBhdm9pZCBkZWZpbmluZyBhIHRpdGxlIGlmIG5vbmUgZXhpc3RzXG5cdFx0Ly8gKHdlIGRvbid0IHdhbnQgdG8gY2F1c2UgYW4gZWxlbWVudCB0byBzdGFydCBtYXRjaGluZyBbdGl0bGVdKVxuXHRcdC8vXG5cdFx0Ly8gV2UgdXNlIHJlbW92ZUF0dHIgb25seSBmb3Iga2V5IGV2ZW50cywgdG8gYWxsb3cgSUUgdG8gZXhwb3J0IHRoZSBjb3JyZWN0XG5cdFx0Ly8gYWNjZXNzaWJsZSBhdHRyaWJ1dGVzLiBGb3IgbW91c2UgZXZlbnRzLCBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkXG5cdFx0Ly8gbmF0aXZlIHRvb2x0aXAgc2hvd2luZyB1cCAoaGFwcGVucyBvbmx5IHdoZW4gcmVtb3ZpbmcgaW5zaWRlIG1vdXNlb3ZlcikuXG5cdFx0aWYgKCB0YXJnZXQuaXMoIFwiW3RpdGxlXVwiICkgKSB7XG5cdFx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCIgKSB7XG5cdFx0XHRcdHRhcmdldC5hdHRyKCBcInRpdGxlXCIsIFwiXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldC5yZW1vdmVBdHRyKCBcInRpdGxlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b29sdGlwID0gdGhpcy5fdG9vbHRpcCggdGFyZ2V0ICk7XG5cdFx0YWRkRGVzY3JpYmVkQnkoIHRhcmdldCwgdG9vbHRpcC5hdHRyKCBcImlkXCIgKSApO1xuXHRcdHRvb2x0aXAuZmluZCggXCIudWktdG9vbHRpcC1jb250ZW50XCIgKS5odG1sKCBjb250ZW50ICk7XG5cblx0XHRmdW5jdGlvbiBwb3NpdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRwb3NpdGlvbk9wdGlvbi5vZiA9IGV2ZW50O1xuXHRcdFx0aWYgKCB0b29sdGlwLmlzKCBcIjpoaWRkZW5cIiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0b29sdGlwLnBvc2l0aW9uKCBwb3NpdGlvbk9wdGlvbiApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3B0aW9ucy50cmFjayAmJiBldmVudCAmJiAvXm1vdXNlLy50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHR0aGlzLl9vbiggdGhpcy5kb2N1bWVudCwge1xuXHRcdFx0XHRtb3VzZW1vdmU6IHBvc2l0aW9uXG5cdFx0XHR9KTtcblx0XHRcdC8vIHRyaWdnZXIgb25jZSB0byBvdmVycmlkZSBlbGVtZW50LXJlbGF0aXZlIHBvc2l0aW9uaW5nXG5cdFx0XHRwb3NpdGlvbiggZXZlbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9vbHRpcC5wb3NpdGlvbiggJC5leHRlbmQoe1xuXHRcdFx0XHRvZjogdGFyZ2V0XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKSApO1xuXHRcdH1cblxuXHRcdHRvb2x0aXAuaGlkZSgpO1xuXG5cdFx0dGhpcy5fc2hvdyggdG9vbHRpcCwgdGhpcy5vcHRpb25zLnNob3cgKTtcblx0XHQvLyBIYW5kbGUgdHJhY2tpbmcgdG9vbHRpcHMgdGhhdCBhcmUgc2hvd24gd2l0aCBhIGRlbGF5ICgjODY0NCkuIEFzIHNvb25cblx0XHQvLyBhcyB0aGUgdG9vbHRpcCBpcyB2aXNpYmxlLCBwb3NpdGlvbiB0aGUgdG9vbHRpcCB1c2luZyB0aGUgbW9zdCByZWNlbnRcblx0XHQvLyBldmVudC5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaG93ICYmIHRoaXMub3B0aW9ucy5zaG93LmRlbGF5ICkge1xuXHRcdFx0ZGVsYXllZFNob3cgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0b29sdGlwLmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiggcG9zaXRpb25PcHRpb24ub2YgKTtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKCBkZWxheWVkU2hvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAkLmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJvcGVuXCIsIGV2ZW50LCB7IHRvb2x0aXA6IHRvb2x0aXAgfSApO1xuXG5cdFx0ZXZlbnRzID0ge1xuXHRcdFx0a2V5dXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFICkge1xuXHRcdFx0XHRcdHZhciBmYWtlRXZlbnQgPSAkLkV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRmYWtlRXZlbnQuY3VycmVudFRhcmdldCA9IHRhcmdldFswXTtcblx0XHRcdFx0XHR0aGlzLmNsb3NlKCBmYWtlRXZlbnQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRvb2x0aXAoIHRvb2x0aXAgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmICggIWV2ZW50IHx8IGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCIgKSB7XG5cdFx0XHRldmVudHMubW91c2VsZWF2ZSA9IFwiY2xvc2VcIjtcblx0XHR9XG5cdFx0aWYgKCAhZXZlbnQgfHwgZXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCIgKSB7XG5cdFx0XHRldmVudHMuZm9jdXNvdXQgPSBcImNsb3NlXCI7XG5cdFx0fVxuXHRcdHRoaXMuX29uKCB0cnVlLCB0YXJnZXQsIGV2ZW50cyApO1xuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFyZ2V0ID0gJCggZXZlbnQgPyBldmVudC5jdXJyZW50VGFyZ2V0IDogdGhpcy5lbGVtZW50ICksXG5cdFx0XHR0b29sdGlwID0gdGhpcy5fZmluZCggdGFyZ2V0ICk7XG5cblx0XHQvLyBkaXNhYmxpbmcgY2xvc2VzIHRoZSB0b29sdGlwLCBzbyB3ZSBuZWVkIHRvIHRyYWNrIHdoZW4gd2UncmUgY2xvc2luZ1xuXHRcdC8vIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgaW4gY2FzZSB0aGUgdG9vbHRpcCBiZWNvbWVzIGRpc2FibGVkIG9uIGNsb3NlXG5cdFx0aWYgKCB0aGlzLmNsb3NpbmcgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gb25seSBzZXQgdGl0bGUgaWYgd2UgaGFkIG9uZSBiZWZvcmUgKHNlZSBjb21tZW50IGluIF9vcGVuKCkpXG5cdFx0aWYgKCB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApIHtcblx0XHRcdHRhcmdldC5hdHRyKCBcInRpdGxlXCIsIHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRGVzY3JpYmVkQnkoIHRhcmdldCApO1xuXG5cdFx0dG9vbHRpcC5zdG9wKCB0cnVlICk7XG5cdFx0dGhpcy5faGlkZSggdG9vbHRpcCwgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fcmVtb3ZlVG9vbHRpcCggJCggdGhpcyApICk7XG5cdFx0fSk7XG5cblx0XHR0YXJnZXQucmVtb3ZlRGF0YSggXCJ1aS10b29sdGlwLW9wZW5cIiApO1xuXHRcdHRoaXMuX29mZiggdGFyZ2V0LCBcIm1vdXNlbGVhdmUgZm9jdXNvdXQga2V5dXBcIiApO1xuXHRcdC8vIFJlbW92ZSAncmVtb3ZlJyBiaW5kaW5nIG9ubHkgb24gZGVsZWdhdGVkIHRhcmdldHNcblx0XHRpZiAoIHRhcmdldFswXSAhPT0gdGhpcy5lbGVtZW50WzBdICkge1xuXHRcdFx0dGhpcy5fb2ZmKCB0YXJnZXQsIFwicmVtb3ZlXCIgKTtcblx0XHR9XG5cdFx0dGhpcy5fb2ZmKCB0aGlzLmRvY3VtZW50LCBcIm1vdXNlbW92ZVwiICk7XG5cblx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwibW91c2VsZWF2ZVwiICkge1xuXHRcdFx0JC5lYWNoKCB0aGlzLnBhcmVudHMsIGZ1bmN0aW9uKCBpZCwgcGFyZW50ICkge1xuXHRcdFx0XHQkKCBwYXJlbnQuZWxlbWVudCApLmF0dHIoIFwidGl0bGVcIiwgcGFyZW50LnRpdGxlICk7XG5cdFx0XHRcdGRlbGV0ZSB0aGF0LnBhcmVudHNbIGlkIF07XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmNsb3NpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQsIHsgdG9vbHRpcDogdG9vbHRpcCB9ICk7XG5cdFx0dGhpcy5jbG9zaW5nID0gZmFsc2U7XG5cdH0sXG5cblx0X3Rvb2x0aXA6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBpZCA9IFwidWktdG9vbHRpcC1cIiArIGluY3JlbWVudHMrKyxcblx0XHRcdHRvb2x0aXAgPSAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0aWQ6IGlkLFxuXHRcdFx0XHRcdHJvbGU6IFwidG9vbHRpcFwiXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS10b29sdGlwIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLXdpZGdldC1jb250ZW50IFwiICtcblx0XHRcdFx0XHQoIHRoaXMub3B0aW9ucy50b29sdGlwQ2xhc3MgfHwgXCJcIiApICk7XG5cdFx0JCggXCI8ZGl2PlwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10b29sdGlwLWNvbnRlbnRcIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRvb2x0aXAgKTtcblx0XHR0b29sdGlwLmFwcGVuZFRvKCB0aGlzLmRvY3VtZW50WzBdLmJvZHkgKTtcblx0XHRpZiAoICQuZm4uYmdpZnJhbWUgKSB7XG5cdFx0XHR0b29sdGlwLmJnaWZyYW1lKCk7XG5cdFx0fVxuXHRcdHRoaXMudG9vbHRpcHNbIGlkIF0gPSBlbGVtZW50O1xuXHRcdHJldHVybiB0b29sdGlwO1xuXHR9LFxuXG5cdF9maW5kOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBpZCA9IHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtaWRcIiApO1xuXHRcdHJldHVybiBpZCA/ICQoIFwiI1wiICsgaWQgKSA6ICQoKTtcblx0fSxcblxuXHRfcmVtb3ZlVG9vbHRpcDogZnVuY3Rpb24oIHRvb2x0aXAgKSB7XG5cdFx0dG9vbHRpcC5yZW1vdmUoKTtcblx0XHRkZWxldGUgdGhpcy50b29sdGlwc1sgdG9vbHRpcC5hdHRyKCBcImlkXCIgKSBdO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHQvLyBjbG9zZSBvcGVuIHRvb2x0aXBzXG5cdFx0JC5lYWNoKCB0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiggaWQsIGVsZW1lbnQgKSB7XG5cdFx0XHQvLyBEZWxlZ2F0ZSB0byBjbG9zZSBtZXRob2QgdG8gaGFuZGxlIGNvbW1vbiBjbGVhbnVwXG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnRbMF07XG5cdFx0XHR0aGF0LmNsb3NlKCBldmVudCwgdHJ1ZSApO1xuXG5cdFx0XHQvLyBSZW1vdmUgaW1tZWRpYXRlbHk7IGRlc3Ryb3lpbmcgYW4gb3BlbiB0b29sdGlwIGRvZXNuJ3QgdXNlIHRoZVxuXHRcdFx0Ly8gaGlkZSBhbmltYXRpb25cblx0XHRcdCQoIFwiI1wiICsgaWQgKS5yZW1vdmUoKTtcblxuXHRcdFx0Ly8gUmVzdG9yZSB0aGUgdGl0bGVcblx0XHRcdGlmICggZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICk7XG5cdFx0XHRcdGVsZW1lbnQucmVtb3ZlRGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApICk7XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuNy4yXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgSm9obiBSZXNpZ1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICogQ29weXJpZ2h0IDIwMTEsIFRoZSBEb2pvIEZvdW5kYXRpb25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQsIEJTRCwgYW5kIEdQTCBMaWNlbnNlcy5cbiAqXG4gKiBEYXRlOiBXZWQgTWFyIDIxIDEyOjQ2OjM0IDIwMTIgLTA3MDBcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuLy8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXHRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbnZhciBqUXVlcnkgPSAoZnVuY3Rpb24oKSB7XG5cbi8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG52YXIgalF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5ICk7XG5cdH0sXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQsXG5cblx0Ly8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG5cdHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Mgb3IgSUQgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdHF1aWNrRXhwciA9IC9eKD86W14jPF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKikkKS8sXG5cblx0Ly8gQ2hlY2sgaWYgYSBzdHJpbmcgaGFzIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGl0XG5cdHJub3R3aGl0ZSA9IC9cXFMvLFxuXG5cdC8vIFVzZWQgZm9yIHRyaW1taW5nIHdoaXRlc3BhY2Vcblx0dHJpbUxlZnQgPSAvXlxccysvLFxuXHR0cmltUmlnaHQgPSAvXFxzKyQvLFxuXG5cdC8vIE1hdGNoIGEgc3RhbmRhbG9uZSB0YWdcblx0cnNpbmdsZVRhZyA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+KT8kLyxcblxuXHQvLyBKU09OIFJlZ0V4cFxuXHRydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvLFxuXHRydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLFxuXHRydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXG5cdHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcblxuXHQvLyBVc2VyYWdlbnQgUmVnRXhwXG5cdHJ3ZWJraXQgPSAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLFxuXHRyb3BlcmEgPSAvKG9wZXJhKSg/Oi4qdmVyc2lvbik/WyBcXC9dKFtcXHcuXSspLyxcblx0cm1zaWUgPSAvKG1zaWUpIChbXFx3Ll0rKS8sXG5cdHJtb3ppbGxhID0gLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKykpPy8sXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XXxbMC05XSkvaWcsXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiAoIGxldHRlciArIFwiXCIgKS50b1VwcGVyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIEtlZXAgYSBVc2VyQWdlbnQgc3RyaW5nIGZvciB1c2Ugd2l0aCBqUXVlcnkuYnJvd3NlclxuXHR1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXG5cdC8vIEZvciBtYXRjaGluZyB0aGUgZW5naW5lIGFuZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyXG5cdGJyb3dzZXJNYXRjaCxcblxuXHQvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcblx0cmVhZHlMaXN0LFxuXG5cdC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyXG5cdERPTUNvbnRlbnRMb2FkZWQsXG5cblx0Ly8gU2F2ZSBhIHJlZmVyZW5jZSB0byBzb21lIGNvcmUgbWV0aG9kc1xuXHR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG5cdHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaCxcblx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdHRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cdGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZixcblxuXHQvLyBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuXHRjbGFzczJ0eXBlID0ge307XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cdGluaXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW0sIHJldCwgZG9jO1xuXG5cdFx0Ly8gSGFuZGxlICQoXCJcIiksICQobnVsbCksIG9yICQodW5kZWZpbmVkKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlICQoRE9NRWxlbWVudClcblx0XHRpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGJvZHkgZWxlbWVudCBvbmx5IGV4aXN0cyBvbmNlLCBvcHRpbWl6ZSBmaW5kaW5nIGl0XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gXCJib2R5XCIgJiYgIWNvbnRleHQgJiYgZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0dGhpc1swXSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHQvLyBBcmUgd2UgZGVhbGluZyB3aXRoIEhUTUwgc3RyaW5nIG9yIGFuIElEP1xuXHRcdFx0aWYgKCBzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiPFwiICYmIHNlbGVjdG9yLmNoYXJBdCggc2VsZWN0b3IubGVuZ3RoIC0gMSApID09PSBcIj5cIiAmJiBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFZlcmlmeSBhIG1hdGNoLCBhbmQgdGhhdCBubyBjb250ZXh0IHdhcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cdFx0XHRcdFx0ZG9jID0gKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBzaW5nbGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgaXQncyBhIHNpbmdsZSB0YWdcblx0XHRcdFx0XHQvLyBqdXN0IGRvIGEgY3JlYXRlRWxlbWVudCBhbmQgc2tpcCB0aGUgcmVzdFxuXHRcdFx0XHRcdHJldCA9IHJzaW5nbGVUYWcuZXhlYyggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9IFsgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggcmV0WzFdICkgXTtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZuLmF0dHIuY2FsbCggc2VsZWN0b3IsIGNvbnRleHQsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBbIGRvYy5jcmVhdGVFbGVtZW50KCByZXRbMV0gKSBdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIG1hdGNoWzFdIF0sIFsgZG9jIF0gKTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gKCByZXQuY2FjaGVhYmxlID8galF1ZXJ5LmNsb25lKHJldC5mcmFnbWVudCkgOiByZXQuZnJhZ21lbnQgKS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIHRoaXMsIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKFwiI2lkXCIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByb290alF1ZXJ5LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IFwiMS43LjJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdC8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcywgMCApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gPT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBhICdjbGVhbicgYXJyYXlcblx0XHRcdHRoaXMudG9BcnJheSgpIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9iamVjdFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgdGhpcy5sZW5ndGggKyBudW0gXSA6IHRoaXNbIG51bSBdICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMsIG5hbWUsIHNlbGVjdG9yICkge1xuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IHRoaXMuY29uc3RydWN0b3IoKTtcblxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGVsZW1zICkgKSB7XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsIGVsZW1zICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdGlmICggbmFtZSA9PT0gXCJmaW5kXCIgKSB7XG5cdFx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgKCB0aGlzLnNlbGVjdG9yID8gXCIgXCIgOiBcIlwiICkgKyBzZWxlY3Rvcjtcblx0XHR9IGVsc2UgaWYgKCBuYW1lICkge1xuXHRcdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArIFwiLlwiICsgbmFtZSArIFwiKFwiICsgc2VsZWN0b3IgKyBcIilcIjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdHJlYWR5OiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0Ly8gQXR0YWNoIHRoZSBsaXN0ZW5lcnNcblx0XHRqUXVlcnkuYmluZFJlYWR5KCk7XG5cblx0XHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdFx0cmVhZHlMaXN0LmFkZCggZm4gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHRpID0gK2k7XG5cdFx0cmV0dXJuIGkgPT09IC0xID9cblx0XHRcdHRoaXMuc2xpY2UoIGkgKSA6XG5cdFx0XHR0aGlzLnNsaWNlKCBpLCBpICsgMSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcblx0XHRcdFwic2xpY2VcIiwgc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIsXCIpICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogW10uc29ydCxcblx0c3BsaWNlOiBbXS5zcGxpY2Vcbn07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmpRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGxlbmd0aCA9PT0gaSApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdC0taTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0bm9Db25mbGljdDogZnVuY3Rpb24oIGRlZXAgKSB7XG5cdFx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LiQgPSBfJDtcblx0XHR9XG5cblx0XHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSxcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblx0XHQvLyBFaXRoZXIgYSByZWxlYXNlZCBob2xkIG9yIGFuIERPTXJlYWR5L2xvYWQgZXZlbnQgYW5kIG5vdCB5ZXQgcmVhZHlcblx0XHRpZiAoICh3YWl0ID09PSB0cnVlICYmICEtLWpRdWVyeS5yZWFkeVdhaXQpIHx8ICh3YWl0ICE9PSB0cnVlICYmICFqUXVlcnkuaXNSZWFkeSkgKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdFx0XHRpZiAoICFkb2N1bWVudC5ib2R5ICkge1xuXHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5LCAxICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdFx0cmVhZHlMaXN0LmZpcmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXIgKSB7XG5cdFx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VyKCBcInJlYWR5XCIgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRiaW5kUmVhZHk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggcmVhZHlMaXN0ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG5cdFx0Ly8gYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSwgMSApO1xuXHRcdH1cblxuXHRcdC8vIE1vemlsbGEsIE9wZXJhIGFuZCB3ZWJraXQgbmlnaHRsaWVzIGN1cnJlbnRseSBzdXBwb3J0IHRoaXMgZXZlbnRcblx0XHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgalF1ZXJ5LnJlYWR5LCBmYWxzZSApO1xuXG5cdFx0Ly8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuXHRcdH0gZWxzZSBpZiAoIGRvY3VtZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0Ly8gZW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLFxuXHRcdFx0Ly8gbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG5cdFx0XHRkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdFx0Ly8gSWYgSUUgYW5kIG5vdCBhIGZyYW1lXG5cdFx0XHQvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG5cdFx0XHR2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9wbGV2ZWwgPSB3aW5kb3cuZnJhbWVFbGVtZW50ID09IG51bGw7XG5cdFx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsICkge1xuXHRcdFx0XHRkb1Njcm9sbENoZWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXG5cdC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcblx0Ly8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuXHR9LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChvYmopICkgJiYgaXNGaW5pdGUoIG9iaiApO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiA9PSBudWxsID9cblx0XHRcdFN0cmluZyggb2JqICkgOlxuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIjtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE11c3QgYmUgYW4gT2JqZWN0LlxuXHRcdC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG5cdFx0aWYgKCAhb2JqIHx8IGpRdWVyeS50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0Ly8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cblx0XHR2YXIga2V5O1xuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdHBhcnNlSlNPTjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhZGF0YSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZCAoSUUgY2FuJ3QgaGFuZGxlIGl0KVxuXHRcdGRhdGEgPSBqUXVlcnkudHJpbSggZGF0YSApO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdFx0aWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHtcblx0XHRcdHJldHVybiB3aW5kb3cuSlNPTi5wYXJzZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgaW5jb21pbmcgZGF0YSBpcyBhY3R1YWwgSlNPTlxuXHRcdC8vIExvZ2ljIGJvcnJvd2VkIGZyb20gaHR0cDovL2pzb24ub3JnL2pzb24yLmpzXG5cdFx0aWYgKCBydmFsaWRjaGFycy50ZXN0KCBkYXRhLnJlcGxhY2UoIHJ2YWxpZGVzY2FwZSwgXCJAXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJ2YWxpZHRva2VucywgXCJdXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJ2YWxpZGJyYWNlcywgXCJcIikpICkge1xuXG5cdFx0XHRyZXR1cm4gKCBuZXcgRnVuY3Rpb24oIFwicmV0dXJuIFwiICsgZGF0YSApICkoKTtcblxuXHRcdH1cblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEgKTtcblx0fSxcblxuXHQvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5cdHBhcnNlWE1MOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiIHx8ICFkYXRhICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHZhciB4bWwsIHRtcDtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCB3aW5kb3cuRE9NUGFyc2VyICkgeyAvLyBTdGFuZGFyZFxuXHRcdFx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEgLCBcInRleHQveG1sXCIgKTtcblx0XHRcdH0gZWxzZSB7IC8vIElFXG5cdFx0XHRcdHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxET01cIiApO1xuXHRcdFx0XHR4bWwuYXN5bmMgPSBcImZhbHNlXCI7XG5cdFx0XHRcdHhtbC5sb2FkWE1MKCBkYXRhICk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCAheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHhtbDtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdC8vIFdvcmthcm91bmRzIGJhc2VkIG9uIGZpbmRpbmdzIGJ5IEppbSBEcmlzY29sbFxuXHQvLyBodHRwOi8vd2VibG9ncy5qYXZhLm5ldC9ibG9nL2RyaXNjb2xsL2FyY2hpdmUvMjAwOS8wOS8wOC9ldmFsLWphdmFzY3JpcHQtZ2xvYmFsLWNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCBkYXRhICYmIHJub3R3aGl0ZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHQvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0Ly8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XG5cdFx0XHQvLyByYXRoZXIgdGhhbiBqUXVlcnkgaW4gRmlyZWZveFxuXHRcdFx0KCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0d2luZG93WyBcImV2YWxcIiBdLmNhbGwoIHdpbmRvdywgZGF0YSApO1xuXHRcdFx0fSApKCBkYXRhICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iamVjdCwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIG5hbWUsIGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcblx0XHRcdGlzT2JqID0gbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRnVuY3Rpb24oIG9iamVjdCApO1xuXG5cdFx0aWYgKCBhcmdzICkge1xuXHRcdFx0aWYgKCBpc09iaiApIHtcblx0XHRcdFx0Zm9yICggbmFtZSBpbiBvYmplY3QgKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5hcHBseSggb2JqZWN0WyBuYW1lIF0sIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5hcHBseSggb2JqZWN0WyBpKysgXSwgYXJncyApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQSBzcGVjaWFsLCBmYXN0LCBjYXNlIGZvciB0aGUgbW9zdCBjb21tb24gdXNlIG9mIGVhY2hcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBpc09iaiApIHtcblx0XHRcdFx0Zm9yICggbmFtZSBpbiBvYmplY3QgKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmplY3RbIG5hbWUgXSwgbmFtZSwgb2JqZWN0WyBuYW1lIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmplY3RbIGkgXSwgaSwgb2JqZWN0WyBpKysgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cdH0sXG5cblx0Ly8gVXNlIG5hdGl2ZSBTdHJpbmcudHJpbSBmdW5jdGlvbiB3aGVyZXZlciBwb3NzaWJsZVxuXHR0cmltOiB0cmltID9cblx0XHRmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0dHJpbS5jYWxsKCB0ZXh0ICk7XG5cdFx0fSA6XG5cblx0XHQvLyBPdGhlcndpc2UgdXNlIG91ciBvd24gdHJpbW1pbmcgZnVuY3Rpb25hbGl0eVxuXHRcdGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHR0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSggdHJpbUxlZnQsIFwiXCIgKS5yZXBsYWNlKCB0cmltUmlnaHQsIFwiXCIgKTtcblx0XHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyYXksIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFycmF5ICE9IG51bGwgKSB7XG5cdFx0XHQvLyBUaGUgd2luZG93LCBzdHJpbmdzIChhbmQgZnVuY3Rpb25zKSBhbHNvIGhhdmUgJ2xlbmd0aCdcblx0XHRcdC8vIFR3ZWFrZWQgbG9naWMgc2xpZ2h0bHkgdG8gaGFuZGxlIEJsYWNrYmVycnkgNC43IFJlZ0V4cCBpc3N1ZXMgIzY5MzBcblx0XHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIGFycmF5ICk7XG5cblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gXCJyZWdleHBcIiB8fCBqUXVlcnkuaXNXaW5kb3coIGFycmF5ICkgKSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnJheSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyYXksIGkgKSB7XG5cdFx0dmFyIGxlbjtcblxuXHRcdGlmICggYXJyYXkgKSB7XG5cdFx0XHRpZiAoIGluZGV4T2YgKSB7XG5cdFx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGFycmF5LCBlbGVtLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdGkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHQvLyBTa2lwIGFjY2Vzc2luZyBpbiBzcGFyc2UgYXJyYXlzXG5cdFx0XHRcdGlmICggaSBpbiBhcnJheSAmJiBhcnJheVsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgaSA9IGZpcnN0Lmxlbmd0aCxcblx0XHRcdGogPSAwO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2Vjb25kLmxlbmd0aCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGZvciAoIHZhciBsID0gc2Vjb25kLmxlbmd0aDsgaiA8IGw7IGorKyApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKCBzZWNvbmRbal0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludiApIHtcblx0XHR2YXIgcmV0ID0gW10sIHJldFZhbDtcblx0XHRpbnYgPSAhIWludjtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIHZhciBpID0gMCwgbGVuZ3RoID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRyZXRWYWwgPSAhIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGludiAhPT0gcmV0VmFsICkge1xuXHRcdFx0XHRyZXQucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSwga2V5LCByZXQgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Ly8ganF1ZXJ5IG9iamVjdHMgYXJlIHRyZWF0ZWQgYXMgYXJyYXlzXG5cdFx0XHRpc0FycmF5ID0gZWxlbXMgaW5zdGFuY2VvZiBqUXVlcnkgfHwgbGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiAoICggbGVuZ3RoID4gMCAmJiBlbGVtc1sgMCBdICYmIGVsZW1zWyBsZW5ndGggLTEgXSApIHx8IGxlbmd0aCA9PT0gMCB8fCBqUXVlcnkuaXNBcnJheSggZWxlbXMgKSApIDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpclxuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0WyByZXQubGVuZ3RoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICgga2V5IGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sga2V5IF0sIGtleSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIHJldC5jb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR2YXIgdG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApLFxuXHRcdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0LCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBwcm94eS5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0Ly8gTXV0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyB0byBhIGNvbGxlY3Rpb25cblx0Ly8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG5cdGFjY2VzczogZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcGFzcyApIHtcblx0XHR2YXIgZXhlYyxcblx0XHRcdGJ1bGsgPSBrZXkgPT0gbnVsbCxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRcdGlmICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdFx0alF1ZXJ5LmFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbaV0sIDEsIGVtcHR5R2V0LCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Y2hhaW5hYmxlID0gMTtcblxuXHRcdC8vIFNldHMgb25lIHZhbHVlXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIE9wdGlvbmFsbHksIGZ1bmN0aW9uIHZhbHVlcyBnZXQgZXhlY3V0ZWQgaWYgZXhlYyBpcyB0cnVlXG5cdFx0XHRleGVjID0gcGFzcyA9PT0gdW5kZWZpbmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBvbmx5IGl0ZXJhdGUgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHRcdGlmICggZXhlYyApIHtcblx0XHRcdFx0XHRleGVjID0gZm47XG5cdFx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBleGVjLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZXkgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0XHRmbiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgZXhlYyA/IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgOiB2YWx1ZSwgcGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYWluYWJsZSA9IDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0XHRlbGVtcyA6XG5cblx0XHRcdC8vIEdldHNcblx0XHRcdGJ1bGsgP1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdFx0bGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xuXHR9LFxuXG5cdG5vdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICggbmV3IERhdGUoKSApLmdldFRpbWUoKTtcblx0fSxcblxuXHQvLyBVc2Ugb2YgalF1ZXJ5LmJyb3dzZXIgaXMgZnJvd25lZCB1cG9uLlxuXHQvLyBNb3JlIGRldGFpbHM6IGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVXRpbGl0aWVzL2pRdWVyeS5icm93c2VyXG5cdHVhTWF0Y2g6IGZ1bmN0aW9uKCB1YSApIHtcblx0XHR1YSA9IHVhLnRvTG93ZXJDYXNlKCk7XG5cblx0XHR2YXIgbWF0Y2ggPSByd2Via2l0LmV4ZWMoIHVhICkgfHxcblx0XHRcdHJvcGVyYS5leGVjKCB1YSApIHx8XG5cdFx0XHRybXNpZS5leGVjKCB1YSApIHx8XG5cdFx0XHR1YS5pbmRleE9mKFwiY29tcGF0aWJsZVwiKSA8IDAgJiYgcm1vemlsbGEuZXhlYyggdWEgKSB8fFxuXHRcdFx0W107XG5cblx0XHRyZXR1cm4geyBicm93c2VyOiBtYXRjaFsxXSB8fCBcIlwiLCB2ZXJzaW9uOiBtYXRjaFsyXSB8fCBcIjBcIiB9O1xuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24galF1ZXJ5U3ViKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRcdHJldHVybiBuZXcgalF1ZXJ5U3ViLmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIGpRdWVyeVN1YiwgdGhpcyApO1xuXHRcdGpRdWVyeVN1Yi5zdXBlcmNsYXNzID0gdGhpcztcblx0XHRqUXVlcnlTdWIuZm4gPSBqUXVlcnlTdWIucHJvdG90eXBlID0gdGhpcygpO1xuXHRcdGpRdWVyeVN1Yi5mbi5jb25zdHJ1Y3RvciA9IGpRdWVyeVN1Yjtcblx0XHRqUXVlcnlTdWIuc3ViID0gdGhpcy5zdWI7XG5cdFx0alF1ZXJ5U3ViLmZuLmluaXQgPSBmdW5jdGlvbiBpbml0KCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRcdGlmICggY29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICYmICEoY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeVN1YikgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBqUXVlcnlTdWIoIGNvbnRleHQgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpRdWVyeS5mbi5pbml0LmNhbGwoIHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5U3ViICk7XG5cdFx0fTtcblx0XHRqUXVlcnlTdWIuZm4uaW5pdC5wcm90b3R5cGUgPSBqUXVlcnlTdWIuZm47XG5cdFx0dmFyIHJvb3RqUXVlcnlTdWIgPSBqUXVlcnlTdWIoZG9jdW1lbnQpO1xuXHRcdHJldHVybiBqUXVlcnlTdWI7XG5cdH0sXG5cblx0YnJvd3Nlcjoge31cbn0pO1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5icm93c2VyTWF0Y2ggPSBqUXVlcnkudWFNYXRjaCggdXNlckFnZW50ICk7XG5pZiAoIGJyb3dzZXJNYXRjaC5icm93c2VyICkge1xuXHRqUXVlcnkuYnJvd3NlclsgYnJvd3Nlck1hdGNoLmJyb3dzZXIgXSA9IHRydWU7XG5cdGpRdWVyeS5icm93c2VyLnZlcnNpb24gPSBicm93c2VyTWF0Y2gudmVyc2lvbjtcbn1cblxuLy8gRGVwcmVjYXRlZCwgdXNlIGpRdWVyeS5icm93c2VyLndlYmtpdCBpbnN0ZWFkXG5pZiAoIGpRdWVyeS5icm93c2VyLndlYmtpdCApIHtcblx0alF1ZXJ5LmJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbn1cblxuLy8gSUUgZG9lc24ndCBtYXRjaCBub24tYnJlYWtpbmcgc3BhY2VzIHdpdGggXFxzXG5pZiAoIHJub3R3aGl0ZS50ZXN0KCBcIlxceEEwXCIgKSApIHtcblx0dHJpbUxlZnQgPSAvXltcXHNcXHhBMF0rLztcblx0dHJpbVJpZ2h0ID0gL1tcXHNcXHhBMF0rJC87XG59XG5cbi8vIEFsbCBqUXVlcnkgb2JqZWN0cyBzaG91bGQgcG9pbnQgYmFjayB0byB0aGVzZVxucm9vdGpRdWVyeSA9IGpRdWVyeShkb2N1bWVudCk7XG5cbi8vIENsZWFudXAgZnVuY3Rpb25zIGZvciB0aGUgZG9jdW1lbnQgcmVhZHkgbWV0aG9kXG5pZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbigpIHtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UgKTtcblx0XHRqUXVlcnkucmVhZHkoKTtcblx0fTtcblxufSBlbHNlIGlmICggZG9jdW1lbnQuYXR0YWNoRXZlbnQgKSB7XG5cdERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHRkb2N1bWVudC5kZXRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCApO1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBUaGUgRE9NIHJlYWR5IGNoZWNrIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcblx0aWYgKCBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0cnkge1xuXHRcdC8vIElmIElFIGlzIHVzZWQsIHVzZSB0aGUgdHJpY2sgYnkgRGllZ28gUGVyaW5pXG5cdFx0Ly8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRzZXRUaW1lb3V0KCBkb1Njcm9sbENoZWNrLCAxICk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSgpO1xuXG5cbi8vIFN0cmluZyB0byBPYmplY3QgZmxhZ3MgZm9ybWF0IGNhY2hlXG52YXIgZmxhZ3NDYWNoZSA9IHt9O1xuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgZmxhZ3MgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVGbGFncyggZmxhZ3MgKSB7XG5cdHZhciBvYmplY3QgPSBmbGFnc0NhY2hlWyBmbGFncyBdID0ge30sXG5cdFx0aSwgbGVuZ3RoO1xuXHRmbGFncyA9IGZsYWdzLnNwbGl0KCAvXFxzKy8gKTtcblx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGZsYWdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdG9iamVjdFsgZmxhZ3NbaV0gXSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRmbGFnczpcdGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIGZsYWdzIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXNcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIGZsYWdzOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIGZsYWdzICkge1xuXG5cdC8vIENvbnZlcnQgZmxhZ3MgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRmbGFncyA9IGZsYWdzID8gKCBmbGFnc0NhY2hlWyBmbGFncyBdIHx8IGNyZWF0ZUZsYWdzKCBmbGFncyApICkgOiB7fTtcblxuXHR2YXIgLy8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cdFx0Ly8gU3RhY2sgb2YgZmlyZSBjYWxscyBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHN0YWNrID0gW10sXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxuXHRcdG1lbW9yeSxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG5cdFx0ZmlyaW5nU3RhcnQsXG5cdFx0Ly8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXG5cdFx0ZmlyaW5nTGVuZ3RoLFxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXgsXG5cdFx0Ly8gQWRkIG9uZSBvciBzZXZlcmFsIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdGxlbmd0aCxcblx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0YWN0dWFsO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSBhcmdzWyBpIF07XG5cdFx0XHRcdHR5cGUgPSBqUXVlcnkudHlwZSggZWxlbSApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYXJyYXlcIiApIHtcblx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0YWRkKCBlbGVtICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHQvLyBBZGQgaWYgbm90IGluIHVuaXF1ZSBtb2RlIGFuZCBjYWxsYmFjayBpcyBub3QgaW5cblx0XHRcdFx0XHRpZiAoICFmbGFncy51bmlxdWUgfHwgIXNlbGYuaGFzKCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRtZW1vcnkgPSAhZmxhZ3MubWVtb3J5IHx8IFsgY29udGV4dCwgYXJncyBdO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGNvbnRleHQsIGFyZ3MgKSA9PT0gZmFsc2UgJiYgZmxhZ3Muc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gdHJ1ZTsgLy8gTWFyayBhcyBoYWx0ZWRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggIWZsYWdzLm9uY2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjayAmJiBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0c2VsZi5maXJlV2l0aCggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdGFkZCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5LCB1bmxlc3MgcHJldmlvdXNcblx0XHRcdFx0XHQvLyBmaXJpbmcgd2FzIGhhbHRlZCAoc3RvcE9uRmFsc2UpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICYmIG1lbW9yeSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gbGVuZ3RoO1xuXHRcdFx0XHRcdFx0ZmlyZSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdGFyZ0luZGV4ID0gMCxcblx0XHRcdFx0XHRcdGFyZ0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIDsgYXJnSW5kZXggPCBhcmdMZW5ndGggOyBhcmdJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBhcmdzWyBhcmdJbmRleCBdID09PSBsaXN0WyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZ0luZGV4IGFuZCBmaXJpbmdMZW5ndGhcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaSA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBzb21lIHVuaWNpdHkgcHJvcGVydHkgdGhlblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGZsYWdzLnVuaXF1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDb250cm9sIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3Rcblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGZuID09PSBsaXN0WyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5IHx8IG1lbW9yeSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBsb2NrZWQ/XG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXN0YWNrO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCBzdGFjayApIHtcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGlmICggIWZsYWdzLm9uY2UgKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIFsgY29udGV4dCwgYXJncyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggZmxhZ3Mub25jZSAmJiBtZW1vcnkgKSApIHtcblx0XHRcdFx0XHRcdGZpcmUoIGNvbnRleHQsIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cblxuXG52YXIgLy8gU3RhdGljIHJlZmVyZW5jZSB0byBzbGljZVxuXHRzbGljZURlZmVycmVkID0gW10uc2xpY2U7XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgZG9uZUxpc3QgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdGZhaWxMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRwcm9ncmVzc0xpc3QgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0bGlzdHMgPSB7XG5cdFx0XHRcdHJlc29sdmU6IGRvbmVMaXN0LFxuXHRcdFx0XHRyZWplY3Q6IGZhaWxMaXN0LFxuXHRcdFx0XHRub3RpZnk6IHByb2dyZXNzTGlzdFxuXHRcdFx0fSxcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdGRvbmU6IGRvbmVMaXN0LmFkZCxcblx0XHRcdFx0ZmFpbDogZmFpbExpc3QuYWRkLFxuXHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3NMaXN0LmFkZCxcblxuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIERlcHJlY2F0ZWRcblx0XHRcdFx0aXNSZXNvbHZlZDogZG9uZUxpc3QuZmlyZWQsXG5cdFx0XHRcdGlzUmVqZWN0ZWQ6IGZhaWxMaXN0LmZpcmVkLFxuXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBkb25lQ2FsbGJhY2tzLCBmYWlsQ2FsbGJhY2tzLCBwcm9ncmVzc0NhbGxiYWNrcyApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBkb25lQ2FsbGJhY2tzICkuZmFpbCggZmFpbENhbGxiYWNrcyApLnByb2dyZXNzKCBwcm9ncmVzc0NhbGxiYWNrcyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUuYXBwbHkoIGRlZmVycmVkLCBhcmd1bWVudHMgKS5mYWlsLmFwcGx5KCBkZWZlcnJlZCwgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB7XG5cdFx0XHRcdFx0XHRcdGRvbmU6IFsgZm5Eb25lLCBcInJlc29sdmVcIiBdLFxuXHRcdFx0XHRcdFx0XHRmYWlsOiBbIGZuRmFpbCwgXCJyZWplY3RcIiBdLFxuXHRcdFx0XHRcdFx0XHRwcm9ncmVzczogWyBmblByb2dyZXNzLCBcIm5vdGlmeVwiIF1cblx0XHRcdFx0XHRcdH0sIGZ1bmN0aW9uKCBoYW5kbGVyLCBkYXRhICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBkYXRhWyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0YWN0aW9uID0gZGF0YVsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdHJldHVybmVkO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkWyBoYW5kbGVyIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpLnRoZW4oIG5ld0RlZmVyLnJlc29sdmUsIG5ld0RlZmVyLnJlamVjdCwgbmV3RGVmZXIubm90aWZ5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgYWN0aW9uICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBuZXdEZWZlciA6IHRoaXMsIFsgcmV0dXJuZWQgXSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkWyBoYW5kbGVyIF0oIG5ld0RlZmVyWyBhY3Rpb24gXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRvYmogPSBwcm9taXNlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHByb21pc2UgKSB7XG5cdFx0XHRcdFx0XHRcdG9ialsga2V5IF0gPSBwcm9taXNlWyBrZXkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0gcHJvbWlzZS5wcm9taXNlKHt9KSxcblx0XHRcdGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBsaXN0cyApIHtcblx0XHRcdGRlZmVycmVkWyBrZXkgXSA9IGxpc3RzWyBrZXkgXS5maXJlO1xuXHRcdFx0ZGVmZXJyZWRbIGtleSArIFwiV2l0aFwiIF0gPSBsaXN0c1sga2V5IF0uZmlyZVdpdGg7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0ZGVmZXJyZWQuZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdGF0ZSA9IFwicmVzb2x2ZWRcIjtcblx0XHR9LCBmYWlsTGlzdC5kaXNhYmxlLCBwcm9ncmVzc0xpc3QubG9jayApLmZhaWwoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RhdGUgPSBcInJlamVjdGVkXCI7XG5cdFx0fSwgZG9uZUxpc3QuZGlzYWJsZSwgcHJvZ3Jlc3NMaXN0LmxvY2sgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIGZpcnN0UGFyYW0gKSB7XG5cdFx0dmFyIGFyZ3MgPSBzbGljZURlZmVycmVkLmNhbGwoIGFyZ3VtZW50cywgMCApLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBhcmdzLmxlbmd0aCxcblx0XHRcdHBWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApLFxuXHRcdFx0Y291bnQgPSBsZW5ndGgsXG5cdFx0XHRwQ291bnQgPSBsZW5ndGgsXG5cdFx0XHRkZWZlcnJlZCA9IGxlbmd0aCA8PSAxICYmIGZpcnN0UGFyYW0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGZpcnN0UGFyYW0ucHJvbWlzZSApID9cblx0XHRcdFx0Zmlyc3RQYXJhbSA6XG5cdFx0XHRcdGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0cHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcblx0XHRmdW5jdGlvbiByZXNvbHZlRnVuYyggaSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSA6IHZhbHVlO1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZGVmZXJyZWQsIGFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gcHJvZ3Jlc3NGdW5jKCBpICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cFZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZURlZmVycmVkLmNhbGwoIGFyZ3VtZW50cywgMCApIDogdmFsdWU7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIHByb21pc2UsIHBWYWx1ZXMgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFyZ3NbIGkgXSAmJiBhcmdzWyBpIF0ucHJvbWlzZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggYXJnc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRhcmdzWyBpIF0ucHJvbWlzZSgpLnRoZW4oIHJlc29sdmVGdW5jKGkpLCBkZWZlcnJlZC5yZWplY3QsIHByb2dyZXNzRnVuYyhpKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tY291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWNvdW50ICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZGVmZXJyZWQsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCBkZWZlcnJlZCAhPT0gZmlyc3RQYXJhbSApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBkZWZlcnJlZCwgbGVuZ3RoID8gWyBmaXJzdFBhcmFtIF0gOiBbXSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxufSk7XG5cblxuXG5cbmpRdWVyeS5zdXBwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBzdXBwb3J0LFxuXHRcdGFsbCxcblx0XHRhLFxuXHRcdHNlbGVjdCxcblx0XHRvcHQsXG5cdFx0aW5wdXQsXG5cdFx0ZnJhZ21lbnQsXG5cdFx0dGRzLFxuXHRcdGV2ZW50cyxcblx0XHRldmVudE5hbWUsXG5cdFx0aSxcblx0XHRpc1N1cHBvcnRlZCxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFByZWxpbWluYXJ5IHRlc3RzXG5cdGRpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIiwgXCJ0XCIpO1xuXHRkaXYuaW5uZXJIVE1MID0gXCIgICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnIHN0eWxlPSd0b3A6MXB4O2Zsb2F0OmxlZnQ7b3BhY2l0eTouNTU7Jz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXG5cdGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKTtcblx0YSA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJhXCIgKVsgMCBdO1xuXG5cdC8vIENhbid0IGdldCBiYXNpYyB0ZXN0IHN1cHBvcnRcblx0aWYgKCAhYWxsIHx8ICFhbGwubGVuZ3RoIHx8ICFhICkge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdC8vIEZpcnN0IGJhdGNoIG9mIHN1cHBvcnRzIHRlc3RzXG5cdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKTtcblx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpICk7XG5cdGlucHV0ID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImlucHV0XCIgKVsgMCBdO1xuXG5cdHN1cHBvcnQgPSB7XG5cdFx0Ly8gSUUgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIC5pbm5lckhUTUwgaXMgdXNlZFxuXHRcdGxlYWRpbmdXaGl0ZXNwYWNlOiAoIGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzICksXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuXHRcdC8vIElFIHdpbGwgaW5zZXJ0IHRoZW0gaW50byBlbXB0eSB0YWJsZXNcblx0XHR0Ym9keTogIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuXHRcdC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcblx0XHRodG1sU2VyaWFsaXplOiAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLFxuXG5cdFx0Ly8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuXHRcdC8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpXG5cdFx0c3R5bGU6IC90b3AvLnRlc3QoIGEuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXG5cdFx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0XHRocmVmTm9ybWFsaXplZDogKCBhLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiL2FcIiApLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgZWxlbWVudCBvcGFjaXR5IGV4aXN0c1xuXHRcdC8vIChJRSB1c2VzIGZpbHRlciBpbnN0ZWFkKVxuXHRcdC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcblx0XHRvcGFjaXR5OiAvXjAuNTUvLnRlc3QoIGEuc3R5bGUub3BhY2l0eSApLFxuXG5cdFx0Ly8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuXHRcdC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcblx0XHRjc3NGbG9hdDogISFhLnN0eWxlLmNzc0Zsb2F0LFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgaWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkIGZvciBhIGNoZWNrYm94XG5cdFx0Ly8gdGhhdCBpdCBkZWZhdWx0cyB0byBcIm9uXCIuXG5cdFx0Ly8gKFdlYktpdCBkZWZhdWx0cyB0byBcIlwiIGluc3RlYWQpXG5cdFx0Y2hlY2tPbjogKCBpbnB1dC52YWx1ZSA9PT0gXCJvblwiICksXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBhIHNlbGVjdGVkLWJ5LWRlZmF1bHQgb3B0aW9uIGhhcyBhIHdvcmtpbmcgc2VsZWN0ZWQgcHJvcGVydHkuXG5cdFx0Ly8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcblx0XHRvcHRTZWxlY3RlZDogb3B0LnNlbGVjdGVkLFxuXG5cdFx0Ly8gVGVzdCBzZXRBdHRyaWJ1dGUgb24gY2FtZWxDYXNlIGNsYXNzLiBJZiBpdCB3b3Jrcywgd2UgbmVlZCBhdHRyRml4ZXMgd2hlbiBkb2luZyBnZXQvc2V0QXR0cmlidXRlIChpZTYvNylcblx0XHRnZXRTZXRBdHRyaWJ1dGU6IGRpdi5jbGFzc05hbWUgIT09IFwidFwiLFxuXG5cdFx0Ly8gVGVzdHMgZm9yIGVuY3R5cGUgc3VwcG9ydCBvbiBhIGZvcm0oIzY3NDMpXG5cdFx0ZW5jdHlwZTogISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKS5lbmN0eXBlLFxuXG5cdFx0Ly8gTWFrZXMgc3VyZSBjbG9uaW5nIGFuIGh0bWw1IGVsZW1lbnQgZG9lcyBub3QgY2F1c2UgcHJvYmxlbXNcblx0XHQvLyBXaGVyZSBvdXRlckhUTUwgaXMgdW5kZWZpbmVkLCB0aGlzIHN0aWxsIHdvcmtzXG5cdFx0aHRtbDVDbG9uZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm5hdlwiKS5jbG9uZU5vZGUoIHRydWUgKS5vdXRlckhUTUwgIT09IFwiPDpuYXY+PC86bmF2PlwiLFxuXG5cdFx0Ly8gV2lsbCBiZSBkZWZpbmVkIGxhdGVyXG5cdFx0c3VibWl0QnViYmxlczogdHJ1ZSxcblx0XHRjaGFuZ2VCdWJibGVzOiB0cnVlLFxuXHRcdGZvY3VzaW5CdWJibGVzOiBmYWxzZSxcblx0XHRkZWxldGVFeHBhbmRvOiB0cnVlLFxuXHRcdG5vQ2xvbmVFdmVudDogdHJ1ZSxcblx0XHRpbmxpbmVCbG9ja05lZWRzTGF5b3V0OiBmYWxzZSxcblx0XHRzaHJpbmtXcmFwQmxvY2tzOiBmYWxzZSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiB0cnVlLFxuXHRcdHBpeGVsTWFyZ2luOiB0cnVlXG5cdH07XG5cblx0Ly8galF1ZXJ5LmJveE1vZGVsIERFUFJFQ0FURUQgaW4gMS4zLCB1c2UgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgaW5zdGVhZFxuXHRqUXVlcnkuYm94TW9kZWwgPSBzdXBwb3J0LmJveE1vZGVsID0gKGRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiKTtcblxuXHQvLyBNYWtlIHN1cmUgY2hlY2tlZCBzdGF0dXMgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gaW5wdXQuY2xvbmVOb2RlKCB0cnVlICkuY2hlY2tlZDtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXG5cdC8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZClcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gVGVzdCB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkZWxldGUgYW4gZXhwYW5kbyBmcm9tIGFuIGVsZW1lbnRcblx0Ly8gRmFpbHMgaW4gSW50ZXJuZXQgRXhwbG9yZXJcblx0dHJ5IHtcblx0XHRkZWxldGUgZGl2LnRlc3Q7XG5cdH0gY2F0Y2goIGUgKSB7XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XG5cdH1cblxuXHRpZiAoICFkaXYuYWRkRXZlbnRMaXN0ZW5lciAmJiBkaXYuYXR0YWNoRXZlbnQgJiYgZGl2LmZpcmVFdmVudCApIHtcblx0XHRkaXYuYXR0YWNoRXZlbnQoIFwib25jbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENsb25pbmcgYSBub2RlIHNob3VsZG4ndCBjb3B5IG92ZXIgYW55XG5cdFx0XHQvLyBib3VuZCBldmVudCBoYW5kbGVycyAoSUUgZG9lcyB0aGlzKVxuXHRcdFx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHR9KTtcblx0XHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuZmlyZUV2ZW50KCBcIm9uY2xpY2tcIiApO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYSByYWRpbyBtYWludGFpbnMgaXRzIHZhbHVlXG5cdC8vIGFmdGVyIGJlaW5nIGFwcGVuZGVkIHRvIHRoZSBET01cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKTtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuXG5cdGlucHV0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpO1xuXG5cdC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0ZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYubGFzdENoaWxkICk7XG5cblx0Ly8gV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGZyYWdtZW50LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIENoZWNrIGlmIGEgZGlzY29ubmVjdGVkIGNoZWNrYm94IHdpbGwgcmV0YWluIGl0cyBjaGVja2VkXG5cdC8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpXG5cdHN1cHBvcnQuYXBwZW5kQ2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cblx0ZnJhZ21lbnQucmVtb3ZlQ2hpbGQoIGlucHV0ICk7XG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBUZWNobmlxdWUgZnJvbSBKdXJpeSBaYXl0c2V2XG5cdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2RldGVjdGluZy1ldmVudC1zdXBwb3J0LXdpdGhvdXQtYnJvd3Nlci1zbmlmZmluZy9cblx0Ly8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBjYXNlIHdoZXJlIG5vbi1zdGFuZGFyZCBldmVudCBzeXN0ZW1zXG5cdC8vIGFyZSB1c2VkLCBuYW1lbHkgaW4gSUUuIFNob3J0LWNpcmN1aXRpbmcgaGVyZSBoZWxwcyB1cyB0b1xuXHQvLyBhdm9pZCBhbiBldmFsIGNhbGwgKGluIHNldEF0dHJpYnV0ZSkgd2hpY2ggY2FuIGNhdXNlIENTUFxuXHQvLyB0byBnbyBoYXl3aXJlLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUFxuXHRpZiAoIGRpdi5hdHRhY2hFdmVudCApIHtcblx0XHRmb3IgKCBpIGluIHtcblx0XHRcdHN1Ym1pdDogMSxcblx0XHRcdGNoYW5nZTogMSxcblx0XHRcdGZvY3VzaW46IDFcblx0XHR9KSB7XG5cdFx0XHRldmVudE5hbWUgPSBcIm9uXCIgKyBpO1xuXHRcdFx0aXNTdXBwb3J0ZWQgPSAoIGV2ZW50TmFtZSBpbiBkaXYgKTtcblx0XHRcdGlmICggIWlzU3VwcG9ydGVkICkge1xuXHRcdFx0XHRkaXYuc2V0QXR0cmlidXRlKCBldmVudE5hbWUsIFwicmV0dXJuO1wiICk7XG5cdFx0XHRcdGlzU3VwcG9ydGVkID0gKCB0eXBlb2YgZGl2WyBldmVudE5hbWUgXSA9PT0gXCJmdW5jdGlvblwiICk7XG5cdFx0XHR9XG5cdFx0XHRzdXBwb3J0WyBpICsgXCJCdWJibGVzXCIgXSA9IGlzU3VwcG9ydGVkO1xuXHRcdH1cblx0fVxuXG5cdGZyYWdtZW50LnJlbW92ZUNoaWxkKCBkaXYgKTtcblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFXG5cdGZyYWdtZW50ID0gc2VsZWN0ID0gb3B0ID0gZGl2ID0gaW5wdXQgPSBudWxsO1xuXG5cdC8vIFJ1biB0ZXN0cyB0aGF0IG5lZWQgYSBib2R5IGF0IGRvYyByZWFkeVxuXHRqUXVlcnkoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRhaW5lciwgb3V0ZXIsIGlubmVyLCB0YWJsZSwgdGQsIG9mZnNldFN1cHBvcnQsXG5cdFx0XHRtYXJnaW5EaXYsIGNvbk1hcmdpblRvcCwgc3R5bGUsIGh0bWwsIHBvc2l0aW9uVG9wTGVmdFdpZHRoSGVpZ2h0LFxuXHRcdFx0cGFkZGluZ01hcmdpbkJvcmRlclZpc2liaWxpdHksIHBhZGRpbmdNYXJnaW5Cb3JkZXIsXG5cdFx0XHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXG5cdFx0aWYgKCAhYm9keSApIHtcblx0XHRcdC8vIFJldHVybiBmb3IgZnJhbWVzZXQgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBib2R5XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uTWFyZ2luVG9wID0gMTtcblx0XHRwYWRkaW5nTWFyZ2luQm9yZGVyID0gXCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOlwiO1xuXHRcdHBvc2l0aW9uVG9wTGVmdFdpZHRoSGVpZ2h0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7XCI7XG5cdFx0cGFkZGluZ01hcmdpbkJvcmRlclZpc2liaWxpdHkgPSBwYWRkaW5nTWFyZ2luQm9yZGVyICsgXCIwO3Zpc2liaWxpdHk6aGlkZGVuO1wiO1xuXHRcdHN0eWxlID0gXCJzdHlsZT0nXCIgKyBwb3NpdGlvblRvcExlZnRXaWR0aEhlaWdodCArIHBhZGRpbmdNYXJnaW5Cb3JkZXIgKyBcIjVweCBzb2xpZCAjMDAwO1wiO1xuXHRcdGh0bWwgPSBcIjxkaXYgXCIgKyBzdHlsZSArIFwiZGlzcGxheTpibG9jazsnPjxkaXYgc3R5bGU9J1wiICsgcGFkZGluZ01hcmdpbkJvcmRlciArIFwiMDtkaXNwbGF5OmJsb2NrO292ZXJmbG93OmhpZGRlbjsnPjwvZGl2PjwvZGl2PlwiICtcblx0XHRcdFwiPHRhYmxlIFwiICsgc3R5bGUgKyBcIicgY2VsbHBhZGRpbmc9JzAnIGNlbGxzcGFjaW5nPScwJz5cIiArXG5cdFx0XHRcIjx0cj48dGQ+PC90ZD48L3RyPjwvdGFibGU+XCI7XG5cblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gcGFkZGluZ01hcmdpbkJvcmRlclZpc2liaWxpdHkgKyBcIndpZHRoOjA7aGVpZ2h0OjA7cG9zaXRpb246c3RhdGljO3RvcDowO21hcmdpbi10b3A6XCIgKyBjb25NYXJnaW5Ub3AgKyBcInB4XCI7XG5cdFx0Ym9keS5pbnNlcnRCZWZvcmUoIGNvbnRhaW5lciwgYm9keS5maXJzdENoaWxkICk7XG5cblx0XHQvLyBDb25zdHJ1Y3QgdGhlIHRlc3QgZWxlbWVudFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG5cdFx0Ly8gdG8gZGlzcGxheTpub25lIGFuZCB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdmlzaWJsZSB0YWJsZSBjZWxscyBpbiBhXG5cdFx0Ly8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG5cdFx0Ly8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcblx0XHQvLyBkaXNwbGF5Om5vbmUgKGl0IGlzIHN0aWxsIHNhZmUgdG8gdXNlIG9mZnNldHMgaWYgYSBwYXJlbnQgZWxlbWVudCBpc1xuXHRcdC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHQvLyAob25seSBJRSA4IGZhaWxzIHRoaXMgdGVzdClcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8dGFibGU+PHRyPjx0ZCBzdHlsZT0nXCIgKyBwYWRkaW5nTWFyZ2luQm9yZGVyICsgXCIwO2Rpc3BsYXk6bm9uZSc+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiO1xuXHRcdHRkcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0ZFwiICk7XG5cdFx0aXNTdXBwb3J0ZWQgPSAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuXG5cdFx0dGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0dGRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgZW1wdHkgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHRcblx0XHQvLyAoSUUgPD0gOCBmYWlsIHRoaXMgdGVzdClcblx0XHRzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IGlzU3VwcG9ydGVkICYmICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XG5cblx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiBGb3IgbW9yZVxuXHRcdC8vIGluZm8gc2VlIGJ1ZyAjMzMzM1xuXHRcdC8vIEZhaWxzIGluIFdlYktpdCBiZWZvcmUgRmViIDIwMTEgbmlnaHRsaWVzXG5cdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdFx0bWFyZ2luRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjBcIjtcblx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMnB4XCI7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIG1hcmdpbkRpdiApO1xuXHRcdFx0c3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0ID1cblx0XHRcdFx0KCBwYXJzZUludCggKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkgfHwgeyBtYXJnaW5SaWdodDogMCB9ICkubWFyZ2luUmlnaHQsIDEwICkgfHwgMCApID09PSAwO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgbmF0aXZlbHkgYmxvY2stbGV2ZWwgZWxlbWVudHMgYWN0IGxpa2UgaW5saW5lLWJsb2NrXG5cdFx0XHQvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG5cdFx0XHQvLyB0aGVtIGxheW91dFxuXHRcdFx0Ly8gKElFIDwgOCBkb2VzIHRoaXMpXG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5wYWRkaW5nID0gXCIxcHhcIjtcblx0XHRcdGRpdi5zdHlsZS5ib3JkZXIgPSAwO1xuXHRcdFx0ZGl2LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcblx0XHRcdGRpdi5zdHlsZS56b29tID0gMTtcblx0XHRcdHN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9ICggZGl2Lm9mZnNldFdpZHRoID09PSAzICk7XG5cblx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnRzIHdpdGggbGF5b3V0IHNocmluay13cmFwIHRoZWlyIGNoaWxkcmVuXG5cdFx0XHQvLyAoSUUgNiBkb2VzIHRoaXMpXG5cdFx0XHRkaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdGRpdi5zdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBzdHlsZT0nd2lkdGg6NXB4Oyc+PC9kaXY+XCI7XG5cdFx0XHRzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSAoIGRpdi5vZmZzZXRXaWR0aCAhPT0gMyApO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID0gcG9zaXRpb25Ub3BMZWZ0V2lkdGhIZWlnaHQgKyBwYWRkaW5nTWFyZ2luQm9yZGVyVmlzaWJpbGl0eTtcblx0XHRkaXYuaW5uZXJIVE1MID0gaHRtbDtcblxuXHRcdG91dGVyID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0aW5uZXIgPSBvdXRlci5maXJzdENoaWxkO1xuXHRcdHRkID0gb3V0ZXIubmV4dFNpYmxpbmcuZmlyc3RDaGlsZC5maXJzdENoaWxkO1xuXG5cdFx0b2Zmc2V0U3VwcG9ydCA9IHtcblx0XHRcdGRvZXNOb3RBZGRCb3JkZXI6ICggaW5uZXIub2Zmc2V0VG9wICE9PSA1ICksXG5cdFx0XHRkb2VzQWRkQm9yZGVyRm9yVGFibGVBbmRDZWxsczogKCB0ZC5vZmZzZXRUb3AgPT09IDUgKVxuXHRcdH07XG5cblx0XHRpbm5lci5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcblx0XHRpbm5lci5zdHlsZS50b3AgPSBcIjIwcHhcIjtcblxuXHRcdC8vIHNhZmFyaSBzdWJ0cmFjdHMgcGFyZW50IGJvcmRlciB3aWR0aCBoZXJlIHdoaWNoIGlzIDVweFxuXHRcdG9mZnNldFN1cHBvcnQuZml4ZWRQb3NpdGlvbiA9ICggaW5uZXIub2Zmc2V0VG9wID09PSAyMCB8fCBpbm5lci5vZmZzZXRUb3AgPT09IDE1ICk7XG5cdFx0aW5uZXIuc3R5bGUucG9zaXRpb24gPSBpbm5lci5zdHlsZS50b3AgPSBcIlwiO1xuXG5cdFx0b3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdG91dGVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG5cdFx0b2Zmc2V0U3VwcG9ydC5zdWJ0cmFjdHNCb3JkZXJGb3JPdmVyZmxvd05vdFZpc2libGUgPSAoIGlubmVyLm9mZnNldFRvcCA9PT0gLTUgKTtcblx0XHRvZmZzZXRTdXBwb3J0LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0ID0gKCBib2R5Lm9mZnNldFRvcCAhPT0gY29uTWFyZ2luVG9wICk7XG5cblx0XHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdFx0ZGl2LnN0eWxlLm1hcmdpblRvcCA9IFwiMSVcIjtcblx0XHRcdHN1cHBvcnQucGl4ZWxNYXJnaW4gPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IG1hcmdpblRvcDogMCB9ICkubWFyZ2luVG9wICE9PSBcIjElXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgY29udGFpbmVyLnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRjb250YWluZXIuc3R5bGUuem9vbSA9IDE7XG5cdFx0fVxuXG5cdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0bWFyZ2luRGl2ID0gZGl2ID0gY29udGFpbmVyID0gbnVsbDtcblxuXHRcdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIG9mZnNldFN1cHBvcnQgKTtcblx0fSk7XG5cblx0cmV0dXJuIHN1cHBvcnQ7XG59KSgpO1xuXG5cblxuXG52YXIgcmJyYWNlID0gL14oPzpcXHsuKlxcfXxcXFsuKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjYWNoZToge30sXG5cblx0Ly8gUGxlYXNlIHVzZSB3aXRoIGNhdXRpb25cblx0dXVpZDogMCxcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0Ly8gTm9uLWRpZ2l0cyByZW1vdmVkIHRvIG1hdGNoIHJpbmxpbmVqUXVlcnlcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggalF1ZXJ5LmZuLmpxdWVyeSArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIHRocm93IHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMgaWYgeW91XG5cdC8vIGF0dGVtcHQgdG8gYWRkIGV4cGFuZG8gcHJvcGVydGllcyB0byB0aGVtLlxuXHRub0RhdGE6IHtcblx0XHRcImVtYmVkXCI6IHRydWUsXG5cdFx0Ly8gQmFuIGFsbCBvYmplY3RzIGV4Y2VwdCBmb3IgRmxhc2ggKHdoaWNoIGhhbmRsZSBleHBhbmRvcylcblx0XHRcIm9iamVjdFwiOiBcImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiLFxuXHRcdFwiYXBwbGV0XCI6IHRydWVcblx0fSxcblxuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRlbGVtID0gZWxlbS5ub2RlVHlwZSA/IGpRdWVyeS5jYWNoZVsgZWxlbVtqUXVlcnkuZXhwYW5kb10gXSA6IGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XG5cdFx0cmV0dXJuICEhZWxlbSAmJiAhaXNFbXB0eURhdGFPYmplY3QoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSwgcHZ0IC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHByaXZhdGVDYWNoZSwgdGhpc0NhY2hlLCByZXQsXG5cdFx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXHRcdFx0Z2V0QnlOYW1lID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIsXG5cblx0XHRcdC8vIFdlIGhhdmUgdG8gaGFuZGxlIERPTSBub2RlcyBhbmQgSlMgb2JqZWN0cyBkaWZmZXJlbnRseSBiZWNhdXNlIElFNi03XG5cdFx0XHQvLyBjYW4ndCBHQyBvYmplY3QgcmVmZXJlbmNlcyBwcm9wZXJseSBhY3Jvc3MgdGhlIERPTS1KUyBib3VuZGFyeVxuXHRcdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdFx0Ly8gT25seSBET00gbm9kZXMgbmVlZCB0aGUgZ2xvYmFsIGpRdWVyeSBjYWNoZTsgSlMgb2JqZWN0IGRhdGEgaXNcblx0XHRcdC8vIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBvYmplY3Qgc28gR0MgY2FuIG9jY3VyIGF1dG9tYXRpY2FsbHlcblx0XHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblxuXHRcdFx0Ly8gT25seSBkZWZpbmluZyBhbiBJRCBmb3IgSlMgb2JqZWN0cyBpZiBpdHMgY2FjaGUgYWxyZWFkeSBleGlzdHMgYWxsb3dzXG5cdFx0XHQvLyB0aGUgY29kZSB0byBzaG9ydGN1dCBvbiB0aGUgc2FtZSBwYXRoIGFzIGEgRE9NIG5vZGUgd2l0aCBubyBjYWNoZVxuXHRcdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogZWxlbVsgaW50ZXJuYWxLZXkgXSAmJiBpbnRlcm5hbEtleSxcblx0XHRcdGlzRXZlbnRzID0gbmFtZSA9PT0gXCJldmVudHNcIjtcblxuXHRcdC8vIEF2b2lkIGRvaW5nIGFueSBtb3JlIHdvcmsgdGhhbiB3ZSBuZWVkIHRvIHdoZW4gdHJ5aW5nIHRvIGdldCBkYXRhIG9uIGFuXG5cdFx0Ly8gb2JqZWN0IHRoYXQgaGFzIG5vIGRhdGEgYXQgYWxsXG5cdFx0aWYgKCAoIWlkIHx8ICFjYWNoZVtpZF0gfHwgKCFpc0V2ZW50cyAmJiAhcHZ0ICYmICFjYWNoZVtpZF0uZGF0YSkpICYmIGdldEJ5TmFtZSAmJiBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhaWQgKSB7XG5cdFx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIGEgbmV3IHVuaXF1ZSBJRCBmb3IgZWFjaCBlbGVtZW50IHNpbmNlIHRoZWlyIGRhdGFcblx0XHRcdC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuXHRcdFx0aWYgKCBpc05vZGUgKSB7XG5cdFx0XHRcdGVsZW1bIGludGVybmFsS2V5IF0gPSBpZCA9ICsralF1ZXJ5LnV1aWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZCA9IGludGVybmFsS2V5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdFx0Y2FjaGVbIGlkIF0gPSB7fTtcblxuXHRcdFx0Ly8gQXZvaWRzIGV4cG9zaW5nIGpRdWVyeSBtZXRhZGF0YSBvbiBwbGFpbiBKUyBvYmplY3RzIHdoZW4gdGhlIG9iamVjdFxuXHRcdFx0Ly8gaXMgc2VyaWFsaXplZCB1c2luZyBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKCAhaXNOb2RlICkge1xuXHRcdFx0XHRjYWNoZVsgaWQgXS50b0pTT04gPSBqUXVlcnkubm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0c1xuXHRcdC8vIHNoYWxsb3cgY29waWVkIG92ZXIgb250byB0aGUgZXhpc3RpbmcgY2FjaGVcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRpZiAoIHB2dCApIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0gPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXSwgbmFtZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0uZGF0YSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLmRhdGEsIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwcml2YXRlQ2FjaGUgPSB0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcblxuXHRcdC8vIGpRdWVyeSBkYXRhKCkgaXMgc3RvcmVkIGluIGEgc2VwYXJhdGUgb2JqZWN0IGluc2lkZSB0aGUgb2JqZWN0J3MgaW50ZXJuYWwgZGF0YVxuXHRcdC8vIGNhY2hlIGluIG9yZGVyIHRvIGF2b2lkIGtleSBjb2xsaXNpb25zIGJldHdlZW4gaW50ZXJuYWwgZGF0YSBhbmQgdXNlci1kZWZpbmVkXG5cdFx0Ly8gZGF0YS5cblx0XHRpZiAoICFwdnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzQ2FjaGUuZGF0YSApIHtcblx0XHRcdFx0dGhpc0NhY2hlLmRhdGEgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0dGhpc0NhY2hlID0gdGhpc0NhY2hlLmRhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdID0gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBVc2VycyBzaG91bGQgbm90IGF0dGVtcHQgdG8gaW5zcGVjdCB0aGUgaW50ZXJuYWwgZXZlbnRzIG9iamVjdCB1c2luZyBqUXVlcnkuZGF0YSxcblx0XHQvLyBpdCBpcyB1bmRvY3VtZW50ZWQgYW5kIHN1YmplY3QgdG8gY2hhbmdlLiBCdXQgZG9lcyBhbnlvbmUgbGlzdGVuPyBOby5cblx0XHRpZiAoIGlzRXZlbnRzICYmICF0aGlzQ2FjaGVbIG5hbWUgXSApIHtcblx0XHRcdHJldHVybiBwcml2YXRlQ2FjaGUuZXZlbnRzO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBib3RoIGNvbnZlcnRlZC10by1jYW1lbCBhbmQgbm9uLWNvbnZlcnRlZCBkYXRhIHByb3BlcnR5IG5hbWVzXG5cdFx0Ly8gSWYgYSBkYXRhIHByb3BlcnR5IHdhcyBzcGVjaWZpZWRcblx0XHRpZiAoIGdldEJ5TmFtZSApIHtcblxuXHRcdFx0Ly8gRmlyc3QgVHJ5IHRvIGZpbmQgYXMtaXMgcHJvcGVydHkgZGF0YVxuXHRcdFx0cmV0ID0gdGhpc0NhY2hlWyBuYW1lIF07XG5cblx0XHRcdC8vIFRlc3QgZm9yIG51bGx8dW5kZWZpbmVkIHByb3BlcnR5IGRhdGFcblx0XHRcdGlmICggcmV0ID09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgdGhlIGNhbWVsQ2FzZWQgcHJvcGVydHlcblx0XHRcdFx0cmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gdGhpc0NhY2hlO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHB2dCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHRpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0aGlzQ2FjaGUsIGksIGwsXG5cblx0XHRcdC8vIFJlZmVyZW5jZSB0byBpbnRlcm5hbCBkYXRhIGNhY2hlIGtleVxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblxuXHRcdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdFx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdFx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogaW50ZXJuYWxLZXk7XG5cblx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cblx0XHQvLyBwdXJwb3NlIGluIGNvbnRpbnVpbmdcblx0XHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5hbWUgKSB7XG5cblx0XHRcdHRoaXNDYWNoZSA9IHB2dCA/IGNhY2hlWyBpZCBdIDogY2FjaGVbIGlkIF0uZGF0YTtcblxuXHRcdFx0aWYgKCB0aGlzQ2FjaGUgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG5hbWVzIGZvciBkYXRhIGtleXNcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIHRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBbIG5hbWUgXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBzcGxpdCB0aGUgY2FtZWwgY2FzZWQgdmVyc2lvbiBieSBzcGFjZXMgdW5sZXNzIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHNcblx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzQ2FjaGVbIG5hbWVbaV0gXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgbGVmdCBpbiB0aGUgY2FjaGUsIHdlIHdhbnQgdG8gY29udGludWVcblx0XHRcdFx0Ly8gYW5kIGxldCB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZiBnZXQgZGVzdHJveWVkXG5cdFx0XHRcdGlmICggISggcHZ0ID8gaXNFbXB0eURhdGFPYmplY3QgOiBqUXVlcnkuaXNFbXB0eU9iamVjdCApKCB0aGlzQ2FjaGUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0XHRpZiAoICFwdnQgKSB7XG5cdFx0XHRkZWxldGUgY2FjaGVbIGlkIF0uZGF0YTtcblxuXHRcdFx0Ly8gRG9uJ3QgZGVzdHJveSB0aGUgcGFyZW50IGNhY2hlIHVubGVzcyB0aGUgaW50ZXJuYWwgZGF0YSBvYmplY3Rcblx0XHRcdC8vIGhhZCBiZWVuIHRoZSBvbmx5IHRoaW5nIGxlZnQgaW4gaXRcblx0XHRcdGlmICggIWlzRW1wdHlEYXRhT2JqZWN0KGNhY2hlWyBpZCBdKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEJyb3dzZXJzIHRoYXQgZmFpbCBleHBhbmRvIGRlbGV0aW9uIGFsc28gcmVmdXNlIHRvIGRlbGV0ZSBleHBhbmRvcyBvblxuXHRcdC8vIHRoZSB3aW5kb3csIGJ1dCBpdCB3aWxsIGFsbG93IGl0IG9uIGFsbCBvdGhlciBKUyBvYmplY3RzOyBvdGhlciBicm93c2Vyc1xuXHRcdC8vIGRvbid0IGNhcmVcblx0XHQvLyBFbnN1cmUgdGhhdCBgY2FjaGVgIGlzIG5vdCBhIHdpbmRvdyBvYmplY3QgIzEwMDgwXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvIHx8ICFjYWNoZS5zZXRJbnRlcnZhbCApIHtcblx0XHRcdGRlbGV0ZSBjYWNoZVsgaWQgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVbIGlkIF0gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIFdlIGRlc3Ryb3llZCB0aGUgY2FjaGUgYW5kIG5lZWQgdG8gZWxpbWluYXRlIHRoZSBleHBhbmRvIG9uIHRoZSBub2RlIHRvIGF2b2lkXG5cdFx0Ly8gZmFsc2UgbG9va3VwcyBpbiB0aGUgY2FjaGUgZm9yIGVudHJpZXMgdGhhdCBubyBsb25nZXIgZXhpc3Rcblx0XHRpZiAoIGlzTm9kZSApIHtcblx0XHRcdC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2Rlcyxcblx0XHRcdC8vIG5vciBkb2VzIGl0IGhhdmUgYSByZW1vdmVBdHRyaWJ1dGUgZnVuY3Rpb24gb24gRG9jdW1lbnQgbm9kZXM7XG5cdFx0XHQvLyB3ZSBtdXN0IGhhbmRsZSBhbGwgb2YgdGhlc2UgY2FzZXNcblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyApIHtcblx0XHRcdFx0ZGVsZXRlIGVsZW1bIGludGVybmFsS2V5IF07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLnJlbW92ZUF0dHJpYnV0ZSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGludGVybmFsS2V5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCB0cnVlICk7XG5cdH0sXG5cblx0Ly8gQSBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgRE9NIG5vZGUgY2FuIGhhbmRsZSB0aGUgZGF0YSBleHBhbmRvXG5cdGFjY2VwdERhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5ub2RlTmFtZSApIHtcblx0XHRcdHZhciBtYXRjaCA9IGpRdWVyeS5ub0RhdGFbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRyZXR1cm4gIShtYXRjaCA9PT0gdHJ1ZSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIikgIT09IG1hdGNoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgcGFydHMsIHBhcnQsIGF0dHIsIG5hbWUsIGwsXG5cdFx0XHRlbGVtID0gdGhpc1swXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YSA9IG51bGw7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGF0dHIgPSBlbGVtLmF0dHJpYnV0ZXM7XG5cdFx0XHRcdFx0Zm9yICggbCA9IGF0dHIubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJbaV0ubmFtZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zdWJzdHJpbmcoNSkgKTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIsIDIgKTtcblx0XHRwYXJ0c1sxXSA9IHBhcnRzWzFdID8gXCIuXCIgKyBwYXJ0c1sxXSA6IFwiXCI7XG5cdFx0cGFydCA9IHBhcnRzWzFdICsgXCIhXCI7XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRhdGEgPSB0aGlzLnRyaWdnZXJIYW5kbGVyKCBcImdldERhdGFcIiArIHBhcnQsIFsgcGFydHNbMF0gXSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0byBmZXRjaCBhbnkgaW50ZXJuYWxseSBzdG9yZWQgZGF0YSBmaXJzdFxuXHRcdFx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YSggZWxlbSwga2V5ICk7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgJiYgcGFydHNbMV0gP1xuXHRcdFx0XHRcdHRoaXMuZGF0YSggcGFydHNbMF0gKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0cGFydHNbMV0gPSB2YWx1ZTtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblxuXHRcdFx0XHRzZWxmLnRyaWdnZXJIYW5kbGVyKCBcInNldERhdGFcIiArIHBhcnQsIHBhcnRzICk7XG5cdFx0XHRcdGpRdWVyeS5kYXRhKCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHRcdHNlbGYudHJpZ2dlckhhbmRsZXIoIFwiY2hhbmdlRGF0YVwiICsgcGFydCwgcGFydHMgKTtcblx0XHRcdH0pO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgZmFsc2UgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0dmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNOdW1lcmljKCBkYXRhICkgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtLCBrZXksIGRhdGEgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG4vLyBjaGVja3MgYSBjYWNoZSBvYmplY3QgZm9yIGVtcHRpbmVzc1xuZnVuY3Rpb24gaXNFbXB0eURhdGFPYmplY3QoIG9iaiApIHtcblx0Zm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuXG5cdFx0Ly8gaWYgdGhlIHB1YmxpYyBkYXRhIG9iamVjdCBpcyBlbXB0eSwgdGhlIHByaXZhdGUgaXMgc3RpbGwgZW1wdHlcblx0XHRpZiAoIG5hbWUgPT09IFwiZGF0YVwiICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvYmpbbmFtZV0gKSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoIG5hbWUgIT09IFwidG9KU09OXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZVF1ZXVlTWFya0RlZmVyKCBlbGVtLCB0eXBlLCBzcmMgKSB7XG5cdHZhciBkZWZlckRhdGFLZXkgPSB0eXBlICsgXCJkZWZlclwiLFxuXHRcdHF1ZXVlRGF0YUtleSA9IHR5cGUgKyBcInF1ZXVlXCIsXG5cdFx0bWFya0RhdGFLZXkgPSB0eXBlICsgXCJtYXJrXCIsXG5cdFx0ZGVmZXIgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIGRlZmVyRGF0YUtleSApO1xuXHRpZiAoIGRlZmVyICYmXG5cdFx0KCBzcmMgPT09IFwicXVldWVcIiB8fCAhalF1ZXJ5Ll9kYXRhKGVsZW0sIHF1ZXVlRGF0YUtleSkgKSAmJlxuXHRcdCggc3JjID09PSBcIm1hcmtcIiB8fCAhalF1ZXJ5Ll9kYXRhKGVsZW0sIG1hcmtEYXRhS2V5KSApICkge1xuXHRcdC8vIEdpdmUgcm9vbSBmb3IgaGFyZC1jb2RlZCBjYWxsYmFja3MgdG8gZmlyZSBmaXJzdFxuXHRcdC8vIGFuZCBldmVudHVhbGx5IG1hcmsvcXVldWUgc29tZXRoaW5nIGVsc2Ugb24gdGhlIGVsZW1lbnRcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5fZGF0YSggZWxlbSwgcXVldWVEYXRhS2V5ICkgJiZcblx0XHRcdFx0IWpRdWVyeS5fZGF0YSggZWxlbSwgbWFya0RhdGFLZXkgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIGRlZmVyRGF0YUtleSwgdHJ1ZSApO1xuXHRcdFx0XHRkZWZlci5maXJlKCk7XG5cdFx0XHR9XG5cdFx0fSwgMCApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdF9tYXJrOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJtYXJrXCI7XG5cdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUsIChqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKSB8fCAwKSArIDEgKTtcblx0XHR9XG5cdH0sXG5cblx0X3VubWFyazogZnVuY3Rpb24oIGZvcmNlLCBlbGVtLCB0eXBlICkge1xuXHRcdGlmICggZm9yY2UgIT09IHRydWUgKSB7XG5cdFx0XHR0eXBlID0gZWxlbTtcblx0XHRcdGVsZW0gPSBmb3JjZTtcblx0XHRcdGZvcmNlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHRcdHZhciBrZXkgPSB0eXBlICsgXCJtYXJrXCIsXG5cdFx0XHRcdGNvdW50ID0gZm9yY2UgPyAwIDogKCAoalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXkgKSB8fCAxKSAtIDEgKTtcblx0XHRcdGlmICggY291bnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwga2V5LCBjb3VudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIGtleSwgdHJ1ZSApO1xuXHRcdFx0XHRoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgXCJtYXJrXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcSB8fCBqUXVlcnkuaXNBcnJheShkYXRhKSApIHtcblx0XHRcdFx0XHRxID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0ge307XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKyBcIi5ydW5cIiwgaG9va3MgKTtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fSwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFxdWV1ZS5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArIFwicXVldWUgXCIgKyB0eXBlICsgXCIucnVuXCIsIHRydWUgKTtcblx0XHRcdGhhbmRsZVF1ZXVlTWFya0RlZmVyKCBlbGVtLCB0eXBlLCBcInF1ZXVlXCIgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHQvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5cdC8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cblx0ZGVsYXk6IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHRcdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iamVjdCApIHtcblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqZWN0ID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR2YXIgZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSBlbGVtZW50cy5sZW5ndGgsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlckRhdGFLZXkgPSB0eXBlICsgXCJkZWZlclwiLFxuXHRcdFx0cXVldWVEYXRhS2V5ID0gdHlwZSArIFwicXVldWVcIixcblx0XHRcdG1hcmtEYXRhS2V5ID0gdHlwZSArIFwibWFya1wiLFxuXHRcdFx0dG1wO1xuXHRcdGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUoIGktLSApIHtcblx0XHRcdGlmICgoIHRtcCA9IGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBkZWZlckRhdGFLZXksIHVuZGVmaW5lZCwgdHJ1ZSApIHx8XG5cdFx0XHRcdFx0KCBqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgcXVldWVEYXRhS2V5LCB1bmRlZmluZWQsIHRydWUgKSB8fFxuXHRcdFx0XHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW1lbnRzWyBpIF0sIG1hcmtEYXRhS2V5LCB1bmRlZmluZWQsIHRydWUgKSApICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW1lbnRzWyBpIF0sIGRlZmVyRGF0YUtleSwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIHRydWUgKSApKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmplY3QgKTtcblx0fVxufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcblxcdFxccl0vZyxcblx0cnNwYWNlID0gL1xccysvLFxuXHRycmV0dXJuID0gL1xcci9nLFxuXHRydHlwZSA9IC9eKD86YnV0dG9ufGlucHV0KSQvaSxcblx0cmZvY3VzYWJsZSA9IC9eKD86YnV0dG9ufGlucHV0fG9iamVjdHxzZWxlY3R8dGV4dGFyZWEpJC9pLFxuXHRyY2xpY2thYmxlID0gL15hKD86cmVhKT8kL2ksXG5cdHJib29sZWFuID0gL14oPzphdXRvZm9jdXN8YXV0b3BsYXl8YXN5bmN8Y2hlY2tlZHxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZHxzZWxlY3RlZCkkL2ksXG5cdGdldFNldEF0dHJpYnV0ZSA9IGpRdWVyeS5zdXBwb3J0LmdldFNldEF0dHJpYnV0ZSxcblx0bm9kZUhvb2ssIGJvb2xIb29rLCBmaXhTcGVjaWZpZWQ7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB0cnkvY2F0Y2ggaGFuZGxlcyBjYXNlcyB3aGVyZSBJRSBiYWxrcyAoc3VjaCBhcyByZW1vdmluZyBhIHByb3BlcnR5IG9uIHdpbmRvdylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXNbIG5hbWUgXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0ZGVsZXRlIHRoaXNbIG5hbWUgXTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGksIGwsIGVsZW0sXG5cdFx0XHRzZXRDbGFzcywgYywgY2w7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaiwgdGhpcy5jbGFzc05hbWUpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCggcnNwYWNlICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggIWVsZW0uY2xhc3NOYW1lICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSB2YWx1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXRDbGFzcyA9IFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0Zm9yICggYyA9IDAsIGNsID0gY2xhc3NOYW1lcy5sZW5ndGg7IGMgPCBjbDsgYysrICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICF+c2V0Q2xhc3MuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIiApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldENsYXNzICs9IGNsYXNzTmFtZXNbIGMgXSArIFwiIFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKCBzZXRDbGFzcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGksIGwsIGVsZW0sIGNsYXNzTmFtZSwgYywgY2w7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaiwgdGhpcy5jbGFzc05hbWUpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHx8IHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjbGFzc05hbWVzID0gKCB2YWx1ZSB8fCBcIlwiICkuc3BsaXQoIHJzcGFjZSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gKFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0Zm9yICggYyA9IDAsIGNsID0gY2xhc3NOYW1lcy5sZW5ndGg7IGMgPCBjbDsgYysrICkge1xuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShcIiBcIiArIGNsYXNzTmFtZXNbIGMgXSArIFwiIFwiLCBcIiBcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKCBjbGFzc05hbWUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc0Jvb2wgPSB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlVmFsLFxuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCggcnNwYWNlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBlcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdHN0YXRlID0gaXNCb29sID8gc3RhdGUgOiAhc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0c2VsZlsgc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCIgXSggY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRvZ2dsZSB3aG9sZSBjbGFzc05hbWVcblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIHNlbGYudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gYXR0cmlidXRlcy52YWx1ZSBpcyB1bmRlZmluZWQgaW4gQmxhY2tiZXJyeSA0LjcgYnV0XG5cdFx0XHRcdC8vIHVzZXMgLnZhbHVlLiBTZWUgIzY5MzJcblx0XHRcdFx0dmFyIHZhbCA9IGVsZW0uYXR0cmlidXRlcy52YWx1ZTtcblx0XHRcdFx0cmV0dXJuICF2YWwgfHwgdmFsLnNwZWNpZmllZCA/IGVsZW0udmFsdWUgOiBlbGVtLnRleHQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgaSwgbWF4LCBvcHRpb24sXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0dmFsdWVzID0gW10sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiO1xuXG5cdFx0XHRcdC8vIE5vdGhpbmcgd2FzIHNlbGVjdGVkXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkICYmIChqUXVlcnkuc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT09IG51bGwpICYmXG5cdFx0XHRcdFx0XHRcdCghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZpeGVzIEJ1ZyAjMjU1MSAtLSBzZWxlY3QudmFsKCkgYnJva2VuIGluIElFIGFmdGVyIGZvcm0ucmVzZXQoKVxuXHRcdFx0XHRpZiAoIG9uZSAmJiAhdmFsdWVzLmxlbmd0aCAmJiBvcHRpb25zLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5KCBvcHRpb25zWyBpbmRleCBdICkudmFsKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdGpRdWVyeShlbGVtKS5maW5kKFwib3B0aW9uXCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkodGhpcykudmFsKCksIHZhbHVlcyApID49IDA7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICggIXZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckZuOiB7XG5cdFx0dmFsOiB0cnVlLFxuXHRcdGNzczogdHJ1ZSxcblx0XHRodG1sOiB0cnVlLFxuXHRcdHRleHQ6IHRydWUsXG5cdFx0ZGF0YTogdHJ1ZSxcblx0XHR3aWR0aDogdHJ1ZSxcblx0XHRoZWlnaHQ6IHRydWUsXG5cdFx0b2Zmc2V0OiB0cnVlXG5cdH0sXG5cblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBwYXNzICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHBhc3MgJiYgbmFtZSBpbiBqUXVlcnkuYXR0ckZuICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApWyBuYW1lIF0oIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8ICggcmJvb2xlYW4udGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIG5vdHhtbCAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJcIiArIHZhbHVlICk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgbm90eG1sICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT09IG51bGwgP1xuXHRcdFx0XHR1bmRlZmluZWQgOlxuXHRcdFx0XHRyZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcE5hbWUsIGF0dHJOYW1lcywgbmFtZSwgbCwgaXNCb29sLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIHZhbHVlICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCByc3BhY2UgKTtcblx0XHRcdGwgPSBhdHRyTmFtZXMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5hbWUgPSBhdHRyTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIG5hbWUgKSB7XG5cdFx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0aXNCb29sID0gcmJvb2xlYW4udGVzdCggbmFtZSApO1xuXG5cdFx0XHRcdFx0Ly8gU2VlICM5Njk5IGZvciBleHBsYW5hdGlvbiBvZiB0aGlzIGFwcHJvYWNoIChzZXR0aW5nIGZpcnN0LCB0aGVuIHJlbW92YWwpXG5cdFx0XHRcdFx0Ly8gRG8gbm90IGRvIHRoaXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyAoc2VlICMxMDg3MClcblx0XHRcdFx0XHRpZiAoICFpc0Jvb2wgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuYXR0ciggZWxlbSwgbmFtZSwgXCJcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggZ2V0U2V0QXR0cmlidXRlID8gbmFtZSA6IHByb3BOYW1lICk7XG5cblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0aWYgKCBpc0Jvb2wgJiYgcHJvcE5hbWUgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdC8vIFdlIGNhbid0IGFsbG93IHRoZSB0eXBlIHByb3BlcnR5IHRvIGJlIGNoYW5nZWQgKHNpbmNlIGl0IGNhdXNlcyBwcm9ibGVtcyBpbiBJRSlcblx0XHRcdFx0aWYgKCBydHlwZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lcnJvciggXCJ0eXBlIHByb3BlcnR5IGNhbid0IGJlIGNoYW5nZWRcIiApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAhalF1ZXJ5LnN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlucHV0XCIpICkge1xuXHRcdFx0XHRcdC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU2LTlcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBpdCdzIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZVxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZm9yIGVsZW1lbnQgY3JlYXRpb25cblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIFVzZSB0aGUgdmFsdWUgcHJvcGVydHkgZm9yIGJhY2sgY29tcGF0XG5cdFx0Ly8gVXNlIHRoZSBub2RlSG9vayBmb3IgYnV0dG9uIGVsZW1lbnRzIGluIElFNi83ICgjMTk1NClcblx0XHR2YWx1ZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRcdFx0aWYgKCBub2RlSG9vayAmJiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZUhvb2suZ2V0KCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5hbWUgaW4gZWxlbSA/XG5cdFx0XHRcdFx0ZWxlbS52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdFx0aWYgKCBub2RlSG9vayAmJiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERvZXMgbm90IHJldHVybiBzbyB0aGF0IHNldEF0dHJpYnV0ZSBpcyBhbHNvIHVzZWRcblx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0dGFiaW5kZXg6IFwidGFiSW5kZXhcIixcblx0XHRyZWFkb25seTogXCJyZWFkT25seVwiLFxuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcblx0XHRtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG5cdFx0Y2VsbHNwYWNpbmc6IFwiY2VsbFNwYWNpbmdcIixcblx0XHRjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuXHRcdHJvd3NwYW46IFwicm93U3BhblwiLFxuXHRcdGNvbHNwYW46IFwiY29sU3BhblwiLFxuXHRcdHVzZW1hcDogXCJ1c2VNYXBcIixcblx0XHRmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuXHRcdGNvbnRlbnRlZGl0YWJsZTogXCJjb250ZW50RWRpdGFibGVcIlxuXHR9LFxuXG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcywgbm90eG1sLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApO1xuXG5cdFx0aWYgKCBub3R4bWwgKSB7XG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwidGFiaW5kZXhcIik7XG5cblx0XHRcdFx0cmV0dXJuIGF0dHJpYnV0ZU5vZGUgJiYgYXR0cmlidXRlTm9kZS5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHBhcnNlSW50KCBhdHRyaWJ1dGVOb2RlLnZhbHVlLCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fCByY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQWRkIHRoZSB0YWJJbmRleCBwcm9wSG9vayB0byBhdHRySG9va3MgZm9yIGJhY2stY29tcGF0IChkaWZmZXJlbnQgY2FzZSBpcyBpbnRlbnRpb25hbClcbmpRdWVyeS5hdHRySG9va3MudGFiaW5kZXggPSBqUXVlcnkucHJvcEhvb2tzLnRhYkluZGV4O1xuXG4vLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdC8vIEFsaWduIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuXHRcdC8vIEZhbGwgYmFjayB0byBhdHRyaWJ1dGUgcHJlc2VuY2Ugd2hlcmUgc29tZSBib29sZWFucyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdHZhciBhdHRyTm9kZSxcblx0XHRcdHByb3BlcnR5ID0galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUgKTtcblx0XHRyZXR1cm4gcHJvcGVydHkgPT09IHRydWUgfHwgdHlwZW9mIHByb3BlcnR5ICE9PSBcImJvb2xlYW5cIiAmJiAoIGF0dHJOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpICkgJiYgYXR0ck5vZGUubm9kZVZhbHVlICE9PSBmYWxzZSA/XG5cdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YXIgcHJvcE5hbWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB2YWx1ZSBpcyB0cnVlIHNpbmNlIHdlIGtub3cgYXQgdGhpcyBwb2ludCBpdCdzIHR5cGUgYm9vbGVhbiBhbmQgbm90IGZhbHNlXG5cdFx0XHQvLyBTZXQgYm9vbGVhbiBhdHRyaWJ1dGVzIHRvIHRoZSBzYW1lIG5hbWUgYW5kIHNldCB0aGUgRE9NIHByb3BlcnR5XG5cdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGlmICggcHJvcE5hbWUgaW4gZWxlbSApIHtcblx0XHRcdFx0Ly8gT25seSBzZXQgdGhlIElETCBzcGVjaWZpY2FsbHkgaWYgaXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbi8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlXG5pZiAoICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG5cblx0Zml4U3BlY2lmaWVkID0ge1xuXHRcdG5hbWU6IHRydWUsXG5cdFx0aWQ6IHRydWUsXG5cdFx0Y29vcmRzOiB0cnVlXG5cdH07XG5cblx0Ly8gVXNlIHRoaXMgZm9yIGFueSBhdHRyaWJ1dGUgaW4gSUU2Lzdcblx0Ly8gVGhpcyBmaXhlcyBhbG1vc3QgZXZlcnkgSUU2LzcgaXNzdWVcblx0bm9kZUhvb2sgPSBqUXVlcnkudmFsSG9va3MuYnV0dG9uID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmV0O1xuXHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRyZXR1cm4gcmV0ICYmICggZml4U3BlY2lmaWVkWyBuYW1lIF0gPyByZXQubm9kZVZhbHVlICE9PSBcIlwiIDogcmV0LnNwZWNpZmllZCApID9cblx0XHRcdFx0cmV0Lm5vZGVWYWx1ZSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0Ly8gU2V0IHRoZSBleGlzdGluZyBvciBjcmVhdGUgYSBuZXcgYXR0cmlidXRlIG5vZGVcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0cmV0ID0gZG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlTm9kZSggcmV0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCByZXQubm9kZVZhbHVlID0gdmFsdWUgKyBcIlwiICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFwcGx5IHRoZSBub2RlSG9vayB0byB0YWJpbmRleFxuXHRqUXVlcnkuYXR0ckhvb2tzLnRhYmluZGV4LnNldCA9IG5vZGVIb29rLnNldDtcblxuXHQvLyBTZXQgd2lkdGggYW5kIGhlaWdodCB0byBhdXRvIGluc3RlYWQgb2YgMCBvbiBlbXB0eSBzdHJpbmcoIEJ1ZyAjODE1MCApXG5cdC8vIFRoaXMgaXMgZm9yIHJlbW92YWxzXG5cdGpRdWVyeS5lYWNoKFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiYXV0b1wiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIFNldCBjb250ZW50ZWRpdGFibGUgdG8gZmFsc2Ugb24gcmVtb3ZhbHMoIzEwNDI5KVxuXHQvLyBTZXR0aW5nIHRvIGVtcHR5IHN0cmluZyB0aHJvd3MgYW4gZXJyb3IgYXMgYW4gaW52YWxpZCB2YWx1ZVxuXHRqUXVlcnkuYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZSA9IHtcblx0XHRnZXQ6IG5vZGVIb29rLmdldCxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gXCJmYWxzZVwiO1xuXHRcdFx0fVxuXHRcdFx0bm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4vLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgKSB7XG5cdGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0sIHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgMiApO1xuXHRcdFx0XHRyZXR1cm4gcmV0ID09PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3R5bGUgKSB7XG5cdGpRdWVyeS5hdHRySG9va3Muc3R5bGUgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBOb3JtYWxpemUgdG8gbG93ZXJjYXNlIHNpbmNlIElFIHVwcGVyY2FzZXMgY3NzIHByb3BlcnR5IG5hbWVzXG5cdFx0XHRyZXR1cm4gZWxlbS5zdHlsZS5jc3NUZXh0LnRvTG93ZXJDYXNlKCkgfHwgdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtLnN0eWxlLmNzc1RleHQgPSBcIlwiICsgdmFsdWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbi8vIEFjY2Vzc2luZyB0aGUgcGFyZW50J3Mgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBmaXhlcyBpdFxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBJRTYvNyBjYWxsIGVuY3R5cGUgZW5jb2RpbmdcbmlmICggIWpRdWVyeS5zdXBwb3J0LmVuY3R5cGUgKSB7XG5cdGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG59XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5jaGVja09uICkge1xuXHRqUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGluIFdlYmtpdCBcIlwiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cbmpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0sIHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxuXG5cblxudmFyIHJmb3JtRWxlbXMgPSAvXig/OnRleHRhcmVhfGlucHV0fHNlbGVjdCkkL2ksXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW15cXC5dKik/KD86XFwuKC4rKSk/JC8sXG5cdHJob3ZlckhhY2sgPSAvKD86XnxcXHMpaG92ZXIoXFwuXFxTKyk/XFxiLyxcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJxdWlja0lzID0gL14oXFx3KikoPzojKFtcXHdcXC1dKykpPyg/OlxcLihbXFx3XFwtXSspKT8kLyxcblx0cXVpY2tQYXJzZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgcXVpY2sgPSBycXVpY2tJcy5leGVjKCBzZWxlY3RvciApO1xuXHRcdGlmICggcXVpY2sgKSB7XG5cdFx0XHQvLyAgIDAgIDEgICAgMiAgIDNcblx0XHRcdC8vIFsgXywgdGFnLCBpZCwgY2xhc3MgXVxuXHRcdFx0cXVpY2tbMV0gPSAoIHF1aWNrWzFdIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cXVpY2tbM10gPSBxdWlja1szXSAmJiBuZXcgUmVnRXhwKCBcIig/Ol58XFxcXHMpXCIgKyBxdWlja1szXSArIFwiKD86XFxcXHN8JClcIiApO1xuXHRcdH1cblx0XHRyZXR1cm4gcXVpY2s7XG5cdH0sXG5cdHF1aWNrSXMgPSBmdW5jdGlvbiggZWxlbSwgbSApIHtcblx0XHR2YXIgYXR0cnMgPSBlbGVtLmF0dHJpYnV0ZXMgfHwge307XG5cdFx0cmV0dXJuIChcblx0XHRcdCghbVsxXSB8fCBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG1bMV0pICYmXG5cdFx0XHQoIW1bMl0gfHwgKGF0dHJzLmlkIHx8IHt9KS52YWx1ZSA9PT0gbVsyXSkgJiZcblx0XHRcdCghbVszXSB8fCBtWzNdLnRlc3QoIChhdHRyc1sgXCJjbGFzc1wiIF0gfHwge30pLnZhbHVlICkpXG5cdFx0KTtcblx0fSxcblx0aG92ZXJIYWNrID0gZnVuY3Rpb24oIGV2ZW50cyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnNwZWNpYWwuaG92ZXIgPyBldmVudHMgOiBldmVudHMucmVwbGFjZSggcmhvdmVySGFjaywgXCJtb3VzZWVudGVyJDEgbW91c2VsZWF2ZSQxXCIgKTtcblx0fTtcblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgZWxlbURhdGEsIGV2ZW50SGFuZGxlLCBldmVudHMsXG5cdFx0XHR0LCB0bnMsIHR5cGUsIG5hbWVzcGFjZXMsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZU9iakluLCBxdWljaywgaGFuZGxlcnMsIHNwZWNpYWw7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGFsbG93IHBsYWluIG9iamVjdHMgdGhvKVxuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICF0eXBlcyB8fCAhaGFuZGxlciB8fCAhKGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICkpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cztcblx0XHRpZiAoICFldmVudHMgKSB7XG5cdFx0XHRlbGVtRGF0YS5ldmVudHMgPSBldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0aWYgKCAhZXZlbnRIYW5kbGUgKSB7XG5cdFx0XHRlbGVtRGF0YS5oYW5kbGUgPSBldmVudEhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmICghZSB8fCBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUpID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGV2ZW50SGFuZGxlLmVsZW0sIGFyZ3VtZW50cyApIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gQWRkIGVsZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlIGZuIHRvIHByZXZlbnQgYSBtZW1vcnkgbGVhayB3aXRoIElFIG5vbi1uYXRpdmUgZXZlbnRzXG5cdFx0XHRldmVudEhhbmRsZS5lbGVtID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0Ly8galF1ZXJ5KC4uLikuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XG5cdFx0dHlwZXMgPSBqUXVlcnkudHJpbSggaG92ZXJIYWNrKHR5cGVzKSApLnNwbGl0KCBcIiBcIiApO1xuXHRcdGZvciAoIHQgPSAwOyB0IDwgdHlwZXMubGVuZ3RoOyB0KysgKSB7XG5cblx0XHRcdHRucyA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gdG5zWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG5zWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogdG5zWzFdLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0cXVpY2s6IHNlbGVjdG9yICYmIHF1aWNrUGFyc2UoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF07XG5cdFx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyL2F0dGFjaEV2ZW50IGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fCBzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIEJpbmQgdGhlIGdsb2JhbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdGVsZW0uYXR0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gTnVsbGlmeSBlbGVtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG5cdFx0ZWxlbSA9IG51bGw7XG5cdH0sXG5cblx0Z2xvYmFsOiB7fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICksXG5cdFx0XHR0LCB0bnMsIHR5cGUsIG9yaWdUeXBlLCBuYW1lc3BhY2VzLCBvcmlnQ291bnQsXG5cdFx0XHRqLCBldmVudHMsIHNwZWNpYWwsIGhhbmRsZSwgZXZlbnRUeXBlLCBoYW5kbGVPYmo7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0galF1ZXJ5LnRyaW0oIGhvdmVySGFjayggdHlwZXMgfHwgXCJcIiApICkuc3BsaXQoXCIgXCIpO1xuXHRcdGZvciAoIHQgPSAwOyB0IDwgdHlwZXMubGVuZ3RoOyB0KysgKSB7XG5cdFx0XHR0bnMgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG5zWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9IHRuc1syXTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3Rvcj8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGV2ZW50VHlwZSA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0b3JpZ0NvdW50ID0gZXZlbnRUeXBlLmxlbmd0aDtcblx0XHRcdG5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzID8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5zcGxpdChcIi5cIikuc29ydCgpLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC4pP1wiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbDtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBldmVudFR5cGUubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50VHlwZVsgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQgKCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQgKCAhbmFtZXNwYWNlcyB8fCBuYW1lc3BhY2VzLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0ICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRldmVudFR5cGUuc3BsaWNlKCBqLS0sIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0ZXZlbnRUeXBlLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggZXZlbnRUeXBlLmxlbmd0aCA9PT0gMCAmJiBvcmlnQ291bnQgIT09IGV2ZW50VHlwZS5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuZWxlbSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XG5cdFx0XHQvLyBzbyB1c2UgaXQgaW5zdGVhZCBvZiBkZWxldGVcblx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBbIFwiZXZlbnRzXCIsIFwiaGFuZGxlXCIgXSwgdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBFdmVudHMgdGhhdCBhcmUgc2FmZSB0byBzaG9ydC1jaXJjdWl0IGlmIG5vIGhhbmRsZXJzIGFyZSBhdHRhY2hlZC5cblx0Ly8gTmF0aXZlIERPTSBldmVudHMgc2hvdWxkIG5vdCBiZSBhZGRlZCwgdGhleSBtYXkgaGF2ZSBpbmxpbmUgaGFuZGxlcnMuXG5cdGN1c3RvbUV2ZW50OiB7XG5cdFx0XCJnZXREYXRhXCI6IHRydWUsXG5cdFx0XCJzZXREYXRhXCI6IHRydWUsXG5cdFx0XCJjaGFuZ2VEYXRhXCI6IHRydWVcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbSAmJiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBFdmVudCBvYmplY3Qgb3IgZXZlbnQgdHlwZVxuXHRcdHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBbXSxcblx0XHRcdGNhY2hlLCBleGNsdXNpdmUsIGksIGN1ciwgb2xkLCBvbnR5cGUsIHNwZWNpYWwsIGhhbmRsZSwgZXZlbnRQYXRoLCBidWJibGVUeXBlO1xuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIiFcIiApID49IDAgKSB7XG5cdFx0XHQvLyBFeGNsdXNpdmUgZXZlbnRzIHRyaWdnZXIgb25seSBmb3IgdGhlIGV4YWN0IGV2ZW50IChubyBuYW1lc3BhY2VzKVxuXHRcdFx0dHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuXHRcdFx0ZXhjbHVzaXZlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+PSAwICkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblxuXHRcdGlmICggKCFlbGVtIHx8IGpRdWVyeS5ldmVudC5jdXN0b21FdmVudFsgdHlwZSBdKSAmJiAhalF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdICkge1xuXHRcdFx0Ly8gTm8galF1ZXJ5IGhhbmRsZXJzIGZvciB0aGlzIGV2ZW50IHR5cGUsIGFuZCBpdCBjYW4ndCBoYXZlIGlubGluZSBoYW5kbGVyc1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBFdmVudCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgP1xuXHRcdFx0Ly8galF1ZXJ5LkV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gPyBldmVudCA6XG5cdFx0XHQvLyBPYmplY3QgbGl0ZXJhbFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgZXZlbnQgKSA6XG5cdFx0XHQvLyBKdXN0IHRoZSBldmVudCB0eXBlIChzdHJpbmcpXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlICk7XG5cblx0XHRldmVudC50eXBlID0gdHlwZTtcblx0XHRldmVudC5pc1RyaWdnZXIgPSB0cnVlO1xuXHRcdGV2ZW50LmV4Y2x1c2l2ZSA9IGV4Y2x1c2l2ZTtcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC4pP1wiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbDtcblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwID8gXCJvblwiICsgdHlwZSA6IFwiXCI7XG5cblx0XHQvLyBIYW5kbGUgYSBnbG9iYWwgdHJpZ2dlclxuXHRcdGlmICggIWVsZW0gKSB7XG5cblx0XHRcdC8vIFRPRE86IFN0b3AgdGF1bnRpbmcgdGhlIGRhdGEgY2FjaGU7IHJlbW92ZSBnbG9iYWwgZXZlbnRzIGFuZCBhbHdheXMgYXR0YWNoIHRvIGRvY3VtZW50XG5cdFx0XHRjYWNoZSA9IGpRdWVyeS5jYWNoZTtcblx0XHRcdGZvciAoIGkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdGlmICggY2FjaGVbIGkgXS5ldmVudHMgJiYgY2FjaGVbIGkgXS5ldmVudHNbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZXZlbnQsIGRhdGEsIGNhY2hlWyBpIF0uaGFuZGxlLmVsZW0sIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSAhPSBudWxsID8galF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApIDogW107XG5cdFx0ZGF0YS51bnNoaWZ0KCBldmVudCApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGV2ZW50UGF0aCA9IFtbIGVsZW0sIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZSBdXTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGN1ciA9IHJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgPyBlbGVtIDogZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0b2xkID0gbnVsbDtcblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goWyBjdXIsIGJ1YmJsZVR5cGUgXSk7XG5cdFx0XHRcdG9sZCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIG9sZCAmJiBvbGQgPT09IGVsZW0ub3duZXJEb2N1bWVudCApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goWyBvbGQuZGVmYXVsdFZpZXcgfHwgb2xkLnBhcmVudFdpbmRvdyB8fCB3aW5kb3csIGJ1YmJsZVR5cGUgXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGZvciAoIGkgPSAwOyBpIDwgZXZlbnRQYXRoLmxlbmd0aCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTsgaSsrICkge1xuXG5cdFx0XHRjdXIgPSBldmVudFBhdGhbaV1bMF07XG5cdFx0XHRldmVudC50eXBlID0gZXZlbnRQYXRoW2ldWzFdO1xuXG5cdFx0XHRoYW5kbGUgPSAoIGpRdWVyeS5fZGF0YSggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmIGpRdWVyeS5fZGF0YSggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblx0XHRcdC8vIE5vdGUgdGhhdCB0aGlzIGlzIGEgYmFyZSBKUyBmdW5jdGlvbiBhbmQgbm90IGEgalF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICYmIGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBlbGVtLm93bmVyRG9jdW1lbnQsIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdCEodHlwZSA9PT0gXCJjbGlja1wiICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJhXCIgKSkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0Ly8gSUU8OSBkaWVzIG9uIGZvY3VzL2JsdXIgdG8gaGlkZGVuIGVsZW1lbnQgKCMxNDg2KVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBlbGVtWyB0eXBlIF0gJiYgKCh0eXBlICE9PSBcImZvY3VzXCIgJiYgdHlwZSAhPT0gXCJibHVyXCIpIHx8IGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aCAhPT0gMCkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdG9sZCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBvbGQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCBvbGQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG9sZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50IHx8IHdpbmRvdy5ldmVudCApO1xuXG5cdFx0dmFyIGhhbmRsZXJzID0gKCAoalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdKSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0YXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApLFxuXHRcdFx0cnVuX2FsbCA9ICFldmVudC5leGNsdXNpdmUgJiYgIWV2ZW50Lm5hbWVzcGFjZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9LFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRpLCBqLCBjdXIsIGpxY3VyLCByZXQsIHNlbE1hdGNoLCBtYXRjaGVkLCBtYXRjaGVzLCBoYW5kbGVPYmosIHNlbCwgcmVsYXRlZDtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnMgdGhhdCBzaG91bGQgcnVuIGlmIHRoZXJlIGFyZSBkZWxlZ2F0ZWQgZXZlbnRzXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmICEoZXZlbnQuYnV0dG9uICYmIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikgKSB7XG5cblx0XHRcdC8vIFByZWdlbmVyYXRlIGEgc2luZ2xlIGpRdWVyeSBvYmplY3QgZm9yIHJldXNlIHdpdGggLmlzKClcblx0XHRcdGpxY3VyID0galF1ZXJ5KHRoaXMpO1xuXHRcdFx0anFjdXIuY29udGV4dCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzO1xuXG5cdFx0XHRmb3IgKCBjdXIgPSBldmVudC50YXJnZXQ7IGN1ciAhPSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgZXZlbnRzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUpXG5cdFx0XHRcdGlmICggY3VyLmRpc2FibGVkICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdHNlbE1hdGNoID0ge307XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGpxY3VyWzBdID0gY3VyO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvcjtcblxuXHRcdFx0XHRcdFx0aWYgKCBzZWxNYXRjaFsgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0c2VsTWF0Y2hbIHNlbCBdID0gKFxuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZU9iai5xdWljayA/IHF1aWNrSXMoIGN1ciwgaGFuZGxlT2JqLnF1aWNrICkgOiBqcWN1ci5pcyggc2VsIClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggc2VsTWF0Y2hbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIG1hdGNoZXM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggaGFuZGxlcnMubGVuZ3RoID4gZGVsZWdhdGVDb3VudCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgbWF0Y2hlczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgaGFuZGxlclF1ZXVlLmxlbmd0aCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTsgaSsrICkge1xuXHRcdFx0bWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSBdO1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBtYXRjaGVkLm1hdGNoZXMubGVuZ3RoICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpOyBqKysgKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IG1hdGNoZWQubWF0Y2hlc1sgaiBdO1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBiZSBub24tZXhjbHVzaXZlIGFuZCBoYXZlIG5vIG5hbWVzcGFjZSwgb3Jcblx0XHRcdFx0Ly8gMikgaGF2ZSBuYW1lc3BhY2UocykgYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggcnVuX2FsbCB8fCAoIWV2ZW50Lm5hbWVzcGFjZSAmJiAhaGFuZGxlT2JqLm5hbWVzcGFjZSkgfHwgZXZlbnQubmFtZXNwYWNlX3JlICYmIGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnJlc3VsdCA9IHJldDtcblx0XHRcdFx0XHRcdGlmICggcmV0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0Ly8gKioqIGF0dHJDaGFuZ2UgYXR0ck5hbWUgcmVsYXRlZE5vZGUgc3JjRWxlbWVudCAgYXJlIG5vdCBub3JtYWxpemVkLCBub24tVzNDLCBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMS44ICoqKlxuXHRwcm9wczogXCJhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcblx0XHRcdFx0ZnJvbUVsZW1lbnQgPSBvcmlnaW5hbC5mcm9tRWxlbWVudDtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcblx0XHRcdFx0ZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBvcmlnaW5hbC50b0VsZW1lbnQgOiBmcm9tRWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSBqUXVlcnkuZXZlbnQuZml4SG9va3NbIGV2ZW50LnR5cGUgXSB8fCB7fSxcblx0XHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0Zm9yICggaSA9IGNvcHkubGVuZ3RoOyBpOyApIHtcblx0XHRcdHByb3AgPSBjb3B5WyAtLWkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gRml4IHRhcmdldCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5ICgjMTkyNSwgSUUgNi83LzggJiBTYWZhcmkyKVxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgU2FmYXJpKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIG1vdXNlL2tleSBldmVudHM7IGFkZCBtZXRhS2V5IGlmIGl0J3Mgbm90IHRoZXJlICgjMzM2OCwgSUU2LzcvOClcblx0XHRpZiAoIGV2ZW50Lm1ldGFLZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGV2ZW50Lm1ldGFLZXkgPSBldmVudC5jdHJsS2V5O1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlcj8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0cmVhZHk6IHtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgcmVhZHkgZXZlbnQgaXMgc2V0dXBcblx0XHRcdHNldHVwOiBqUXVlcnkuYmluZFJlYWR5XG5cdFx0fSxcblxuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblxuXHRcdGZvY3VzOiB7XG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSB7XG5cdFx0XHRcdC8vIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIHNwZWNpYWwgY2FzZSBvbiB3aW5kb3dzXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5vbmJlZm9yZXVubG9hZCA9IGV2ZW50SGFuZGxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub25iZWZvcmV1bmxvYWQgPT09IGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHRcdHRoaXMub25iZWZvcmV1bmxvYWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7IHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxuLy8gU29tZSBwbHVnaW5zIGFyZSB1c2luZywgYnV0IGl0J3MgdW5kb2N1bWVudGVkL2RlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZC5cbi8vIFRoZSAxLjcgc3BlY2lhbCBldmVudCBpbnRlcmZhY2Ugc2hvdWxkIHByb3ZpZGUgYWxsIHRoZSBob29rcyBuZWVkZWQgbm93LlxualF1ZXJ5LmV2ZW50LmhhbmRsZSA9IGpRdWVyeS5ldmVudC5kaXNwYXRjaDtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG5cdGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdFx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0gOlxuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdGlmICggZWxlbS5kZXRhY2hFdmVudCApIHtcblx0XHRcdGVsZW0uZGV0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIGhhbmRsZSApO1xuXHRcdH1cblx0fTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKCBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fCBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlIHx8XG5cdFx0XHRzcmMuZ2V0UHJldmVudERlZmF1bHQgJiYgc3JjLmdldFByZXZlbnREZWZhdWx0KCkgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlIChJRSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXHRcdGlmICggIWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5zdG9wUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0XHQvLyBvdGhlcndpc2Ugc2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIHRydWUgKElFKVxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG5qUXVlcnkuZWFjaCh7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iaixcblx0XHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdHJldDtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIElFIHN1Ym1pdCBkZWxlZ2F0aW9uXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5zdWJtaXRCdWJibGVzICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLnN1Ym1pdCA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBPbmx5IG5lZWQgdGhpcyBmb3IgZGVsZWdhdGVkIGZvcm0gc3VibWl0IGV2ZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBOb2RlIG5hbWUgY2hlY2sgYXZvaWRzIGEgVk1MLXJlbGF0ZWQgY3Jhc2ggaW4gSUUgKCM5ODA3KVxuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0LFxuXHRcdFx0XHRcdGZvcm0gPSBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApID8gZWxlbS5mb3JtIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoIGZvcm0gJiYgIWZvcm0uX3N1Ym1pdF9hdHRhY2hlZCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBmb3JtLCBcInN1Ym1pdC5fc3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50Ll9zdWJtaXRfYnViYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRmb3JtLl9zdWJtaXRfYXR0YWNoZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UgZG9uJ3QgbmVlZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdH0sXG5cdFx0XG5cdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHQvLyBJZiBmb3JtIHdhcyBzdWJtaXR0ZWQgYnkgdGhlIHVzZXIsIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIHRyZWVcblx0XHRcdGlmICggZXZlbnQuX3N1Ym1pdF9idWJibGUgKSB7XG5cdFx0XHRcdGRlbGV0ZSBldmVudC5fc3VibWl0X2J1YmJsZTtcblx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwic3VibWl0XCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBPbmx5IG5lZWQgdGhpcyBmb3IgZGVsZWdhdGVkIGZvcm0gc3VibWl0IGV2ZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGRlbGVnYXRlZCBoYW5kbGVyczsgY2xlYW5EYXRhIGV2ZW50dWFsbHkgcmVhcHMgc3VibWl0IGhhbmRsZXJzIGF0dGFjaGVkIGFib3ZlXG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fc3VibWl0XCIgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIElFIGNoYW5nZSBkZWxlZ2F0aW9uIGFuZCBjaGVja2JveC9yYWRpbyBmaXhcbmlmICggIWpRdWVyeS5zdXBwb3J0LmNoYW5nZUJ1YmJsZXMgKSB7XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge1xuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApICkge1xuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IGZpcmUgY2hhbmdlIG9uIGEgY2hlY2svcmFkaW8gdW50aWwgYmx1cjsgdHJpZ2dlciBpdCBvbiBjbGlja1xuXHRcdFx0XHQvLyBhZnRlciBhIHByb3BlcnR5Y2hhbmdlLiBFYXQgdGhlIGJsdXItY2hhbmdlIGluIHNwZWNpYWwuY2hhbmdlLmhhbmRsZS5cblx0XHRcdFx0Ly8gVGhpcyBzdGlsbCBmaXJlcyBvbmNoYW5nZSBhIHNlY29uZCB0aW1lIGZvciBjaGVjay9yYWRpbyBhZnRlciBibHVyLlxuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lID09PSBcImNoZWNrZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcywgZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZWxlZ2F0ZWQgZXZlbnQ7IGxhenktYWRkIGEgY2hhbmdlIGhhbmRsZXIgb24gZGVzY2VuZGFudCBpbnB1dHNcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiYmVmb3JlYWN0aXZhdGUuX2NoYW5nZVwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldDtcblxuXHRcdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggZWxlbS5ub2RlTmFtZSApICYmICFlbGVtLl9jaGFuZ2VfYXR0YWNoZWQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWxlbSwgXCJjaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNTaW11bGF0ZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxlbS5fY2hhbmdlX2F0dGFjaGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGVsZW0gPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdC8vIFN3YWxsb3cgbmF0aXZlIGNoYW5nZSBldmVudHMgZnJvbSBjaGVja2JveC9yYWRpbywgd2UgYWxyZWFkeSB0cmlnZ2VyZWQgdGhlbSBhYm92ZVxuXHRcdFx0aWYgKCB0aGlzICE9PSBlbGVtIHx8IGV2ZW50LmlzU2ltdWxhdGVkIHx8IGV2ZW50LmlzVHJpZ2dlciB8fCAoZWxlbS50eXBlICE9PSBcInJhZGlvXCIgJiYgZWxlbS50eXBlICE9PSBcImNoZWNrYm94XCIpICkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fY2hhbmdlXCIgKTtcblxuXHRcdFx0cmV0dXJuIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbmlmICggIWpRdWVyeS5zdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGF0dGFjaGVzID0gMCxcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYXR0YWNoZXMrKyA9PT0gMCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggLS1hdHRhY2hlcyA9PT0gMCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHsgLy8gJiYgc2VsZWN0b3IgIT0gbnVsbFxuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdHZhciBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID8gaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDogaGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHZhciB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRsaXZlOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdGpRdWVyeSggdGhpcy5jb250ZXh0ICkub24oIHR5cGVzLCB0aGlzLnNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRkaWU6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0alF1ZXJ5KCB0aGlzLmNvbnRleHQgKS5vZmYoIHR5cGVzLCB0aGlzLnNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDE/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yLCBmbiApO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0aWYgKCB0aGlzWzBdICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzWzBdLCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oIGZuICkge1xuXHRcdC8vIFNhdmUgcmVmZXJlbmNlIHRvIGFyZ3VtZW50cyBmb3IgYWNjZXNzIGluIGNsb3N1cmVcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKyssXG5cdFx0XHRpID0gMCxcblx0XHRcdHRvZ2dsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hpY2ggZnVuY3Rpb24gdG8gZXhlY3V0ZVxuXHRcdFx0XHR2YXIgbGFzdFRvZ2dsZSA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQgKSB8fCAwICkgJSBpO1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwibGFzdFRvZ2dsZVwiICsgZm4uZ3VpZCwgbGFzdFRvZ2dsZSArIDEgKTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBjbGlja3Mgc3RvcFxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdC8vIGFuZCBleGVjdXRlIHRoZSBmdW5jdGlvblxuXHRcdFx0XHRyZXR1cm4gYXJnc1sgbGFzdFRvZ2dsZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB8fCBmYWxzZTtcblx0XHRcdH07XG5cblx0XHQvLyBsaW5rIGFsbCB0aGUgZnVuY3Rpb25zLCBzbyBhbnkgb2YgdGhlbSBjYW4gdW5iaW5kIHRoaXMgY2xpY2sgaGFuZGxlclxuXHRcdHRvZ2dsZXIuZ3VpZCA9IGd1aWQ7XG5cdFx0d2hpbGUgKCBpIDwgYXJncy5sZW5ndGggKSB7XG5cdFx0XHRhcmdzWyBpKysgXS5ndWlkID0gZ3VpZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jbGljayggdG9nZ2xlciApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcblxuXHRpZiAoIGpRdWVyeS5hdHRyRm4gKSB7XG5cdFx0alF1ZXJ5LmF0dHJGblsgbmFtZSBdID0gdHJ1ZTtcblx0fVxuXG5cdGlmICggcmtleUV2ZW50LnRlc3QoIG5hbWUgKSApIHtcblx0XHRqUXVlcnkuZXZlbnQuZml4SG9va3NbIG5hbWUgXSA9IGpRdWVyeS5ldmVudC5rZXlIb29rcztcblx0fVxuXG5cdGlmICggcm1vdXNlRXZlbnQudGVzdCggbmFtZSApICkge1xuXHRcdGpRdWVyeS5ldmVudC5maXhIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV2ZW50Lm1vdXNlSG9va3M7XG5cdH1cbn0pO1xuXG5cblxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZVxuICogIENvcHlyaWdodCAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uXG4gKiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCwgQlNELCBhbmQgR1BMIExpY2Vuc2VzLlxuICogIE1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKi9cbihmdW5jdGlvbigpe1xuXG52YXIgY2h1bmtlciA9IC8oKD86XFwoKD86XFwoW14oKV0rXFwpfFteKCldKykrXFwpfFxcWyg/OlxcW1teXFxbXFxdXSpcXF18WydcIl1bXidcIl0qWydcIl18W15cXFtcXF0nXCJdKykrXFxdfFxcXFwufFteID4rfiwoXFxbXFxcXF0rKSt8Wz4rfl0pKFxccyosXFxzKik/KCg/Oi58XFxyfFxcbikqKS9nLFxuXHRleHBhbmRvID0gXCJzaXpjYWNoZVwiICsgKE1hdGgucmFuZG9tKCkgKyAnJykucmVwbGFjZSgnLicsICcnKSxcblx0ZG9uZSA9IDAsXG5cdHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0aGFzRHVwbGljYXRlID0gZmFsc2UsXG5cdGJhc2VIYXNEdXBsaWNhdGUgPSB0cnVlLFxuXHRyQmFja3NsYXNoID0gL1xcXFwvZyxcblx0clJldHVybiA9IC9cXHJcXG4vZyxcblx0ck5vbldvcmQgPSAvXFxXLztcblxuLy8gSGVyZSB3ZSBjaGVjayBpZiB0aGUgSmF2YVNjcmlwdCBlbmdpbmUgaXMgdXNpbmcgc29tZSBzb3J0IG9mXG4vLyBvcHRpbWl6YXRpb24gd2hlcmUgaXQgZG9lcyBub3QgYWx3YXlzIGNhbGwgb3VyIGNvbXBhcmlzaW9uXG4vLyBmdW5jdGlvbi4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgZGlzY2FyZCB0aGUgaGFzRHVwbGljYXRlIHZhbHVlLlxuLy8gICBUaHVzIGZhciB0aGF0IGluY2x1ZGVzIEdvb2dsZSBDaHJvbWUuXG5bMCwgMF0uc29ydChmdW5jdGlvbigpIHtcblx0YmFzZUhhc0R1cGxpY2F0ZSA9IGZhbHNlO1xuXHRyZXR1cm4gMDtcbn0pO1xuXG52YXIgU2l6emxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIG9yaWdDb250ZXh0ID0gY29udGV4dDtcblxuXHRpZiAoIGNvbnRleHQubm9kZVR5cGUgIT09IDEgJiYgY29udGV4dC5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRpZiAoICFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHR2YXIgbSwgc2V0LCBjaGVja1NldCwgZXh0cmEsIHJldCwgY3VyLCBwb3AsIGksXG5cdFx0cHJ1bmUgPSB0cnVlLFxuXHRcdGNvbnRleHRYTUwgPSBTaXp6bGUuaXNYTUwoIGNvbnRleHQgKSxcblx0XHRwYXJ0cyA9IFtdLFxuXHRcdHNvRmFyID0gc2VsZWN0b3I7XG5cblx0Ly8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaHVua2VyIHJlZ2V4cCAoc3RhcnQgZnJvbSBoZWFkKVxuXHRkbyB7XG5cdFx0Y2h1bmtlci5leGVjKCBcIlwiICk7XG5cdFx0bSA9IGNodW5rZXIuZXhlYyggc29GYXIgKTtcblxuXHRcdGlmICggbSApIHtcblx0XHRcdHNvRmFyID0gbVszXTtcblxuXHRcdFx0cGFydHMucHVzaCggbVsxXSApO1xuXG5cdFx0XHRpZiAoIG1bMl0gKSB7XG5cdFx0XHRcdGV4dHJhID0gbVszXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IHdoaWxlICggbSApO1xuXG5cdGlmICggcGFydHMubGVuZ3RoID4gMSAmJiBvcmlnUE9TLmV4ZWMoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdICkge1xuXHRcdFx0c2V0ID0gcG9zUHJvY2VzcyggcGFydHNbMF0gKyBwYXJ0c1sxXSwgY29udGV4dCwgc2VlZCApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldCA9IEV4cHIucmVsYXRpdmVbIHBhcnRzWzBdIF0gP1xuXHRcdFx0XHRbIGNvbnRleHQgXSA6XG5cdFx0XHRcdFNpenpsZSggcGFydHMuc2hpZnQoKSwgY29udGV4dCApO1xuXG5cdFx0XHR3aGlsZSAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0XHRzZWxlY3RvciArPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0ID0gcG9zUHJvY2Vzcyggc2VsZWN0b3IsIHNldCwgc2VlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0Ly8gKGJ1dCBub3QgaWYgaXQnbGwgYmUgZmFzdGVyIGlmIHRoZSBpbm5lciBzZWxlY3RvciBpcyBhbiBJRClcblx0XHRpZiAoICFzZWVkICYmIHBhcnRzLmxlbmd0aCA+IDEgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiAhY29udGV4dFhNTCAmJlxuXHRcdFx0XHRFeHByLm1hdGNoLklELnRlc3QocGFydHNbMF0pICYmICFFeHByLm1hdGNoLklELnRlc3QocGFydHNbcGFydHMubGVuZ3RoIC0gMV0pICkge1xuXG5cdFx0XHRyZXQgPSBTaXp6bGUuZmluZCggcGFydHMuc2hpZnQoKSwgY29udGV4dCwgY29udGV4dFhNTCApO1xuXHRcdFx0Y29udGV4dCA9IHJldC5leHByID9cblx0XHRcdFx0U2l6emxlLmZpbHRlciggcmV0LmV4cHIsIHJldC5zZXQgKVswXSA6XG5cdFx0XHRcdHJldC5zZXRbMF07XG5cdFx0fVxuXG5cdFx0aWYgKCBjb250ZXh0ICkge1xuXHRcdFx0cmV0ID0gc2VlZCA/XG5cdFx0XHRcdHsgZXhwcjogcGFydHMucG9wKCksIHNldDogbWFrZUFycmF5KHNlZWQpIH0gOlxuXHRcdFx0XHRTaXp6bGUuZmluZCggcGFydHMucG9wKCksIHBhcnRzLmxlbmd0aCA9PT0gMSAmJiAocGFydHNbMF0gPT09IFwiflwiIHx8IHBhcnRzWzBdID09PSBcIitcIikgJiYgY29udGV4dC5wYXJlbnROb2RlID8gY29udGV4dC5wYXJlbnROb2RlIDogY29udGV4dCwgY29udGV4dFhNTCApO1xuXG5cdFx0XHRzZXQgPSByZXQuZXhwciA/XG5cdFx0XHRcdFNpenpsZS5maWx0ZXIoIHJldC5leHByLCByZXQuc2V0ICkgOlxuXHRcdFx0XHRyZXQuc2V0O1xuXG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdGNoZWNrU2V0ID0gbWFrZUFycmF5KCBzZXQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJ1bmUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ciA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRwb3AgPSBjdXI7XG5cblx0XHRcdFx0aWYgKCAhRXhwci5yZWxhdGl2ZVsgY3VyIF0gKSB7XG5cdFx0XHRcdFx0Y3VyID0gXCJcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb3AgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcG9wID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cG9wID0gY29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIGN1ciBdKCBjaGVja1NldCwgcG9wLCBjb250ZXh0WE1MICk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hlY2tTZXQgPSBwYXJ0cyA9IFtdO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWNoZWNrU2V0ICkge1xuXHRcdGNoZWNrU2V0ID0gc2V0O1xuXHR9XG5cblx0aWYgKCAhY2hlY2tTZXQgKSB7XG5cdFx0U2l6emxlLmVycm9yKCBjdXIgfHwgc2VsZWN0b3IgKTtcblx0fVxuXG5cdGlmICggdG9TdHJpbmcuY2FsbChjaGVja1NldCkgPT09IFwiW29iamVjdCBBcnJheV1cIiApIHtcblx0XHRpZiAoICFwcnVuZSApIHtcblx0XHRcdHJlc3VsdHMucHVzaC5hcHBseSggcmVzdWx0cywgY2hlY2tTZXQgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGZvciAoIGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2hlY2tTZXRbaV0gJiYgKGNoZWNrU2V0W2ldID09PSB0cnVlIHx8IGNoZWNrU2V0W2ldLm5vZGVUeXBlID09PSAxICYmIFNpenpsZS5jb250YWlucyhjb250ZXh0LCBjaGVja1NldFtpXSkpICkge1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaCggc2V0W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgY2hlY2tTZXRbaV0gIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNoZWNrU2V0W2ldICYmIGNoZWNrU2V0W2ldLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaCggc2V0W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHRtYWtlQXJyYXkoIGNoZWNrU2V0LCByZXN1bHRzICk7XG5cdH1cblxuXHRpZiAoIGV4dHJhICkge1xuXHRcdFNpenpsZSggZXh0cmEsIG9yaWdDb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG5cdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0aWYgKCBzb3J0T3JkZXIgKSB7XG5cdFx0aGFzRHVwbGljYXRlID0gYmFzZUhhc0R1cGxpY2F0ZTtcblx0XHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdFx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdHNbaV0gPT09IHJlc3VsdHNbIGkgLSAxIF0gKSB7XG5cdFx0XHRcdFx0cmVzdWx0cy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBzZXQgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIHNldCApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBub2RlLCBleHByICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBbbm9kZV0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmZpbmQgPSBmdW5jdGlvbiggZXhwciwgY29udGV4dCwgaXNYTUwgKSB7XG5cdHZhciBzZXQsIGksIGxlbiwgbWF0Y2gsIHR5cGUsIGxlZnQ7XG5cblx0aWYgKCAhZXhwciApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRmb3IgKCBpID0gMCwgbGVuID0gRXhwci5vcmRlci5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHR0eXBlID0gRXhwci5vcmRlcltpXTtcblxuXHRcdGlmICggKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXS5leGVjKCBleHByICkpICkge1xuXHRcdFx0bGVmdCA9IG1hdGNoWzFdO1xuXHRcdFx0bWF0Y2guc3BsaWNlKCAxLCAxICk7XG5cblx0XHRcdGlmICggbGVmdC5zdWJzdHIoIGxlZnQubGVuZ3RoIC0gMSApICE9PSBcIlxcXFxcIiApIHtcblx0XHRcdFx0bWF0Y2hbMV0gPSAobWF0Y2hbMV0gfHwgXCJcIikucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xuXHRcdFx0XHRzZXQgPSBFeHByLmZpbmRbIHR5cGUgXSggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICk7XG5cblx0XHRcdFx0aWYgKCBzZXQgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRleHByID0gZXhwci5yZXBsYWNlKCBFeHByLm1hdGNoWyB0eXBlIF0sIFwiXCIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggIXNldCApIHtcblx0XHRzZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApIDpcblx0XHRcdFtdO1xuXHR9XG5cblx0cmV0dXJuIHsgc2V0OiBzZXQsIGV4cHI6IGV4cHIgfTtcbn07XG5cblNpenpsZS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgc2V0LCBpbnBsYWNlLCBub3QgKSB7XG5cdHZhciBtYXRjaCwgYW55Rm91bmQsXG5cdFx0dHlwZSwgZm91bmQsIGl0ZW0sIGZpbHRlciwgbGVmdCxcblx0XHRpLCBwYXNzLFxuXHRcdG9sZCA9IGV4cHIsXG5cdFx0cmVzdWx0ID0gW10sXG5cdFx0Y3VyTG9vcCA9IHNldCxcblx0XHRpc1hNTEZpbHRlciA9IHNldCAmJiBzZXRbMF0gJiYgU2l6emxlLmlzWE1MKCBzZXRbMF0gKTtcblxuXHR3aGlsZSAoIGV4cHIgJiYgc2V0Lmxlbmd0aCApIHtcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBFeHByLmxlZnRNYXRjaFsgdHlwZSBdLmV4ZWMoIGV4cHIgKSkgIT0gbnVsbCAmJiBtYXRjaFsyXSApIHtcblx0XHRcdFx0ZmlsdGVyID0gRXhwci5maWx0ZXJbIHR5cGUgXTtcblx0XHRcdFx0bGVmdCA9IG1hdGNoWzFdO1xuXG5cdFx0XHRcdGFueUZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0bWF0Y2guc3BsaWNlKDEsMSk7XG5cblx0XHRcdFx0aWYgKCBsZWZ0LnN1YnN0ciggbGVmdC5sZW5ndGggLSAxICkgPT09IFwiXFxcXFwiICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJMb29wID09PSByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIEV4cHIucHJlRmlsdGVyWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBFeHByLnByZUZpbHRlclsgdHlwZSBdKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QsIGlzWE1MRmlsdGVyICk7XG5cblx0XHRcdFx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdFx0XHRcdGFueUZvdW5kID0gZm91bmQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyAoaXRlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbSApIHtcblx0XHRcdFx0XHRcdFx0Zm91bmQgPSBmaWx0ZXIoIGl0ZW0sIG1hdGNoLCBpLCBjdXJMb29wICk7XG5cdFx0XHRcdFx0XHRcdHBhc3MgPSBub3QgXiBmb3VuZDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGlucGxhY2UgJiYgZm91bmQgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhc3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbnlGb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VyTG9vcFtpXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwYXNzICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBpdGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0YW55Rm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBmb3VuZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGlmICggIWlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRjdXJMb29wID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV4cHIgPSBleHByLnJlcGxhY2UoIEV4cHIubWF0Y2hbIHR5cGUgXSwgXCJcIiApO1xuXG5cdFx0XHRcdFx0aWYgKCAhYW55Rm91bmQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbXByb3BlciBleHByZXNzaW9uXG5cdFx0aWYgKCBleHByID09PSBvbGQgKSB7XG5cdFx0XHRpZiAoIGFueUZvdW5kID09IG51bGwgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggZXhwciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGQgPSBleHByO1xuXHR9XG5cblx0cmV0dXJuIGN1ckxvb3A7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmVpdmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG52YXIgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgdmFyIGksIG5vZGUsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlLFxuXHRcdHJldCA9IFwiXCI7XG5cblx0aWYgKCBub2RlVHlwZSApIHtcblx0XHRpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdC8vIFVzZSB0ZXh0Q29udGVudCB8fCBpbm5lclRleHQgZm9yIGVsZW1lbnRzXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgZWxlbS5pbm5lclRleHQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHQvLyBSZXBsYWNlIElFJ3MgY2FycmlhZ2UgcmV0dXJuc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lclRleHQucmVwbGFjZSggclJldHVybiwgJycgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFRyYXZlcnNlIGl0J3MgY2hpbGRyZW5cblx0XHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcblx0XHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRmb3IgKCBpID0gMDsgKG5vZGUgPSBlbGVtW2ldKTsgaSsrICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gOCApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJldDtcbn07XG5cbnZhciBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblx0b3JkZXI6IFsgXCJJRFwiLCBcIk5BTUVcIiwgXCJUQUdcIiBdLFxuXG5cdG1hdGNoOiB7XG5cdFx0SUQ6IC8jKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspLyxcblx0XHRDTEFTUzogL1xcLigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKS8sXG5cdFx0TkFNRTogL1xcW25hbWU9WydcIl0qKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspWydcIl0qXFxdLyxcblx0XHRBVFRSOiAvXFxbXFxzKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVxccyooPzooXFxTPz0pXFxzKig/OihbJ1wiXSkoLio/KVxcM3woIz8oPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikqKXwpfClcXHMqXFxdLyxcblx0XHRUQUc6IC9eKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXCpcXC1dfFxcXFwuKSspLyxcblx0XHRDSElMRDogLzoob25seXxudGh8bGFzdHxmaXJzdCktY2hpbGQoPzpcXChcXHMqKGV2ZW58b2RkfCg/OlsrXFwtXT9cXGQrfCg/OlsrXFwtXT9cXGQqKT9uXFxzKig/OlsrXFwtXVxccypcXGQrKT8pKVxccypcXCkpPy8sXG5cdFx0UE9TOiAvOihudGh8ZXF8Z3R8bHR8Zmlyc3R8bGFzdHxldmVufG9kZCkoPzpcXCgoXFxkKilcXCkpPyg/PVteXFwtXXwkKS8sXG5cdFx0UFNFVURPOiAvOigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKSg/OlxcKChbJ1wiXT8pKCg/OlxcKFteXFwpXStcXCl8W15cXChcXCldKikrKVxcMlxcKSk/L1xuXHR9LFxuXG5cdGxlZnRNYXRjaDoge30sXG5cblx0YXR0ck1hcDoge1xuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIlxuXHR9LFxuXG5cdGF0dHJIYW5kbGU6IHtcblx0XHRocmVmOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKTtcblx0XHR9LFxuXHRcdHR5cGU6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHRcdH1cblx0fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiK1wiOiBmdW5jdGlvbihjaGVja1NldCwgcGFydCl7XG5cdFx0XHR2YXIgaXNQYXJ0U3RyID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIsXG5cdFx0XHRcdGlzVGFnID0gaXNQYXJ0U3RyICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICksXG5cdFx0XHRcdGlzUGFydFN0ck5vdFRhZyA9IGlzUGFydFN0ciAmJiAhaXNUYWc7XG5cblx0XHRcdGlmICggaXNUYWcgKSB7XG5cdFx0XHRcdHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aCwgZWxlbTsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IGNoZWNrU2V0W2ldKSApIHtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbS5wcmV2aW91c1NpYmxpbmcpICYmIGVsZW0ubm9kZVR5cGUgIT09IDEgKSB7fVxuXG5cdFx0XHRcdFx0Y2hlY2tTZXRbaV0gPSBpc1BhcnRTdHJOb3RUYWcgfHwgZWxlbSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHBhcnQgP1xuXHRcdFx0XHRcdFx0ZWxlbSB8fCBmYWxzZSA6XG5cdFx0XHRcdFx0XHRlbGVtID09PSBwYXJ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNQYXJ0U3RyTm90VGFnICkge1xuXHRcdFx0XHRTaXp6bGUuZmlsdGVyKCBwYXJ0LCBjaGVja1NldCwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRcIj5cIjogZnVuY3Rpb24oIGNoZWNrU2V0LCBwYXJ0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdGlzUGFydFN0ciA9IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IGNoZWNrU2V0Lmxlbmd0aDtcblxuXHRcdFx0aWYgKCBpc1BhcnRTdHIgJiYgIXJOb25Xb3JkLnRlc3QoIHBhcnQgKSApIHtcblx0XHRcdFx0cGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNoZWNrU2V0W2ldO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdGNoZWNrU2V0W2ldID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHBhcnQgPyBwYXJlbnQgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjaGVja1NldFtpXTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0XHRcdGNoZWNrU2V0W2ldID0gaXNQYXJ0U3RyID9cblx0XHRcdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlIDpcblx0XHRcdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlID09PSBwYXJ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXNQYXJ0U3RyICkge1xuXHRcdFx0XHRcdFNpenpsZS5maWx0ZXIoIHBhcnQsIGNoZWNrU2V0LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0XCJcIjogZnVuY3Rpb24oY2hlY2tTZXQsIHBhcnQsIGlzWE1MKXtcblx0XHRcdHZhciBub2RlQ2hlY2ssXG5cdFx0XHRcdGRvbmVOYW1lID0gZG9uZSsrLFxuXHRcdFx0XHRjaGVja0ZuID0gZGlyQ2hlY2s7XG5cblx0XHRcdGlmICggdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgIXJOb25Xb3JkLnRlc3QoIHBhcnQgKSApIHtcblx0XHRcdFx0cGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bm9kZUNoZWNrID0gcGFydDtcblx0XHRcdFx0Y2hlY2tGbiA9IGRpck5vZGVDaGVjaztcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tGbiggXCJwYXJlbnROb2RlXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCApO1xuXHRcdH0sXG5cblx0XHRcIn5cIjogZnVuY3Rpb24oIGNoZWNrU2V0LCBwYXJ0LCBpc1hNTCApIHtcblx0XHRcdHZhciBub2RlQ2hlY2ssXG5cdFx0XHRcdGRvbmVOYW1lID0gZG9uZSsrLFxuXHRcdFx0XHRjaGVja0ZuID0gZGlyQ2hlY2s7XG5cblx0XHRcdGlmICggdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgIXJOb25Xb3JkLnRlc3QoIHBhcnQgKSApIHtcblx0XHRcdFx0cGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bm9kZUNoZWNrID0gcGFydDtcblx0XHRcdFx0Y2hlY2tGbiA9IGRpck5vZGVDaGVjaztcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tGbiggXCJwcmV2aW91c1NpYmxpbmdcIiwgcGFydCwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbmQ6IHtcblx0XHRJRDogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMV0pO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFttXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHROQU1FOiBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIG1hdGNoWzFdICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXN1bHRzW2ldLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdFx0cmV0LnB1c2goIHJlc3VsdHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmV0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFRBRzogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIG1hdGNoWzFdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwcmVGaWx0ZXI6IHtcblx0XHRDTEFTUzogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUwgKSB7XG5cdFx0XHRtYXRjaCA9IFwiIFwiICsgbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApICsgXCIgXCI7XG5cblx0XHRcdGlmICggaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggbm90IF4gKGVsZW0uY2xhc3NOYW1lICYmIChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoL1tcXHRcXG5cXHJdL2csIFwiIFwiKS5pbmRleE9mKG1hdGNoKSA+PSAwKSApIHtcblx0XHRcdFx0XHRcdGlmICggIWlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpbnBsYWNlICkge1xuXHRcdFx0XHRcdFx0Y3VyTG9vcFtpXSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdElEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xuXHRcdH0sXG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCApIHtcblx0XHRcdHJldHVybiBtYXRjaFsxXS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoWzJdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcK3xcXHMqL2csICcnKTtcblxuXHRcdFx0XHQvLyBwYXJzZSBlcXVhdGlvbnMgbGlrZSAnZXZlbicsICdvZGQnLCAnNScsICcybicsICczbisyJywgJzRuLTEnLCAnLW4rNidcblx0XHRcdFx0dmFyIHRlc3QgPSAvKC0/KShcXGQqKSg/Om4oWytcXC1dP1xcZCopKT8vLmV4ZWMoXG5cdFx0XHRcdFx0bWF0Y2hbMl0gPT09IFwiZXZlblwiICYmIFwiMm5cIiB8fCBtYXRjaFsyXSA9PT0gXCJvZGRcIiAmJiBcIjJuKzFcIiB8fFxuXHRcdFx0XHRcdCEvXFxELy50ZXN0KCBtYXRjaFsyXSApICYmIFwiMG4rXCIgKyBtYXRjaFsyXSB8fCBtYXRjaFsyXSk7XG5cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBudW1iZXJzIChmaXJzdCluKyhsYXN0KSBpbmNsdWRpbmcgaWYgdGhleSBhcmUgbmVnYXRpdmVcblx0XHRcdFx0bWF0Y2hbMl0gPSAodGVzdFsxXSArICh0ZXN0WzJdIHx8IDEpKSAtIDA7XG5cdFx0XHRcdG1hdGNoWzNdID0gdGVzdFszXSAtIDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogTW92ZSB0byBub3JtYWwgY2FjaGluZyBzeXN0ZW1cblx0XHRcdG1hdGNoWzBdID0gZG9uZSsrO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdEFUVFI6IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QsIGlzWE1MICkge1xuXHRcdFx0dmFyIG5hbWUgPSBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKTtcblxuXHRcdFx0aWYgKCAhaXNYTUwgJiYgRXhwci5hdHRyTWFwW25hbWVdICkge1xuXHRcdFx0XHRtYXRjaFsxXSA9IEV4cHIuYXR0ck1hcFtuYW1lXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGlmIGFuIHVuLXF1b3RlZCB2YWx1ZSB3YXMgdXNlZFxuXHRcdFx0bWF0Y2hbNF0gPSAoIG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbNF0gPSBcIiBcIiArIG1hdGNoWzRdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggbWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90ICkge1xuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gXCJub3RcIiApIHtcblx0XHRcdFx0Ly8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgY29tcGxleCBleHByZXNzaW9uLCBvciBhIHNpbXBsZSBvbmVcblx0XHRcdFx0aWYgKCAoIGNodW5rZXIuZXhlYyhtYXRjaFszXSkgfHwgXCJcIiApLmxlbmd0aCA+IDEgfHwgL15cXHcvLnRlc3QobWF0Y2hbM10pICkge1xuXHRcdFx0XHRcdG1hdGNoWzNdID0gU2l6emxlKG1hdGNoWzNdLCBudWxsLCBudWxsLCBjdXJMb29wKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciByZXQgPSBTaXp6bGUuZmlsdGVyKG1hdGNoWzNdLCBjdXJMb29wLCBpbnBsYWNlLCB0cnVlIF4gbm90KTtcblxuXHRcdFx0XHRcdGlmICggIWlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaC5hcHBseSggcmVzdWx0LCByZXQgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggRXhwci5tYXRjaC5QT1MudGVzdCggbWF0Y2hbMF0gKSB8fCBFeHByLm1hdGNoLkNISUxELnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFBPUzogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2gudW5zaGlmdCggdHJ1ZSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcnM6IHtcblx0XHRlbmFibGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSAmJiBlbGVtLnR5cGUgIT09IFwiaGlkZGVuXCI7XG5cdFx0fSxcblxuXHRcdGRpc2FibGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRjaGVja2VkOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmNoZWNrZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdHNlbGVjdGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gISFlbGVtLmZpcnN0Q2hpbGQ7XG5cdFx0fSxcblxuXHRcdGVtcHR5OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhZWxlbS5maXJzdENoaWxkO1xuXHRcdH0sXG5cblx0XHRoYXM6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhIVNpenpsZSggbWF0Y2hbM10sIGVsZW0gKS5sZW5ndGg7XG5cdFx0fSxcblxuXHRcdGhlYWRlcjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKC9oXFxkL2kpLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApLCB0eXBlID0gZWxlbS50eXBlO1xuXHRcdFx0Ly8gSUU2IGFuZCA3IHdpbGwgbWFwIGVsZW0udHlwZSB0byAndGV4dCcgZm9yIG5ldyBIVE1MNSB0eXBlcyAoc2VhcmNoLCBldGMpXG5cdFx0XHQvLyB1c2UgZ2V0QXR0cmlidXRlIGluc3RlYWQgdG8gdGVzdCB0aGlzIGNhc2Vcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcInRleHRcIiA9PT0gdHlwZSAmJiAoIGF0dHIgPT09IHR5cGUgfHwgYXR0ciA9PT0gbnVsbCApO1xuXHRcdH0sXG5cblx0XHRyYWRpbzogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJyYWRpb1wiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGNoZWNrYm94OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcImNoZWNrYm94XCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0ZmlsZTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJmaWxlXCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0cGFzc3dvcmQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cblx0XHRzdWJtaXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInN1Ym1pdFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcImltYWdlXCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInJlc2V0XCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0YnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBcImJ1dHRvblwiID09PSBlbGVtLnR5cGUgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbi9pKS50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHR9XG5cdH0sXG5cdHNldEZpbHRlcnM6IHtcblx0XHRmaXJzdDogZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0bGFzdDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoLCBhcnJheSApIHtcblx0XHRcdHJldHVybiBpID09PSBhcnJheS5sZW5ndGggLSAxO1xuXHRcdH0sXG5cblx0XHRldmVuOiBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMiA9PT0gMDtcblx0XHR9LFxuXG5cdFx0b2RkOiBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMiA9PT0gMTtcblx0XHR9LFxuXG5cdFx0bHQ6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBpIDwgbWF0Y2hbM10gLSAwO1xuXHRcdH0sXG5cblx0XHRndDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIGkgPiBtYXRjaFszXSAtIDA7XG5cdFx0fSxcblxuXHRcdG50aDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoWzNdIC0gMCA9PT0gaTtcblx0XHR9LFxuXG5cdFx0ZXE6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBtYXRjaFszXSAtIDAgPT09IGk7XG5cdFx0fVxuXHR9LFxuXHRmaWx0ZXI6IHtcblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCwgaSwgYXJyYXkgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRmaWx0ZXIgPSBFeHByLmZpbHRlcnNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSBcImNvbnRhaW5zXCIgKSB7XG5cdFx0XHRcdHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KFsgZWxlbSBdKSB8fCBcIlwiKS5pbmRleE9mKG1hdGNoWzNdKSA+PSAwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSBcIm5vdFwiICkge1xuXHRcdFx0XHR2YXIgbm90ID0gbWF0Y2hbM107XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBsID0gbm90Lmxlbmd0aDsgaiA8IGw7IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIG5vdFtqXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZmlyc3QsIGxhc3QsXG5cdFx0XHRcdGRvbmVOYW1lLCBwYXJlbnQsIGNhY2hlLFxuXHRcdFx0XHRjb3VudCwgZGlmZixcblx0XHRcdFx0dHlwZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRub2RlID0gZWxlbTtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblx0XHRcdFx0Y2FzZSBcIm9ubHlcIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmaXJzdFwiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cblx0XHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRcdGNhc2UgXCJsYXN0XCI6XG5cdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y2FzZSBcIm50aFwiOlxuXHRcdFx0XHRcdGZpcnN0ID0gbWF0Y2hbMl07XG5cdFx0XHRcdFx0bGFzdCA9IG1hdGNoWzNdO1xuXG5cdFx0XHRcdFx0aWYgKCBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZG9uZU5hbWUgPSBtYXRjaFswXTtcblx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCAmJiAocGFyZW50WyBleHBhbmRvIF0gIT09IGRvbmVOYW1lIHx8ICFlbGVtLm5vZGVJbmRleCkgKSB7XG5cdFx0XHRcdFx0XHRjb3VudCA9IDA7XG5cblx0XHRcdFx0XHRcdGZvciAoIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVJbmRleCA9ICsrY291bnQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cGFyZW50WyBleHBhbmRvIF0gPSBkb25lTmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkaWZmID0gZWxlbS5ub2RlSW5kZXggLSBsYXN0O1xuXG5cdFx0XHRcdFx0aWYgKCBmaXJzdCA9PT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSAwO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0SUQ6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IG1hdGNoO1xuXHRcdH0sXG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAobWF0Y2ggPT09IFwiKlwiICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHx8ICEhZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoO1xuXHRcdH0sXG5cblx0XHRDTEFTUzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIChcIiBcIiArIChlbGVtLmNsYXNzTmFtZSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSArIFwiIFwiKVxuXHRcdFx0XHQuaW5kZXhPZiggbWF0Y2ggKSA+IC0xO1xuXHRcdH0sXG5cblx0XHRBVFRSOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRyZXN1bHQgPSBTaXp6bGUuYXR0ciA/XG5cdFx0XHRcdFx0U2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKSA6XG5cdFx0XHRcdFx0RXhwci5hdHRySGFuZGxlWyBuYW1lIF0gP1xuXHRcdFx0XHRcdEV4cHIuYXR0ckhhbmRsZVsgbmFtZSBdKCBlbGVtICkgOlxuXHRcdFx0XHRcdGVsZW1bIG5hbWUgXSAhPSBudWxsID9cblx0XHRcdFx0XHRcdGVsZW1bIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApLFxuXHRcdFx0XHR2YWx1ZSA9IHJlc3VsdCArIFwiXCIsXG5cdFx0XHRcdHR5cGUgPSBtYXRjaFsyXSxcblx0XHRcdFx0Y2hlY2sgPSBtYXRjaFs0XTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdCA9PSBudWxsID9cblx0XHRcdFx0dHlwZSA9PT0gXCIhPVwiIDpcblx0XHRcdFx0IXR5cGUgJiYgU2l6emxlLmF0dHIgP1xuXHRcdFx0XHRyZXN1bHQgIT0gbnVsbCA6XG5cdFx0XHRcdHR5cGUgPT09IFwiPVwiID9cblx0XHRcdFx0dmFsdWUgPT09IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCIqPVwiID9cblx0XHRcdFx0dmFsdWUuaW5kZXhPZihjaGVjaykgPj0gMCA6XG5cdFx0XHRcdHR5cGUgPT09IFwifj1cIiA/XG5cdFx0XHRcdChcIiBcIiArIHZhbHVlICsgXCIgXCIpLmluZGV4T2YoY2hlY2spID49IDAgOlxuXHRcdFx0XHQhY2hlY2sgP1xuXHRcdFx0XHR2YWx1ZSAmJiByZXN1bHQgIT09IGZhbHNlIDpcblx0XHRcdFx0dHlwZSA9PT0gXCIhPVwiID9cblx0XHRcdFx0dmFsdWUgIT09IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCJePVwiID9cblx0XHRcdFx0dmFsdWUuaW5kZXhPZihjaGVjaykgPT09IDAgOlxuXHRcdFx0XHR0eXBlID09PSBcIiQ9XCIgP1xuXHRcdFx0XHR2YWx1ZS5zdWJzdHIodmFsdWUubGVuZ3RoIC0gY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHR0eXBlID09PSBcInw9XCIgP1xuXHRcdFx0XHR2YWx1ZSA9PT0gY2hlY2sgfHwgdmFsdWUuc3Vic3RyKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0ZmFsc2U7XG5cdFx0fSxcblxuXHRcdFBPUzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoLCBpLCBhcnJheSApIHtcblx0XHRcdHZhciBuYW1lID0gbWF0Y2hbMl0sXG5cdFx0XHRcdGZpbHRlciA9IEV4cHIuc2V0RmlsdGVyc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIGZpbHRlciApIHtcblx0XHRcdFx0cmV0dXJuIGZpbHRlciggZWxlbSwgaSwgbWF0Y2gsIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgb3JpZ1BPUyA9IEV4cHIubWF0Y2guUE9TLFxuXHRmZXNjYXBlID0gZnVuY3Rpb24oYWxsLCBudW0pe1xuXHRcdHJldHVybiBcIlxcXFxcIiArIChudW0gLSAwICsgMSk7XG5cdH07XG5cbmZvciAoIHZhciB0eXBlIGluIEV4cHIubWF0Y2ggKSB7XG5cdEV4cHIubWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UgKyAoLyg/IVteXFxbXSpcXF0pKD8hW15cXChdKlxcKSkvLnNvdXJjZSkgKTtcblx0RXhwci5sZWZ0TWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIC8oXig/Oi58XFxyfFxcbikqPykvLnNvdXJjZSArIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UucmVwbGFjZSgvXFxcXChcXGQrKS9nLCBmZXNjYXBlKSApO1xufVxuLy8gRXhwb3NlIG9yaWdQT1Ncbi8vIFwiZ2xvYmFsXCIgYXMgaW4gcmVnYXJkbGVzcyBvZiByZWxhdGlvbiB0byBicmFja2V0cy9wYXJlbnNcbkV4cHIubWF0Y2guZ2xvYmFsUE9TID0gb3JpZ1BPUztcblxudmFyIG1ha2VBcnJheSA9IGZ1bmN0aW9uKCBhcnJheSwgcmVzdWx0cyApIHtcblx0YXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXksIDAgKTtcblxuXHRpZiAoIHJlc3VsdHMgKSB7XG5cdFx0cmVzdWx0cy5wdXNoLmFwcGx5KCByZXN1bHRzLCBhcnJheSApO1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xufTtcblxuLy8gUGVyZm9ybSBhIHNpbXBsZSBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZlxuLy8gY29udmVydGluZyBhIE5vZGVMaXN0IHRvIGFuIGFycmF5IHVzaW5nIGJ1aWx0aW4gbWV0aG9kcy5cbi8vIEFsc28gdmVyaWZpZXMgdGhhdCB0aGUgcmV0dXJuZWQgYXJyYXkgaG9sZHMgRE9NIG5vZGVzXG4vLyAod2hpY2ggaXMgbm90IHRoZSBjYXNlIGluIHRoZSBCbGFja2JlcnJ5IGJyb3dzZXIpXG50cnkge1xuXHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNoaWxkTm9kZXMsIDAgKVswXS5ub2RlVHlwZTtcblxuLy8gUHJvdmlkZSBhIGZhbGxiYWNrIG1ldGhvZCBpZiBpdCBkb2VzIG5vdCB3b3JrXG59IGNhdGNoKCBlICkge1xuXHRtYWtlQXJyYXkgPSBmdW5jdGlvbiggYXJyYXksIHJlc3VsdHMgKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggdG9TdHJpbmcuY2FsbChhcnJheSkgPT09IFwiW29iamVjdCBBcnJheV1cIiApIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCByZXQsIGFycmF5ICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgYXJyYXkubGVuZ3RoID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggYXJyYXlbaV0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGFycmF5W2ldOyBpKysgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGFycmF5W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG52YXIgc29ydE9yZGVyLCBzaWJsaW5nQ2hlY2s7XG5cbmlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICkge1xuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiB8fCAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0XHRcdHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gLTEgOiAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgNCA/IC0xIDogMTtcblx0fTtcblxufSBlbHNlIHtcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gVGhlIG5vZGVzIGFyZSBpZGVudGljYWwsIHdlIGNhbiBleGl0IGVhcmx5XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gdXNpbmcgc291cmNlSW5kZXggKGluIElFKSBpZiBpdCdzIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdFx0fSBlbHNlIGlmICggYS5zb3VyY2VJbmRleCAmJiBiLnNvdXJjZUluZGV4ICkge1xuXHRcdFx0cmV0dXJuIGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXHRcdH1cblxuXHRcdHZhciBhbCwgYmwsXG5cdFx0XHRhcCA9IFtdLFxuXHRcdFx0YnAgPSBbXSxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGN1ciA9IGF1cDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MgKG9yIGlkZW50aWNhbCkgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHRpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXG5cdFx0Ly8gSWYgbm8gcGFyZW50cyB3ZXJlIGZvdW5kIHRoZW4gdGhlIG5vZGVzIGFyZSBkaXNjb25uZWN0ZWRcblx0XHR9IGVsc2UgaWYgKCAhYXVwICkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXG5cdFx0fSBlbHNlIGlmICggIWJ1cCApIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB0aGV5J3JlIHNvbWV3aGVyZSBlbHNlIGluIHRoZSB0cmVlIHNvIHdlIG5lZWRcblx0XHQvLyB0byBidWlsZCB1cCBhIGZ1bGwgbGlzdCBvZiB0aGUgcGFyZW50Tm9kZXMgZm9yIGNvbXBhcmlzb25cblx0XHR3aGlsZSAoIGN1ciApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0Y3VyID0gYnVwO1xuXG5cdFx0d2hpbGUgKCBjdXIgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGFsID0gYXAubGVuZ3RoO1xuXHRcdGJsID0gYnAubGVuZ3RoO1xuXG5cdFx0Ly8gU3RhcnQgd2Fsa2luZyBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbCAmJiBpIDwgYmw7IGkrKyApIHtcblx0XHRcdGlmICggYXBbaV0gIT09IGJwW2ldICkge1xuXHRcdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXZSBlbmRlZCBzb21lcGxhY2UgdXAgdGhlIHRyZWUgc28gZG8gYSBzaWJsaW5nIGNoZWNrXG5cdFx0cmV0dXJuIGkgPT09IGFsID9cblx0XHRcdHNpYmxpbmdDaGVjayggYSwgYnBbaV0sIC0xICkgOlxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYiwgMSApO1xuXHR9O1xuXG5cdHNpYmxpbmdDaGVjayA9IGZ1bmN0aW9uKCBhLCBiLCByZXQgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHR2YXIgY3VyID0gYS5uZXh0U2libGluZztcblxuXHRcdHdoaWxlICggY3VyICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Y3VyID0gY3VyLm5leHRTaWJsaW5nO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9O1xufVxuXG4vLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lIHdoZW5cbi8vIHF1ZXJ5aW5nIGJ5IGdldEVsZW1lbnRCeUlkIChhbmQgcHJvdmlkZSBhIHdvcmthcm91bmQpXG4oZnVuY3Rpb24oKXtcblx0Ly8gV2UncmUgZ29pbmcgdG8gaW5qZWN0IGEgZmFrZSBpbnB1dCBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQgbmFtZVxuXHR2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0aWQgPSBcInNjcmlwdFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcblx0XHRyb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdGZvcm0uaW5uZXJIVE1MID0gXCI8YSBuYW1lPSdcIiArIGlkICsgXCInLz5cIjtcblxuXHQvLyBJbmplY3QgaXQgaW50byB0aGUgcm9vdCBlbGVtZW50LCBjaGVjayBpdHMgc3RhdHVzLCBhbmQgcmVtb3ZlIGl0IHF1aWNrbHlcblx0cm9vdC5pbnNlcnRCZWZvcmUoIGZvcm0sIHJvb3QuZmlyc3RDaGlsZCApO1xuXG5cdC8vIFRoZSB3b3JrYXJvdW5kIGhhcyB0byBkbyBhZGRpdGlvbmFsIGNoZWNrcyBhZnRlciBhIGdldEVsZW1lbnRCeUlkXG5cdC8vIFdoaWNoIHNsb3dzIHRoaW5ncyBkb3duIGZvciBvdGhlciBicm93c2VycyAoaGVuY2UgdGhlIGJyYW5jaGluZylcblx0aWYgKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQgKSApIHtcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNYTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtYXRjaFsxXSk7XG5cblx0XHRcdFx0cmV0dXJuIG0gP1xuXHRcdFx0XHRcdG0uaWQgPT09IG1hdGNoWzFdIHx8IHR5cGVvZiBtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikubm9kZVZhbHVlID09PSBtYXRjaFsxXSA/XG5cdFx0XHRcdFx0XHRbbV0gOlxuXHRcdFx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0RXhwci5maWx0ZXIuSUQgPSBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIG5vZGUgJiYgbm9kZS5ub2RlVmFsdWUgPT09IG1hdGNoO1xuXHRcdH07XG5cdH1cblxuXHRyb290LnJlbW92ZUNoaWxkKCBmb3JtICk7XG5cblx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0cm9vdCA9IGZvcm0gPSBudWxsO1xufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG5cdC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgYnJvd3NlciByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0Ly8gd2hlbiBkb2luZyBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIilcblxuXHQvLyBDcmVhdGUgYSBmYWtlIGVsZW1lbnRcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXG5cdC8vIE1ha2Ugc3VyZSBubyBjb21tZW50cyBhcmUgZm91bmRcblx0aWYgKCBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aCA+IDAgKSB7XG5cdFx0RXhwci5maW5kLlRBRyA9IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCApIHtcblx0XHRcdHZhciByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggbWF0Y2hbMV0gKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHZhciB0bXAgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IHJlc3VsdHNbaV07IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIHJlc3VsdHNbaV0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggcmVzdWx0c1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdHMgPSB0bXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgYW4gYXR0cmlidXRlIHJldHVybnMgbm9ybWFsaXplZCBocmVmIGF0dHJpYnV0ZXNcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXG5cdGlmICggZGl2LmZpcnN0Q2hpbGQgJiYgdHlwZW9mIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0ZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSAhPT0gXCIjXCIgKSB7XG5cblx0XHRFeHByLmF0dHJIYW5kbGUuaHJlZiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImhyZWZcIiwgMiApO1xuXHRcdH07XG5cdH1cblxuXHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRkaXYgPSBudWxsO1xufSkoKTtcblxuaWYgKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkge1xuXHQoZnVuY3Rpb24oKXtcblx0XHR2YXIgb2xkU2l6emxlID0gU2l6emxlLFxuXHRcdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRcdGlkID0gXCJfX3NpenpsZV9fXCI7XG5cblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8cCBjbGFzcz0nVEVTVCc+PC9wPlwiO1xuXG5cdFx0Ly8gU2FmYXJpIGNhbid0IGhhbmRsZSB1cHBlcmNhc2Ugb3IgdW5pY29kZSBjaGFyYWN0ZXJzIHdoZW5cblx0XHQvLyBpbiBxdWlya3MgbW9kZS5cblx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsICYmIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLlRFU1RcIikubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdFNpenpsZSA9IGZ1bmN0aW9uKCBxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQgKSB7XG5cdFx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdFx0Ly8gT25seSB1c2UgcXVlcnlTZWxlY3RvckFsbCBvbiBub24tWE1MIGRvY3VtZW50c1xuXHRcdFx0Ly8gKElEIHNlbGVjdG9ycyBkb24ndCB3b3JrIGluIG5vbi1IVE1MIGRvY3VtZW50cylcblx0XHRcdGlmICggIXNlZWQgJiYgIVNpenpsZS5pc1hNTChjb250ZXh0KSApIHtcblx0XHRcdFx0Ly8gU2VlIGlmIHdlIGZpbmQgYSBzZWxlY3RvciB0byBzcGVlZCB1cFxuXHRcdFx0XHR2YXIgbWF0Y2ggPSAvXihcXHcrJCl8XlxcLihbXFx3XFwtXSskKXxeIyhbXFx3XFwtXSskKS8uZXhlYyggcXVlcnkgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoICYmIChjb250ZXh0Lm5vZGVUeXBlID09PSAxIHx8IGNvbnRleHQubm9kZVR5cGUgPT09IDkpICkge1xuXHRcdFx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggcXVlcnkgKSwgZXh0cmEgKTtcblxuXHRcdFx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSAmJiBFeHByLmZpbmQuQ0xBU1MgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtYXRjaFsyXSApLCBleHRyYSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29udGV4dC5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiYm9keVwiKVxuXHRcdFx0XHRcdC8vIFRoZSBib2R5IGVsZW1lbnQgb25seSBleGlzdHMgb25jZSwgb3B0aW1pemUgZmluZGluZyBpdFxuXHRcdFx0XHRcdGlmICggcXVlcnkgPT09IFwiYm9keVwiICYmIGNvbnRleHQuYm9keSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIFsgY29udGV4dC5ib2R5IF0sIGV4dHJhICk7XG5cblx0XHRcdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggJiYgbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzNdICk7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuXHRcdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtYXRjaFszXSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBbIGVsZW0gXSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBbXSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7fVxuXG5cdFx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHRcdC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxuXHRcdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdFx0dmFyIG9sZENvbnRleHQgPSBjb250ZXh0LFxuXHRcdFx0XHRcdFx0b2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApLFxuXHRcdFx0XHRcdFx0bmlkID0gb2xkIHx8IGlkLFxuXHRcdFx0XHRcdFx0aGFzUGFyZW50ID0gY29udGV4dC5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0cmVsYXRpdmVIaWVyYXJjaHlTZWxlY3RvciA9IC9eXFxzKlsrfl0vLnRlc3QoIHF1ZXJ5ICk7XG5cblx0XHRcdFx0XHRpZiAoICFvbGQgKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIC8nL2csIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCByZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yICYmIGhhc1BhcmVudCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmICggIXJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgfHwgaGFzUGFyZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCIgKyBxdWVyeSApLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBjYXRjaChwc2V1ZG9FcnJvcikge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoICFvbGQgKSB7XG5cdFx0XHRcdFx0XHRcdG9sZENvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9sZFNpenpsZShxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQpO1xuXHRcdH07XG5cblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBvbGRTaXp6bGUgKSB7XG5cdFx0XHRTaXp6bGVbIHByb3AgXSA9IG9sZFNpenpsZVsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fSkoKTtcbn1cblxuKGZ1bmN0aW9uKCl7XG5cdHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdG1hdGNoZXMgPSBodG1sLm1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1vek1hdGNoZXNTZWxlY3RvciB8fCBodG1sLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG5cdGlmICggbWF0Y2hlcyApIHtcblx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5IGZhaWxzIHRoaXMpXG5cdFx0dmFyIGRpc2Nvbm5lY3RlZE1hdGNoID0gIW1hdGNoZXMuY2FsbCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLCBcImRpdlwiICksXG5cdFx0XHRwc2V1ZG9Xb3JrcyA9IGZhbHNlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIlt0ZXN0IT0nJ106c2l6emxlXCIgKTtcblxuXHRcdH0gY2F0Y2goIHBzZXVkb0Vycm9yICkge1xuXHRcdFx0cHNldWRvV29ya3MgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggbm9kZSwgZXhwciApIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRcdFx0ZXhwciA9IGV4cHIucmVwbGFjZSgvXFw9XFxzKihbXidcIlxcXV0qKVxccypcXF0vZywgXCI9JyQxJ11cIik7XG5cblx0XHRcdGlmICggIVNpenpsZS5pc1hNTCggbm9kZSApICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICggcHNldWRvV29ya3MgfHwgIUV4cHIubWF0Y2guUFNFVURPLnRlc3QoIGV4cHIgKSAmJiAhLyE9Ly50ZXN0KCBleHByICkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBub2RlLCBleHByICk7XG5cblx0XHRcdFx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdFx0XHRcdGlmICggcmV0IHx8ICFkaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOSwgc28gY2hlY2sgZm9yIHRoYXRcblx0XHRcdFx0XHRcdFx0XHRub2RlLmRvY3VtZW50ICYmIG5vZGUuZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIFtub2RlXSkubGVuZ3RoID4gMDtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0ndGVzdCBlJz48L2Rpdj48ZGl2IGNsYXNzPSd0ZXN0Jz48L2Rpdj5cIjtcblxuXHQvLyBPcGVyYSBjYW4ndCBmaW5kIGEgc2Vjb25kIGNsYXNzbmFtZSAoaW4gOS42KVxuXHQvLyBBbHNvLCBtYWtlIHN1cmUgdGhhdCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGFjdHVhbGx5IGV4aXN0c1xuXHRpZiAoICFkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB8fCBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoID09PSAwICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFNhZmFyaSBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcywgZG9lc24ndCBjYXRjaCBjaGFuZ2VzIChpbiAzLjIpXG5cdGRpdi5sYXN0Q2hpbGQuY2xhc3NOYW1lID0gXCJlXCI7XG5cblx0aWYgKCBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdEV4cHIub3JkZXIuc3BsaWNlKDEsIDAsIFwiQ0xBU1NcIik7XG5cdEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCwgaXNYTUwgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobWF0Y2hbMV0pO1xuXHRcdH1cblx0fTtcblxuXHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRkaXYgPSBudWxsO1xufSkoKTtcblxuZnVuY3Rpb24gZGlyTm9kZUNoZWNrKCBkaXIsIGN1ciwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MICkge1xuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0dmFyIGVsZW0gPSBjaGVja1NldFtpXTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHZhciBtYXRjaCA9IGZhbHNlO1xuXG5cdFx0XHRlbGVtID0gZWxlbVtkaXJdO1xuXG5cdFx0XHR3aGlsZSAoIGVsZW0gKSB7XG5cdFx0XHRcdGlmICggZWxlbVsgZXhwYW5kbyBdID09PSBkb25lTmFtZSApIHtcblx0XHRcdFx0XHRtYXRjaCA9IGNoZWNrU2V0W2VsZW0uc2l6c2V0XTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNYTUwgKXtcblx0XHRcdFx0XHRlbGVtWyBleHBhbmRvIF0gPSBkb25lTmFtZTtcblx0XHRcdFx0XHRlbGVtLnNpenNldCA9IGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gY3VyICkge1xuXHRcdFx0XHRcdG1hdGNoID0gZWxlbTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrU2V0W2ldID0gbWF0Y2g7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRpckNoZWNrKCBkaXIsIGN1ciwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MICkge1xuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0dmFyIGVsZW0gPSBjaGVja1NldFtpXTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHZhciBtYXRjaCA9IGZhbHNlO1xuXG5cdFx0XHRlbGVtID0gZWxlbVtkaXJdO1xuXG5cdFx0XHR3aGlsZSAoIGVsZW0gKSB7XG5cdFx0XHRcdGlmICggZWxlbVsgZXhwYW5kbyBdID09PSBkb25lTmFtZSApIHtcblx0XHRcdFx0XHRtYXRjaCA9IGNoZWNrU2V0W2VsZW0uc2l6c2V0XTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIGV4cGFuZG8gXSA9IGRvbmVOYW1lO1xuXHRcdFx0XHRcdFx0ZWxlbS5zaXpzZXQgPSBpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGN1ciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdGlmICggZWxlbSA9PT0gY3VyICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggU2l6emxlLmZpbHRlciggY3VyLCBbZWxlbV0gKS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBlbGVtO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbSA9IGVsZW1bZGlyXTtcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tTZXRbaV0gPSBtYXRjaDtcblx0XHR9XG5cdH1cbn1cblxuaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgKSB7XG5cdFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdHJldHVybiBhICE9PSBiICYmIChhLmNvbnRhaW5zID8gYS5jb250YWlucyhiKSA6IHRydWUpO1xuXHR9O1xuXG59IGVsc2UgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdHJldHVybiAhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgMTYpO1xuXHR9O1xuXG59IGVsc2Uge1xuXHRTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cblNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gKGVsZW0gPyBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSA6IDApLmRvY3VtZW50RWxlbWVudDtcblxuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxudmFyIHBvc1Byb2Nlc3MgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCxcblx0XHR0bXBTZXQgPSBbXSxcblx0XHRsYXRlciA9IFwiXCIsXG5cdFx0cm9vdCA9IGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0O1xuXG5cdC8vIFBvc2l0aW9uIHNlbGVjdG9ycyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIGZpbHRlclxuXHQvLyBBbmQgc28gbXVzdCA6bm90KHBvc2l0aW9uYWwpIHNvIHdlIG1vdmUgYWxsIFBTRVVET3MgdG8gdGhlIGVuZFxuXHR3aGlsZSAoIChtYXRjaCA9IEV4cHIubWF0Y2guUFNFVURPLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXHRcdGxhdGVyICs9IG1hdGNoWzBdO1xuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSggRXhwci5tYXRjaC5QU0VVRE8sIFwiXCIgKTtcblx0fVxuXG5cdHNlbGVjdG9yID0gRXhwci5yZWxhdGl2ZVtzZWxlY3Rvcl0gPyBzZWxlY3RvciArIFwiKlwiIDogc2VsZWN0b3I7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gcm9vdC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3Rvciwgcm9vdFtpXSwgdG1wU2V0LCBzZWVkICk7XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlLmZpbHRlciggbGF0ZXIsIHRtcFNldCApO1xufTtcblxuLy8gRVhQT1NFXG4vLyBPdmVycmlkZSBzaXp6bGUgYXR0cmlidXRlIHJldHJpZXZhbFxuU2l6emxlLmF0dHIgPSBqUXVlcnkuYXR0cjtcblNpenpsZS5zZWxlY3RvcnMuYXR0ck1hcCA9IHt9O1xualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5maWx0ZXJzO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG59KSgpO1xuXG5cbnZhciBydW50aWwgPSAvVW50aWwkLyxcblx0cnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXZVbnRpbHxwcmV2QWxsKS8sXG5cdC8vIE5vdGU6IFRoaXMgUmVnRXhwIHNob3VsZCBiZSBpbXByb3ZlZCwgb3IgbGlrZWx5IHB1bGxlZCBmcm9tIFNpenpsZVxuXHRybXVsdGlzZWxlY3RvciA9IC8sLyxcblx0aXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC8sXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRQT1MgPSBqUXVlcnkuZXhwci5tYXRjaC5nbG9iYWxQT1MsXG5cdC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0aSwgbDtcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgcmV0ID0gdGhpcy5wdXNoU3RhY2soIFwiXCIsIFwiZmluZFwiLCBzZWxlY3RvciApLFxuXHRcdFx0bGVuZ3RoLCBuLCByO1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGxlbmd0aCA9IHJldC5sZW5ndGg7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHRoaXNbaV0sIHJldCApO1xuXG5cdFx0XHRpZiAoIGkgPiAwICkge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcmVzdWx0cyBhcmUgdW5pcXVlXG5cdFx0XHRcdGZvciAoIG4gPSBsZW5ndGg7IG4gPCByZXQubGVuZ3RoOyBuKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggciA9IDA7IHIgPCBsZW5ndGg7IHIrKyApIHtcblx0XHRcdFx0XHRcdGlmICggcmV0W3JdID09PSByZXRbbl0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldC5zcGxpY2Uobi0tLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCApO1xuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IsIGZhbHNlKSwgXCJub3RcIiwgc2VsZWN0b3IpO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCB0cnVlKSwgXCJmaWx0ZXJcIiwgc2VsZWN0b3IgKTtcblx0fSxcblxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXNlbGVjdG9yICYmIChcblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0XHRQT1MudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkuaW5kZXgoIHRoaXNbMF0gKSA+PSAwIDpcblx0XHRcdFx0XHRqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgdGhpcyApLmxlbmd0aCA+IDAgOlxuXHRcdFx0XHR0aGlzLmZpbHRlciggc2VsZWN0b3IgKS5sZW5ndGggPiAwICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgcmV0ID0gW10sIGksIGwsIGN1ciA9IHRoaXNbMF07XG5cblx0XHQvLyBBcnJheSAoZGVwcmVjYXRlZCBhcyBvZiBqUXVlcnkgMS43KVxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0dmFyIGxldmVsID0gMTtcblxuXHRcdFx0d2hpbGUgKCBjdXIgJiYgY3VyLm93bmVyRG9jdW1lbnQgJiYgY3VyICE9PSBjb250ZXh0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0XHRcdGlmICggalF1ZXJ5KCBjdXIgKS5pcyggc2VsZWN0b3JzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdHJldC5wdXNoKHsgc2VsZWN0b3I6IHNlbGVjdG9yc1sgaSBdLCBlbGVtOiBjdXIsIGxldmVsOiBsZXZlbCB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdFx0bGV2ZWwrKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHQvLyBTdHJpbmdcblx0XHR2YXIgcG9zID0gUE9TLnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Y3VyID0gdGhpc1tpXTtcblxuXHRcdFx0d2hpbGUgKCBjdXIgKSB7XG5cdFx0XHRcdGlmICggcG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYgKCAhY3VyIHx8ICFjdXIub3duZXJEb2N1bWVudCB8fCBjdXIgPT09IGNvbnRleHQgfHwgY3VyLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldCA9IHJldC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQ7XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgXCJjbG9zZXN0XCIsIHNlbGVjdG9ycyApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkgPyB0aGlzLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBpbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KFxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzICk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0dmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yICYmIHNlbGVjdG9yLm5vZGVUeXBlID8gWyBzZWxlY3RvciBdIDogc2VsZWN0b3IgKSxcblx0XHRcdGFsbCA9IGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGlzRGlzY29ubmVjdGVkKCBzZXRbMF0gKSB8fCBpc0Rpc2Nvbm5lY3RlZCggYWxsWzBdICkgP1xuXHRcdFx0YWxsIDpcblx0XHRcdGpRdWVyeS51bmlxdWUoIGFsbCApICk7XG5cdH0sXG5cblx0YW5kU2VsZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCB0aGlzLnByZXZPYmplY3QgKTtcblx0fVxufSk7XG5cbi8vIEEgcGFpbmZ1bGx5IHNpbXBsZSBjaGVjayB0byBzZWUgaWYgYW4gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWRcbi8vIGZyb20gYSBkb2N1bWVudCAoc2hvdWxkIGJlIGltcHJvdmVkLCB3aGVyZSBmZWFzaWJsZSkuXG5mdW5jdGlvbiBpc0Rpc2Nvbm5lY3RlZCggbm9kZSApIHtcblx0cmV0dXJuICFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5udGgoIGVsZW0sIDIsIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm50aCggZWxlbSwgMiwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xuXHRcdFx0ZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50IDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoICFydW50aWwudGVzdCggbmFtZSApICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLmxlbmd0aCA+IDEgJiYgIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0O1xuXG5cdFx0aWYgKCAodGhpcy5sZW5ndGggPiAxIHx8IHJtdWx0aXNlbGVjdG9yLnRlc3QoIHNlbGVjdG9yICkpICYmIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRyZXQgPSByZXQucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBuYW1lLCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKS5qb2luKFwiLFwiKSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHRcdGlmICggbm90ICkge1xuXHRcdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxID9cblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtc1swXSwgZXhwcikgPyBbIGVsZW1zWzBdIF0gOiBbXSA6XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGVsZW1zKTtcblx0fSxcblxuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHRjdXIgPSBlbGVtWyBkaXIgXTtcblxuXHRcdHdoaWxlICggY3VyICYmIGN1ci5ub2RlVHlwZSAhPT0gOSAmJiAodW50aWwgPT09IHVuZGVmaW5lZCB8fCBjdXIubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeSggY3VyICkuaXMoIHVudGlsICkpICkge1xuXHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHR9XG5cdFx0XHRjdXIgPSBjdXJbZGlyXTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH0sXG5cblx0bnRoOiBmdW5jdGlvbiggY3VyLCByZXN1bHQsIGRpciwgZWxlbSApIHtcblx0XHRyZXN1bHQgPSByZXN1bHQgfHwgMTtcblx0XHR2YXIgbnVtID0gMDtcblxuXHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXJbZGlyXSApIHtcblx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICsrbnVtID09PSByZXN1bHQgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjdXI7XG5cdH0sXG5cblx0c2libGluZzogZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdFx0dmFyIHIgPSBbXTtcblxuXHRcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdFx0ci5wdXNoKCBuICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHI7XG5cdH1cbn0pO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBrZWVwICkge1xuXG5cdC8vIENhbid0IHBhc3MgbnVsbCBvciB1bmRlZmluZWQgdG8gaW5kZXhPZiBpbiBGaXJlZm94IDRcblx0Ly8gU2V0IHRvIDAgdG8gc2tpcCBzdHJpbmcgY2hlY2tcblx0cXVhbGlmaWVyID0gcXVhbGlmaWVyIHx8IDA7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHZhciByZXRWYWwgPSAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gcmV0VmFsID09PSBrZWVwO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgPT09IGtlZXA7XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR2YXIgZmlsdGVyZWQgPSBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9KTtcblxuXHRcdGlmICggaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGZpbHRlcmVkLCAha2VlcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZmlsdGVyZWQgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdHJldHVybiAoIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBxdWFsaWZpZXIgKSA+PSAwICkgPT09IGtlZXA7XG5cdH0pO1xufVxuXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICkge1xuXHR2YXIgbGlzdCA9IG5vZGVOYW1lcy5zcGxpdCggXCJ8XCIgKSxcblx0c2FmZUZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0aWYgKCBzYWZlRnJhZy5jcmVhdGVFbGVtZW50ICkge1xuXHRcdHdoaWxlICggbGlzdC5sZW5ndGggKSB7XG5cdFx0XHRzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRsaXN0LnBvcCgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc2FmZUZyYWc7XG59XG5cbnZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuXHRcdFwiaGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixcblx0cmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/OlxcZCt8bnVsbClcIi9nLFxuXHRybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vaWcsXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuXHRydGJvZHkgPSAvPHRib2R5L2ksXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZSkvaSxcblx0cm5vY2FjaGUgPSAvPCg/OnNjcmlwdHxvYmplY3R8ZW1iZWR8b3B0aW9ufHN0eWxlKS9pLFxuXHRybm9zaGltY2FjaGUgPSBuZXcgUmVnRXhwKFwiPCg/OlwiICsgbm9kZU5hbWVzICsgXCIpW1xcXFxzLz5dXCIsIFwiaVwiKSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXFwvKGphdmF8ZWNtYSlzY3JpcHQvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3xcXC1cXC0pLyxcblx0d3JhcE1hcCA9IHtcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblx0XHRsZWdlbmQ6IFsgMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIiBdLFxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRcdGNvbDogWyAyLCBcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdFx0YXJlYTogWyAxLCBcIjxtYXA+XCIsIFwiPC9tYXA+XCIgXSxcblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fSxcblx0c2FmZUZyYWdtZW50ID0gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApO1xuXG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIElFIGNhbid0IHNlcmlhbGl6ZSA8bGluaz4gYW5kIDxzY3JpcHQ+IHRhZ3Mgbm9ybWFsbHlcbmlmICggIWpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgKSB7XG5cdHdyYXBNYXAuX2RlZmF1bHQgPSBbIDEsIFwiZGl2PGRpdj5cIiwgXCI8L2Rpdj5cIiBdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCAoIHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkuY3JlYXRlVGV4dE5vZGUoIHZhbHVlICkgKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0dmFyIHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCApLmVxKDApLmNsb25lKHRydWUpO1xuXG5cdFx0XHRpZiAoIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCB0cnVlLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0dGhpcy5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHRoaXMuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHZhciBzZXQgPSBqUXVlcnkuY2xlYW4oIGFyZ3VtZW50cyApO1xuXHRcdFx0c2V0LnB1c2guYXBwbHkoIHNldCwgdGhpcy50b0FycmF5KCkgKTtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2V0LCBcImJlZm9yZVwiLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHZhciBzZXQgPSB0aGlzLnB1c2hTdGFjayggdGhpcywgXCJhZnRlclwiLCBhcmd1bWVudHMgKTtcblx0XHRcdHNldC5wdXNoLmFwcGx5KCBzZXQsIGpRdWVyeS5jbGVhbihhcmd1bWVudHMpICk7XG5cdFx0XHRyZXR1cm4gc2V0O1xuXHRcdH1cblx0fSxcblxuXHQvLyBrZWVwRGF0YSBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHktLWRvIG5vdCBkb2N1bWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBbIGVsZW0gXSApLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xuXHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVDaGlsZCggZWxlbS5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1swXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwucmVwbGFjZSggcmlubGluZWpRdWVyeSwgXCJcIiApIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQoIGpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFybGVhZGluZ1doaXRlc3BhY2UudGVzdCggdmFsdWUgKSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgW1wiXCIsIFwiXCJdIClbMV0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbaV0gfHwge307XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJlZm9yZSB0aGV5IGFyZSBpbnNlcnRlZFxuXHRcdFx0Ly8gdGhpcyBjYW4gaGVscCBmaXggcmVwbGFjaW5nIGEgcGFyZW50IHdpdGggY2hpbGQgZWxlbWVudHNcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCBvbGQgPSBzZWxmLmh0bWwoKTtcblx0XHRcdFx0XHRzZWxmLnJlcGxhY2VXaXRoKCB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBvbGQgKSApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5KCB2YWx1ZSApLmRldGFjaCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRcdFx0cGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZSgpO1xuXG5cdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRqUXVlcnkobmV4dCkuYmVmb3JlKCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeShwYXJlbnQpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRcdHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlKSwgXCJyZXBsYWNlV2l0aFwiLCB2YWx1ZSApIDpcblx0XHRcdFx0dGhpcztcblx0XHR9XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgdGFibGUsIGNhbGxiYWNrICkge1xuXHRcdHZhciByZXN1bHRzLCBmaXJzdCwgZnJhZ21lbnQsIHBhcmVudCxcblx0XHRcdHZhbHVlID0gYXJnc1swXSxcblx0XHRcdHNjcmlwdHMgPSBbXTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmNoZWNrQ2xvbmUgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS5kb21NYW5pcCggYXJncywgdGFibGUsIGNhbGxiYWNrLCB0cnVlICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcblx0XHRcdFx0YXJnc1swXSA9IHZhbHVlLmNhbGwodGhpcywgaSwgdGFibGUgPyBzZWxmLmh0bWwoKSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIHRhYmxlLCBjYWxsYmFjayApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWzBdICkge1xuXHRcdFx0cGFyZW50ID0gdmFsdWUgJiYgdmFsdWUucGFyZW50Tm9kZTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgaW4gYSBmcmFnbWVudCwganVzdCB1c2UgdGhhdCBpbnN0ZWFkIG9mIGJ1aWxkaW5nIGEgbmV3IG9uZVxuXHRcdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5wYXJlbnROb2RlICYmIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdHJlc3VsdHMgPSB7IGZyYWdtZW50OiBwYXJlbnQgfTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0cyA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzLCBzY3JpcHRzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZyYWdtZW50ID0gcmVzdWx0cy5mcmFnbWVudDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0Zmlyc3QgPSBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRcdHRhYmxlID0gdGFibGUgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBmaXJzdCwgXCJ0clwiICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGgsIGxhc3RJbmRleCA9IGwgLSAxOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoXG5cdFx0XHRcdFx0XHR0YWJsZSA/XG5cdFx0XHRcdFx0XHRcdHJvb3QodGhpc1tpXSwgZmlyc3QpIDpcblx0XHRcdFx0XHRcdFx0dGhpc1tpXSxcblx0XHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvIG5vdCBsZWFrIG1lbW9yeSBieSBpbmFkdmVydGVudGx5IGRpc2NhcmRpbmdcblx0XHRcdFx0XHRcdC8vIHRoZSBvcmlnaW5hbCBmcmFnbWVudCAod2hpY2ggbWlnaHQgaGF2ZSBhdHRhY2hlZCBkYXRhKSBpbnN0ZWFkIG9mXG5cdFx0XHRcdFx0XHQvLyB1c2luZyBpdDsgaW4gYWRkaXRpb24sIHVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgb2JqZWN0IGZvciB0aGUgbGFzdFxuXHRcdFx0XHRcdFx0Ly8gaXRlbSBpbnN0ZWFkIG9mIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cCBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5XG5cdFx0XHRcdFx0XHQvLyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKEJ1ZyAjODA3MCkuXG5cdFx0XHRcdFx0XHQvLyBGcmFnbWVudHMgZnJvbSB0aGUgZnJhZ21lbnQgY2FjaGUgbXVzdCBhbHdheXMgYmUgY2xvbmVkIGFuZCBuZXZlciB1c2VkXG5cdFx0XHRcdFx0XHQvLyBpbiBwbGFjZS5cblx0XHRcdFx0XHRcdHJlc3VsdHMuY2FjaGVhYmxlIHx8ICggbCA+IDEgJiYgaSA8IGxhc3RJbmRleCApID9cblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsb25lKCBmcmFnbWVudCwgdHJ1ZSwgdHJ1ZSApIDpcblx0XHRcdFx0XHRcdFx0ZnJhZ21lbnRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBzY3JpcHRzLCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uc3JjICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdFx0XHRcdFx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHR1cmw6IGVsZW0uc3JjLFxuXHRcdFx0XHRcdFx0XHRhc3luYzogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoICggZWxlbS50ZXh0IHx8IGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCIvKiQwKi9cIiApICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gcm9vdCggZWxlbSwgY3VyICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgP1xuXHRcdChlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRlbGVtLmFwcGVuZENoaWxkKGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpKSA6XG5cdFx0ZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeS5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgdHlwZSwgaSwgbCxcblx0XHRvbGREYXRhID0galF1ZXJ5Ll9kYXRhKCBzcmMgKSxcblx0XHRjdXJEYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0LCBvbGREYXRhICksXG5cdFx0ZXZlbnRzID0gb2xkRGF0YS5ldmVudHM7XG5cblx0aWYgKCBldmVudHMgKSB7XG5cdFx0ZGVsZXRlIGN1ckRhdGEuaGFuZGxlO1xuXHRcdGN1ckRhdGEuZXZlbnRzID0ge307XG5cblx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gbWFrZSB0aGUgY2xvbmVkIHB1YmxpYyBkYXRhIG9iamVjdCBhIGNvcHkgZnJvbSB0aGUgb3JpZ2luYWxcblx0aWYgKCBjdXJEYXRhLmRhdGEgKSB7XG5cdFx0Y3VyRGF0YS5kYXRhID0galF1ZXJ5LmV4dGVuZCgge30sIGN1ckRhdGEuZGF0YSApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lRml4QXR0cmlidXRlcyggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWU7XG5cblx0Ly8gV2UgZG8gbm90IG5lZWQgdG8gZG8gYW55dGhpbmcgZm9yIG5vbi1FbGVtZW50c1xuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gY2xlYXJBdHRyaWJ1dGVzIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZXMsIHdoaWNoIHdlIGRvbid0IHdhbnQsXG5cdC8vIGJ1dCBhbHNvIHJlbW92ZXMgdGhlIGF0dGFjaEV2ZW50IGV2ZW50cywgd2hpY2ggd2UgKmRvKiB3YW50XG5cdGlmICggZGVzdC5jbGVhckF0dHJpYnV0ZXMgKSB7XG5cdFx0ZGVzdC5jbGVhckF0dHJpYnV0ZXMoKTtcblx0fVxuXG5cdC8vIG1lcmdlQXR0cmlidXRlcywgaW4gY29udHJhc3QsIG9ubHkgbWVyZ2VzIGJhY2sgb24gdGhlXG5cdC8vIG9yaWdpbmFsIGF0dHJpYnV0ZXMsIG5vdCB0aGUgZXZlbnRzXG5cdGlmICggZGVzdC5tZXJnZUF0dHJpYnV0ZXMgKSB7XG5cdFx0ZGVzdC5tZXJnZUF0dHJpYnV0ZXMoIHNyYyApO1xuXHR9XG5cblx0bm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gSUU2LTggZmFpbCB0byBjbG9uZSBjaGlsZHJlbiBpbnNpZGUgb2JqZWN0IGVsZW1lbnRzIHRoYXQgdXNlXG5cdC8vIHRoZSBwcm9wcmlldGFyeSBjbGFzc2lkIGF0dHJpYnV0ZSB2YWx1ZSAocmF0aGVyIHRoYW4gdGhlIHR5cGVcblx0Ly8gYXR0cmlidXRlKSB0byBpZGVudGlmeSB0aGUgdHlwZSBvZiBjb250ZW50IHRvIGRpc3BsYXlcblx0aWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRkZXN0Lm91dGVySFRNTCA9IHNyYy5vdXRlckhUTUw7XG5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAoc3JjLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCBzcmMudHlwZSA9PT0gXCJyYWRpb1wiKSApIHtcblx0XHQvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94XG5cdFx0Ly8gb3IgcmFkaW8gYnV0dG9uLiBXb3JzZSwgSUU2LTcgZmFpbCB0byBnaXZlIHRoZSBjbG9uZWQgZWxlbWVudFxuXHRcdC8vIGEgY2hlY2tlZCBhcHBlYXJhbmNlIGlmIHRoZSBkZWZhdWx0Q2hlY2tlZCB2YWx1ZSBpc24ndCBhbHNvIHNldFxuXHRcdGlmICggc3JjLmNoZWNrZWQgKSB7XG5cdFx0XHRkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gSUU2LTcgZ2V0IGNvbmZ1c2VkIGFuZCBlbmQgdXAgc2V0dGluZyB0aGUgdmFsdWUgb2YgYSBjbG9uZWRcblx0XHQvLyBjaGVja2JveC9yYWRpbyBidXR0b24gdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgXCJvblwiXG5cdFx0aWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XG5cdFx0XHRkZXN0LnZhbHVlID0gc3JjLnZhbHVlO1xuXHRcdH1cblxuXHQvLyBJRTYtOCBmYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZFxuXHQvLyBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiApIHtcblx0XHRkZXN0LnNlbGVjdGVkID0gc3JjLmRlZmF1bHRTZWxlY3RlZDtcblxuXHQvLyBJRTYtOCBmYWlscyB0byBzZXQgdGhlIGRlZmF1bHRWYWx1ZSB0byB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuXG5cdC8vIGNsb25pbmcgb3RoZXIgdHlwZXMgb2YgaW5wdXQgZmllbGRzXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gSUUgYmxhbmtzIGNvbnRlbnRzIHdoZW4gY2xvbmluZyBzY3JpcHRzXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcInNjcmlwdFwiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7XG5cdFx0ZGVzdC50ZXh0ID0gc3JjLnRleHQ7XG5cdH1cblxuXHQvLyBFdmVudCBkYXRhIGdldHMgcmVmZXJlbmNlZCBpbnN0ZWFkIG9mIGNvcGllZCBpZiB0aGUgZXhwYW5kb1xuXHQvLyBnZXRzIGNvcGllZCB0b29cblx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XG5cblx0Ly8gQ2xlYXIgZmxhZ3MgZm9yIGJ1YmJsaW5nIHNwZWNpYWwgY2hhbmdlL3N1Ym1pdCBldmVudHMsIHRoZXkgbXVzdFxuXHQvLyBiZSByZWF0dGFjaGVkIHdoZW4gdGhlIG5ld2x5IGNsb25lZCBldmVudHMgYXJlIGZpcnN0IGFjdGl2YXRlZFxuXHRkZXN0LnJlbW92ZUF0dHJpYnV0ZSggXCJfc3VibWl0X2F0dGFjaGVkXCIgKTtcblx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIFwiX2NoYW5nZV9hdHRhY2hlZFwiICk7XG59XG5cbmpRdWVyeS5idWlsZEZyYWdtZW50ID0gZnVuY3Rpb24oIGFyZ3MsIG5vZGVzLCBzY3JpcHRzICkge1xuXHR2YXIgZnJhZ21lbnQsIGNhY2hlYWJsZSwgY2FjaGVyZXN1bHRzLCBkb2MsXG5cdGZpcnN0ID0gYXJnc1sgMCBdO1xuXG5cdC8vIG5vZGVzIG1heSBjb250YWluIGVpdGhlciBhbiBleHBsaWNpdCBkb2N1bWVudCBvYmplY3QsXG5cdC8vIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb3IgY29udGV4dCBvYmplY3QuXG5cdC8vIElmIG5vZGVzWzBdIGNvbnRhaW5zIGEgdmFsaWQgb2JqZWN0IHRvIGFzc2lnbiB0byBkb2Ncblx0aWYgKCBub2RlcyAmJiBub2Rlc1swXSApIHtcblx0XHRkb2MgPSBub2Rlc1swXS5vd25lckRvY3VtZW50IHx8IG5vZGVzWzBdO1xuXHR9XG5cblx0Ly8gRW5zdXJlIHRoYXQgYW4gYXR0ciBvYmplY3QgZG9lc24ndCBpbmNvcnJlY3RseSBzdGFuZCBpbiBhcyBhIGRvY3VtZW50IG9iamVjdFxuXHQvLyBDaHJvbWUgYW5kIEZpcmVmb3ggc2VlbSB0byBhbGxvdyB0aGlzIHRvIG9jY3VyIGFuZCB3aWxsIHRocm93IGV4Y2VwdGlvblxuXHQvLyBGaXhlcyAjODk1MFxuXHRpZiAoICFkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCApIHtcblx0XHRkb2MgPSBkb2N1bWVudDtcblx0fVxuXG5cdC8vIE9ubHkgY2FjaGUgXCJzbWFsbFwiICgxLzIgS0IpIEhUTUwgc3RyaW5ncyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1haW4gZG9jdW1lbnRcblx0Ly8gQ2xvbmluZyBvcHRpb25zIGxvc2VzIHRoZSBzZWxlY3RlZCBzdGF0ZSwgc28gZG9uJ3QgY2FjaGUgdGhlbVxuXHQvLyBJRSA2IGRvZXNuJ3QgbGlrZSBpdCB3aGVuIHlvdSBwdXQgPG9iamVjdD4gb3IgPGVtYmVkPiBlbGVtZW50cyBpbiBhIGZyYWdtZW50XG5cdC8vIEFsc28sIFdlYktpdCBkb2VzIG5vdCBjbG9uZSAnY2hlY2tlZCcgYXR0cmlidXRlcyBvbiBjbG9uZU5vZGUsIHNvIGRvbid0IGNhY2hlXG5cdC8vIExhc3RseSwgSUU2LDcsOCB3aWxsIG5vdCBjb3JyZWN0bHkgcmV1c2UgY2FjaGVkIGZyYWdtZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIHVua25vd24gZWxlbXMgIzEwNTAxXG5cdGlmICggYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGZpcnN0Lmxlbmd0aCA8IDUxMiAmJiBkb2MgPT09IGRvY3VtZW50ICYmXG5cdFx0Zmlyc3QuY2hhckF0KDApID09PSBcIjxcIiAmJiAhcm5vY2FjaGUudGVzdCggZmlyc3QgKSAmJlxuXHRcdChqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lIHx8ICFyY2hlY2tlZC50ZXN0KCBmaXJzdCApKSAmJlxuXHRcdChqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lIHx8ICFybm9zaGltY2FjaGUudGVzdCggZmlyc3QgKSkgKSB7XG5cblx0XHRjYWNoZWFibGUgPSB0cnVlO1xuXG5cdFx0Y2FjaGVyZXN1bHRzID0galF1ZXJ5LmZyYWdtZW50c1sgZmlyc3QgXTtcblx0XHRpZiAoIGNhY2hlcmVzdWx0cyAmJiBjYWNoZXJlc3VsdHMgIT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGNhY2hlcmVzdWx0cztcblx0XHR9XG5cdH1cblxuXHRpZiAoICFmcmFnbWVudCApIHtcblx0XHRmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0alF1ZXJ5LmNsZWFuKCBhcmdzLCBkb2MsIGZyYWdtZW50LCBzY3JpcHRzICk7XG5cdH1cblxuXHRpZiAoIGNhY2hlYWJsZSApIHtcblx0XHRqUXVlcnkuZnJhZ21lbnRzWyBmaXJzdCBdID0gY2FjaGVyZXN1bHRzID8gZnJhZ21lbnQgOiAxO1xuXHR9XG5cblx0cmV0dXJuIHsgZnJhZ21lbnQ6IGZyYWdtZW50LCBjYWNoZWFibGU6IGNhY2hlYWJsZSB9O1xufTtcblxualF1ZXJ5LmZyYWdtZW50cyA9IHt9O1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRwYXJlbnQgPSB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLnBhcmVudE5vZGU7XG5cblx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpbnNlcnQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0aW5zZXJ0WyBvcmlnaW5hbCBdKCB0aGlzWzBdICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnNlcnQubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHR2YXIgZWxlbXMgPSAoIGkgPiAwID8gdGhpcy5jbG9uZSh0cnVlKSA6IHRoaXMgKS5nZXQoKTtcblx0XHRcdFx0alF1ZXJ5KCBpbnNlcnRbaV0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblx0XHRcdFx0cmV0ID0gcmV0LmNvbmNhdCggZWxlbXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQsIG5hbWUsIGluc2VydC5zZWxlY3RvciApO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRBbGwoIGVsZW0gKSB7XG5cdGlmICggdHlwZW9mIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGVsZW0ucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXR1cm4gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG59XG5cbi8vIFVzZWQgaW4gY2xlYW4sIGZpeGVzIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKSB7XG5cdGlmICggZWxlbS50eXBlID09PSBcImNoZWNrYm94XCIgfHwgZWxlbS50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0ZWxlbS5kZWZhdWx0Q2hlY2tlZCA9IGVsZW0uY2hlY2tlZDtcblx0fVxufVxuLy8gRmluZHMgYWxsIGlucHV0cyBhbmQgcGFzc2VzIHRoZW0gdG8gZml4RGVmYXVsdENoZWNrZWRcbmZ1bmN0aW9uIGZpbmRJbnB1dHMoIGVsZW0gKSB7XG5cdHZhciBub2RlTmFtZSA9ICggZWxlbS5ub2RlTmFtZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKTtcblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICk7XG5cdC8vIFNraXAgc2NyaXB0cywgZ2V0IG90aGVyIGNoaWxkcmVuXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lICE9PSBcInNjcmlwdFwiICYmIHR5cGVvZiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdGpRdWVyeS5ncmVwKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIiksIGZpeERlZmF1bHRDaGVja2VkICk7XG5cdH1cbn1cblxuLy8gRGVyaXZlZCBGcm9tOiBodHRwOi8vd3d3LmllY3NzLmNvbS9zaGltcHJvdmUvamF2YXNjcmlwdC9zaGltcHJvdmUuMS0wLTEuanNcbmZ1bmN0aW9uIHNoaW1DbG9uZU5vZGUoIGVsZW0gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0ZGl2LmlubmVySFRNTCA9IGVsZW0ub3V0ZXJIVE1MO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBzcmNFbGVtZW50cyxcblx0XHRcdGRlc3RFbGVtZW50cyxcblx0XHRcdGksXG5cdFx0XHQvLyBJRTw9OCBkb2VzIG5vdCBwcm9wZXJseSBjbG9uZSBkZXRhY2hlZCwgdW5rbm93biBlbGVtZW50IG5vZGVzXG5cdFx0XHRjbG9uZSA9IGpRdWVyeS5zdXBwb3J0Lmh0bWw1Q2xvbmUgfHwgalF1ZXJ5LmlzWE1MRG9jKGVsZW0pIHx8ICFybm9zaGltY2FjaGUudGVzdCggXCI8XCIgKyBlbGVtLm5vZGVOYW1lICsgXCI+XCIgKSA/XG5cdFx0XHRcdGVsZW0uY2xvbmVOb2RlKCB0cnVlICkgOlxuXHRcdFx0XHRzaGltQ2xvbmVOb2RlKCBlbGVtICk7XG5cblx0XHRpZiAoICghalF1ZXJ5LnN1cHBvcnQubm9DbG9uZUV2ZW50IHx8ICFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCkgJiZcblx0XHRcdFx0KGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEpICYmICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkgKSB7XG5cdFx0XHQvLyBJRSBjb3BpZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCB3aGVuIHVzaW5nIGNsb25lTm9kZS5cblx0XHRcdC8vIENhbGxpbmcgZGV0YWNoRXZlbnQgb24gdGhlIGNsb25lIHdpbGwgYWxzbyByZW1vdmUgdGhlIGV2ZW50c1xuXHRcdFx0Ly8gZnJvbSB0aGUgb3JpZ2luYWwuIEluIG9yZGVyIHRvIGdldCBhcm91bmQgdGhpcywgd2UgdXNlIHNvbWVcblx0XHRcdC8vIHByb3ByaWV0YXJ5IG1ldGhvZHMgdG8gY2xlYXIgdGhlIGV2ZW50cy4gVGhhbmtzIHRvIE1vb1Rvb2xzXG5cdFx0XHQvLyBndXlzIGZvciB0aGlzIGhvdG5lc3MuXG5cblx0XHRcdGNsb25lRml4QXR0cmlidXRlcyggZWxlbSwgY2xvbmUgKTtcblxuXHRcdFx0Ly8gVXNpbmcgU2l6emxlIGhlcmUgaXMgY3Jhenkgc2xvdywgc28gd2UgdXNlIGdldEVsZW1lbnRzQnlUYWdOYW1lIGluc3RlYWRcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdC8vIFdlaXJkIGl0ZXJhdGlvbiBiZWNhdXNlIElFIHdpbGwgcmVwbGFjZSB0aGUgbGVuZ3RoIHByb3BlcnR5XG5cdFx0XHQvLyB3aXRoIGFuIGVsZW1lbnQgaWYgeW91IGFyZSBjbG9uaW5nIHRoZSBib2R5IGFuZCBvbmUgb2YgdGhlXG5cdFx0XHQvLyBlbGVtZW50cyBvbiB0aGUgcGFnZSBoYXMgYSBuYW1lIG9yIGlkIG9mIFwibGVuZ3RoXCJcblx0XHRcdGZvciAoIGkgPSAwOyBzcmNFbGVtZW50c1tpXTsgKytpICkge1xuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCB0aGUgZGVzdGluYXRpb24gbm9kZSBpcyBub3QgbnVsbDsgRml4ZXMgIzk1ODdcblx0XHRcdFx0aWYgKCBkZXN0RWxlbWVudHNbaV0gKSB7XG5cdFx0XHRcdFx0Y2xvbmVGaXhBdHRyaWJ1dGVzKCBzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgc3JjRWxlbWVudHNbaV07ICsraSApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3JjRWxlbWVudHMgPSBkZXN0RWxlbWVudHMgPSBudWxsO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuOiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIGZyYWdtZW50LCBzY3JpcHRzICkge1xuXHRcdHZhciBjaGVja1NjcmlwdFR5cGUsIHNjcmlwdCwgaixcblx0XHRcdFx0cmV0ID0gW107XG5cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdC8vICFjb250ZXh0LmNyZWF0ZUVsZW1lbnQgZmFpbHMgaW4gSUUgd2l0aCBhbiBlcnJvciBidXQgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmNyZWF0ZUVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRjb250ZXh0ID0gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRbMF0gJiYgY29udGV4dFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0ZWxlbSArPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIHN0cmluZyBpbnRvIERPTSBub2Rlc1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRml4IFwiWEhUTUxcIi1zdHlsZSB0YWdzIGluIGFsbCBicm93c2Vyc1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcblxuXHRcdFx0XHRcdC8vIFRyaW0gd2hpdGVzcGFjZSwgb3RoZXJ3aXNlIGluZGV4T2Ygd29uJ3Qgd29yayBhcyBleHBlY3RlZFxuXHRcdFx0XHRcdHZhciB0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbXCJcIiwgXCJcIl0gKVsxXS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQsXG5cdFx0XHRcdFx0XHRkZXB0aCA9IHdyYXBbMF0sXG5cdFx0XHRcdFx0XHRkaXYgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRcdFx0XHRzYWZlQ2hpbGROb2RlcyA9IHNhZmVGcmFnbWVudC5jaGlsZE5vZGVzLFxuXHRcdFx0XHRcdFx0cmVtb3ZlO1xuXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIHdyYXBwZXIgZWxlbWVudCB0byB1bmtub3duIGVsZW1lbnQgc2FmZSBkb2MgZnJhZ21lbnRcblx0XHRcdFx0XHRpZiAoIGNvbnRleHQgPT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBmcmFnbWVudCB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgZm9yIHRoaXMgZG9jdW1lbnRcblx0XHRcdFx0XHRcdHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFVzZSBhIGZyYWdtZW50IGNyZWF0ZWQgd2l0aCB0aGUgb3duZXIgZG9jdW1lbnRcblx0XHRcdFx0XHRcdGNyZWF0ZVNhZmVGcmFnbWVudCggY29udGV4dCApLmFwcGVuZENoaWxkKCBkaXYgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBHbyB0byBodG1sIGFuZCBiYWNrLCB0aGVuIHBlZWwgb2ZmIGV4dHJhIHdyYXBwZXJzXG5cdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtICsgd3JhcFsyXTtcblxuXHRcdFx0XHRcdC8vIE1vdmUgdG8gdGhlIHJpZ2h0IGRlcHRoXG5cdFx0XHRcdFx0d2hpbGUgKCBkZXB0aC0tICkge1xuXHRcdFx0XHRcdFx0ZGl2ID0gZGl2Lmxhc3RDaGlsZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LnRib2R5ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgPHRhYmxlPiwgKm1heSogaGF2ZSBzcHVyaW91cyA8dGJvZHk+XG5cdFx0XHRcdFx0XHR2YXIgaGFzQm9keSA9IHJ0Ym9keS50ZXN0KGVsZW0pLFxuXHRcdFx0XHRcdFx0XHR0Ym9keSA9IHRhZyA9PT0gXCJ0YWJsZVwiICYmICFoYXNCb2R5ID9cblx0XHRcdFx0XHRcdFx0XHRkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5jaGlsZE5vZGVzIDpcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN0cmluZyB3YXMgYSBiYXJlIDx0aGVhZD4gb3IgPHRmb290PlxuXHRcdFx0XHRcdFx0XHRcdHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFoYXNCb2R5ID9cblx0XHRcdFx0XHRcdFx0XHRcdGRpdi5jaGlsZE5vZGVzIDpcblx0XHRcdFx0XHRcdFx0XHRcdFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gdGJvZHkubGVuZ3RoIC0gMTsgaiA+PSAwIDsgLS1qICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGJvZHlbIGogXSwgXCJ0Ym9keVwiICkgJiYgIXRib2R5WyBqIF0uY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGJvZHlbIGogXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0Ym9keVsgaiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJRSBjb21wbGV0ZWx5IGtpbGxzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIGlubmVySFRNTCBpcyB1c2VkXG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgJiYgcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdGRpdi5pbnNlcnRCZWZvcmUoIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIHJsZWFkaW5nV2hpdGVzcGFjZS5leGVjKGVsZW0pWzBdICksIGRpdi5maXJzdENoaWxkICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IGRpdi5jaGlsZE5vZGVzO1xuXG5cdFx0XHRcdFx0Ly8gQ2xlYXIgZWxlbWVudHMgZnJvbSBEb2N1bWVudEZyYWdtZW50IChzYWZlRnJhZ21lbnQgb3Igb3RoZXJ3aXNlKVxuXHRcdFx0XHRcdC8vIHRvIGF2b2lkIGhvYXJkaW5nIGVsZW1lbnRzLiBGaXhlcyAjMTEzNTZcblx0XHRcdFx0XHRpZiAoIGRpdiApIHtcblx0XHRcdFx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblxuXHRcdFx0XHRcdFx0Ly8gR3VhcmQgYWdhaW5zdCAtMSBpbmRleCBleGNlcHRpb25zIGluIEZGMy42XG5cdFx0XHRcdFx0XHRpZiAoIHNhZmVDaGlsZE5vZGVzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZSA9IHNhZmVDaGlsZE5vZGVzWyBzYWZlQ2hpbGROb2Rlcy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCByZW1vdmUgJiYgcmVtb3ZlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVtb3ZlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHJlbW92ZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0cyBkZWZhdWx0Q2hlY2tlZCBmb3IgYW55IHJhZGlvcyBhbmQgY2hlY2tib3hlc1xuXHRcdFx0Ly8gYWJvdXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSBpbiBJRSA2LzcgKCM4MDYwKVxuXHRcdFx0dmFyIGxlbjtcblx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmFwcGVuZENoZWNrZWQgKSB7XG5cdFx0XHRcdGlmICggZWxlbVswXSAmJiB0eXBlb2YgKGxlbiA9IGVsZW0ubGVuZ3RoKSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdFx0ZmluZElucHV0cyggZWxlbVtqXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaW5kSW5wdXRzKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlICkge1xuXHRcdFx0XHRyZXQucHVzaCggZWxlbSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0ID0galF1ZXJ5Lm1lcmdlKCByZXQsIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZyYWdtZW50ICkge1xuXHRcdFx0Y2hlY2tTY3JpcHRUeXBlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAhZWxlbS50eXBlIHx8IHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSApO1xuXHRcdFx0fTtcblx0XHRcdGZvciAoIGkgPSAwOyByZXRbaV07IGkrKyApIHtcblx0XHRcdFx0c2NyaXB0ID0gcmV0W2ldO1xuXHRcdFx0XHRpZiAoIHNjcmlwdHMgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBzY3JpcHQsIFwic2NyaXB0XCIgKSAmJiAoIXNjcmlwdC50eXBlIHx8IHJzY3JpcHRUeXBlLnRlc3QoIHNjcmlwdC50eXBlICkpICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggc2NyaXB0LnBhcmVudE5vZGUgPyBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICkgOiBzY3JpcHQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggc2NyaXB0Lm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dmFyIGpzVGFncyA9IGpRdWVyeS5ncmVwKCBzY3JpcHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwic2NyaXB0XCIgKSwgY2hlY2tTY3JpcHRUeXBlICk7XG5cblx0XHRcdFx0XHRcdHJldC5zcGxpY2UuYXBwbHkoIHJldCwgW2kgKyAxLCAwXS5jb25jYXQoIGpzVGFncyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKCBzY3JpcHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGlkLFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRkZWxldGVFeHBhbmRvID0galF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVOYW1lICYmIGpRdWVyeS5ub0RhdGFbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlkID0gZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcblxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0ZGF0YSA9IGNhY2hlWyBpZCBdO1xuXG5cdFx0XHRcdGlmICggZGF0YSAmJiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRmb3IgKCB2YXIgdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOdWxsIHRoZSBET00gcmVmZXJlbmNlIHRvIGF2b2lkIElFNi83LzggbGVhayAoIzcwNTQpXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmhhbmRsZSApIHtcblx0XHRcdFx0XHRcdGRhdGEuaGFuZGxlLmVsZW0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGVsZXRlRXhwYW5kbyApIHtcblx0XHRcdFx0XHRkZWxldGUgZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLnJlbW92ZUF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsgaWQgXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaSxcblx0cm9wYWNpdHkgPSAvb3BhY2l0eT0oW14pXSopLyxcblx0Ly8gZml4ZWQgZm9yIElFOSwgc2VlICM4MzQ2XG5cdHJ1cHBlciA9IC8oW0EtWl18Xm1zKS9nLFxuXHRybnVtID0gL15bXFwtK10/KD86XFxkKlxcLik/XFxkKyQvaSxcblx0cm51bW5vbnB4ID0gL14tPyg/OlxcZCpcXC4pP1xcZCsoPyFweClbXlxcZFxcc10rJC9pLFxuXHRycmVsTnVtID0gL14oW1xcLStdKT0oW1xcLSsuXFxkZV0rKS8sXG5cdHJtYXJnaW4gPSAvXm1hcmdpbi8sXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cblx0Ly8gb3JkZXIgaXMgaW1wb3J0YW50IVxuXHRjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSxcblxuXHRjdXJDU1MsXG5cblx0Z2V0Q29tcHV0ZWRTdHlsZSxcblx0Y3VycmVudFN0eWxlO1xuXG5qUXVlcnkuZm4uY3NzID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUub3BhY2l0eTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBFeGNsdWRlIHRoZSBmb2xsb3dpbmcgY3NzIHByb3BlcnRpZXMgdG8gYWRkIHB4XG5cdGNzc051bWJlcjoge1xuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHQvLyBub3JtYWxpemUgZmxvYXQgY3NzIHByb3BlcnR5XG5cdFx0XCJmbG9hdFwiOiBqUXVlcnkuc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCBvcmlnTmFtZTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggKyggcmV0WzFdICsgMSkgKiArcmV0WzJdICkgKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBOYU4gYW5kIG51bGwgdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB0eXBlID09PSBcIm51bWJlclwiICYmIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIFdyYXBwZWQgdG8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGVycm9ycyB3aGVuICdpbnZhbGlkJyB2YWx1ZXMgYXJlIHByb3ZpZGVkXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjNTUwOVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXHRcdHZhciByZXQsIGhvb2tzO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0Ly8gY3NzRmxvYXQgbmVlZHMgYSBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdGlmICggbmFtZSA9PT0gXCJjc3NGbG9hdFwiICkge1xuXHRcdFx0bmFtZSA9IFwiZmxvYXRcIjtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0fSBlbHNlIGlmICggY3VyQ1NTICkge1xuXHRcdFx0cmV0dXJuIGN1ckNTUyggZWxlbSwgbmFtZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zXG5cdHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHR2YXIgb2xkID0ge30sXG5cdFx0XHRyZXQsIG5hbWU7XG5cblx0XHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0XHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG59KTtcblxuLy8gREVQUkVDQVRFRCBpbiAxLjMsIFVzZSBqUXVlcnkuY3NzKCkgaW5zdGVhZFxualF1ZXJ5LmN1ckNTUyA9IGpRdWVyeS5jc3M7XG5cbmlmICggZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0Z2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHZhciByZXQsIGRlZmF1bHRWaWV3LCBjb21wdXRlZFN0eWxlLCB3aWR0aCxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoIHJ1cHBlciwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoIChkZWZhdWx0VmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgJiZcblx0XHRcdFx0KGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICkpICkge1xuXG5cdFx0XHRyZXQgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKTtcblx0XHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIFdlYktpdCB1c2VzIFwiY29tcHV0ZWQgdmFsdWUgKHBlcmNlbnRhZ2UgaWYgc3BlY2lmaWVkKVwiIGluc3RlYWQgb2YgXCJ1c2VkIHZhbHVlXCIgZm9yIG1hcmdpbnNcblx0XHQvLyB3aGljaCBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQucGl4ZWxNYXJnaW4gJiYgY29tcHV0ZWRTdHlsZSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgKSB7XG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0c3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG5pZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7XG5cdGN1cnJlbnRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHZhciBsZWZ0LCByc0xlZnQsIHVuY29tcHV0ZWQsXG5cdFx0XHRyZXQgPSBlbGVtLmN1cnJlbnRTdHlsZSAmJiBlbGVtLmN1cnJlbnRTdHlsZVsgbmFtZSBdLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcblx0XHQvLyBzbyB3ZSBkb24ndCBkZWZhdWx0IHRvIGF1dG9cblx0XHRpZiAoIHJldCA9PSBudWxsICYmIHN0eWxlICYmICh1bmNvbXB1dGVkID0gc3R5bGVbIG5hbWUgXSkgKSB7XG5cdFx0XHRyZXQgPSB1bmNvbXB1dGVkO1xuXHRcdH1cblxuXHRcdC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcblx0XHQvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxXG5cblx0XHQvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcblx0XHQvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0bGVmdCA9IHN0eWxlLmxlZnQ7XG5cdFx0XHRyc0xlZnQgPSBlbGVtLnJ1bnRpbWVTdHlsZSAmJiBlbGVtLnJ1bnRpbWVTdHlsZS5sZWZ0O1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRpZiAoIHJzTGVmdCApIHtcblx0XHRcdFx0ZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IGVsZW0uY3VycmVudFN0eWxlLmxlZnQ7XG5cdFx0XHR9XG5cdFx0XHRzdHlsZS5sZWZ0ID0gbmFtZSA9PT0gXCJmb250U2l6ZVwiID8gXCIxZW1cIiA6IHJldDtcblx0XHRcdHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFwicHhcIjtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUubGVmdCA9IGxlZnQ7XG5cdFx0XHRpZiAoIHJzTGVmdCApIHtcblx0XHRcdFx0ZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IHJzTGVmdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCJhdXRvXCIgOiByZXQ7XG5cdH07XG59XG5cbmN1ckNTUyA9IGdldENvbXB1dGVkU3R5bGUgfHwgY3VycmVudFN0eWxlO1xuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eVxuXHR2YXIgdmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRsZW4gPSA0O1xuXG5cdGlmICggdmFsID4gMCApIHtcblx0XHRpZiAoIGV4dHJhICE9PSBcImJvcmRlclwiICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpICs9IDIgKSB7XG5cdFx0XHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0XHRcdHZhbCAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdICkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdFx0dmFsICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0gKSApIHx8IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsIC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWwgKyBcInB4XCI7XG5cdH1cblxuXHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lICk7XG5cdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdH1cblxuXHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGQgcGFkZGluZywgYm9yZGVyLCBtYXJnaW5cblx0aWYgKCBleHRyYSApIHtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkgKz0gMiApIHtcblx0XHRcdHZhbCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdICkgKSB8fCAwO1xuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSkgKSB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWwgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ub2Zmc2V0V2lkdGggIT09IDAgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHJudW0udGVzdCggdmFsdWUgKSA/XG5cdFx0XHRcdHZhbHVlICsgXCJweFwiIDpcblx0XHRcdFx0dmFsdWU7XG5cdFx0fVxuXHR9O1xufSk7XG5cbmlmICggIWpRdWVyeS5zdXBwb3J0Lm9wYWNpdHkgKSB7XG5cdGpRdWVyeS5jc3NIb29rcy5vcGFjaXR5ID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0Ly8gSUUgdXNlcyBmaWx0ZXJzIGZvciBvcGFjaXR5XG5cdFx0XHRyZXR1cm4gcm9wYWNpdHkudGVzdCggKGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDogZWxlbS5zdHlsZS5maWx0ZXIpIHx8IFwiXCIgKSA/XG5cdFx0XHRcdCggcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgLyAxMDAgKSArIFwiXCIgOlxuXHRcdFx0XHRjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdFx0XHRjdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0b3BhY2l0eSA9IGpRdWVyeS5pc051bWVyaWMoIHZhbHVlICkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiIDogXCJcIixcblx0XHRcdFx0ZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cblx0XHRcdC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuXHRcdFx0Ly8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbFxuXHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtIGF0dGVtcHQgdG8gcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgIzY2NTJcblx0XHRcdGlmICggdmFsdWUgPj0gMSAmJiBqUXVlcnkudHJpbSggZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgXCJcIiApICkgPT09IFwiXCIgKSB7XG5cblx0XHRcdFx0Ly8gU2V0dGluZyBzdHlsZS5maWx0ZXIgdG8gbnVsbCwgXCJcIiAmIFwiIFwiIHN0aWxsIGxlYXZlIFwiZmlsdGVyOlwiIGluIHRoZSBjc3NUZXh0XG5cdFx0XHRcdC8vIGlmIFwiZmlsdGVyOlwiIGlzIHByZXNlbnQgYXQgYWxsLCBjbGVhclR5cGUgaXMgZGlzYWJsZWQsIHdlIHdhbnQgdG8gYXZvaWQgdGhpc1xuXHRcdFx0XHQvLyBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgaXMgSUUgT25seSwgYnV0IHNvIGFwcGFyZW50bHkgaXMgdGhpcyBjb2RlIHBhdGguLi5cblx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlKCBcImZpbHRlclwiICk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhlcmUgaXMgbm8gZmlsdGVyIHN0eWxlIGFwcGxpZWQgaW4gYSBjc3MgcnVsZSwgd2UgYXJlIGRvbmVcblx0XHRcdFx0aWYgKCBjdXJyZW50U3R5bGUgJiYgIWN1cnJlbnRTdHlsZS5maWx0ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSwgc2V0IG5ldyBmaWx0ZXIgdmFsdWVzXG5cdFx0XHRzdHlsZS5maWx0ZXIgPSByYWxwaGEudGVzdCggZmlsdGVyICkgP1xuXHRcdFx0XHRmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBvcGFjaXR5ICkgOlxuXHRcdFx0XHRmaWx0ZXIgKyBcIiBcIiArIG9wYWNpdHk7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkoZnVuY3Rpb24oKSB7XG5cdC8vIFRoaXMgaG9vayBjYW5ub3QgYmUgYWRkZWQgdW50aWwgRE9NIHJlYWR5IGJlY2F1c2UgdGhlIHN1cHBvcnQgdGVzdFxuXHQvLyBmb3IgaXQgaXMgbm90IHJ1biB1bnRpbCBhZnRlciBET00gcmVhZHlcblx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCApIHtcblx0XHRqUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHRcdC8vIFdvcmsgYXJvdW5kIGJ5IHRlbXBvcmFyaWx5IHNldHRpbmcgZWxlbWVudCBkaXNwbGF5IHRvIGlubGluZS1ibG9ja1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBjdXJDU1MoIGVsZW0sIFwibWFyZ2luLXJpZ2h0XCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUubWFyZ2luUmlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuaWYgKCBqUXVlcnkuZXhwciAmJiBqUXVlcnkuZXhwci5maWx0ZXJzICkge1xuXHRqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciB3aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRoZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcblxuXHRcdHJldHVybiAoIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCApIHx8ICghalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzICYmICgoZWxlbS5zdHlsZSAmJiBlbGVtLnN0eWxlLmRpc3BsYXkpIHx8IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkpID09PSBcIm5vbmVcIik7XG5cdH07XG5cblx0alF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xuXHR9O1xufVxuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblxuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGksXG5cblx0XHRcdFx0Ly8gYXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9O1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKilcXHI/JC9tZywgLy8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG5cdHJpbnB1dCA9IC9eKD86Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxoaWRkZW58bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaSxcblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwXFwtc3RvcmFnZXwuK1xcLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRycXVlcnkgPSAvXFw/Lyxcblx0cnNjcmlwdCA9IC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLFxuXHRyc2VsZWN0VGV4dGFyZWEgPSAvXig/OnNlbGVjdHx0ZXh0YXJlYSkvaSxcblx0cnNwYWNlc0FqYXggPSAvXFxzKy8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cnVybCA9IC9eKFtcXHdcXCtcXC5cXC1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKSk/KT8vLFxuXG5cdC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2Rcblx0X2xvYWQgPSBqUXVlcnkuZm4ubG9hZCxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jYXRpb24sXG5cblx0Ly8gRG9jdW1lbnQgbG9jYXRpb24gc2VnbWVudHNcblx0YWpheExvY1BhcnRzLFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFtcIiovXCJdICsgW1wiKlwiXTtcblxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcbi8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxudHJ5IHtcblx0YWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbn0gY2F0Y2goIGUgKSB7XG5cdC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XG5cdC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcblx0YWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XG59XG5cbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdHZhciBkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5zcGxpdCggcnNwYWNlc0FqYXggKSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGRhdGFUeXBlcy5sZW5ndGgsXG5cdFx0XHRcdGRhdGFUeXBlLFxuXHRcdFx0XHRsaXN0LFxuXHRcdFx0XHRwbGFjZUJlZm9yZTtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpIF07XG5cdFx0XHRcdC8vIFdlIGNvbnRyb2wgaWYgd2UncmUgYXNrZWQgdG8gYWRkIGJlZm9yZVxuXHRcdFx0XHQvLyBhbnkgZXhpc3RpbmcgZWxlbWVudFxuXHRcdFx0XHRwbGFjZUJlZm9yZSA9IC9eXFwrLy50ZXN0KCBkYXRhVHlwZSApO1xuXHRcdFx0XHRpZiAoIHBsYWNlQmVmb3JlICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc3Vic3RyKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdCA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXTtcblx0XHRcdFx0Ly8gdGhlbiB3ZSBhZGQgdG8gdGhlIHN0cnVjdHVyZSBhY2NvcmRpbmdseVxuXHRcdFx0XHRsaXN0WyBwbGFjZUJlZm9yZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCIgXSggZnVuYyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSLFxuXHRcdGRhdGFUeXBlIC8qIGludGVybmFsICovLCBpbnNwZWN0ZWQgLyogaW50ZXJuYWwgKi8gKSB7XG5cblx0ZGF0YVR5cGUgPSBkYXRhVHlwZSB8fCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdO1xuXHRpbnNwZWN0ZWQgPSBpbnNwZWN0ZWQgfHwge307XG5cblx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblxuXHR2YXIgbGlzdCA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSxcblx0XHRpID0gMCxcblx0XHRsZW5ndGggPSBsaXN0ID8gbGlzdC5sZW5ndGggOiAwLFxuXHRcdGV4ZWN1dGVPbmx5ID0gKCBzdHJ1Y3R1cmUgPT09IHByZWZpbHRlcnMgKSxcblx0XHRzZWxlY3Rpb247XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoICYmICggZXhlY3V0ZU9ubHkgfHwgIXNlbGVjdGlvbiApOyBpKysgKSB7XG5cdFx0c2VsZWN0aW9uID0gbGlzdFsgaSBdKCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0Ly8gSWYgd2UgZ290IHJlZGlyZWN0ZWQgdG8gYW5vdGhlciBkYXRhVHlwZVxuXHRcdC8vIHdlIHRyeSB0aGVyZSBpZiBleGVjdXRpbmcgb25seSBhbmQgbm90IGRvbmUgYWxyZWFkeVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggIWV4ZWN1dGVPbmx5IHx8IGluc3BlY3RlZFsgc2VsZWN0aW9uIF0gKSB7XG5cdFx0XHRcdHNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIHNlbGVjdGlvbiApO1xuXHRcdFx0XHRzZWxlY3Rpb24gPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhcblx0XHRcdFx0XHRcdHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiwgc2VsZWN0aW9uLCBpbnNwZWN0ZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gSWYgd2UncmUgb25seSBleGVjdXRpbmcgb3Igbm90aGluZyB3YXMgc2VsZWN0ZWRcblx0Ly8gd2UgdHJ5IHRoZSBjYXRjaGFsbCBkYXRhVHlwZSBpZiBub3QgZG9uZSBhbHJlYWR5XG5cdGlmICggKCBleGVjdXRlT25seSB8fCAhc2VsZWN0aW9uICkgJiYgIWluc3BlY3RlZFsgXCIqXCIgXSApIHtcblx0XHRzZWxlY3Rpb24gPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhcblx0XHRcdFx0c3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSLCBcIipcIiwgaW5zcGVjdGVkICk7XG5cdH1cblx0Ly8gdW5uZWNlc3Nhcnkgd2hlbiBvbmx5IGV4ZWN1dGluZyAocHJlZmlsdGVycylcblx0Ly8gYnV0IGl0J2xsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbGxlciBpbiB0aGF0IGNhc2Vcblx0cmV0dXJuIHNlbGVjdGlvbjtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0bG9hZDogZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0Ly8gRG9uJ3QgZG8gYSByZXF1ZXN0IGlmIG5vIGVsZW1lbnRzIGFyZSBiZWluZyByZXF1ZXN0ZWRcblx0XHR9IGVsc2UgaWYgKCAhdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YXIgb2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cdFx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IHVybC5zbGljZSggb2ZmLCB1cmwubGVuZ3RoICk7XG5cdFx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgdG8gYSBHRVQgcmVxdWVzdFxuXHRcdHZhciB0eXBlID0gXCJHRVRcIjtcblxuXHRcdC8vIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdhcyBwcm92aWRlZFxuXHRcdGlmICggcGFyYW1zICkge1xuXHRcdFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblx0XHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0cGFyYW1zID0galF1ZXJ5LnBhcmFtKCBwYXJhbXMsIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwgKTtcblx0XHRcdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8vIFJlcXVlc3QgdGhlIHJlbW90ZSBkb2N1bWVudFxuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtcyxcblx0XHRcdC8vIENvbXBsZXRlIGNhbGxiYWNrIChyZXNwb25zZVRleHQgaXMgdXNlZCBpbnRlcm5hbGx5KVxuXHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzLCByZXNwb25zZVRleHQgKSB7XG5cdFx0XHRcdC8vIFN0b3JlIHRoZSByZXNwb25zZSBhcyBzcGVjaWZpZWQgYnkgdGhlIGpxWEhSIG9iamVjdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgPSBqcVhIUi5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGluamVjdCB0aGUgSFRNTCBpbnRvIGFsbCB0aGUgbWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIGpxWEhSLmlzUmVzb2x2ZWQoKSApIHtcblx0XHRcdFx0XHQvLyAjNDgyNTogR2V0IHRoZSBhY3R1YWwgcmVzcG9uc2UgaW4gY2FzZVxuXHRcdFx0XHRcdC8vIGEgZGF0YUZpbHRlciBpcyBwcmVzZW50IGluIGFqYXhTZXR0aW5nc1xuXHRcdFx0XHRcdGpxWEhSLmRvbmUoZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZVRleHQgPSByO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vIFNlZSBpZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWRcblx0XHRcdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IGRpdiB0byBob2xkIHRoZSByZXN1bHRzXG5cdFx0XHRcdFx0XHRqUXVlcnkoXCI8ZGl2PlwiKVxuXHRcdFx0XHRcdFx0XHQvLyBpbmplY3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudCBpbiwgcmVtb3ZpbmcgdGhlIHNjcmlwdHNcblx0XHRcdFx0XHRcdFx0Ly8gdG8gYXZvaWQgYW55ICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzIGluIElFXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQocmVzcG9uc2VUZXh0LnJlcGxhY2UocnNjcmlwdCwgXCJcIikpXG5cblx0XHRcdFx0XHRcdFx0Ly8gTG9jYXRlIHRoZSBzcGVjaWZpZWQgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0LmZpbmQoc2VsZWN0b3IpIDpcblxuXHRcdFx0XHRcdFx0Ly8gSWYgbm90LCBqdXN0IGluamVjdCB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRzZWxmLmVhY2goIGNhbGxiYWNrLCBbIHJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCB0aGlzLmVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhdGhpcy5kaXNhYmxlZCAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCByc2VsZWN0VGV4dGFyZWEudGVzdCggdGhpcy5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmlucHV0LnRlc3QoIHRoaXMudHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICl7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCwgaSApe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0pLmdldCgpO1xuXHR9XG59KTtcblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBcImFqYXhTdGFydCBhamF4U3RvcCBhamF4Q29tcGxldGUgYWpheEVycm9yIGFqYXhTdWNjZXNzIGFqYXhTZW5kXCIuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCBpLCBvICl7XG5cdGpRdWVyeS5mblsgbyBdID0gZnVuY3Rpb24oIGYgKXtcblx0XHRyZXR1cm4gdGhpcy5vbiggbywgZiApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBzaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2ssXG5cdFx0XHRkYXRhVHlwZTogdHlwZVxuXHRcdH0pO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRzZXR0aW5ncyA9IHRhcmdldDtcblx0XHRcdHRhcmdldCA9IGpRdWVyeS5hamF4U2V0dGluZ3M7XG5cdFx0fVxuXHRcdGFqYXhFeHRlbmQoIHRhcmdldCwgc2V0dGluZ3MgKTtcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGFqYXhMb2NQYXJ0c1sgMSBdICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIixcblx0XHRcdFwiKlwiOiBhbGxUeXBlc1xuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAveG1sLyxcblx0XHRcdGh0bWw6IC9odG1sLyxcblx0XHRcdGpzb246IC9qc29uL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiXG5cdFx0fSxcblxuXHRcdC8vIExpc3Qgb2YgZGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gMSkga2V5IGZvcm1hdCBpcyBcInNvdXJjZV90eXBlIGRlc3RpbmF0aW9uX3R5cGVcIiAoYSBzaW5nbGUgc3BhY2UgaW4tYmV0d2Vlbilcblx0XHQvLyAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkIGZvciBzb3VyY2VfdHlwZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiB3aW5kb3cuU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHRjb250ZXh0OiB0cnVlLFxuXHRcdFx0dXJsOiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzXG5cdFx0XHQvLyBJdCdzIHRoZSBjYWxsYmFja0NvbnRleHQgaWYgb25lIHdhcyBwcm92aWRlZCBpbiB0aGUgb3B0aW9uc1xuXHRcdFx0Ly8gYW5kIGlmIGl0J3MgYSBET00gbm9kZSBvciBhIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBjYWxsYmFja0NvbnRleHQgIT09IHMgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICkgP1xuXHRcdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6IGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXHRcdFx0Ly8gaWZNb2RpZmllZCBrZXlcblx0XHRcdGlmTW9kaWZpZWRLZXksXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblx0XHRcdC8vIHRyYW5zcG9ydFxuXHRcdFx0dHJhbnNwb3J0LFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblx0XHRcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcImFib3J0XCI7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIHN0YXR1c1RleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgc3RhdHVzVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0Ly8gSXQgaXMgZGVmaW5lZCBoZXJlIGJlY2F1c2UganNsaW50IGNvbXBsYWlucyBpZiBpdCBpcyBkZWNsYXJlZFxuXHRcdC8vIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uICh3aGljaCB3b3VsZCBiZSBtb3JlIGxvZ2ljYWwgYW5kIHJlYWRhYmxlKVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0dmFyIGlzU3VjY2Vzcyxcblx0XHRcdFx0c3VjY2Vzcyxcblx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0LFxuXHRcdFx0XHRyZXNwb25zZSA9IHJlc3BvbnNlcyA/IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0bGFzdE1vZGlmaWVkLFxuXHRcdFx0XHRldGFnO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblxuXHRcdFx0XHRcdGlmICggKCBsYXN0TW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdID0gbGFzdE1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICggZXRhZyA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkV0YWdcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdID0gZXRhZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblxuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRzdWNjZXNzID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJzdWNjZXNzXCI7XG5cdFx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0Ly8gV2UgaGF2ZSBhIHBhcnNlcmVycm9yXG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJwYXJzZXJlcnJvclwiO1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCAhc3RhdHVzVGV4dCB8fCBzdGF0dXMgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9IFwiXCIgKyAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhcIiArICggaXNTdWNjZXNzID8gXCJTdWNjZXNzXCIgOiBcIkVycm9yXCIgKSxcblx0XHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblx0XHRqcVhIUi5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXG5cdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRqcVhIUi5zdGF0dXNDb2RlID0gZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHR2YXIgdG1wO1xuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRmb3IgKCB0bXAgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgdG1wIF0gPSBbIHN0YXR1c0NvZGVbdG1wXSwgbWFwW3RtcF0gXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gbWFwWyBqcVhIUi5zdGF0dXMgXTtcblx0XHRcdFx0XHRqcVhIUi50aGVuKCB0bXAsIHRtcCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAoIzU4NjY6IElFNyBpc3N1ZSB3aXRoIHByb3RvY29sLWxlc3MgdXJscylcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApLnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5zcGxpdCggcnNwYWNlc0FqYXggKTtcblxuXHRcdC8vIERldGVybWluZSBpZiBhIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPSBhamF4TG9jUGFydHNbIDIgXSB8fFxuXHRcdFx0XHRcdCggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IDgwIDogNDQzICkgKSAhPVxuXHRcdFx0XHRcdFx0KCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MyApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdGZpcmVHbG9iYWxzID0gcy5nbG9iYWw7XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgaWZNb2RpZmllZEtleSBiZWZvcmUgYWRkaW5nIHRoZSBhbnRpLWNhY2hlIHBhcmFtZXRlclxuXHRcdFx0aWZNb2RpZmllZEtleSA9IHMudXJsO1xuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHZhciB0cyA9IGpRdWVyeS5ub3coKSxcblx0XHRcdFx0XHQvLyB0cnkgcmVwbGFjaW5nIF89IGlmIGl0IGlzIHRoZXJlXG5cdFx0XHRcdFx0cmV0ID0gcy51cmwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIHRzICk7XG5cblx0XHRcdFx0Ly8gaWYgbm90aGluZyB3YXMgcmVwbGFjZWQsIGFkZCB0aW1lc3RhbXAgdG8gdGhlIGVuZFxuXHRcdFx0XHRzLnVybCA9IHJldCArICggKCByZXQgPT09IHMudXJsICkgPyAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgdHMgOiBcIlwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmTW9kaWZpZWRLZXkgPSBpZk1vZGlmaWVkS2V5IHx8IHMudXJsO1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBpZk1vZGlmaWVkS2V5IF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBpZk1vZGlmaWVkS2V5IF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHlcblx0XHRcdFx0anFYSFIuYWJvcnQoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHQvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuXHQvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcblx0cGFyYW06IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0XHR2YXIgcyA9IFtdLFxuXHRcdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6IHZhbHVlO1xuXHRcdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdFx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHRcdH1cblxuXHRcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdFx0Zm9yICggdmFyIHByZWZpeCBpbiBhICkge1xuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0XHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElmIGFycmF5IGl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0c1xuXHRcdFx0XHQvLyBudW1lcmljIGluZGV4IHRvIHJlc29sdmUgZGVzZXJpYWxpemF0aW9uIGFtYmlndWl0eSBpc3N1ZXMuXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCByYWNrIChhcyBvZiAxLjAuMCkgY2FuJ3QgY3VycmVudGx5IGRlc2VyaWFsaXplXG5cdFx0XHRcdC8vIG5lc3RlZCBhcnJheXMgcHJvcGVybHksIGFuZCBhdHRlbXB0aW5nIHRvIGRvIHNvIG1heSBjYXVzZVxuXHRcdFx0XHQvLyBhIHNlcnZlciBlcnJvci4gUG9zc2libGUgZml4ZXMgYXJlIHRvIG1vZGlmeSByYWNrJ3Ncblx0XHRcdFx0Ly8gZGVzZXJpYWxpemF0aW9uIGFsZ29yaXRobSBvciB0byBwcm92aWRlIGFuIG9wdGlvbiBvciBmbGFnXG5cdFx0XHRcdC8vIHRvIGZvcmNlIGFycmF5IHNlcmlhbGl6YXRpb24gdG8gYmUgc2hhbGxvdy5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFRoaXMgaXMgc3RpbGwgb24gdGhlIGpRdWVyeSBvYmplY3QuLi4gZm9yIG5vd1xuLy8gV2FudCB0byBtb3ZlIHRoaXMgdG8galF1ZXJ5LmFqYXggc29tZSBkYXlcbmpRdWVyeS5leHRlbmQoe1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fVxuXG59KTtcblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBzZXRzIGFsbCByZXNwb25zZVhYWCBmaWVsZHMgYWNjb3JkaW5nbHlcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLFxuXHRcdHJlc3BvbnNlRmllbGRzID0gcy5yZXNwb25zZUZpZWxkcyxcblx0XHRjdCxcblx0XHR0eXBlLFxuXHRcdGZpbmFsRGF0YVR5cGUsXG5cdFx0Zmlyc3REYXRhVHlwZTtcblxuXHQvLyBGaWxsIHJlc3BvbnNlWFhYIGZpZWxkc1xuXHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlRmllbGRzICkge1xuXHRcdGlmICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRqcVhIUlsgcmVzcG9uc2VGaWVsZHNbdHlwZV0gXSA9IHJlc3BvbnNlc1sgdHlwZSBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImNvbnRlbnQtdHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLy8gQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlICkge1xuXG5cdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdGlmICggcy5kYXRhRmlsdGVyICkge1xuXHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHR9XG5cblx0dmFyIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHRpLFxuXHRcdGtleSxcblx0XHRsZW5ndGggPSBkYXRhVHlwZXMubGVuZ3RoLFxuXHRcdHRtcCxcblx0XHQvLyBDdXJyZW50IGFuZCBwcmV2aW91cyBkYXRhVHlwZXNcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzWyAwIF0sXG5cdFx0cHJldixcblx0XHQvLyBDb252ZXJzaW9uIGV4cHJlc3Npb25cblx0XHRjb252ZXJzaW9uLFxuXHRcdC8vIENvbnZlcnNpb24gZnVuY3Rpb25cblx0XHRjb252LFxuXHRcdC8vIENvbnZlcnNpb24gZnVuY3Rpb25zICh0cmFuc2l0aXZlIGNvbnZlcnNpb24pXG5cdFx0Y29udjEsXG5cdFx0Y29udjI7XG5cblx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGNoYWluXG5cdGZvciAoIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBDcmVhdGUgY29udmVydGVycyBtYXBcblx0XHQvLyB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdGZvciAoIGtleSBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCB0aGUgZGF0YVR5cGVzXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlc1sgaSBdO1xuXG5cdFx0Ly8gSWYgY3VycmVudCBpcyBhdXRvIGRhdGFUeXBlLCB1cGRhdGUgaXQgdG8gcHJldlxuXHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cdFx0XHRjdXJyZW50ID0gcHJldjtcblx0XHQvLyBJZiBubyBhdXRvIGFuZCBkYXRhVHlwZXMgYXJlIGFjdHVhbGx5IGRpZmZlcmVudFxuXHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIEdldCB0aGUgY29udmVydGVyXG5cdFx0XHRjb252ZXJzaW9uID0gcHJldiArIFwiIFwiICsgY3VycmVudDtcblx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252ZXJzaW9uIF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBkaXJlY3QgY29udmVydGVyLCBzZWFyY2ggdHJhbnNpdGl2ZWx5XG5cdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRjb252MiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0Zm9yICggY29udjEgaW4gY29udmVydGVycyApIHtcblx0XHRcdFx0XHR0bXAgPSBjb252MS5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRpZiAoIHRtcFsgMCBdID09PSBwcmV2IHx8IHRtcFsgMCBdID09PSBcIipcIiApIHtcblx0XHRcdFx0XHRcdGNvbnYyID0gY29udmVydGVyc1sgdG1wWzFdICsgXCIgXCIgKyBjdXJyZW50IF07XG5cdFx0XHRcdFx0XHRpZiAoIGNvbnYyICkge1xuXHRcdFx0XHRcdFx0XHRjb252MSA9IGNvbnZlcnRlcnNbIGNvbnYxIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udjEgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnYyO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252MiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udjE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBubyBjb252ZXJ0ZXIsIGRpc3BhdGNoIGFuIGVycm9yXG5cdFx0XHRpZiAoICEoIGNvbnYgfHwgY29udjIgKSApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIGNvbnZlcnNpb24ucmVwbGFjZShcIiBcIixcIiB0byBcIikgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGZvdW5kIGNvbnZlcnRlciBpcyBub3QgYW4gZXF1aXZhbGVuY2Vcblx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0Ly8gQ29udmVydCB3aXRoIDEgb3IgMiBjb252ZXJ0ZXJzIGFjY29yZGluZ2x5XG5cdFx0XHRcdHJlc3BvbnNlID0gY29udiA/IGNvbnYoIHJlc3BvbnNlICkgOiBjb252MiggY29udjEocmVzcG9uc2UpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXNwb25zZTtcbn1cblxuXG5cblxudmFyIGpzYyA9IGpRdWVyeS5ub3coKSxcblx0anNyZSA9IC8oXFw9KVxcPygmfCQpfFxcP1xcPy9pO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIGpzYysrICk7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0RGF0YSA9ICggdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICYmIC9eYXBwbGljYXRpb25cXC94XFwtd3d3XFwtZm9ybVxcLXVybGVuY29kZWQvLnRlc3QoIHMuY29udGVudFR5cGUgKTtcblxuXHRpZiAoIHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiB8fFxuXHRcdHMuanNvbnAgIT09IGZhbHNlICYmICgganNyZS50ZXN0KCBzLnVybCApIHx8XG5cdFx0XHRcdGluc3BlY3REYXRhICYmIGpzcmUudGVzdCggcy5kYXRhICkgKSApIHtcblxuXHRcdHZhciByZXNwb25zZUNvbnRhaW5lcixcblx0XHRcdGpzb25wQ2FsbGJhY2sgPSBzLmpzb25wQ2FsbGJhY2sgPVxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgPyBzLmpzb25wQ2FsbGJhY2soKSA6IHMuanNvbnBDYWxsYmFjayxcblx0XHRcdHByZXZpb3VzID0gd2luZG93WyBqc29ucENhbGxiYWNrIF0sXG5cdFx0XHR1cmwgPSBzLnVybCxcblx0XHRcdGRhdGEgPSBzLmRhdGEsXG5cdFx0XHRyZXBsYWNlID0gXCIkMVwiICsganNvbnBDYWxsYmFjayArIFwiJDJcIjtcblxuXHRcdGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHR1cmwgPSB1cmwucmVwbGFjZSgganNyZSwgcmVwbGFjZSApO1xuXHRcdFx0aWYgKCBzLnVybCA9PT0gdXJsICkge1xuXHRcdFx0XHRpZiAoIGluc3BlY3REYXRhICkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoIGpzcmUsIHJlcGxhY2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHMuZGF0YSA9PT0gZGF0YSApIHtcblx0XHRcdFx0XHQvLyBBZGQgY2FsbGJhY2sgbWFudWFsbHlcblx0XHRcdFx0XHR1cmwgKz0gKC9cXD8vLnRlc3QoIHVybCApID8gXCImXCIgOiBcIj9cIikgKyBzLmpzb25wICsgXCI9XCIgKyBqc29ucENhbGxiYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cy51cmwgPSB1cmw7XG5cdFx0cy5kYXRhID0gZGF0YTtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHR3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSA9IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gWyByZXNwb25zZSBdO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvblxuXHRcdGpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIFNldCBjYWxsYmFjayBiYWNrIHRvIHByZXZpb3VzIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSA9IHByZXZpb3VzO1xuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcmV2aW91cyApICkge1xuXHRcdFx0XHR3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBqc29ucENhbGxiYWNrICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvamF2YXNjcmlwdHxlY21hc2NyaXB0L1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGdsb2JhbFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdFx0cy5nbG9iYWwgPSBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKHMpIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblxuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0XHRcdHNjcmlwdC5hc3luYyA9IFwiYXN5bmNcIjtcblxuXHRcdFx0XHRpZiAoIHMuc2NyaXB0Q2hhcnNldCApIHtcblx0XHRcdFx0XHRzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjcmlwdC5zcmMgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBBdHRhY2ggaGFuZGxlcnMgZm9yIGFsbCBicm93c2Vyc1xuXHRcdFx0XHRzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgbWVtb3J5IGxlYWsgaW4gSUVcblx0XHRcdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBzY3JpcHRcblx0XHRcdFx0XHRcdGlmICggaGVhZCAmJiBzY3JpcHQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0aGVhZC5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIERlcmVmZXJlbmNlIHRoZSBzY3JpcHRcblx0XHRcdFx0XHRcdHNjcmlwdCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgaWYgbm90IGFib3J0XG5cdFx0XHRcdFx0XHRpZiAoICFpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gVXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIGFwcGVuZENoaWxkICB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXG5cdFx0XHRcdC8vIFRoaXMgYXJpc2VzIHdoZW4gYSBiYXNlIG5vZGUgaXMgdXNlZCAoIzI3MDkgYW5kICM0Mzc4KS5cblx0XHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoIHNjcmlwdCwgaGVhZC5maXJzdENoaWxkICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggc2NyaXB0ICkge1xuXHRcdFx0XHRcdHNjcmlwdC5vbmxvYWQoIDAsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgLy8gIzUyODA6IEludGVybmV0IEV4cGxvcmVyIHdpbGwga2VlcCBjb25uZWN0aW9ucyBhbGl2ZSBpZiB3ZSBkb24ndCBhYm9ydCBvbiB1bmxvYWRcblx0eGhyT25VbmxvYWRBYm9ydCA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0ID8gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gQWJvcnQgYWxsIHBlbmRpbmcgcmVxdWVzdHNcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcblx0XHRcdHhockNhbGxiYWNrc1sga2V5IF0oIDAsIDEgKTtcblx0XHR9XG5cdH0gOiBmYWxzZSxcblx0eGhySWQgPSAwLFxuXHR4aHJDYWxsYmFja3M7XG5cbi8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCggZSApIHt9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVhIUigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxIVFRQXCIgKTtcblx0fSBjYXRjaCggZSApIHt9XG59XG5cbi8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3Rcbi8vIChUaGlzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGFqYXhTZXR0aW5ncyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgP1xuXHQvKiBNaWNyb3NvZnQgZmFpbGVkIHRvIHByb3Blcmx5XG5cdCAqIGltcGxlbWVudCB0aGUgWE1MSHR0cFJlcXVlc3QgaW4gSUU3IChjYW4ndCByZXF1ZXN0IGxvY2FsIGZpbGVzKSxcblx0ICogc28gd2UgdXNlIHRoZSBBY3RpdmVYT2JqZWN0IHdoZW4gaXQgaXMgYXZhaWxhYmxlXG5cdCAqIEFkZGl0aW9uYWxseSBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgaW4gSUU3L0lFOCBzb1xuXHQgKiB3ZSBuZWVkIGEgZmFsbGJhY2suXG5cdCAqL1xuXHRmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuaXNMb2NhbCAmJiBjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuXHR9IDpcblx0Ly8gRm9yIGFsbCBvdGhlciBicm93c2VycywgdXNlIHRoZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBvYmplY3Rcblx0Y3JlYXRlU3RhbmRhcmRYSFI7XG5cbi8vIERldGVybWluZSBzdXBwb3J0IHByb3BlcnRpZXNcbihmdW5jdGlvbiggeGhyICkge1xuXHRqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuc3VwcG9ydCwge1xuXHRcdGFqYXg6ICEheGhyLFxuXHRcdGNvcnM6ICEheGhyICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIgKVxuXHR9KTtcbn0pKCBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpICk7XG5cbi8vIENyZWF0ZSB0cmFuc3BvcnQgaWYgdGhlIGJyb3dzZXIgY2FuIHByb3ZpZGUgYW4geGhyXG5pZiAoIGpRdWVyeS5zdXBwb3J0LmFqYXggKSB7XG5cblx0alF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oIHMgKSB7XG5cdFx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRcdGlmICggIXMuY3Jvc3NEb21haW4gfHwgalF1ZXJ5LnN1cHBvcnQuY29ycyApIHtcblxuXHRcdFx0dmFyIGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgYSBuZXcgeGhyXG5cdFx0XHRcdFx0dmFyIHhociA9IHMueGhyKCksXG5cdFx0XHRcdFx0XHRoYW5kbGUsXG5cdFx0XHRcdFx0XHRpO1xuXG5cdFx0XHRcdFx0Ly8gT3BlbiB0aGUgc29ja2V0XG5cdFx0XHRcdFx0Ly8gUGFzc2luZyBudWxsIHVzZXJuYW1lLCBnZW5lcmF0ZXMgYSBsb2dpbiBwb3B1cCBvbiBPcGVyYSAoIzI4NjUpXG5cdFx0XHRcdFx0aWYgKCBzLnVzZXJuYW1lICkge1xuXHRcdFx0XHRcdFx0eGhyLm9wZW4oIHMudHlwZSwgcy51cmwsIHMuYXN5bmMsIHMudXNlcm5hbWUsIHMucGFzc3dvcmQgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eGhyLm9wZW4oIHMudHlwZSwgcy51cmwsIHMuYXN5bmMgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBzLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gcy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gcy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBzLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIHMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIXMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZWVkIGFuIGV4dHJhIHRyeS9jYXRjaCBmb3IgY3Jvc3MgZG9tYWluIHJlcXVlc3RzIGluIEZpcmVmb3ggM1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoKCBfICkge31cblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcblx0XHRcdFx0XHQvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSlcblx0XHRcdFx0XHR4aHIuc2VuZCggKCBzLmhhc0NvbnRlbnQgJiYgcy5kYXRhICkgfHwgbnVsbCApO1xuXG5cdFx0XHRcdFx0Ly8gTGlzdGVuZXJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0LFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlcyxcblx0XHRcdFx0XHRcdFx0eG1sO1xuXG5cdFx0XHRcdFx0XHQvLyBGaXJlZm94IHRocm93cyBleGNlcHRpb25zIHdoZW4gYWNjZXNzaW5nIHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdC8vIG9mIGFuIHhociB3aGVuIGEgbmV0d29yayBlcnJvciBvY2N1cmVkXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vaGVscGZ1bC5rbm9icy1kaWFscy5jb20vaW5kZXgucGhwL0NvbXBvbmVudF9yZXR1cm5lZF9mYWlsdXJlX2NvZGU6XzB4ODAwNDAxMTFfKE5TX0VSUk9SX05PVF9BVkFJTEFCTEUpXG5cdFx0XHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFdhcyBuZXZlciBjYWxsZWQgYW5kIGlzIGFib3J0ZWQgb3IgY29tcGxldGVcblx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayAmJiAoIGlzQWJvcnQgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2FsbGVkIG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIERvIG5vdCBrZWVwIGFzIGFjdGl2ZSBhbnltb3JlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHhock9uVW5sb2FkQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGhhbmRsZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIElmIGl0J3MgYW4gYWJvcnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBYm9ydCBpdCBtYW51YWxseSBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VzID0ge307XG5cdFx0XHRcdFx0XHRcdFx0XHR4bWwgPSB4aHIucmVzcG9uc2VYTUw7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIENvbnN0cnVjdCByZXNwb25zZSBsaXN0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHhtbCAmJiB4bWwuZG9jdW1lbnRFbGVtZW50IC8qICM0OTU4ICovICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMueG1sID0geG1sO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIHJlcXVlc3RpbmcgYmluYXJ5IGRhdGEsIElFNi05IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBvbiBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgcmVzcG9uc2VUZXh0ICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMudGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoKCBfICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0YXR1c1RleHQgZm9yIGZhdWx0eSBjcm9zcy1kb21haW4gcmVxdWVzdHNcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFdlIG5vcm1hbGl6ZSB3aXRoIFdlYmtpdCBnaXZpbmcgYW4gZW1wdHkgc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsdGVyIHN0YXR1cyBmb3Igbm9uIHN0YW5kYXJkIGJlaGF2aW9yc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcmVxdWVzdCBpcyBsb2NhbCBhbmQgd2UgaGF2ZSBkYXRhOiBhc3N1bWUgYSBzdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAoc3VjY2VzcyB3aXRoIG5vIGRhdGEgd29uJ3QgZ2V0IG5vdGlmaWVkLCB0aGF0J3MgdGhlIGJlc3Qgd2Vcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGNhbiBkbyBnaXZlbiBjdXJyZW50IGltcGxlbWVudGF0aW9ucylcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggIXN0YXR1cyAmJiBzLmlzTG9jYWwgJiYgIXMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHJlc3BvbnNlcy50ZXh0ID8gMjAwIDogNDA0O1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUUgLSAjMTQ1MDogc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMTIyMyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gMjA0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCggZmlyZWZveEFjY2Vzc0V4Y2VwdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggLTEsIGZpcmVmb3hBY2Nlc3NFeGNlcHRpb24gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDYWxsIGNvbXBsZXRlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBzdGF0dXMsIHN0YXR1c1RleHQsIHJlc3BvbnNlcywgcmVzcG9uc2VIZWFkZXJzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGluIHN5bmMgbW9kZSBvciBpdCdzIGluIGNhY2hlXG5cdFx0XHRcdFx0Ly8gYW5kIGhhcyBiZWVuIHJldHJpZXZlZCBkaXJlY3RseSAoSUU2ICYgSUU3KVxuXHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gbWFudWFsbHkgZmlyZSB0aGUgY2FsbGJhY2tcblx0XHRcdFx0XHRpZiAoICFzLmFzeW5jIHx8IHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aGFuZGxlID0gKyt4aHJJZDtcblx0XHRcdFx0XHRcdGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhY3RpdmUgeGhycyBjYWxsYmFja3MgbGlzdCBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdFx0Ly8gYW5kIGF0dGFjaCB0aGUgdW5sb2FkIGhhbmRsZXJcblx0XHRcdFx0XHRcdFx0aWYgKCAheGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0XHRcdFx0XHRcdHhockNhbGxiYWNrcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggd2luZG93ICkudW5sb2FkKCB4aHJPblVubG9hZEFib3J0ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gQWRkIHRvIGxpc3Qgb2YgYWN0aXZlIHhocnMgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdHhockNhbGxiYWNrc1sgaGFuZGxlIF0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjYWxsYmFjaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygwLDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuXG5cblxuXG52YXIgZWxlbWRpc3BsYXkgPSB7fSxcblx0aWZyYW1lLCBpZnJhbWVEb2MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRyZnhudW0gPSAvXihbK1xcLV09KT8oW1xcZCsuXFwtXSspKFthLXolXSopJC9pLFxuXHR0aW1lcklkLFxuXHRmeEF0dHJzID0gW1xuXHRcdC8vIGhlaWdodCBhbmltYXRpb25zXG5cdFx0WyBcImhlaWdodFwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiLCBcInBhZGRpbmdUb3BcIiwgXCJwYWRkaW5nQm90dG9tXCIgXSxcblx0XHQvLyB3aWR0aCBhbmltYXRpb25zXG5cdFx0WyBcIndpZHRoXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwicGFkZGluZ0xlZnRcIiwgXCJwYWRkaW5nUmlnaHRcIiBdLFxuXHRcdC8vIG9wYWNpdHkgYW5pbWF0aW9uc1xuXHRcdFsgXCJvcGFjaXR5XCIgXVxuXHRdLFxuXHRmeE5vdztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNob3c6IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZWxlbSwgZGlzcGxheTtcblxuXHRcdGlmICggc3BlZWQgfHwgc3BlZWQgPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBnZW5GeChcInNob3dcIiwgMyksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gdGhpcy5sZW5ndGg7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBlbGVtLnN0eWxlICkge1xuXHRcdFx0XHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5fZGF0YShlbGVtLCBcIm9sZGRpc3BsYXlcIikgJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKCAoZGlzcGxheSA9PT0gXCJcIiAmJiBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIpIHx8XG5cdFx0XHRcdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHRcdFx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBlbGVtLnN0eWxlICkge1xuXHRcdFx0XHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwiXCIgfHwgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZGU6IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHNwZWVkIHx8IHNwZWVkID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggZ2VuRngoXCJoaWRlXCIsIDMpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGVsZW0sIGRpc3BsYXksXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRqID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaSA8IGo7IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbaV07XG5cdFx0XHRcdGlmICggZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdFx0XHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGo7IGkrKyApIHtcblx0XHRcdFx0aWYgKCB0aGlzW2ldLnN0eWxlICkge1xuXHRcdFx0XHRcdHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSxcblxuXHQvLyBTYXZlIHRoZSBvbGQgdG9nZ2xlIGZ1bmN0aW9uXG5cdF90b2dnbGU6IGpRdWVyeS5mbi50b2dnbGUsXG5cblx0dG9nZ2xlOiBmdW5jdGlvbiggZm4sIGZuMiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGJvb2wgPSB0eXBlb2YgZm4gPT09IFwiYm9vbGVhblwiO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbihmbikgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oZm4yKSApIHtcblx0XHRcdHRoaXMuX3RvZ2dsZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsIHx8IGJvb2wgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzdGF0ZSA9IGJvb2wgPyBmbiA6IGpRdWVyeSh0aGlzKS5pcyhcIjpoaWRkZW5cIik7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKVsgc3RhdGUgPyBcInNob3dcIiA6IFwiaGlkZVwiIF0oKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYW5pbWF0ZShnZW5GeChcInRvZ2dsZVwiLCAzKSwgZm4sIGZuMiwgY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoXCI6aGlkZGVuXCIpLmNzcyhcIm9wYWNpdHlcIiwgMCkuc2hvdygpLmVuZCgpXG5cdFx0XHRcdFx0LmFuaW1hdGUoe29wYWNpdHk6IHRvfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuXHR9LFxuXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgb3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggb3B0YWxsLmNvbXBsZXRlLCBbIGZhbHNlIF0gKTtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgY2hhbmdlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhcyBwZXItcHJvcGVydHkgZWFzaW5nIHdpbGwgYmUgbG9zdFxuXHRcdHByb3AgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApO1xuXG5cdFx0ZnVuY3Rpb24gZG9BbmltYXRpb24oKSB7XG5cdFx0XHQvLyBYWFggJ3RoaXMnIGRvZXMgbm90IGFsd2F5cyBoYXZlIGEgbm9kZU5hbWUgd2hlbiBydW5uaW5nIHRoZVxuXHRcdFx0Ly8gdGVzdCBzdWl0ZVxuXG5cdFx0XHRpZiAoIG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGpRdWVyeS5fbWFyayggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb3B0ID0galF1ZXJ5LmV4dGVuZCgge30sIG9wdGFsbCApLFxuXHRcdFx0XHRpc0VsZW1lbnQgPSB0aGlzLm5vZGVUeXBlID09PSAxLFxuXHRcdFx0XHRoaWRkZW4gPSBpc0VsZW1lbnQgJiYgalF1ZXJ5KHRoaXMpLmlzKFwiOmhpZGRlblwiKSxcblx0XHRcdFx0bmFtZSwgdmFsLCBwLCBlLCBob29rcywgcmVwbGFjZSxcblx0XHRcdFx0cGFydHMsIHN0YXJ0LCBlbmQsIHVuaXQsXG5cdFx0XHRcdG1ldGhvZDtcblxuXHRcdFx0Ly8gd2lsbCBzdG9yZSBwZXIgcHJvcGVydHkgZWFzaW5nIGFuZCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIGFuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuXHRcdFx0b3B0LmFuaW1hdGVkUHJvcGVydGllcyA9IHt9O1xuXG5cdFx0XHQvLyBmaXJzdCBwYXNzIG92ZXIgcHJvcGVydHlzIHRvIGV4cGFuZCAvIG5vcm1hbGl6ZVxuXHRcdFx0Zm9yICggcCBpbiBwcm9wICkge1xuXHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggcCApO1xuXHRcdFx0XHRpZiAoIHAgIT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0cHJvcFsgbmFtZSBdID0gcHJvcFsgcCBdO1xuXHRcdFx0XHRcdGRlbGV0ZSBwcm9wWyBwIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICggaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSApICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHRcdFx0cmVwbGFjZSA9IGhvb2tzLmV4cGFuZCggcHJvcFsgbmFtZSBdICk7XG5cdFx0XHRcdFx0ZGVsZXRlIHByb3BbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIG5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b250IG92ZXJ3cml0ZSBrZXlzIGFscmVhZHkgcHJlc2VudC5cblx0XHRcdFx0XHQvLyBhbHNvIC0gcmV1c2luZyAncCcgZnJvbSBhYm92ZSBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdFx0XHRmb3IgKCBwIGluIHJlcGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICEgKCBwIGluIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcFsgcCBdID0gcmVwbGFjZVsgcCBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBuYW1lIGluIHByb3AgKSB7XG5cdFx0XHRcdHZhbCA9IHByb3BbIG5hbWUgXTtcblx0XHRcdFx0Ly8gZWFzaW5nIHJlc29sdXRpb246IHBlciBwcm9wZXJ0eSA+IG9wdC5zcGVjaWFsRWFzaW5nID4gb3B0LmVhc2luZyA+ICdzd2luZycgKGRlZmF1bHQpXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRcdG9wdC5hbmltYXRlZFByb3BlcnRpZXNbIG5hbWUgXSA9IHZhbFsgMSBdO1xuXHRcdFx0XHRcdHZhbCA9IHByb3BbIG5hbWUgXSA9IHZhbFsgMCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9wdC5hbmltYXRlZFByb3BlcnRpZXNbIG5hbWUgXSA9IG9wdC5zcGVjaWFsRWFzaW5nICYmIG9wdC5zcGVjaWFsRWFzaW5nWyBuYW1lIF0gfHwgb3B0LmVhc2luZyB8fCAnc3dpbmcnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB2YWwgPT09IFwiaGlkZVwiICYmIGhpZGRlbiB8fCB2YWwgPT09IFwic2hvd1wiICYmICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdC5jb21wbGV0ZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGlzRWxlbWVudCAmJiAoIG5hbWUgPT09IFwiaGVpZ2h0XCIgfHwgbmFtZSA9PT0gXCJ3aWR0aFwiICkgKSB7XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0XHRcdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdFxuXHRcdFx0XHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdFx0XHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0XHRcdFx0b3B0Lm92ZXJmbG93ID0gWyB0aGlzLnN0eWxlLm92ZXJmbG93LCB0aGlzLnN0eWxlLm92ZXJmbG93WCwgdGhpcy5zdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdFx0XHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0XHRcdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNzcyggdGhpcywgXCJkaXNwbGF5XCIgKSA9PT0gXCJpbmxpbmVcIiAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY3NzKCB0aGlzLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xuXHRcdFx0XHRcdFx0Ly8gYmxvY2stbGV2ZWwgZWxlbWVudHMgbmVlZCB0byBiZSBpbmxpbmUgd2l0aCBsYXlvdXRcblx0XHRcdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgfHwgZGVmYXVsdERpc3BsYXkoIHRoaXMubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZS56b29tID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHQub3ZlcmZsb3cgIT0gbnVsbCApIHtcblx0XHRcdFx0dGhpcy5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHAgaW4gcHJvcCApIHtcblx0XHRcdFx0ZSA9IG5ldyBqUXVlcnkuZngoIHRoaXMsIG9wdCwgcCApO1xuXHRcdFx0XHR2YWwgPSBwcm9wWyBwIF07XG5cblx0XHRcdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWwgKSApIHtcblxuXHRcdFx0XHRcdC8vIFRyYWNrcyB3aGV0aGVyIHRvIHNob3cgb3IgaGlkZSBiYXNlZCBvbiBwcml2YXRlXG5cdFx0XHRcdFx0Ly8gZGF0YSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdG1ldGhvZCA9IGpRdWVyeS5fZGF0YSggdGhpcywgXCJ0b2dnbGVcIiArIHAgKSB8fCAoIHZhbCA9PT0gXCJ0b2dnbGVcIiA/IGhpZGRlbiA/IFwic2hvd1wiIDogXCJoaWRlXCIgOiAwICk7XG5cdFx0XHRcdFx0aWYgKCBtZXRob2QgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwidG9nZ2xlXCIgKyBwLCBtZXRob2QgPT09IFwic2hvd1wiID8gXCJoaWRlXCIgOiBcInNob3dcIiApO1xuXHRcdFx0XHRcdFx0ZVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZVsgdmFsIF0oKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWwgKTtcblx0XHRcdFx0XHRzdGFydCA9IGUuY3VyKCk7XG5cblx0XHRcdFx0XHRpZiAoIHBhcnRzICkge1xuXHRcdFx0XHRcdFx0ZW5kID0gcGFyc2VGbG9hdCggcGFydHNbMl0gKTtcblx0XHRcdFx0XHRcdHVuaXQgPSBwYXJ0c1szXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHAgXSA/IFwiXCIgOiBcInB4XCIgKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjb21wdXRlIHN0YXJ0aW5nIHZhbHVlXG5cdFx0XHRcdFx0XHRpZiAoIHVuaXQgIT09IFwicHhcIiApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0aGlzLCBwLCAoZW5kIHx8IDEpICsgdW5pdCk7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0ID0gKCAoZW5kIHx8IDEpIC8gZS5jdXIoKSApICogc3RhcnQ7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdGhpcywgcCwgc3RhcnQgKyB1bml0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG5cdFx0XHRcdFx0XHRpZiAoIHBhcnRzWzFdICkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSAoIChwYXJ0c1sgMSBdID09PSBcIi09XCIgPyAtMSA6IDEpICogZW5kICkgKyBzdGFydDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZS5jdXN0b20oIHN0YXJ0LCBlbmQsIHVuaXQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlLmN1c3RvbSggc3RhcnQsIHZhbCwgXCJcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgSlMgc3RyaWN0IGNvbXBsaWFuY2Vcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRoYWRUaW1lcnMgPSBmYWxzZSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApO1xuXG5cdFx0XHQvLyBjbGVhciBtYXJrZXIgY291bnRlcnMgaWYgd2Uga25vdyB0aGV5IHdvbid0IGJlXG5cdFx0XHRpZiAoICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuX3VubWFyayggdHJ1ZSwgdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBzdG9wUXVldWUoIGVsZW0sIGRhdGEsIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgaG9va3MgPSBkYXRhWyBpbmRleCBdO1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgaW5kZXgsIHRydWUgKTtcblx0XHRcdFx0aG9va3Muc3RvcCggZ290b0VuZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT0gbnVsbCApIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIGluZGV4LmluZGV4T2YoXCIucnVuXCIpID09PSBpbmRleC5sZW5ndGggLSA0ICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCB0aGlzLCBkYXRhLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggZGF0YVsgaW5kZXggPSB0eXBlICsgXCIucnVuXCIgXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKXtcblx0XHRcdFx0c3RvcFF1ZXVlKCB0aGlzLCBkYXRhLCBpbmRleCApO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZvcmNlIHRoZSBuZXh0IHN0ZXAgdG8gYmUgdGhlIGxhc3Rcblx0XHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXSggdHJ1ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uc2F2ZVN0YXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGhhZFRpbWVycyA9IHRydWU7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG5cdFx0XHQvLyB0aW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoIHdpbGwgZGVxdWV1ZVxuXHRcdFx0Ly8gYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmRcblx0XHRcdGlmICggISggZ290b0VuZCAmJiBoYWRUaW1lcnMgKSApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG59KTtcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHNldFRpbWVvdXQoIGNsZWFyRnhOb3csIDAgKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuZnVuY3Rpb24gY2xlYXJGeE5vdygpIHtcblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgbnVtICkge1xuXHR2YXIgb2JqID0ge307XG5cblx0alF1ZXJ5LmVhY2goIGZ4QXR0cnMuY29uY2F0LmFwcGx5KFtdLCBmeEF0dHJzLnNsaWNlKCAwLCBudW0gKSksIGZ1bmN0aW9uKCkge1xuXHRcdG9ialsgdGhpcyBdID0gdHlwZTtcblx0fSk7XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goe1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiwgMSApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIsIDEgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiLCAxICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRzcGVlZDogZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHRcdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdFx0fTtcblxuXHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0XHRvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHRcdC8vIG5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRcdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHRcdH1cblxuXHRcdC8vIFF1ZXVlaW5nXG5cdFx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRcdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBub1VubWFyayApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBub1VubWFyayAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdGpRdWVyeS5fdW5tYXJrKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBvcHQ7XG5cdH0sXG5cblx0ZWFzaW5nOiB7XG5cdFx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRcdHJldHVybiBwO1xuXHRcdH0sXG5cdFx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdFx0cmV0dXJuICggLU1hdGguY29zKCBwKk1hdGguUEkgKSAvIDIgKSArIDAuNTtcblx0XHR9XG5cdH0sXG5cblx0dGltZXJzOiBbXSxcblxuXHRmeDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AgKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cblx0XHRvcHRpb25zLm9yaWcgPSBvcHRpb25zLm9yaWcgfHwge307XG5cdH1cblxufSk7XG5cbmpRdWVyeS5meC5wcm90b3R5cGUgPSB7XG5cdC8vIFNpbXBsZSBmdW5jdGlvbiBmb3Igc2V0dGluZyBhIHN0eWxlIHZhbHVlXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHQoIGpRdWVyeS5meC5zdGVwWyB0aGlzLnByb3AgXSB8fCBqUXVlcnkuZnguc3RlcC5fZGVmYXVsdCApKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjdXJyZW50IHNpemVcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuZWxlbVsgdGhpcy5wcm9wIF0gIT0gbnVsbCAmJiAoIXRoaXMuZWxlbS5zdHlsZSB8fCB0aGlzLmVsZW0uc3R5bGVbIHRoaXMucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbVsgdGhpcy5wcm9wIF07XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnNlZCxcblx0XHRcdHIgPSBqUXVlcnkuY3NzKCB0aGlzLmVsZW0sIHRoaXMucHJvcCApO1xuXHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLFxuXHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMsXG5cdFx0Ly8gc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXG5cdFx0cmV0dXJuIGlzTmFOKCBwYXJzZWQgPSBwYXJzZUZsb2F0KCByICkgKSA/ICFyIHx8IHIgPT09IFwiYXV0b1wiID8gMCA6IHIgOiBwYXJzZWQ7XG5cdH0sXG5cblx0Ly8gU3RhcnQgYW4gYW5pbWF0aW9uIGZyb20gb25lIG51bWJlciB0byBhbm90aGVyXG5cdGN1c3RvbTogZnVuY3Rpb24oIGZyb20sIHRvLCB1bml0ICkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGZ4ID0galF1ZXJ5LmZ4O1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpO1xuXHRcdHRoaXMuZW5kID0gdG87XG5cdFx0dGhpcy5ub3cgPSB0aGlzLnN0YXJ0ID0gZnJvbTtcblx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAwO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgdGhpcy51bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgdGhpcy5wcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cblx0XHRmdW5jdGlvbiB0KCBnb3RvRW5kICkge1xuXHRcdFx0cmV0dXJuIHNlbGYuc3RlcCggZ290b0VuZCApO1xuXHRcdH1cblxuXHRcdHQucXVldWUgPSB0aGlzLm9wdGlvbnMucXVldWU7XG5cdFx0dC5lbGVtID0gdGhpcy5lbGVtO1xuXHRcdHQuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5fZGF0YSggc2VsZi5lbGVtLCBcImZ4c2hvd1wiICsgc2VsZi5wcm9wICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuaGlkZSApIHtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHNlbGYuZWxlbSwgXCJmeHNob3dcIiArIHNlbGYucHJvcCwgc2VsZi5zdGFydCApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzZWxmLm9wdGlvbnMuc2hvdyApIHtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHNlbGYuZWxlbSwgXCJmeHNob3dcIiArIHNlbGYucHJvcCwgc2VsZi5lbmQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAoIHQoKSAmJiBqUXVlcnkudGltZXJzLnB1c2godCkgJiYgIXRpbWVySWQgKSB7XG5cdFx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGZ4LnRpY2ssIGZ4LmludGVydmFsICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbXBsZSAnc2hvdycgZnVuY3Rpb25cblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCB0aGlzLmVsZW0sIFwiZnhzaG93XCIgKyB0aGlzLnByb3AgKTtcblxuXHRcdC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcblx0XHR0aGlzLm9wdGlvbnMub3JpZ1sgdGhpcy5wcm9wIF0gPSBkYXRhU2hvdyB8fCBqUXVlcnkuc3R5bGUoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XG5cdFx0dGhpcy5vcHRpb25zLnNob3cgPSB0cnVlO1xuXG5cdFx0Ly8gQmVnaW4gdGhlIGFuaW1hdGlvblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHN0YXJ0IGF0IGEgc21hbGwgd2lkdGgvaGVpZ2h0IHRvIGF2b2lkIGFueSBmbGFzaCBvZiBjb250ZW50XG5cdFx0aWYgKCBkYXRhU2hvdyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gVGhpcyBzaG93IGlzIHBpY2tpbmcgdXAgd2hlcmUgYSBwcmV2aW91cyBoaWRlIG9yIHNob3cgbGVmdCBvZmZcblx0XHRcdHRoaXMuY3VzdG9tKCB0aGlzLmN1cigpLCBkYXRhU2hvdyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmN1c3RvbSggdGhpcy5wcm9wID09PSBcIndpZHRoXCIgfHwgdGhpcy5wcm9wID09PSBcImhlaWdodFwiID8gMSA6IDAsIHRoaXMuY3VyKCkgKTtcblx0XHR9XG5cblx0XHQvLyBTdGFydCBieSBzaG93aW5nIHRoZSBlbGVtZW50XG5cdFx0alF1ZXJ5KCB0aGlzLmVsZW0gKS5zaG93KCk7XG5cdH0sXG5cblx0Ly8gU2ltcGxlICdoaWRlJyBmdW5jdGlvblxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXG5cdFx0dGhpcy5vcHRpb25zLm9yaWdbIHRoaXMucHJvcCBdID0galF1ZXJ5Ll9kYXRhKCB0aGlzLmVsZW0sIFwiZnhzaG93XCIgKyB0aGlzLnByb3AgKSB8fCBqUXVlcnkuc3R5bGUoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XG5cdFx0dGhpcy5vcHRpb25zLmhpZGUgPSB0cnVlO1xuXG5cdFx0Ly8gQmVnaW4gdGhlIGFuaW1hdGlvblxuXHRcdHRoaXMuY3VzdG9tKCB0aGlzLmN1cigpLCAwICk7XG5cdH0sXG5cblx0Ly8gRWFjaCBzdGVwIG9mIGFuIGFuaW1hdGlvblxuXHRzdGVwOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHR2YXIgcCwgbiwgY29tcGxldGUsXG5cdFx0XHR0ID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGRvbmUgPSB0cnVlLFxuXHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIGdvdG9FbmQgfHwgdCA+PSBvcHRpb25zLmR1cmF0aW9uICsgdGhpcy5zdGFydFRpbWUgKSB7XG5cdFx0XHR0aGlzLm5vdyA9IHRoaXMuZW5kO1xuXHRcdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdG9wdGlvbnMuYW5pbWF0ZWRQcm9wZXJ0aWVzWyB0aGlzLnByb3AgXSA9IHRydWU7XG5cblx0XHRcdGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXNbIHAgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkb25lICkge1xuXHRcdFx0XHQvLyBSZXNldCB0aGUgb3ZlcmZsb3dcblx0XHRcdFx0aWYgKCBvcHRpb25zLm92ZXJmbG93ICE9IG51bGwgJiYgIWpRdWVyeS5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggWyBcIlwiLCBcIlhcIiwgXCJZXCIgXSwgZnVuY3Rpb24oIGluZGV4LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc3R5bGVbIFwib3ZlcmZsb3dcIiArIHZhbHVlIF0gPSBvcHRpb25zLm92ZXJmbG93WyBpbmRleCBdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGlkZSB0aGUgZWxlbWVudCBpZiB0aGUgXCJoaWRlXCIgb3BlcmF0aW9uIHdhcyBkb25lXG5cdFx0XHRcdGlmICggb3B0aW9ucy5oaWRlICkge1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBwcm9wZXJ0aWVzLCBpZiB0aGUgaXRlbSBoYXMgYmVlbiBoaWRkZW4gb3Igc2hvd25cblx0XHRcdFx0aWYgKCBvcHRpb25zLmhpZGUgfHwgb3B0aW9ucy5zaG93ICkge1xuXHRcdFx0XHRcdGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHAsIG9wdGlvbnMub3JpZ1sgcCBdICk7XG5cdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiArIHAsIHRydWUgKTtcblx0XHRcdFx0XHRcdC8vIFRvZ2dsZSBkYXRhIGlzIG5vIGxvbmdlciBuZWVkZWRcblx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBcInRvZ2dsZVwiICsgcCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGNvbXBsZXRlIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBjb21wbGV0ZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdC8vIHdlIG11c3QgZW5zdXJlIGl0IHdvbid0IGJlIGNhbGxlZCB0d2ljZS4gIzU2ODRcblxuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0Y29tcGxldGUuY2FsbCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjbGFzc2ljYWwgZWFzaW5nIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gSW5maW5pdHkgZHVyYXRpb25cblx0XHRcdGlmICggb3B0aW9ucy5kdXJhdGlvbiA9PSBJbmZpbml0eSApIHtcblx0XHRcdFx0dGhpcy5ub3cgPSB0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0biA9IHQgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IG4gLyBvcHRpb25zLmR1cmF0aW9uO1xuXG5cdFx0XHRcdC8vIFBlcmZvcm0gdGhlIGVhc2luZyBmdW5jdGlvbiwgZGVmYXVsdHMgdG8gc3dpbmdcblx0XHRcdFx0dGhpcy5wb3MgPSBqUXVlcnkuZWFzaW5nWyBvcHRpb25zLmFuaW1hdGVkUHJvcGVydGllc1t0aGlzLnByb3BdIF0oIHRoaXMuc3RhdGUsIG4sIDAsIDEsIG9wdGlvbnMuZHVyYXRpb24gKTtcblx0XHRcdFx0dGhpcy5ub3cgPSB0aGlzLnN0YXJ0ICsgKCAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQZXJmb3JtIHRoZSBuZXh0IHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmZ4LCB7XG5cdHRpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lcixcblx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0XHR9XG5cdH0sXG5cblx0aW50ZXJ2YWw6IDEzLFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0XHR0aW1lcklkID0gbnVsbDtcblx0fSxcblxuXHRzcGVlZHM6IHtcblx0XHRzbG93OiA2MDAsXG5cdFx0ZmFzdDogMjAwLFxuXHRcdC8vIERlZmF1bHQgc3BlZWRcblx0XHRfZGVmYXVsdDogNDAwXG5cdH0sXG5cblx0c3RlcDoge1xuXHRcdG9wYWNpdHk6IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgXCJvcGFjaXR5XCIsIGZ4Lm5vdyApO1xuXHRcdH0sXG5cblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGZ4ICkge1xuXHRcdFx0aWYgKCBmeC5lbGVtLnN0eWxlICYmIGZ4LmVsZW0uc3R5bGVbIGZ4LnByb3AgXSAhPSBudWxsICkge1xuXHRcdFx0XHRmeC5lbGVtLnN0eWxlWyBmeC5wcm9wIF0gPSBmeC5ub3cgKyBmeC51bml0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnguZWxlbVsgZngucHJvcCBdID0gZngubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEVuc3VyZSBwcm9wcyB0aGF0IGNhbid0IGJlIG5lZ2F0aXZlIGRvbid0IGdvIHRoZXJlIG9uIHVuZGVyc2hvb3QgZWFzaW5nXG5qUXVlcnkuZWFjaCggZnhBdHRycy5jb25jYXQuYXBwbHkoIFtdLCBmeEF0dHJzICksIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHQvLyBleGNsdWRlIG1hcmdpblRvcCwgbWFyZ2luTGVmdCwgbWFyZ2luQm90dG9tIGFuZCBtYXJnaW5SaWdodCBmcm9tIHRoaXMgbGlzdFxuXHRpZiAoIHByb3AuaW5kZXhPZiggXCJtYXJnaW5cIiApICkge1xuXHRcdGpRdWVyeS5meC5zdGVwWyBwcm9wIF0gPSBmdW5jdGlvbiggZnggKSB7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGZ4LmVsZW0sIHByb3AsIE1hdGgubWF4KDAsIGZ4Lm5vdykgKyBmeC51bml0ICk7XG5cdFx0fTtcblx0fVxufSk7XG5cbmlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcblx0alF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0XHR9KS5sZW5ndGg7XG5cdH07XG59XG5cbi8vIFRyeSB0byByZXN0b3JlIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXG5cdGlmICggIWVsZW1kaXNwbGF5WyBub2RlTmFtZSBdICkge1xuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdFx0ZWxlbSA9IGpRdWVyeSggXCI8XCIgKyBub2RlTmFtZSArIFwiPlwiICkuYXBwZW5kVG8oIGJvZHkgKSxcblx0XHRcdGRpc3BsYXkgPSBlbGVtLmNzcyggXCJkaXNwbGF5XCIgKTtcblx0XHRlbGVtLnJlbW92ZSgpO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsXG5cdFx0Ly8gZ2V0IGVsZW1lbnQncyByZWFsIGRlZmF1bHQgZGlzcGxheSBieSBhdHRhY2hpbmcgaXQgdG8gYSB0ZW1wIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdC8vIE5vIGlmcmFtZSB0byB1c2UgeWV0LCBzbyBjcmVhdGUgaXRcblx0XHRcdGlmICggIWlmcmFtZSApIHtcblx0XHRcdFx0aWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpZnJhbWVcIiApO1xuXHRcdFx0XHRpZnJhbWUuZnJhbWVCb3JkZXIgPSBpZnJhbWUud2lkdGggPSBpZnJhbWUuaGVpZ2h0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZCggaWZyYW1lICk7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGNhY2hlYWJsZSBjb3B5IG9mIHRoZSBpZnJhbWUgZG9jdW1lbnQgb24gZmlyc3QgY2FsbC5cblx0XHRcdC8vIElFIGFuZCBPcGVyYSB3aWxsIGFsbG93IHVzIHRvIHJldXNlIHRoZSBpZnJhbWVEb2Mgd2l0aG91dCByZS13cml0aW5nIHRoZSBmYWtlIEhUTUxcblx0XHRcdC8vIGRvY3VtZW50IHRvIGl0OyBXZWJLaXQgJiBGaXJlZm94IHdvbid0IGFsbG93IHJldXNpbmcgdGhlIGlmcmFtZSBkb2N1bWVudC5cblx0XHRcdGlmICggIWlmcmFtZURvYyB8fCAhaWZyYW1lLmNyZWF0ZUVsZW1lbnQgKSB7XG5cdFx0XHRcdGlmcmFtZURvYyA9ICggaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudCApLmRvY3VtZW50O1xuXHRcdFx0XHRpZnJhbWVEb2Mud3JpdGUoICggalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgPyBcIjwhZG9jdHlwZSBodG1sPlwiIDogXCJcIiApICsgXCI8aHRtbD48Ym9keT5cIiApO1xuXHRcdFx0XHRpZnJhbWVEb2MuY2xvc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbSA9IGlmcmFtZURvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApO1xuXG5cdFx0XHRpZnJhbWVEb2MuYm9keS5hcHBlbmRDaGlsZCggZWxlbSApO1xuXG5cdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGlmcmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcbn1cblxuXG5cblxudmFyIGdldE9mZnNldCxcblx0cnRhYmxlID0gL150KD86YWJsZXxkfGgpJC9pLFxuXHRycm9vdCA9IC9eKD86Ym9keXxodG1sKSQvaTtcblxuaWYgKCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcblx0Z2V0T2Zmc2V0ID0gZnVuY3Rpb24oIGVsZW0sIGRvYywgZG9jRWxlbSwgYm94ICkge1xuXHRcdHRyeSB7XG5cdFx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH0gY2F0Y2goZSkge31cblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhYm94IHx8ICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3ggPyB7IHRvcDogYm94LnRvcCwgbGVmdDogYm94LmxlZnQgfSA6IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0dmFyIGJvZHkgPSBkb2MuYm9keSxcblx0XHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICksXG5cdFx0XHRjbGllbnRUb3AgID0gZG9jRWxlbS5jbGllbnRUb3AgIHx8IGJvZHkuY2xpZW50VG9wICB8fCAwLFxuXHRcdFx0Y2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcblx0XHRcdHNjcm9sbFRvcCAgPSB3aW4ucGFnZVlPZmZzZXQgfHwgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgZG9jRWxlbS5zY3JvbGxUb3AgIHx8IGJvZHkuc2Nyb2xsVG9wLFxuXHRcdFx0c2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldCB8fCBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0LFxuXHRcdFx0dG9wICA9IGJveC50b3AgICsgc2Nyb2xsVG9wICAtIGNsaWVudFRvcCxcblx0XHRcdGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcblx0fTtcblxufSBlbHNlIHtcblx0Z2V0T2Zmc2V0ID0gZnVuY3Rpb24oIGVsZW0sIGRvYywgZG9jRWxlbSApIHtcblx0XHR2YXIgY29tcHV0ZWRTdHlsZSxcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50LFxuXHRcdFx0cHJldk9mZnNldFBhcmVudCA9IGVsZW0sXG5cdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdHByZXZDb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcgPyBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICkgOiBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdHRvcCA9IGVsZW0ub2Zmc2V0VG9wLFxuXHRcdFx0bGVmdCA9IGVsZW0ub2Zmc2V0TGVmdDtcblxuXHRcdHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0gIT09IGJvZHkgJiYgZWxlbSAhPT0gZG9jRWxlbSApIHtcblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZml4ZWRQb3NpdGlvbiAmJiBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSA6IGVsZW0uY3VycmVudFN0eWxlO1xuXHRcdFx0dG9wICAtPSBlbGVtLnNjcm9sbFRvcDtcblx0XHRcdGxlZnQgLT0gZWxlbS5zY3JvbGxMZWZ0O1xuXG5cdFx0XHRpZiAoIGVsZW0gPT09IG9mZnNldFBhcmVudCApIHtcblx0XHRcdFx0dG9wICArPSBlbGVtLm9mZnNldFRvcDtcblx0XHRcdFx0bGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90QWRkQm9yZGVyICYmICEoalF1ZXJ5LnN1cHBvcnQuZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHMgJiYgcnRhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkpICkge1xuXHRcdFx0XHRcdHRvcCAgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCAgKSB8fCAwO1xuXHRcdFx0XHRcdGxlZnQgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggKSB8fCAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldk9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlICYmIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiICkge1xuXHRcdFx0XHR0b3AgICs9IHBhcnNlRmxvYXQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGggICkgfHwgMDtcblx0XHRcdFx0bGVmdCArPSBwYXJzZUZsb2F0KCBjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCApIHx8IDA7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblx0XHR9XG5cblx0XHRpZiAoIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHR0b3AgICs9IGJvZHkub2Zmc2V0VG9wO1xuXHRcdFx0bGVmdCArPSBib2R5Lm9mZnNldExlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5maXhlZFBvc2l0aW9uICYmIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHR0b3AgICs9IE1hdGgubWF4KCBkb2NFbGVtLnNjcm9sbFRvcCwgYm9keS5zY3JvbGxUb3AgKTtcblx0XHRcdGxlZnQgKz0gTWF0aC5tYXgoIGRvY0VsZW0uc2Nyb2xsTGVmdCwgYm9keS5zY3JvbGxMZWZ0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcblx0fTtcbn1cblxualF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0dmFyIGVsZW0gPSB0aGlzWzBdLFxuXHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdGlmICggIWRvYyApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggZWxlbSA9PT0gZG9jLmJvZHkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5vZmZzZXQuYm9keU9mZnNldCggZWxlbSApO1xuXHR9XG5cblx0cmV0dXJuIGdldE9mZnNldCggZWxlbSwgZG9jLCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG59O1xuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXG5cdGJvZHlPZmZzZXQ6IGZ1bmN0aW9uKCBib2R5ICkge1xuXHRcdHZhciB0b3AgPSBib2R5Lm9mZnNldFRvcCxcblx0XHRcdGxlZnQgPSBib2R5Lm9mZnNldExlZnQ7XG5cblx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0ICkge1xuXHRcdFx0dG9wICArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGJvZHksIFwibWFyZ2luVG9wXCIpICkgfHwgMDtcblx0XHRcdGxlZnQgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpbkxlZnRcIikgKSB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG5cdH0sXG5cblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgcG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKTtcblxuXHRcdC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHR2YXIgY3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKSxcblx0XHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKSxcblx0XHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApLFxuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmIGpRdWVyeS5pbkFycmF5KFwiYXV0b1wiLCBbY3VyQ1NTVG9wLCBjdXJDU1NMZWZ0XSkgPiAtMSxcblx0XHRcdHByb3BzID0ge30sIGN1clBvc2l0aW9uID0ge30sIGN1clRvcCwgY3VyTGVmdDtcblxuXHRcdC8vIG5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbMF0gKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgZWxlbSA9IHRoaXNbMF0sXG5cblx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXG5cblx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0b2Zmc2V0ICAgICAgID0gdGhpcy5vZmZzZXQoKSxcblx0XHRwYXJlbnRPZmZzZXQgPSBycm9vdC50ZXN0KG9mZnNldFBhcmVudFswXS5ub2RlTmFtZSkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gU3VidHJhY3QgZWxlbWVudCBtYXJnaW5zXG5cdFx0Ly8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcblx0XHQvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuXHRcdG9mZnNldC50b3AgIC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5Ub3BcIikgKSB8fCAwO1xuXHRcdG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcblxuXHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIpICkgfHwgMDtcblx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIikgKSB8fCAwO1xuXG5cdFx0Ly8gU3VidHJhY3QgdGhlIHR3byBvZmZzZXRzXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoIXJyb290LnRlc3Qob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAmJiBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50O1xuXHRcdH0pO1xuXHR9XG59KTtcblxuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7c2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIn0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSAvWS8udGVzdCggcHJvcCApO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyAocHJvcCBpbiB3aW4pID8gd2luWyBwcm9wIF0gOlxuXHRcdFx0XHRcdGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsICYmIHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIG1ldGhvZCBdIHx8XG5cdFx0XHRcdFx0XHR3aW4uZG9jdW1lbnQuYm9keVsgbWV0aG9kIF0gOlxuXHRcdFx0XHRcdGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHQgdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID9cblx0XHRlbGVtIDpcblx0XHRlbGVtLm5vZGVUeXBlID09PSA5ID9cblx0XHRcdGVsZW0uZGVmYXVsdFZpZXcgfHwgZWxlbS5wYXJlbnRXaW5kb3cgOlxuXHRcdFx0ZmFsc2U7XG59XG5cblxuXG5cbi8vIENyZWF0ZSB3aWR0aCwgaGVpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHR2YXIgY2xpZW50UHJvcCA9IFwiY2xpZW50XCIgKyBuYW1lLFxuXHRcdHNjcm9sbFByb3AgPSBcInNjcm9sbFwiICsgbmFtZSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIG5hbWU7XG5cblx0Ly8gaW5uZXJIZWlnaHQgYW5kIGlubmVyV2lkdGhcblx0alF1ZXJ5LmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cdFx0cmV0dXJuIGVsZW0gP1xuXHRcdFx0ZWxlbS5zdHlsZSA/XG5cdFx0XHRwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBcInBhZGRpbmdcIiApICkgOlxuXHRcdFx0dGhpc1sgdHlwZSBdKCkgOlxuXHRcdFx0bnVsbDtcblx0fTtcblxuXHQvLyBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aFxuXHRqUXVlcnkuZm5bIFwib3V0ZXJcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4gKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdHJldHVybiBlbGVtID9cblx0XHRcdGVsZW0uc3R5bGUgP1xuXHRcdFx0cGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgbWFyZ2luID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKSApIDpcblx0XHRcdHRoaXNbIHR5cGUgXSgpIDpcblx0XHRcdG51bGw7XG5cdH07XG5cblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdHZhciBkb2MsIGRvY0VsZW1Qcm9wLCBvcmlnLCByZXQ7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdC8vIDNyZCBjb25kaXRpb24gYWxsb3dzIE5va2lhIHN1cHBvcnQsIGFzIGl0IHN1cHBvcnRzIHRoZSBkb2NFbGVtIHByb3AgYnV0IG5vdCBDU1MxQ29tcGF0XG5cdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnQ7XG5cdFx0XHRcdGRvY0VsZW1Qcm9wID0gZG9jLmRvY3VtZW50RWxlbWVudFsgY2xpZW50UHJvcCBdO1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgZG9jRWxlbVByb3AgfHxcblx0XHRcdFx0XHRkb2MuYm9keSAmJiBkb2MuYm9keVsgY2xpZW50UHJvcCBdIHx8IGRvY0VsZW1Qcm9wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcblx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0Ly8gd2hlbiBhIHdpbmRvdyA+IGRvY3VtZW50LCBJRTYgcmVwb3J0cyBhIG9mZnNldFtXaWR0aC9IZWlnaHRdID4gY2xpZW50W1dpZHRoL0hlaWdodF1cblx0XHRcdFx0Ly8gc28gd2UgY2FuJ3QgdXNlIG1heCwgYXMgaXQnbGwgY2hvb3NlIHRoZSBpbmNvcnJlY3Qgb2Zmc2V0W1dpZHRoL0hlaWdodF1cblx0XHRcdFx0Ly8gaW5zdGVhZCB3ZSB1c2UgdGhlIGNvcnJlY3QgY2xpZW50W1dpZHRoL0hlaWdodF1cblx0XHRcdFx0Ly8gc3VwcG9ydDpJRTZcblx0XHRcdFx0aWYgKCBkb2NbIGNsaWVudFByb3AgXSA+PSBkb2NbIHNjcm9sbFByb3AgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZG9jWyBjbGllbnRQcm9wIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0ZWxlbS5ib2R5WyBzY3JvbGxQcm9wIF0sIGRvY1sgc2Nyb2xsUHJvcCBdLFxuXHRcdFx0XHRcdGVsZW0uYm9keVsgb2Zmc2V0UHJvcCBdLCBkb2NbIG9mZnNldFByb3AgXVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG9yaWcgPSBqUXVlcnkuY3NzKCBlbGVtLCB0eXBlICk7XG5cdFx0XHRcdHJldCA9IHBhcnNlRmxvYXQoIG9yaWcgKTtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5pc051bWVyaWMoIHJldCApID8gcmV0IDogb3JpZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdGpRdWVyeSggZWxlbSApLmNzcyggdHlwZSwgdmFsdWUgKTtcblx0XHR9LCB0eXBlLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cblxuXG5cbi8vIEV4cG9zZSBqUXVlcnkgdG8gdGhlIGdsb2JhbCBvYmplY3RcbndpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhcyBhbiBBTUQgbW9kdWxlLCBidXQgb25seSBmb3IgQU1EIGxvYWRlcnMgdGhhdFxuLy8gdW5kZXJzdGFuZCB0aGUgaXNzdWVzIHdpdGggbG9hZGluZyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBqUXVlcnlcbi8vIGluIGEgcGFnZSB0aGF0IGFsbCBtaWdodCBjYWxsIGRlZmluZSgpLiBUaGUgbG9hZGVyIHdpbGwgaW5kaWNhdGVcbi8vIHRoZXkgaGF2ZSBzcGVjaWFsIGFsbG93YW5jZXMgZm9yIG11bHRpcGxlIGpRdWVyeSB2ZXJzaW9ucyBieVxuLy8gc3BlY2lmeWluZyBkZWZpbmUuYW1kLmpRdWVyeSA9IHRydWUuIFJlZ2lzdGVyIGFzIGEgbmFtZWQgbW9kdWxlLFxuLy8gc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlciBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLFxuLy8gYnV0IG5vdCB1c2UgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdCB1bmRlcnN0YW5kcyBhbm9ueW1vdXNcbi8vIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0IHdheSB0byByZWdpc3Rlci5cbi8vIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlIGRlcml2ZWQgZnJvbVxuLy8gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2UgZmlsZSBuYW1lLlxuLy8gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50cyB0byBjYWxsXG4vLyBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUuYW1kLmpRdWVyeSApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4galF1ZXJ5OyB9ICk7XG59XG5cblxuXG59KSggd2luZG93ICk7IiwiLypcbiAgICBodHRwOi8vd3d3LkpTT04ub3JnL2pzb24yLmpzXG4gICAgMjAwOS0wNi0yOVxuXG4gICAgUHVibGljIERvbWFpbi5cblxuICAgIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cblxuICAgIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcblxuICAgIFRoaXMgZmlsZSBjcmVhdGVzIGEgZ2xvYmFsIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIG1ldGhvZHM6IHN0cmluZ2lmeVxuICAgIGFuZCBwYXJzZS5cblxuICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuXG4gICAgICAgICAgICByZXBsYWNlciAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuXG4gICAgICAgICAgICBzcGFjZSAgICAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiBuZXN0ZWQgc3RydWN0dXJlcy4gSWYgaXQgaXMgb21pdHRlZCwgdGhlIHRleHQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgYmUgcGFja2VkIHdpdGhvdXQgZXh0cmEgd2hpdGVzcGFjZS4gSWYgaXQgaXMgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIHNwZWNpZnkgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gaW5kZW50IGF0IGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLiBJZiBpdCBpcyBhIHN0cmluZyAoc3VjaCBhcyAnXFx0JyBvciAnJm5ic3A7JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwcm9kdWNlcyBhIEpTT04gdGV4dCBmcm9tIGEgSmF2YVNjcmlwdCB2YWx1ZS5cblxuICAgICAgICAgICAgV2hlbiBhbiBvYmplY3QgdmFsdWUgaXMgZm91bmQsIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYSB0b0pTT05cbiAgICAgICAgICAgIG1ldGhvZCwgaXRzIHRvSlNPTiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuIEEgdG9KU09OIG1ldGhvZCBkb2VzIG5vdCBzZXJpYWxpemU6IGl0IHJldHVybnMgdGhlXG4gICAgICAgICAgICB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgbmFtZS92YWx1ZSBwYWlyIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICBvciB1bmRlZmluZWQgaWYgbm90aGluZyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIHRvSlNPTiBtZXRob2RcbiAgICAgICAgICAgIHdpbGwgYmUgcGFzc2VkIHRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSB2YWx1ZSwgYW5kIHRoaXMgd2lsbCBiZVxuICAgICAgICAgICAgYm91bmQgdG8gdGhlIG9iamVjdCBob2xkaW5nIHRoZSBrZXkuXG5cbiAgICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuICAgICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4gICAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuICAgICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4gICAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4gICAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuICAgICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuICAgICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3JcbiAgICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4gICAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2VcbiAgICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgVGhlIG9wdGlvbmFsIHNwYWNlIHBhcmFtZXRlciBwcm9kdWNlcyBhIHN0cmluZ2lmaWNhdGlvbiBvZiB0aGVcbiAgICAgICAgICAgIHZhbHVlIHRoYXQgaXMgZmlsbGVkIHdpdGggbGluZSBicmVha3MgYW5kIGluZGVudGF0aW9uIHRvIG1ha2UgaXRcbiAgICAgICAgICAgIGVhc2llciB0byByZWFkLlxuXG4gICAgICAgICAgICBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbm9uLWVtcHR5IHN0cmluZywgdGhlbiB0aGF0IHN0cmluZyB3aWxsXG4gICAgICAgICAgICBiZSB1c2VkIGZvciBpbmRlbnRhdGlvbi4gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgdGhlblxuICAgICAgICAgICAgdGhlIGluZGVudGF0aW9uIHdpbGwgYmUgdGhhdCBtYW55IHNwYWNlcy5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSwgbnVsbCwgJ1xcdCcpO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbbmV3IERhdGUoKV0sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGUgP1xuICAgICAgICAgICAgICAgICAgICAnRGF0ZSgnICsgdGhpc1trZXldICsgJyknIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcIkRhdGUoLS0tY3VycmVudCB0aW1lLS0tKVwiXSdcblxuXG4gICAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbiAgICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuICAgICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuICAgICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4gICAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuICAgICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4gICAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9XG4vXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pVChcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0oPzpcXC5cXGQqKT8pWiQvLmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCthWzFdLCArYVsyXSAtIDEsICthWzNdLCArYVs0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArYVs1XSwgK2FbNl0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSgnW1wiRGF0ZSgwOS8wOS8yMDAxKVwiXScsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSAnRGF0ZSgnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMSkgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuICAgIHJlZGlzdHJpYnV0ZS5cblxuICAgIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4gICAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4gICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICBOT1QgQ09OVFJPTC5cbiovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuLyptZW1iZXJzIFwiXCIsIFwiXFxiXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxmXCIsIFwiXFxyXCIsIFwiXFxcIlwiLCBKU09OLCBcIlxcXFxcIiwgYXBwbHksXG4gICAgY2FsbCwgY2hhckNvZGVBdCwgZ2V0VVRDRGF0ZSwgZ2V0VVRDRnVsbFllYXIsIGdldFVUQ0hvdXJzLFxuICAgIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiAgICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgICB0ZXN0LCB0b0pTT04sIHRvU3RyaW5nLCB2YWx1ZU9mXG4qL1xuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG52YXIgSlNPTiA9IEpTT04gfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodGhpcy52YWx1ZU9mKCkpID9cbiAgICAgICAgICAgICAgICAgICB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArICctJyArXG4gICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID1cbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBnYXAsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/XG4gICAgICAgICAgICAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6XG4gICAgICAgICAgICAgICAgICAgIGdhcCA/ICdbXFxuJyArIGdhcCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4vLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbi8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDpcbiAgICAgICAgICAgICAgICBnYXAgPyAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnfScgOiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBwYXJzZSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04ucGFyc2UgPSBmdW5jdGlvbiAodGV4dCwgcmV2aXZlcikge1xuXG4vLyBUaGUgcGFyc2UgbWV0aG9kIHRha2VzIGEgdGV4dCBhbmQgYW4gb3B0aW9uYWwgcmV2aXZlciBmdW5jdGlvbiwgYW5kIHJldHVybnNcbi8vIGEgSmF2YVNjcmlwdCB2YWx1ZSBpZiB0aGUgdGV4dCBpcyBhIHZhbGlkIEpTT04gdGV4dC5cblxuICAgICAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblxuLy8gVGhlIHdhbGsgbWV0aG9kIGlzIHVzZWQgdG8gcmVjdXJzaXZlbHkgd2FsayB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZSBzb1xuLy8gdGhhdCBtb2RpZmljYXRpb25zIGNhbiBiZSBtYWRlLlxuXG4gICAgICAgICAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIGN4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoY3gudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoY3gsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbi8vIEluIHRoZSBzZWNvbmQgc3RhZ2UsIHdlIHJ1biB0aGUgdGV4dCBhZ2FpbnN0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBsb29rXG4vLyBmb3Igbm9uLUpTT04gcGF0dGVybnMuIFdlIGFyZSBlc3BlY2lhbGx5IGNvbmNlcm5lZCB3aXRoICcoKScgYW5kICduZXcnXG4vLyBiZWNhdXNlIHRoZXkgY2FuIGNhdXNlIGludm9jYXRpb24sIGFuZCAnPScgYmVjYXVzZSBpdCBjYW4gY2F1c2UgbXV0YXRpb24uXG4vLyBCdXQganVzdCB0byBiZSBzYWZlLCB3ZSB3YW50IHRvIHJlamVjdCBhbGwgdW5leHBlY3RlZCBmb3Jtcy5cblxuLy8gV2Ugc3BsaXQgdGhlIHNlY29uZCBzdGFnZSBpbnRvIDQgcmVnZXhwIG9wZXJhdGlvbnMgaW4gb3JkZXIgdG8gd29yayBhcm91bmRcbi8vIGNyaXBwbGluZyBpbmVmZmljaWVuY2llcyBpbiBJRSdzIGFuZCBTYWZhcmkncyByZWdleHAgZW5naW5lcy4gRmlyc3Qgd2Vcbi8vIHJlcGxhY2UgdGhlIEpTT04gYmFja3NsYXNoIHBhaXJzIHdpdGggJ0AnIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCAnXScgY2hhcmFjdGVycy4gVGhpcmQsIHdlIGRlbGV0ZSBhbGxcbi8vIG9wZW4gYnJhY2tldHMgdGhhdCBmb2xsb3cgYSBjb2xvbiBvciBjb21tYSBvciB0aGF0IGJlZ2luIHRoZSB0ZXh0LiBGaW5hbGx5LFxuLy8gd2UgbG9vayB0byBzZWUgdGhhdCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYXJlIG9ubHkgd2hpdGVzcGFjZSBvciAnXScgb3Jcbi8vICcsJyBvciAnOicgb3IgJ3snIG9yICd9Jy4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoL15bXFxdLDp7fVxcc10qJC8uXG50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpLlxucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJykuXG5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZywgJycpKSkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgd2Fsayh7Jyc6IGp9LCAnJykgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG4iLCIvKlxuICoganNUcmVlIChjdXN0b20gdmVyc2lvbiBmb3IgU2lsdmVyU3RyaXBlOiAxLjAtcmMzICsgbWlub3IgYnVnZml4ZXMpXG4gKiBodHRwOi8vanN0cmVlLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgSXZhbiBCb3poYW5vdiAodmFrYXRhLmNvbSlcbiAqXG4gKiBMaWNlbnNlZCBzYW1lIGFzIGpxdWVyeSAtIHVuZGVyIHRoZSB0ZXJtcyBvZiBlaXRoZXIgdGhlIE1JVCBMaWNlbnNlIG9yIHRoZSBHUEwgVmVyc2lvbiAyIExpY2Vuc2VcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqICAgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKlxuICogJERhdGU6IDIwMTEtMDItMDkgMDE6MTc6MTQgKzAyMDAgKNGB0YAsIDA5INGE0LXQstGAIDIwMTEpICRcbiAqICRSZXZpc2lvbjogMjM2ICRcbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBvbmV2YXI6IHRydWUsIHVuZGVmOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cbi8qZ2xvYmFsIHdpbmRvdyA6IGZhbHNlLCBjbGVhckludGVydmFsOiBmYWxzZSwgY2xlYXJUaW1lb3V0OiBmYWxzZSwgZG9jdW1lbnQ6IGZhbHNlLCBzZXRJbnRlcnZhbDogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBqUXVlcnk6IGZhbHNlLCBuYXZpZ2F0b3I6IGZhbHNlLCBYU0xUUHJvY2Vzc29yOiBmYWxzZSwgRE9NUGFyc2VyOiBmYWxzZSwgWE1MU2VyaWFsaXplcjogZmFsc2UqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gdG9wIHdyYXBwZXIgdG8gcHJldmVudCBtdWx0aXBsZSBpbmNsdXNpb24gKGlzIHRoaXMgT0s/KVxuKGZ1bmN0aW9uICgpIHsgaWYoalF1ZXJ5ICYmIGpRdWVyeS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cdHZhciBpc19pZTYgPSBmYWxzZSwgaXNfaWU3ID0gZmFsc2UsIGlzX2ZmMiA9IGZhbHNlO1xuXG4vKiBcbiAqIGpzVHJlZSBjb3JlXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQvLyBDb21tb24gZnVuY3Rpb25zIG5vdCByZWxhdGVkIHRvIGpzVHJlZSBcblx0Ly8gZGVjaWRlZCB0byBtb3ZlIHRoZW0gdG8gYSBgdmFrYXRhYCBcIm5hbWVzcGFjZVwiXG5cdCQudmFrYXRhID0ge307XG5cdC8vIENTUyByZWxhdGVkIGZ1bmN0aW9uc1xuXHQkLnZha2F0YS5jc3MgPSB7XG5cdFx0Z2V0X2NzcyA6IGZ1bmN0aW9uKHJ1bGVfbmFtZSwgZGVsZXRlX2ZsYWcsIHNoZWV0KSB7XG5cdFx0XHRydWxlX25hbWUgPSBydWxlX25hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciBjc3NfcnVsZXMgPSBzaGVldC5jc3NSdWxlcyB8fCBzaGVldC5ydWxlcyxcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmKGNzc19ydWxlcy5sZW5ndGggJiYgaiA+IGNzc19ydWxlcy5sZW5ndGggKyA1KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZihjc3NfcnVsZXNbal0uc2VsZWN0b3JUZXh0ICYmIGNzc19ydWxlc1tqXS5zZWxlY3RvclRleHQudG9Mb3dlckNhc2UoKSA9PSBydWxlX25hbWUpIHtcblx0XHRcdFx0XHRpZihkZWxldGVfZmxhZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0aWYoc2hlZXQucmVtb3ZlUnVsZSkgeyBzaGVldC5yZW1vdmVSdWxlKGopOyB9XG5cdFx0XHRcdFx0XHRpZihzaGVldC5kZWxldGVSdWxlKSB7IHNoZWV0LmRlbGV0ZVJ1bGUoaik7IH1cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgcmV0dXJuIGNzc19ydWxlc1tqXTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoY3NzX3J1bGVzWysral0pO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YWRkX2NzcyA6IGZ1bmN0aW9uKHJ1bGVfbmFtZSwgc2hlZXQpIHtcblx0XHRcdGlmKCQuanN0cmVlLmNzcy5nZXRfY3NzKHJ1bGVfbmFtZSwgZmFsc2UsIHNoZWV0KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKHNoZWV0Lmluc2VydFJ1bGUpIHsgc2hlZXQuaW5zZXJ0UnVsZShydWxlX25hbWUgKyAnIHsgfScsIDApOyB9IGVsc2UgeyBzaGVldC5hZGRSdWxlKHJ1bGVfbmFtZSwgbnVsbCwgMCk7IH1cblx0XHRcdHJldHVybiAkLnZha2F0YS5jc3MuZ2V0X2NzcyhydWxlX25hbWUpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlX2NzcyA6IGZ1bmN0aW9uKHJ1bGVfbmFtZSwgc2hlZXQpIHsgXG5cdFx0XHRyZXR1cm4gJC52YWthdGEuY3NzLmdldF9jc3MocnVsZV9uYW1lLCB0cnVlLCBzaGVldCk7IFxuXHRcdH0sXG5cdFx0YWRkX3NoZWV0IDogZnVuY3Rpb24ob3B0cykge1xuXHRcdCAgLy8gTU9ESUZJRUQgaXNjaG9tbWVyL1NpbHZlclN0cmlwZTogYWRkX3NoZWV0IHNpZ25pZmljYW50bHkgc2xvd3MgZG93biByZW5kZXJpbmcsXG5cdFx0ICAvLyB3ZSdyZSBsb2FkaW5nIGFsbCByZXF1aXJlZCBDU1MgZGlyZWN0bHkgcmF0aGVyIHRoYW4gYWRkaW5nIGl0IGlubGluZVxuXHRcdCAgXG4gICAgICAvLyB2YXIgdG1wID0gZmFsc2UsIGlzX25ldyA9IHRydWU7XG4gICAgICAvLyBpZihvcHRzLnN0cikge1xuICAgICAgLy8gIGlmKG9wdHMudGl0bGUpIHsgdG1wID0gJChcInN0eWxlW2lkPSdcIiArIG9wdHMudGl0bGUgKyBcIi1zdHlsZXNoZWV0J11cIilbMF07IH1cbiAgICAgIC8vICBpZih0bXApIHsgaXNfbmV3ID0gZmFsc2U7IH1cbiAgICAgIC8vICBlbHNlIHtcbiAgICAgIC8vICAgIHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIC8vICAgIHRtcC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLFwidGV4dC9jc3NcIik7XG4gICAgICAvLyAgICBpZihvcHRzLnRpdGxlKSB7IHRtcC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvcHRzLnRpdGxlICsgXCItc3R5bGVzaGVldFwiKTsgfVxuICAgICAgLy8gIH1cbiAgICAgIC8vICBpZih0bXAuc3R5bGVTaGVldCkge1xuICAgICAgLy8gICAgaWYoaXNfbmV3KSB7IFxuICAgICAgLy8gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQodG1wKTsgXG4gICAgICAvLyAgICAgIHRtcC5zdHlsZVNoZWV0LmNzc1RleHQgPSBvcHRzLnN0cjsgXG4gICAgICAvLyAgICB9XG4gICAgICAvLyAgICBlbHNlIHtcbiAgICAgIC8vICAgICAgdG1wLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRtcC5zdHlsZVNoZWV0LmNzc1RleHQgKyBcIiBcIiArIG9wdHMuc3RyOyBcbiAgICAgIC8vICAgIH1cbiAgICAgIC8vICB9XG4gICAgICAvLyAgZWxzZSB7XG4gICAgICAvLyAgICB0bXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUob3B0cy5zdHIpKTtcbiAgICAgIC8vICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgLy8gIH1cbiAgICAgIC8vICByZXR1cm4gdG1wLnNoZWV0IHx8IHRtcC5zdHlsZVNoZWV0O1xuICAgICAgLy8gfVxuICAgICAgLy8gaWYob3B0cy51cmwpIHtcbiAgICAgIC8vICBpZihkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KSB7XG4gICAgICAvLyAgICB0cnkgeyB0bXAgPSBkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KG9wdHMudXJsKTsgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAvLyAgfVxuICAgICAgLy8gIGVsc2Uge1xuICAgICAgLy8gICAgdG1wICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgIC8vICAgIHRtcC5yZWwgICA9ICdzdHlsZXNoZWV0JztcbiAgICAgIC8vICAgIHRtcC50eXBlICA9ICd0ZXh0L2Nzcyc7XG4gICAgICAvLyAgICB0bXAubWVkaWEgPSBcImFsbFwiO1xuICAgICAgLy8gICAgdG1wLmhyZWYgID0gb3B0cy51cmw7XG4gICAgICAvLyAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgIC8vICAgIHJldHVybiB0bXAuc3R5bGVTaGVldDtcbiAgICAgIC8vICB9XG4gICAgICAvLyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIHByaXZhdGUgdmFyaWFibGVzIFxuXHR2YXIgaW5zdGFuY2VzID0gW10sXHRcdFx0Ly8gaW5zdGFuY2UgYXJyYXkgKHVzZWQgYnkgJC5qc3RyZWUucmVmZXJlbmNlL2NyZWF0ZS9mb2N1c2VkKVxuXHRcdGZvY3VzZWRfaW5zdGFuY2UgPSAtMSxcdC8vIHRoZSBpbmRleCBpbiB0aGUgaW5zdGFuY2UgYXJyYXkgb2YgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGluc3RhbmNlXG5cdFx0cGx1Z2lucyA9IHt9LFx0XHRcdC8vIGxpc3Qgb2YgaW5jbHVkZWQgcGx1Z2luc1xuXHRcdHByZXBhcmVkX21vdmUgPSB7fTtcdFx0Ly8gZm9yIHRoZSBtb3ZlX25vZGUgZnVuY3Rpb25cblxuXHQvLyBqUXVlcnkgcGx1Z2luIHdyYXBwZXIgKHRoYW5rcyB0byBqcXVlcnkgVUkgd2lkZ2V0IGZ1bmN0aW9uKVxuXHQkLmZuLmpzdHJlZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSAodHlwZW9mIHNldHRpbmdzID09ICdzdHJpbmcnKSwgLy8gaXMgdGhpcyBhIG1ldGhvZCBjYWxsIGxpa2UgJCgpLmpzdHJlZShcIm9wZW5fbm9kZVwiKVxuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gaWYgYSBtZXRob2QgY2FsbCBleGVjdXRlIHRoZSBtZXRob2Qgb24gYWxsIHNlbGVjdGVkIGluc3RhbmNlc1xuXHRcdGlmKGlzTWV0aG9kQ2FsbCkge1xuXHRcdFx0aWYoc2V0dGluZ3Muc3Vic3RyaW5nKDAsIDEpID09ICdfJykgeyByZXR1cm4gcmV0dXJuVmFsdWU7IH1cblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VzWyQuZGF0YSh0aGlzLCBcImpzdHJlZV9pbnN0YW5jZV9pZFwiKV0sXG5cdFx0XHRcdFx0bWV0aG9kVmFsdWUgPSAoaW5zdGFuY2UgJiYgJC5pc0Z1bmN0aW9uKGluc3RhbmNlW3NldHRpbmdzXSkpID8gaW5zdGFuY2Vbc2V0dGluZ3NdLmFwcGx5KGluc3RhbmNlLCBhcmdzKSA6IGluc3RhbmNlO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBtZXRob2RWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoc2V0dGluZ3MuaW5kZXhPZihcImlzX1wiKSA9PT0gMCB8fCAobWV0aG9kVmFsdWUgIT09IHRydWUgJiYgbWV0aG9kVmFsdWUgIT09IGZhbHNlKSkpIHsgcmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZTsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGV4dGVuZCBzZXR0aW5ncyBhbmQgYWxsb3cgZm9yIG11bHRpcGxlIGhhc2hlcyBhbmQgJC5kYXRhXG5cdFx0XHRcdHZhciBpbnN0YW5jZV9pZCA9ICQuZGF0YSh0aGlzLCBcImpzdHJlZV9pbnN0YW5jZV9pZFwiKSxcblx0XHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdFx0YiA9IHNldHRpbmdzID8gJC5leHRlbmQoe30sIHRydWUsIHNldHRpbmdzKSA6IHt9LFxuXHRcdFx0XHRcdGMgPSAkKHRoaXMpLCBcblx0XHRcdFx0XHRzID0gZmFsc2UsIFxuXHRcdFx0XHRcdHQgPSBbXTtcblx0XHRcdFx0YSA9IGEuY29uY2F0KGFyZ3MpO1xuXHRcdFx0XHRpZihjLmRhdGEoXCJqc3RyZWVcIikpIHsgYS5wdXNoKGMuZGF0YShcImpzdHJlZVwiKSk7IH1cblx0XHRcdFx0YiA9IGEubGVuZ3RoID8gJC5leHRlbmQuYXBwbHkobnVsbCwgW3RydWUsIGJdLmNvbmNhdChhKSkgOiBiO1xuXG5cdFx0XHRcdC8vIGlmIGFuIGluc3RhbmNlIGFscmVhZHkgZXhpc3RzLCBkZXN0cm95IGl0IGZpcnN0XG5cdFx0XHRcdGlmKHR5cGVvZiBpbnN0YW5jZV9pZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnN0YW5jZXNbaW5zdGFuY2VfaWRdKSB7IGluc3RhbmNlc1tpbnN0YW5jZV9pZF0uZGVzdHJveSgpOyB9XG5cdFx0XHRcdC8vIHB1c2ggYSBuZXcgZW1wdHkgb2JqZWN0IHRvIHRoZSBpbnN0YW5jZXMgYXJyYXlcblx0XHRcdFx0aW5zdGFuY2VfaWQgPSBwYXJzZUludChpbnN0YW5jZXMucHVzaCh7fSksMTApIC0gMTtcblx0XHRcdFx0Ly8gc3RvcmUgdGhlIGpzdHJlZSBpbnN0YW5jZSBpZCB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcblx0XHRcdFx0JC5kYXRhKHRoaXMsIFwianN0cmVlX2luc3RhbmNlX2lkXCIsIGluc3RhbmNlX2lkKTtcblx0XHRcdFx0Ly8gY2xlYW4gdXAgYWxsIHBsdWdpbnNcblx0XHRcdFx0Yi5wbHVnaW5zID0gJC5pc0FycmF5KGIucGx1Z2lucykgPyBiLnBsdWdpbnMgOiAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnNsaWNlKCk7XG5cdFx0XHRcdGIucGx1Z2lucy51bnNoaWZ0KFwiY29yZVwiKTtcblx0XHRcdFx0Ly8gb25seSB1bmlxdWUgcGx1Z2luc1xuXHRcdFx0XHRiLnBsdWdpbnMgPSBiLnBsdWdpbnMuc29ydCgpLmpvaW4oXCIsLFwiKS5yZXBsYWNlKC8oLHxeKShbXixdKykoLCxcXDIpKygsfCQpL2csXCIkMSQyJDRcIikucmVwbGFjZSgvLCwrL2csXCIsXCIpLnJlcGxhY2UoLywkLyxcIlwiKS5zcGxpdChcIixcIik7XG5cblx0XHRcdFx0Ly8gZXh0ZW5kIGRlZmF1bHRzIHdpdGggcGFzc2VkIGRhdGFcblx0XHRcdFx0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkLmpzdHJlZS5kZWZhdWx0cywgYik7XG5cdFx0XHRcdHMucGx1Z2lucyA9IGIucGx1Z2lucztcblx0XHRcdFx0JC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uIChpLCB2YWwpIHsgXG5cdFx0XHRcdFx0aWYoJC5pbkFycmF5KGksIHMucGx1Z2lucykgPT09IC0xKSB7IHNbaV0gPSBudWxsOyBkZWxldGUgc1tpXTsgfSBcblx0XHRcdFx0XHRlbHNlIHsgdC5wdXNoKGkpOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzLnBsdWdpbnMgPSB0O1xuXG5cdFx0XHRcdC8vIHB1c2ggdGhlIG5ldyBvYmplY3QgdG8gdGhlIGluc3RhbmNlcyBhcnJheSAoYXQgdGhlIHNhbWUgdGltZSBzZXQgdGhlIGRlZmF1bHQgY2xhc3NlcyB0byB0aGUgY29udGFpbmVyKSBhbmQgaW5pdFxuXHRcdFx0XHRpbnN0YW5jZXNbaW5zdGFuY2VfaWRdID0gbmV3ICQuanN0cmVlLl9pbnN0YW5jZShpbnN0YW5jZV9pZCwgJCh0aGlzKS5hZGRDbGFzcyhcImpzdHJlZSBqc3RyZWUtXCIgKyBpbnN0YW5jZV9pZCksIHMpOyBcblx0XHRcdFx0Ly8gaW5pdCBhbGwgYWN0aXZhdGVkIHBsdWdpbnMgZm9yIHRoaXMgaW5zdGFuY2Vcblx0XHRcdFx0JC5lYWNoKGluc3RhbmNlc1tpbnN0YW5jZV9pZF0uX2dldF9zZXR0aW5ncygpLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCB2YWwpIHsgaW5zdGFuY2VzW2luc3RhbmNlX2lkXS5kYXRhW3ZhbF0gPSB7fTsgfSk7XG5cdFx0XHRcdCQuZWFjaChpbnN0YW5jZXNbaW5zdGFuY2VfaWRdLl9nZXRfc2V0dGluZ3MoKS5wbHVnaW5zLCBmdW5jdGlvbiAoaSwgdmFsKSB7IGlmKHBsdWdpbnNbdmFsXSkgeyBwbHVnaW5zW3ZhbF0uX19pbml0LmFwcGx5KGluc3RhbmNlc1tpbnN0YW5jZV9pZF0pOyB9IH0pO1xuXHRcdFx0XHQvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZVxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBpZihpbnN0YW5jZXNbaW5zdGFuY2VfaWRdKSB7IGluc3RhbmNlc1tpbnN0YW5jZV9pZF0uaW5pdCgpOyB9IH0sIDApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIHJldHVybiB0aGUganF1ZXJ5IHNlbGVjdGlvbiAob3IgaWYgaXQgd2FzIGEgbWV0aG9kIGNhbGwgdGhhdCByZXR1cm5lZCBhIHZhbHVlIC0gdGhlIHJldHVybmVkIHZhbHVlKVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblx0Ly8gb2JqZWN0IHRvIHN0b3JlIGV4cG9zZWQgZnVuY3Rpb25zIGFuZCBvYmplY3RzXG5cdCQuanN0cmVlID0ge1xuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0cGx1Z2lucyA6IFtdXG5cdFx0fSxcblx0XHRfZm9jdXNlZCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlc1tmb2N1c2VkX2luc3RhbmNlXSB8fCBudWxsOyB9LFxuXHRcdF9yZWZlcmVuY2UgOiBmdW5jdGlvbiAobmVlZGxlKSB7IFxuXHRcdFx0Ly8gZ2V0IGJ5IGluc3RhbmNlIGlkXG5cdFx0XHRpZihpbnN0YW5jZXNbbmVlZGxlXSkgeyByZXR1cm4gaW5zdGFuY2VzW25lZWRsZV07IH1cblx0XHRcdC8vIGdldCBieSBET00gKGlmIHN0aWxsIG5vIGx1Y2sgLSByZXR1cm4gbnVsbFxuXHRcdFx0dmFyIG8gPSAkKG5lZWRsZSk7IFxuXHRcdFx0aWYoIW8ubGVuZ3RoICYmIHR5cGVvZiBuZWVkbGUgPT09IFwic3RyaW5nXCIpIHsgbyA9ICQoXCIjXCIgKyBuZWVkbGUpOyB9XG5cdFx0XHRpZighby5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRcdHJldHVybiBpbnN0YW5jZXNbby5jbG9zZXN0KFwiLmpzdHJlZVwiKS5kYXRhKFwianN0cmVlX2luc3RhbmNlX2lkXCIpXSB8fCBudWxsOyBcblx0XHR9LFxuXHRcdF9pbnN0YW5jZSA6IGZ1bmN0aW9uIChpbmRleCwgY29udGFpbmVyLCBzZXR0aW5ncykgeyBcblx0XHRcdC8vIGZvciBwbHVnaW5zIHRvIHN0b3JlIGRhdGEgaW5cblx0XHRcdHRoaXMuZGF0YSA9IHsgY29yZSA6IHt9IH07XG5cdFx0XHR0aGlzLmdldF9zZXR0aW5nc1x0PSBmdW5jdGlvbiAoKSB7IHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgc2V0dGluZ3MpOyB9O1xuXHRcdFx0dGhpcy5fZ2V0X3NldHRpbmdzXHQ9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldHRpbmdzOyB9O1xuXHRcdFx0dGhpcy5nZXRfaW5kZXhcdFx0PSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleDsgfTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lclx0PSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250YWluZXI7IH07XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250YWluZXIuY2hpbGRyZW4oXCJ1bDplcSgwKVwiKTsgfTtcblx0XHRcdHRoaXMuX3NldF9zZXR0aW5nc1x0PSBmdW5jdGlvbiAocykgeyBcblx0XHRcdFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgc2V0dGluZ3MsIHMpO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdF9mbiA6IHsgfSxcblx0XHRwbHVnaW4gOiBmdW5jdGlvbiAocG5hbWUsIHBkYXRhKSB7XG5cdFx0XHRwZGF0YSA9ICQuZXh0ZW5kKHt9LCB7XG5cdFx0XHRcdF9faW5pdFx0XHQ6ICQubm9vcCwgXG5cdFx0XHRcdF9fZGVzdHJveVx0OiAkLm5vb3AsXG5cdFx0XHRcdF9mblx0XHRcdDoge30sXG5cdFx0XHRcdGRlZmF1bHRzXHQ6IGZhbHNlXG5cdFx0XHR9LCBwZGF0YSk7XG5cdFx0XHRwbHVnaW5zW3BuYW1lXSA9IHBkYXRhO1xuXG5cdFx0XHQkLmpzdHJlZS5kZWZhdWx0c1twbmFtZV0gPSBwZGF0YS5kZWZhdWx0cztcblx0XHRcdCQuZWFjaChwZGF0YS5fZm4sIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0dmFsLnBsdWdpblx0XHQ9IHBuYW1lO1xuXHRcdFx0XHR2YWwub2xkXHRcdFx0PSAkLmpzdHJlZS5fZm5baV07XG5cdFx0XHRcdCQuanN0cmVlLl9mbltpXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgcnNsdCxcblx0XHRcdFx0XHRcdGZ1bmMgPSB2YWwsXG5cdFx0XHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRcdGV2bnQgPSBuZXcgJC5FdmVudChcImJlZm9yZS5qc3RyZWVcIiksXG5cdFx0XHRcdFx0XHRybGJrID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZih0aGlzLmRhdGEuY29yZS5sb2NrZWQgPT09IHRydWUgJiYgaSAhPT0gXCJ1bmxvY2tcIiAmJiBpICE9PSBcImlzX2xvY2tlZFwiKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgZnVuY3Rpb24gYmVsb25ncyB0byB0aGUgaW5jbHVkZWQgcGx1Z2lucyBvZiB0aGlzIGluc3RhbmNlXG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0aWYoZnVuYyAmJiBmdW5jLnBsdWdpbiAmJiAkLmluQXJyYXkoZnVuYy5wbHVnaW4sIHRoaXMuX2dldF9zZXR0aW5ncygpLnBsdWdpbnMpICE9PSAtMSkgeyBicmVhazsgfVxuXHRcdFx0XHRcdFx0ZnVuYyA9IGZ1bmMub2xkO1xuXHRcdFx0XHRcdH0gd2hpbGUoZnVuYyk7XG5cdFx0XHRcdFx0aWYoIWZ1bmMpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0XHQvLyBjb250ZXh0IGFuZCBmdW5jdGlvbiB0byB0cmlnZ2VyIGV2ZW50cywgdGhlbiBmaW5hbGx5IGNhbGwgdGhlIGZ1bmN0aW9uXG5cdFx0XHRcdFx0aWYoaS5pbmRleE9mKFwiX1wiKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cnNsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cnNsdCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLnRyaWdnZXJIYW5kbGVyKGV2bnQsIHsgXCJmdW5jXCIgOiBpLCBcImluc3RcIiA6IHRoaXMsIFwiYXJnc1wiIDogYXJncywgXCJwbHVnaW5cIiA6IGZ1bmMucGx1Z2luIH0pO1xuXHRcdFx0XHRcdFx0aWYocnNsdCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgcnNsdCAhPT0gXCJ1bmRlZmluZWRcIikgeyBhcmdzID0gcnNsdDsgfVxuXG5cdFx0XHRcdFx0XHRyc2x0ID0gZnVuYy5hcHBseShcblx0XHRcdFx0XHRcdFx0JC5leHRlbmQoe30sIHRoaXMsIHsgXG5cdFx0XHRcdFx0XHRcdFx0X19jYWxsYmFjayA6IGZ1bmN0aW9uIChkYXRhKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkudHJpZ2dlckhhbmRsZXIoIGkgKyAnLmpzdHJlZScsIHsgXCJpbnN0XCIgOiB0aGlzLCBcImFyZ3NcIiA6IGFyZ3MsIFwicnNsdFwiIDogZGF0YSwgXCJybGJrXCIgOiBybGJrIH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0X19yb2xsYmFjayA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRybGJrID0gdGhpcy5nZXRfcm9sbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBybGJrO1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0X19jYWxsX29sZCA6IGZ1bmN0aW9uIChyZXBsYWNlX2FyZ3VtZW50cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmMub2xkLmFwcGx5KHRoaXMsIChyZXBsYWNlX2FyZ3VtZW50cyA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBhcmdzICkgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pLCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyByZXR1cm4gdGhlIHJlc3VsdFxuXHRcdFx0XHRcdHJldHVybiByc2x0O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQkLmpzdHJlZS5fZm5baV0ub2xkID0gdmFsLm9sZDtcblx0XHRcdFx0JC5qc3RyZWUuX2ZuW2ldLnBsdWdpbiA9IHBuYW1lO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRyb2xsYmFjayA6IGZ1bmN0aW9uIChyYikge1xuXHRcdFx0aWYocmIpIHtcblx0XHRcdFx0aWYoISQuaXNBcnJheShyYikpIHsgcmIgPSBbIHJiIF07IH1cblx0XHRcdFx0JC5lYWNoKHJiLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2VzW3ZhbC5pXS5zZXRfcm9sbGJhY2sodmFsLmgsIHZhbC5kKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvLyBzZXQgdGhlIHByb3RvdHlwZSBmb3IgYWxsIGluc3RhbmNlc1xuXHQkLmpzdHJlZS5fZm4gPSAkLmpzdHJlZS5faW5zdGFuY2UucHJvdG90eXBlID0ge307XG5cblx0Ly8gbG9hZCB0aGUgY3NzIHdoZW4gRE9NIGlzIHJlYWR5XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gY29kZSBpcyBjb3BpZWQgZnJvbSBqUXVlcnkgKCQuYnJvd3NlciBpcyBkZXByZWNhdGVkICsgdGhlcmUgaXMgYSBidWcgaW4gSUUpXG5cdFx0dmFyIHUgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHR2ID0gKHUubWF0Y2goIC8uKz8oPzpydnxpdHxyYXxpZSlbXFwvOiBdKFtcXGQuXSspLyApIHx8IFswLCcwJ10pWzFdLFxuXHRcdFx0Y3NzX3N0cmluZyA9ICcnICsgXG5cdFx0XHRcdCcuanN0cmVlIHVsLCAuanN0cmVlIGxpIHsgZGlzcGxheTpibG9jazsgbWFyZ2luOjAgMCAwIDA7IHBhZGRpbmc6MCAwIDAgMDsgbGlzdC1zdHlsZS10eXBlOm5vbmU7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBsaSB7IGRpc3BsYXk6YmxvY2s7IG1pbi1oZWlnaHQ6MThweDsgbGluZS1oZWlnaHQ6MThweDsgd2hpdGUtc3BhY2U6bm93cmFwOyBtYXJnaW4tbGVmdDoxOHB4OyBtaW4td2lkdGg6MThweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlLXJ0bCBsaSB7IG1hcmdpbi1sZWZ0OjA7IG1hcmdpbi1yaWdodDoxOHB4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgPiB1bCA+IGxpIHsgbWFyZ2luLWxlZnQ6MHB4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUtcnRsID4gdWwgPiBsaSB7IG1hcmdpbi1yaWdodDowcHg7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBpbnMgeyBkaXNwbGF5OmlubGluZS1ibG9jazsgdGV4dC1kZWNvcmF0aW9uOm5vbmU7IHdpZHRoOjE4cHg7IGhlaWdodDoxOHB4OyBtYXJnaW46MCAwIDAgMDsgcGFkZGluZzowOyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgYSB7IGRpc3BsYXk6aW5saW5lLWJsb2NrOyBsaW5lLWhlaWdodDoxNnB4OyBoZWlnaHQ6MTZweDsgY29sb3I6YmxhY2s7IHdoaXRlLXNwYWNlOm5vd3JhcDsgdGV4dC1kZWNvcmF0aW9uOm5vbmU7IHBhZGRpbmc6MXB4IDJweDsgbWFyZ2luOjA7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBhOmZvY3VzIHsgb3V0bGluZTogbm9uZTsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIGEgPiBpbnMgeyBoZWlnaHQ6MTZweDsgd2lkdGg6MTZweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIGEgPiAuanN0cmVlLWljb24geyBtYXJnaW4tcmlnaHQ6M3B4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUtcnRsIGEgPiAuanN0cmVlLWljb24geyBtYXJnaW4tbGVmdDozcHg7IG1hcmdpbi1yaWdodDowOyB9ICcgKyBcblx0XHRcdFx0J2xpLmpzdHJlZS1vcGVuID4gdWwgeyBkaXNwbGF5OmJsb2NrOyB9ICcgKyBcblx0XHRcdFx0J2xpLmpzdHJlZS1jbG9zZWQgPiB1bCB7IGRpc3BsYXk6bm9uZTsgfSAnO1xuXHRcdC8vIENvcnJlY3QgSUUgNiAoZG9lcyBub3Qgc3VwcG9ydCB0aGUgPiBDU1Mgc2VsZWN0b3IpXG5cdFx0aWYoL21zaWUvLnRlc3QodSkgJiYgcGFyc2VJbnQodiwgMTApID09IDYpIHsgXG5cdFx0XHRpc19pZTYgPSB0cnVlO1xuXG5cdFx0XHQvLyBmaXggaW1hZ2UgZmxpY2tlciBhbmQgbGFjayBvZiBjYWNoaW5nXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb2N1bWVudC5leGVjQ29tbWFuZChcIkJhY2tncm91bmRJbWFnZUNhY2hlXCIsIGZhbHNlLCB0cnVlKTtcblx0XHRcdH0gY2F0Y2ggKGVycikgeyB9XG5cblx0XHRcdGNzc19zdHJpbmcgKz0gJycgKyBcblx0XHRcdFx0Jy5qc3RyZWUgbGkgeyBoZWlnaHQ6MThweDsgbWFyZ2luLWxlZnQ6MDsgbWFyZ2luLXJpZ2h0OjA7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBsaSBsaSB7IG1hcmdpbi1sZWZ0OjE4cHg7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZS1ydGwgbGkgbGkgeyBtYXJnaW4tbGVmdDowcHg7IG1hcmdpbi1yaWdodDoxOHB4OyB9ICcgKyBcblx0XHRcdFx0J2xpLmpzdHJlZS1vcGVuIHVsIHsgZGlzcGxheTpibG9jazsgfSAnICsgXG5cdFx0XHRcdCdsaS5qc3RyZWUtY2xvc2VkIHVsIHsgZGlzcGxheTpub25lICFpbXBvcnRhbnQ7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBsaSBhIHsgZGlzcGxheTppbmxpbmU7IGJvcmRlci13aWR0aDowICFpbXBvcnRhbnQ7IHBhZGRpbmc6MHB4IDJweCAhaW1wb3J0YW50OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgbGkgYSBpbnMgeyBoZWlnaHQ6MTZweDsgd2lkdGg6MTZweDsgbWFyZ2luLXJpZ2h0OjNweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlLXJ0bCBsaSBhIGlucyB7IG1hcmdpbi1yaWdodDowcHg7IG1hcmdpbi1sZWZ0OjNweDsgfSAnO1xuXHRcdH1cblx0XHQvLyBDb3JyZWN0IElFIDcgKHNoaWZ0cyBhbmNob3Igbm9kZXMgb25ob3Zlcilcblx0XHRpZigvbXNpZS8udGVzdCh1KSAmJiBwYXJzZUludCh2LCAxMCkgPT0gNykgeyBcblx0XHRcdGlzX2llNyA9IHRydWU7XG5cdFx0XHRjc3Nfc3RyaW5nICs9ICcuanN0cmVlIGxpIGEgeyBib3JkZXItd2lkdGg6MCAhaW1wb3J0YW50OyBwYWRkaW5nOjBweCAycHggIWltcG9ydGFudDsgfSAnO1xuXHRcdH1cblx0XHQvLyBjb3JyZWN0IGZmMiBsYWNrIG9mIGRpc3BsYXk6aW5saW5lLWJsb2NrXG5cdFx0aWYoIS9jb21wYXRpYmxlLy50ZXN0KHUpICYmIC9tb3ppbGxhLy50ZXN0KHUpICYmIHBhcnNlRmxvYXQodiwgMTApIDwgMS45KSB7XG5cdFx0XHRpc19mZjIgPSB0cnVlO1xuXHRcdFx0Y3NzX3N0cmluZyArPSAnJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBpbnMgeyBkaXNwbGF5Oi1tb3otaW5saW5lLWJveDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIGxpIHsgbGluZS1oZWlnaHQ6MTJweDsgfSAnICsgLy8gV0hZPz9cblx0XHRcdFx0Jy5qc3RyZWUgYSB7IGRpc3BsYXk6LW1vei1pbmxpbmUtYm94OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS1uby1pY29ucyAuanN0cmVlLWNoZWNrYm94IHsgZGlzcGxheTotbW96LWlubGluZS1zdGFjayAhaW1wb3J0YW50OyB9ICc7XG5cdFx0XHRcdC8qIHRoaXMgc2hvdWxkbid0IGJlIGhlcmUgYXMgaXQgaXMgdGhlbWUgc3BlY2lmaWMgKi9cblx0XHR9XG5cdFx0Ly8gdGhlIGRlZmF1bHQgc3R5bGVzaGVldFxuXHRcdCQudmFrYXRhLmNzcy5hZGRfc2hlZXQoeyBzdHIgOiBjc3Nfc3RyaW5nLCB0aXRsZSA6IFwianN0cmVlXCIgfSk7XG5cdH0pO1xuXG5cdC8vIGNvcmUgZnVuY3Rpb25zIChvcGVuLCBjbG9zZSwgY3JlYXRlLCB1cGRhdGUsIGRlbGV0ZSlcblx0JC5qc3RyZWUucGx1Z2luKFwiY29yZVwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5kYXRhLmNvcmUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRhdGEuY29yZS50b19vcGVuID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5jb3JlLmluaXRpYWxseV9vcGVuO1xuXHRcdFx0dGhpcy5kYXRhLmNvcmUudG9fbG9hZCA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuY29yZS5pbml0aWFsbHlfbG9hZDtcblx0XHR9LFxuXHRcdGRlZmF1bHRzIDogeyBcblx0XHRcdGh0bWxfdGl0bGVzXHQ6IGZhbHNlLFxuXHRcdFx0YW5pbWF0aW9uXHQ6IDUwMCxcblx0XHRcdGluaXRpYWxseV9vcGVuIDogW10sXG5cdFx0XHRpbml0aWFsbHlfbG9hZCA6IFtdLFxuXHRcdFx0b3Blbl9wYXJlbnRzIDogdHJ1ZSxcblx0XHRcdG5vdGlmeV9wbHVnaW5zIDogdHJ1ZSxcblx0XHRcdHJ0bFx0XHRcdDogZmFsc2UsXG5cdFx0XHRsb2FkX29wZW5cdDogZmFsc2UsXG5cdFx0XHRzdHJpbmdzXHRcdDoge1xuXHRcdFx0XHRsb2FkaW5nXHRcdDogXCJMb2FkaW5nIC4uLlwiLFxuXHRcdFx0XHRuZXdfbm9kZVx0OiBcIk5ldyBub2RlXCIsXG5cdFx0XHRcdG11bHRpcGxlX3NlbGVjdGlvbiA6IFwiTXVsdGlwbGUgc2VsZWN0aW9uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9mbiA6IHsgXG5cdFx0XHRpbml0XHQ6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHRoaXMuc2V0X2ZvY3VzKCk7IFxuXHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLnJ0bCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmFkZENsYXNzKFwianN0cmVlLXJ0bFwiKS5jc3MoXCJkaXJlY3Rpb25cIiwgXCJydGxcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuaHRtbChcIjx1bD48bGkgY2xhc3M9J2pzdHJlZS1sYXN0IGpzdHJlZS1sZWFmJz48aW5zPiYjMTYwOzwvaW5zPjxhIGNsYXNzPSdqc3RyZWUtbG9hZGluZycgaHJlZj0nIyc+PGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiICsgdGhpcy5fZ2V0X3N0cmluZyhcImxvYWRpbmdcIikgKyBcIjwvYT48L2xpPjwvdWw+XCIpO1xuXHRcdFx0XHR0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKFwibGkuanN0cmVlLWNsb3NlZCwgbGkuanN0cmVlLWxlYWZcIikuZXEoMCkuaGVpZ2h0KCkgfHwgMTg7XG5cblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHQuZGVsZWdhdGUoXCJsaSA+IGluc1wiLCBcImNsaWNrLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJndCA9ICQoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0Ly8gaWYodHJndC5pcyhcImluc1wiKSAmJiBldmVudC5wYWdlWSAtIHRyZ3Qub2Zmc2V0KCkudG9wIDwgdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0KSB7IHRoaXMudG9nZ2xlX25vZGUodHJndCk7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZSh0cmd0KTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5iaW5kKFwibW91c2Vkb3duLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0X2ZvY3VzKCk7IC8vIFRoaXMgdXNlZCB0byBiZSBzZXRUaW1lb3V0KHNldF9mb2N1cywwKSAtIHdoeT9cblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5iaW5kKFwiZGJsY2xpY2suanN0cmVlXCIsIGZ1bmN0aW9uIChldmVudCkgeyBcblx0XHRcdFx0XHRcdHZhciBzZWw7XG5cdFx0XHRcdFx0XHRpZihkb2N1bWVudC5zZWxlY3Rpb24gJiYgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KSB7IGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYod2luZG93LmdldFNlbGVjdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdFx0XHR0cnkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbC5jb2xsYXBzZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikgeyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5ub3RpZnlfcGx1Z2lucykge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0XHQuYmluZChcImxvYWRfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdFx0XHR2YXIgbyA9IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopLFxuXHRcdFx0XHRcdFx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyA9PT0gLTEpIHsgbyA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRcdG8uZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRoID0gJCh0aGlzKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRoLmRhdGEoXCJqc3RyZWVcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKHRoLmRhdGEoXCJqc3RyZWVcIiksIGZ1bmN0aW9uIChwbHVnaW4sIHZhbHVlcykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHQuZGF0YVtwbHVnaW5dICYmICQuaXNGdW5jdGlvbih0W1wiX1wiICsgcGx1Z2luICsgXCJfbm90aWZ5XCJdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dFtcIl9cIiArIHBsdWdpbiArIFwiX25vdGlmeVwiXS5jYWxsKHQsIHRoLCB2YWx1ZXMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmxvYWRfb3Blbikge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0XHQuYmluZChcImxvYWRfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdFx0XHR2YXIgbyA9IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopLFxuXHRcdFx0XHRcdFx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyA9PT0gLTEpIHsgbyA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRcdG8uZmluZChcImxpLmpzdHJlZS1vcGVuOm5vdCg6aGFzKHVsKSlcIikuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0LmxvYWRfbm9kZSh0aGlzLCAkLm5vb3AsICQubm9vcCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdFx0dGhpcy5sb2FkX25vZGUoLTEsIGZ1bmN0aW9uICgpIHsgdGhpcy5sb2FkZWQoKTsgdGhpcy5yZWxvYWRfbm9kZXMoKTsgfSk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVzdHJveVx0OiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHRuID0gdGhpcy5nZXRfaW5kZXgoKSxcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCksXG5cdFx0XHRcdFx0X3RoaXMgPSB0aGlzO1xuXG5cdFx0XHRcdCQuZWFjaChzLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHR0cnkgeyBwbHVnaW5zW3ZhbF0uX19kZXN0cm95LmFwcGx5KF90aGlzKTsgfSBjYXRjaChlcnIpIHsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHRcdC8vIHNldCBmb2N1cyB0byBhbm90aGVyIGluc3RhbmNlIGlmIHRoaXMgb25lIGlzIGZvY3VzZWRcblx0XHRcdFx0aWYodGhpcy5pc19mb2N1c2VkKCkpIHsgXG5cdFx0XHRcdFx0Zm9yKGkgaW4gaW5zdGFuY2VzKSB7IFxuXHRcdFx0XHRcdFx0aWYoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGkpICYmIGkgIT0gbikgeyBcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldF9mb2N1cygpOyBcblx0XHRcdFx0XHRcdFx0YnJlYWs7IFxuXHRcdFx0XHRcdFx0fSBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgbm8gb3RoZXIgaW5zdGFuY2UgZm91bmRcblx0XHRcdFx0aWYobiA9PT0gZm9jdXNlZF9pbnN0YW5jZSkgeyBmb2N1c2VkX2luc3RhbmNlID0gLTE7IH1cblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCB0cmFjZXMgb2YganN0cmVlIGluIHRoZSBET00gKG9ubHkgdGhlIG9uZXMgc2V0IHVzaW5nIGpzdHJlZSopIGFuZCBjbGVhbnMgYWxsIGV2ZW50c1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdC51bmJpbmQoXCIuanN0cmVlXCIpXG5cdFx0XHRcdFx0LnVuZGVsZWdhdGUoXCIuanN0cmVlXCIpXG5cdFx0XHRcdFx0LnJlbW92ZURhdGEoXCJqc3RyZWVfaW5zdGFuY2VfaWRcIilcblx0XHRcdFx0XHQuZmluZChcIltjbGFzc149J2pzdHJlZSddXCIpXG5cdFx0XHRcdFx0XHQuYW5kU2VsZigpXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsJycpOyB9KTtcblx0XHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0XHQudW5iaW5kKFwiLmpzdHJlZS1cIiArIG4pXG5cdFx0XHRcdFx0LnVuZGVsZWdhdGUoXCIuanN0cmVlLVwiICsgbik7XG5cdFx0XHRcdC8vIHJlbW92ZSB0aGUgYWN0dWFsIGRhdGFcblx0XHRcdFx0aW5zdGFuY2VzW25dID0gbnVsbDtcblx0XHRcdFx0ZGVsZXRlIGluc3RhbmNlc1tuXTtcblx0XHRcdH0sXG5cblx0XHRcdF9jb3JlX25vdGlmeSA6IGZ1bmN0aW9uIChuLCBkYXRhKSB7XG5cdFx0XHRcdGlmKGRhdGEub3BlbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUobiwgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRsb2NrIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmRhdGEuY29yZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmFkZENsYXNzKFwianN0cmVlLWxvY2tlZFwiKS5jc3MoXCJvcGFjaXR5XCIsXCIwLjdcIik7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7fSk7XG5cdFx0XHR9LFxuXHRcdFx0dW5sb2NrIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmRhdGEuY29yZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2NrZWRcIikuY3NzKFwib3BhY2l0eVwiLFwiMVwiKTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHt9KTtcblx0XHRcdH0sXG5cdFx0XHRpc19sb2NrZWQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGEuY29yZS5sb2NrZWQ7IH0sXG5cdFx0XHRzYXZlX29wZW5lZCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdFx0dGhpcy5kYXRhLmNvcmUudG9fb3BlbiA9IFtdO1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKFwibGkuanN0cmVlLW9wZW5cIikuZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdGlmKHRoaXMuaWQpIHsgX3RoaXMuZGF0YS5jb3JlLnRvX29wZW4ucHVzaChcIiNcIiArIHRoaXMuaWQudG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIikpOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soX3RoaXMuZGF0YS5jb3JlLnRvX29wZW4pO1xuXHRcdFx0fSxcblx0XHRcdHNhdmVfbG9hZGVkIDogZnVuY3Rpb24gKCkgeyB9LFxuXHRcdFx0cmVsb2FkX25vZGVzIDogZnVuY3Rpb24gKGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdFx0ZG9uZSA9IHRydWUsXG5cdFx0XHRcdFx0Y3VycmVudCA9IFtdLFxuXHRcdFx0XHRcdHJlbWFpbmluZyA9IFtdO1xuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHsgXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmNvcmUucmVvcGVuID0gZmFsc2U7IFxuXHRcdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnJlZnJlc2hpbmcgPSB0cnVlOyBcblx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS50b19vcGVuID0gJC5tYXAoJC5tYWtlQXJyYXkodGhpcy5kYXRhLmNvcmUudG9fb3BlbiksIGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIiNcIiArIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIik7IH0pO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQgPSAkLm1hcCgkLm1ha2VBcnJheSh0aGlzLmRhdGEuY29yZS50b19sb2FkKSwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiI1wiICsgbi50b1N0cmluZygpLnJlcGxhY2UoL14jLyxcIlwiKS5yZXBsYWNlKC9cXFxcXFwvL2csXCIvXCIpLnJlcGxhY2UoL1xcLy9nLFwiXFxcXFxcL1wiKS5yZXBsYWNlKC9cXFxcXFwuL2csXCIuXCIpLnJlcGxhY2UoL1xcLi9nLFwiXFxcXC5cIikucmVwbGFjZSgvXFw6L2csXCJcXFxcOlwiKTsgfSk7XG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvcmUudG9fb3Blbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQgPSB0aGlzLmRhdGEuY29yZS50b19sb2FkLmNvbmNhdCh0aGlzLmRhdGEuY29yZS50b19vcGVuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLmNvcmUudG9fbG9hZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQkLmVhY2godGhpcy5kYXRhLmNvcmUudG9fbG9hZCwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRcdFx0aWYodmFsID09IFwiI1wiKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHRpZigkKHZhbCkubGVuZ3RoKSB7IGN1cnJlbnQucHVzaCh2YWwpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgcmVtYWluaW5nLnB1c2godmFsKTsgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmKGN1cnJlbnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS50b19sb2FkID0gcmVtYWluaW5nO1xuXHRcdFx0XHRcdFx0JC5lYWNoKGN1cnJlbnQsIGZ1bmN0aW9uIChpLCB2YWwpIHsgXG5cdFx0XHRcdFx0XHRcdGlmKCFfdGhpcy5faXNfbG9hZGVkKHZhbCkpIHtcblx0XHRcdFx0XHRcdFx0XHRfdGhpcy5sb2FkX25vZGUodmFsLCBmdW5jdGlvbiAoKSB7IF90aGlzLnJlbG9hZF9ub2Rlcyh0cnVlKTsgfSwgZnVuY3Rpb24gKCkgeyBfdGhpcy5yZWxvYWRfbm9kZXModHJ1ZSk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdGRvbmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5jb3JlLnRvX29wZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JC5lYWNoKHRoaXMuZGF0YS5jb3JlLnRvX29wZW4sIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRcdF90aGlzLm9wZW5fbm9kZSh2YWwsIGZhbHNlLCB0cnVlKTsgXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZG9uZSkgeyBcblx0XHRcdFx0XHQvLyBUT0RPOiBmaW5kIGEgbW9yZSBlbGVnYW50IGFwcHJvYWNoIHRvIHN5bmNyb25pemluZyByZXR1cm5pbmcgcmVxdWVzdHNcblx0XHRcdFx0XHRpZih0aGlzLmRhdGEuY29yZS5yZW9wZW4pIHsgY2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5jb3JlLnJlb3Blbik7IH1cblx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS5yZW9wZW4gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuX19jYWxsYmFjayh7fSwgX3RoaXMpOyB9LCA1MCk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmNvcmUucmVmcmVzaGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVvcGVuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZW9wZW4gOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5jb3JlLnRvX29wZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JC5lYWNoKHRoaXMuZGF0YS5jb3JlLnRvX29wZW4sIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRcdF90aGlzLm9wZW5fbm9kZSh2YWwsIGZhbHNlLCB0cnVlKTsgXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHt9KTtcblx0XHRcdH0sXG5cdFx0XHRyZWZyZXNoIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdFx0dGhpcy5zYXZlX29wZW5lZCgpO1xuXHRcdFx0XHRpZighb2JqKSB7IG9iaiA9IC0xOyB9XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmopIHsgb2JqID0gLTE7IH1cblx0XHRcdFx0aWYob2JqICE9PSAtMSkgeyBvYmouY2hpbGRyZW4oXCJVTFwiKS5yZW1vdmUoKTsgfVxuXHRcdFx0XHRlbHNlIHsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZW1wdHkoKTsgfVxuXHRcdFx0XHR0aGlzLmxvYWRfbm9kZShcblx0XHRcdFx0XHRvYmosIFxuXHRcdFx0XHRcdGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRfdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9ian0pOyBcblx0XHRcdFx0XHRcdF90aGlzLnJlbG9hZF9ub2RlcygpOyBcblx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgc19jYWxsLmNhbGwodGhpcyk7IFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZV9jYWxsXG5cdFx0XHRcdCk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRHVtbXkgZnVuY3Rpb24gdG8gZmlyZSBhZnRlciB0aGUgZmlyc3QgbG9hZCAoc28gdGhhdCB0aGVyZSBpcyBhIGpzdHJlZS5sb2FkZWQgZXZlbnQpXG5cdFx0XHRsb2FkZWRcdDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7IFxuXHRcdFx0fSxcblx0XHRcdC8vIGRlYWwgd2l0aCBmb2N1c1xuXHRcdFx0c2V0X2ZvY3VzXHQ6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdGlmKHRoaXMuaXNfZm9jdXNlZCgpKSB7IHJldHVybjsgfVxuXHRcdFx0XHR2YXIgZiA9ICQuanN0cmVlLl9mb2N1c2VkKCk7XG5cdFx0XHRcdGlmKGYpIHsgZi51bnNldF9mb2N1cygpOyB9XG5cblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuYWRkQ2xhc3MoXCJqc3RyZWUtZm9jdXNlZFwiKTsgXG5cdFx0XHRcdGZvY3VzZWRfaW5zdGFuY2UgPSB0aGlzLmdldF9pbmRleCgpOyBcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXHRcdFx0aXNfZm9jdXNlZFx0OiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRyZXR1cm4gZm9jdXNlZF9pbnN0YW5jZSA9PSB0aGlzLmdldF9pbmRleCgpOyBcblx0XHRcdH0sXG5cdFx0XHR1bnNldF9mb2N1c1x0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmKHRoaXMuaXNfZm9jdXNlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtZm9jdXNlZFwiKTsgXG5cdFx0XHRcdFx0Zm9jdXNlZF9pbnN0YW5jZSA9IC0xOyBcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIHRyYXZlcnNlXG5cdFx0XHRfZ2V0X25vZGVcdFx0OiBmdW5jdGlvbiAob2JqKSB7IFxuXHRcdFx0XHR2YXIgJG9iaiA9ICQob2JqLCB0aGlzLmdldF9jb250YWluZXIoKSk7IFxuXHRcdFx0XHRpZigkb2JqLmlzKFwiLmpzdHJlZVwiKSB8fCBvYmogPT0gLTEpIHsgcmV0dXJuIC0xOyB9IFxuXHRcdFx0XHQkb2JqID0gJG9iai5jbG9zZXN0KFwibGlcIiwgdGhpcy5nZXRfY29udGFpbmVyKCkpOyBcblx0XHRcdFx0cmV0dXJuICRvYmoubGVuZ3RoID8gJG9iaiA6IGZhbHNlOyBcblx0XHRcdH0sXG5cdFx0XHRfZ2V0X25leHRcdFx0OiBmdW5jdGlvbiAob2JqLCBzdHJpY3QpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09PSAtMSkgeyByZXR1cm4gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaTpmaXJzdC1jaGlsZFwiKTsgfVxuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoc3RyaWN0KSB7IHJldHVybiAob2JqLm5leHRBbGwoXCJsaVwiKS5zaXplKCkgPiAwKSA/IG9iai5uZXh0QWxsKFwibGk6ZXEoMClcIikgOiBmYWxzZTsgfVxuXG5cdFx0XHRcdGlmKG9iai5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHJldHVybiBvYmouZmluZChcImxpOmVxKDApXCIpOyB9XG5cdFx0XHRcdGVsc2UgaWYob2JqLm5leHRBbGwoXCJsaVwiKS5zaXplKCkgPiAwKSB7IHJldHVybiBvYmoubmV4dEFsbChcImxpOmVxKDApXCIpOyB9XG5cdFx0XHRcdGVsc2UgeyByZXR1cm4gb2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcImxpXCIpLm5leHQoXCJsaVwiKS5lcSgwKTsgfVxuXHRcdFx0fSxcblx0XHRcdF9nZXRfcHJldlx0XHQ6IGZ1bmN0aW9uIChvYmosIHN0cmljdCkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogPT09IC0xKSB7IHJldHVybiB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpOmxhc3QtY2hpbGRcIik7IH1cblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKHN0cmljdCkgeyByZXR1cm4gKG9iai5wcmV2QWxsKFwibGlcIikubGVuZ3RoID4gMCkgPyBvYmoucHJldkFsbChcImxpOmVxKDApXCIpIDogZmFsc2U7IH1cblxuXHRcdFx0XHRpZihvYmoucHJldihcImxpXCIpLmxlbmd0aCkge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5wcmV2KFwibGlcIikuZXEoMCk7XG5cdFx0XHRcdFx0d2hpbGUob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgb2JqID0gb2JqLmNoaWxkcmVuKFwidWw6ZXEoMClcIikuY2hpbGRyZW4oXCJsaTpsYXN0XCIpOyB9XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgdmFyIG8gPSBvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwibGk6ZXEoMClcIik7IHJldHVybiBvLmxlbmd0aCA/IG8gOiBmYWxzZTsgfVxuXHRcdFx0fSxcblx0XHRcdF9nZXRfcGFyZW50XHRcdDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogPT0gLTEgfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBvID0gb2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaTplcSgwKVwiKTtcblx0XHRcdFx0cmV0dXJuIG8ubGVuZ3RoID8gbyA6IC0xO1xuXHRcdFx0fSxcblx0XHRcdF9nZXRfY2hpbGRyZW5cdDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogPT09IC0xKSB7IHJldHVybiB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsOmVxKDApXCIpLmNoaWxkcmVuKFwibGlcIik7IH1cblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHJldHVybiBvYmouY2hpbGRyZW4oXCJ1bDplcSgwKVwiKS5jaGlsZHJlbihcImxpXCIpO1xuXHRcdFx0fSxcblx0XHRcdGdldF9wYXRoXHRcdDogZnVuY3Rpb24gKG9iaiwgaWRfbW9kZSkge1xuXHRcdFx0XHR2YXIgcCA9IFtdLFxuXHRcdFx0XHRcdF90aGlzID0gdGhpcztcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09PSAtMSB8fCAhb2JqIHx8ICFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHAucHVzaCggaWRfbW9kZSA/IHRoaXMuaWQgOiBfdGhpcy5nZXRfdGV4dCh0aGlzKSApO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cC5yZXZlcnNlKCk7XG5cdFx0XHRcdHAucHVzaCggaWRfbW9kZSA/IG9iai5hdHRyKFwiaWRcIikgOiB0aGlzLmdldF90ZXh0KG9iaikgKTtcblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBzdHJpbmcgZnVuY3Rpb25zXG5cdFx0XHRfZ2V0X3N0cmluZyA6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuc3RyaW5nc1trZXldIHx8IGtleTtcblx0XHRcdH0sXG5cblx0XHRcdGlzX29wZW5cdFx0OiBmdW5jdGlvbiAob2JqKSB7IG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7IHJldHVybiBvYmogJiYgb2JqICE9PSAtMSAmJiBvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKTsgfSxcblx0XHRcdGlzX2Nsb3NlZFx0OiBmdW5jdGlvbiAob2JqKSB7IG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7IHJldHVybiBvYmogJiYgb2JqICE9PSAtMSAmJiBvYmouaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpOyB9LFxuXHRcdFx0aXNfbGVhZlx0XHQ6IGZ1bmN0aW9uIChvYmopIHsgb2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTsgcmV0dXJuIG9iaiAmJiBvYmogIT09IC0xICYmIG9iai5oYXNDbGFzcyhcImpzdHJlZS1sZWFmXCIpOyB9LFxuXHRcdFx0Y29ycmVjdF9zdGF0ZVx0OiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLWNsb3NlZCBqc3RyZWUtb3BlblwiKS5hZGRDbGFzcyhcImpzdHJlZS1sZWFmXCIpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlKCk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gb3Blbi9jbG9zZVxuXHRcdFx0b3Blbl9ub2RlXHQ6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrLCBza2lwX2FuaW1hdGlvbikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoIW9iai5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgaWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCgpOyB9IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgcyA9IHNraXBfYW5pbWF0aW9uIHx8IGlzX2llNiA/IDAgOiB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmFuaW1hdGlvbixcblx0XHRcdFx0XHR0ID0gdGhpcztcblx0XHRcdFx0aWYoIXRoaXMuX2lzX2xvYWRlZChvYmopKSB7XG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdHRoaXMubG9hZF9ub2RlKG9iaiwgZnVuY3Rpb24gKCkgeyB0Lm9wZW5fbm9kZShvYmosIGNhbGxiYWNrLCBza2lwX2FuaW1hdGlvbik7IH0sIGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLm9wZW5fcGFyZW50cykge1xuXHRcdFx0XHRcdFx0b2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcIi5qc3RyZWUtY2xvc2VkXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0Lm9wZW5fbm9kZSh0aGlzLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocykgeyBvYmouY2hpbGRyZW4oXCJ1bFwiKS5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpOyB9XG5cdFx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLWNsb3NlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1vcGVuXCIpLmNoaWxkcmVuKFwiYVwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdGlmKHMpIHsgb2JqLmNoaWxkcmVuKFwidWxcIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZURvd24ocywgZnVuY3Rpb24gKCkgeyB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB0LmFmdGVyX29wZW4ob2JqKTsgfSk7IH1cblx0XHRcdFx0XHRlbHNlIHsgdC5hZnRlcl9vcGVuKG9iaik7IH1cblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwoKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWZ0ZXJfb3Blblx0OiBmdW5jdGlvbiAob2JqKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7IH0sXG5cdFx0XHRjbG9zZV9ub2RlXHQ6IGZ1bmN0aW9uIChvYmosIHNraXBfYW5pbWF0aW9uKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHZhciBzID0gc2tpcF9hbmltYXRpb24gfHwgaXNfaWU2ID8gMCA6IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuYW5pbWF0aW9uLFxuXHRcdFx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCB8fCAhb2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKHMpIHsgb2JqLmNoaWxkcmVuKFwidWxcIikuYXR0cihcInN0eWxlXCIsXCJkaXNwbGF5OmJsb2NrICFpbXBvcnRhbnRcIik7IH1cblx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLW9wZW5cIikuYWRkQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpO1xuXHRcdFx0XHRpZihzKSB7IG9iai5jaGlsZHJlbihcInVsXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVVcChzLCBmdW5jdGlvbiAoKSB7IHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiXCI7IHQuYWZ0ZXJfY2xvc2Uob2JqKTsgfSk7IH1cblx0XHRcdFx0ZWxzZSB7IHQuYWZ0ZXJfY2xvc2Uob2JqKTsgfVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyX2Nsb3NlXHQ6IGZ1bmN0aW9uIChvYmopIHsgdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTsgfSxcblx0XHRcdHRvZ2dsZV9ub2RlXHQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyByZXR1cm4gdGhpcy5vcGVuX25vZGUob2JqKTsgfVxuXHRcdFx0XHRpZihvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkgeyByZXR1cm4gdGhpcy5jbG9zZV9ub2RlKG9iaik7IH1cblx0XHRcdH0sXG5cdFx0XHRvcGVuX2FsbFx0OiBmdW5jdGlvbiAob2JqLCBkb19hbmltYXRpb24sIG9yaWdpbmFsX29iaikge1xuXHRcdFx0XHRvYmogPSBvYmogPyB0aGlzLl9nZXRfbm9kZShvYmopIDogLTE7XG5cdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSkgeyBvYmogPSB0aGlzLmdldF9jb250YWluZXJfdWwoKTsgfVxuXHRcdFx0XHRpZihvcmlnaW5hbF9vYmopIHsgXG5cdFx0XHRcdFx0b2JqID0gb2JqLmZpbmQoXCJsaS5qc3RyZWUtY2xvc2VkXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG9yaWdpbmFsX29iaiA9IG9iajtcblx0XHRcdFx0XHRpZihvYmouaXMoXCIuanN0cmVlLWNsb3NlZFwiKSkgeyBvYmogPSBvYmouZmluZChcImxpLmpzdHJlZS1jbG9zZWRcIikuYW5kU2VsZigpOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IG9iaiA9IG9iai5maW5kKFwibGkuanN0cmVlLWNsb3NlZFwiKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdG9iai5lYWNoKGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0dmFyIF9fdGhpcyA9IHRoaXM7IFxuXHRcdFx0XHRcdGlmKCFfdGhpcy5faXNfbG9hZGVkKHRoaXMpKSB7IF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmdW5jdGlvbigpIHsgX3RoaXMub3Blbl9hbGwoX190aGlzLCBkb19hbmltYXRpb24sIG9yaWdpbmFsX29iaik7IH0sICFkb19hbmltYXRpb24pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmYWxzZSwgIWRvX2FuaW1hdGlvbik7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIHNvIHRoYXQgY2FsbGJhY2sgaXMgZmlyZWQgQUZURVIgYWxsIG5vZGVzIGFyZSBvcGVuXG5cdFx0XHRcdGlmKG9yaWdpbmFsX29iai5maW5kKCdsaS5qc3RyZWUtY2xvc2VkJykubGVuZ3RoID09PSAwKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvcmlnaW5hbF9vYmogfSk7IH1cblx0XHRcdH0sXG5cdFx0XHRjbG9zZV9hbGxcdDogZnVuY3Rpb24gKG9iaiwgZG9fYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdG9iaiA9IG9iaiA/IHRoaXMuX2dldF9ub2RlKG9iaikgOiB0aGlzLmdldF9jb250YWluZXIoKTtcblx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT09IC0xKSB7IG9iaiA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpOyB9XG5cdFx0XHRcdG9iai5maW5kKFwibGkuanN0cmVlLW9wZW5cIikuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24gKCkgeyBfdGhpcy5jbG9zZV9ub2RlKHRoaXMsICFkb19hbmltYXRpb24pOyB9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdH0sXG5cdFx0XHRjbGVhbl9ub2RlXHQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gb2JqICYmIG9iaiAhPSAtMSA/ICQob2JqKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpO1xuXHRcdFx0XHRvYmogPSBvYmouaXMoXCJsaVwiKSA/IG9iai5maW5kKFwibGlcIikuYW5kU2VsZigpIDogb2JqLmZpbmQoXCJsaVwiKTtcblx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLWxhc3RcIilcblx0XHRcdFx0XHQuZmlsdGVyKFwibGk6bGFzdC1jaGlsZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1sYXN0XCIpLmVuZCgpXG5cdFx0XHRcdFx0LmZpbHRlcihcIjpoYXMobGkpXCIpXG5cdFx0XHRcdFx0XHQubm90KFwiLmpzdHJlZS1vcGVuXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxlYWZcIikuYWRkQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpO1xuXHRcdFx0XHRvYmoubm90KFwiLmpzdHJlZS1vcGVuLCAuanN0cmVlLWNsb3NlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1sZWFmXCIpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlKCk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gcm9sbGJhY2tcblx0XHRcdGdldF9yb2xsYmFjayA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm4geyBpIDogdGhpcy5nZXRfaW5kZXgoKSwgaCA6IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuY2xvbmUodHJ1ZSksIGQgOiB0aGlzLmRhdGEgfTsgXG5cdFx0XHR9LFxuXHRcdFx0c2V0X3JvbGxiYWNrIDogZnVuY3Rpb24gKGh0bWwsIGRhdGEpIHtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuZW1wdHkoKS5hcHBlbmQoaHRtbCk7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0fSxcblx0XHRcdC8vIER1bW15IGZ1bmN0aW9ucyB0byBiZSBvdmVyd3JpdHRlbiBieSBhbnkgZGF0YXN0b3JlIHBsdWdpbiBpbmNsdWRlZFxuXHRcdFx0bG9hZF9ub2RlXHQ6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7IH0sXG5cdFx0XHRfaXNfbG9hZGVkXHQ6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHRydWU7IH0sXG5cblx0XHRcdC8vIEJhc2ljIG9wZXJhdGlvbnM6IGNyZWF0ZVxuXHRcdFx0Y3JlYXRlX25vZGVcdDogZnVuY3Rpb24gKG9iaiwgcG9zaXRpb24sIGpzLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHBvc2l0aW9uID0gdHlwZW9mIHBvc2l0aW9uID09PSBcInVuZGVmaW5lZFwiID8gXCJsYXN0XCIgOiBwb3NpdGlvbjtcblx0XHRcdFx0dmFyIGQgPSAkKFwiPGxpIC8+XCIpLFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLFxuXHRcdFx0XHRcdHRtcDtcblxuXHRcdFx0XHRpZihvYmogIT09IC0xICYmICFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZighaXNfbG9hZGVkICYmICF0aGlzLl9pc19sb2FkZWQob2JqKSkgeyB0aGlzLmxvYWRfbm9kZShvYmosIGZ1bmN0aW9uICgpIHsgdGhpcy5jcmVhdGVfbm9kZShvYmosIHBvc2l0aW9uLCBqcywgY2FsbGJhY2ssIHRydWUpOyB9KTsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdFx0dGhpcy5fX3JvbGxiYWNrKCk7XG5cblx0XHRcdFx0aWYodHlwZW9mIGpzID09PSBcInN0cmluZ1wiKSB7IGpzID0geyBcImRhdGFcIiA6IGpzIH07IH1cblx0XHRcdFx0aWYoIWpzKSB7IGpzID0ge307IH1cblx0XHRcdFx0aWYoanMuYXR0cikgeyBkLmF0dHIoanMuYXR0cik7IH1cblx0XHRcdFx0aWYoanMubWV0YWRhdGEpIHsgZC5kYXRhKGpzLm1ldGFkYXRhKTsgfVxuXHRcdFx0XHRpZihqcy5zdGF0ZSkgeyBkLmFkZENsYXNzKFwianN0cmVlLVwiICsganMuc3RhdGUpOyB9XG5cdFx0XHRcdGlmKCFqcy5kYXRhKSB7IGpzLmRhdGEgPSB0aGlzLl9nZXRfc3RyaW5nKFwibmV3X25vZGVcIik7IH1cblx0XHRcdFx0aWYoISQuaXNBcnJheShqcy5kYXRhKSkgeyB0bXAgPSBqcy5kYXRhOyBqcy5kYXRhID0gW107IGpzLmRhdGEucHVzaCh0bXApOyB9XG5cdFx0XHRcdCQuZWFjaChqcy5kYXRhLCBmdW5jdGlvbiAoaSwgbSkge1xuXHRcdFx0XHRcdHRtcCA9ICQoXCI8YSAvPlwiKTtcblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24obSkpIHsgbSA9IG0uY2FsbCh0aGlzLCBqcyk7IH1cblx0XHRcdFx0XHRpZih0eXBlb2YgbSA9PSBcInN0cmluZ1wiKSB7IHRtcC5hdHRyKCdocmVmJywnIycpWyBzLmh0bWxfdGl0bGVzID8gXCJodG1sXCIgOiBcInRleHRcIiBdKG0pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZighbS5hdHRyKSB7IG0uYXR0ciA9IHt9OyB9XG5cdFx0XHRcdFx0XHRpZighbS5hdHRyLmhyZWYpIHsgbS5hdHRyLmhyZWYgPSAnIyc7IH1cblx0XHRcdFx0XHRcdHRtcC5hdHRyKG0uYXR0cilbIHMuaHRtbF90aXRsZXMgPyBcImh0bWxcIiA6IFwidGV4dFwiIF0obS50aXRsZSk7XG5cdFx0XHRcdFx0XHRpZihtLmxhbmd1YWdlKSB7IHRtcC5hZGRDbGFzcyhtLmxhbmd1YWdlKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bXAucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIik7XG5cdFx0XHRcdFx0aWYoIW0uaWNvbiAmJiBqcy5pY29uKSB7IG0uaWNvbiA9IGpzLmljb247IH1cblx0XHRcdFx0XHRpZihtLmljb24pIHsgXG5cdFx0XHRcdFx0XHRpZihtLmljb24uaW5kZXhPZihcIi9cIikgPT09IC0xKSB7IHRtcC5jaGlsZHJlbihcImluc1wiKS5hZGRDbGFzcyhtLmljb24pOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgdG1wLmNoaWxkcmVuKFwiaW5zXCIpLmNzcyhcImJhY2tncm91bmRcIixcInVybCgnXCIgKyBtLmljb24gKyBcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XCIpOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGQuYXBwZW5kKHRtcCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpO1xuXHRcdFx0XHRpZihvYmogPT09IC0xKSB7XG5cdFx0XHRcdFx0b2JqID0gdGhpcy5nZXRfY29udGFpbmVyKCk7XG5cdFx0XHRcdFx0aWYocG9zaXRpb24gPT09IFwiYmVmb3JlXCIpIHsgcG9zaXRpb24gPSBcImZpcnN0XCI7IH1cblx0XHRcdFx0XHRpZihwb3NpdGlvbiA9PT0gXCJhZnRlclwiKSB7IHBvc2l0aW9uID0gXCJsYXN0XCI7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2gocG9zaXRpb24pIHtcblx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6IG9iai5iZWZvcmUoZCk7IHRtcCA9IHRoaXMuX2dldF9wYXJlbnQob2JqKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImFmdGVyXCIgOiBvYmouYWZ0ZXIoZCk7ICB0bXAgPSB0aGlzLl9nZXRfcGFyZW50KG9iaik7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0XHRjYXNlIFwiZmlyc3RcIiA6XG5cdFx0XHRcdFx0XHRpZighb2JqLmNoaWxkcmVuKFwidWxcIikubGVuZ3RoKSB7IG9iai5hcHBlbmQoXCI8dWwgLz5cIik7IH1cblx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcInVsXCIpLnByZXBlbmQoZCk7XG5cdFx0XHRcdFx0XHR0bXAgPSBvYmo7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdFx0aWYoIW9iai5jaGlsZHJlbihcInVsXCIpLmxlbmd0aCkgeyBvYmouYXBwZW5kKFwiPHVsIC8+XCIpOyB9XG5cdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJ1bFwiKS5hcHBlbmQoZCk7XG5cdFx0XHRcdFx0XHR0bXAgPSBvYmo7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0aWYoIW9iai5jaGlsZHJlbihcInVsXCIpLmxlbmd0aCkgeyBvYmouYXBwZW5kKFwiPHVsIC8+XCIpOyB9XG5cdFx0XHRcdFx0XHRpZighcG9zaXRpb24pIHsgcG9zaXRpb24gPSAwOyB9XG5cdFx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGRyZW4oXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpLmVxKHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGlmKHRtcC5sZW5ndGgpIHsgdG1wLmJlZm9yZShkKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IG9iai5jaGlsZHJlbihcInVsXCIpLmFwcGVuZChkKTsgfVxuXHRcdFx0XHRcdFx0dG1wID0gb2JqO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodG1wID09PSAtMSB8fCB0bXAuZ2V0KDApID09PSB0aGlzLmdldF9jb250YWluZXIoKS5nZXQoMCkpIHsgdG1wID0gLTE7IH1cblx0XHRcdFx0dGhpcy5jbGVhbl9ub2RlKHRtcCk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBkLCBcInBhcmVudFwiIDogdG1wIH0pO1xuXHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIGQpOyB9XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fSxcblx0XHRcdC8vIEJhc2ljIG9wZXJhdGlvbnM6IHJlbmFtZSAoZGVhbCB3aXRoIHRleHQpXG5cdFx0XHRnZXRfdGV4dFx0OiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuaHRtbF90aXRsZXM7XG5cdFx0XHRcdG9iaiA9IG9iai5jaGlsZHJlbihcImE6ZXEoMClcIik7XG5cdFx0XHRcdGlmKHMpIHtcblx0XHRcdFx0XHRvYmogPSBvYmouY2xvbmUoKTtcblx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJJTlNcIikucmVtb3ZlKCk7XG5cdFx0XHRcdFx0cmV0dXJuIG9iai5odG1sKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b2JqID0gb2JqLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ub2RlVHlwZSA9PSAzOyB9KVswXTtcblx0XHRcdFx0XHRyZXR1cm4gb2JqID8gb2JqLm5vZGVWYWx1ZSA6ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0X3RleHRcdDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRvYmogPSBvYmouY2hpbGRyZW4oXCJhOmVxKDApXCIpO1xuXHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmh0bWxfdGl0bGVzKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IG9iai5jaGlsZHJlbihcIklOU1wiKS5jbG9uZSgpO1xuXHRcdFx0XHRcdG9iai5odG1sKHZhbCkucHJlcGVuZCh0bXApO1xuXHRcdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwibmFtZVwiIDogdmFsIH0pO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgfSlbMF07XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJuYW1lXCIgOiB2YWwgfSk7XG5cdFx0XHRcdFx0cmV0dXJuIChvYmoubm9kZVZhbHVlID0gdmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmFtZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHRpZihvYmogJiYgb2JqLmxlbmd0aCAmJiB0aGlzLnNldF90ZXh0LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwibmFtZVwiIDogdmFsIH0pOyB9XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQmFzaWMgb3BlcmF0aW9uczogZGVsZXRpbmcgbm9kZXNcblx0XHRcdGRlbGV0ZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dGhpcy5fX3JvbGxiYWNrKCk7XG5cdFx0XHRcdHZhciBwID0gdGhpcy5fZ2V0X3BhcmVudChvYmopLCBwcmV2ID0gJChbXSksIHQgPSB0aGlzO1xuXHRcdFx0XHRvYmouZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHJldiA9IHByZXYuYWRkKHQuX2dldF9wcmV2KHRoaXMpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG9iaiA9IG9iai5kZXRhY2goKTtcblx0XHRcdFx0aWYocCAhPT0gLTEgJiYgcC5maW5kKFwiPiB1bCA+IGxpXCIpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHAucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtb3BlbiBqc3RyZWUtY2xvc2VkXCIpLmFkZENsYXNzKFwianN0cmVlLWxlYWZcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jbGVhbl9ub2RlKHApO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcInByZXZcIiA6IHByZXYsIFwicGFyZW50XCIgOiBwIH0pO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblx0XHRcdHByZXBhcmVfbW92ZSA6IGZ1bmN0aW9uIChvLCByLCBwb3MsIGNiLCBpc19jYikge1xuXHRcdFx0XHR2YXIgcCA9IHt9O1xuXG5cdFx0XHRcdHAub3QgPSAkLmpzdHJlZS5fcmVmZXJlbmNlKG8pIHx8IHRoaXM7XG5cdFx0XHRcdHAubyA9IHAub3QuX2dldF9ub2RlKG8pO1xuXHRcdFx0XHRwLnIgPSByID09PSAtIDEgPyAtMSA6IHRoaXMuX2dldF9ub2RlKHIpO1xuXHRcdFx0XHRwLnAgPSAodHlwZW9mIHBvcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwb3MgPT09IGZhbHNlKSA/IFwibGFzdFwiIDogcG9zOyAvLyBUT0RPOiBtb3ZlIHRvIGEgc2V0dGluZ1xuXHRcdFx0XHRpZighaXNfY2IgJiYgcHJlcGFyZWRfbW92ZS5vICYmIHByZXBhcmVkX21vdmUub1swXSA9PT0gcC5vWzBdICYmIHByZXBhcmVkX21vdmUuclswXSA9PT0gcC5yWzBdICYmIHByZXBhcmVkX21vdmUucCA9PT0gcC5wKSB7XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHByZXBhcmVkX21vdmUpO1xuXHRcdFx0XHRcdGlmKGNiKSB7IGNiLmNhbGwodGhpcywgcHJlcGFyZWRfbW92ZSk7IH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cC5vdCA9ICQuanN0cmVlLl9yZWZlcmVuY2UocC5vKSB8fCB0aGlzO1xuXHRcdFx0XHRwLnJ0ID0gJC5qc3RyZWUuX3JlZmVyZW5jZShwLnIpIHx8IHRoaXM7IC8vIHIgPT09IC0xID8gcC5vdCA6ICQuanN0cmVlLl9yZWZlcmVuY2UocC5yKSB8fCB0aGlzXG5cdFx0XHRcdGlmKHAuciA9PT0gLTEgfHwgIXAucikge1xuXHRcdFx0XHRcdHAuY3IgPSAtMTtcblx0XHRcdFx0XHRzd2l0Y2gocC5wKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IDA7IFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IHAucnQuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCIgPiB1bCA+IGxpXCIpLmxlbmd0aDsgXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IHAucDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKCEvXihiZWZvcmV8YWZ0ZXIpJC8udGVzdChwLnApICYmICF0aGlzLl9pc19sb2FkZWQocC5yKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHAuciwgZnVuY3Rpb24gKCkgeyB0aGlzLnByZXBhcmVfbW92ZShvLCByLCBwb3MsIGNiLCB0cnVlKTsgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN3aXRjaChwLnApIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IHAuci5pbmRleCgpO1xuXHRcdFx0XHRcdFx0XHRwLmNyID0gcC5ydC5fZ2V0X3BhcmVudChwLnIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdFx0XHRwLmNwID0gcC5yLmluZGV4KCkgKyAxO1xuXHRcdFx0XHRcdFx0XHRwLmNyID0gcC5ydC5fZ2V0X3BhcmVudChwLnIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJmaXJzdFwiOlxuXHRcdFx0XHRcdFx0XHRwLmNwID0gMDtcblx0XHRcdFx0XHRcdFx0cC5jciA9IHAucjtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdFx0XHRwLmNwID0gcC5yLmZpbmQoXCIgPiB1bCA+IGxpXCIpLmxlbmd0aDsgXG5cdFx0XHRcdFx0XHRcdHAuY3IgPSBwLnI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDogXG5cdFx0XHRcdFx0XHRcdHAuY3AgPSBwLnA7XG5cdFx0XHRcdFx0XHRcdHAuY3IgPSBwLnI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwLm5wID0gcC5jciA9PSAtMSA/IHAucnQuZ2V0X2NvbnRhaW5lcigpIDogcC5jcjtcblx0XHRcdFx0cC5vcCA9IHAub3QuX2dldF9wYXJlbnQocC5vKTtcblx0XHRcdFx0cC5jb3AgPSBwLm8uaW5kZXgoKTtcblx0XHRcdFx0aWYocC5vcCA9PT0gLTEpIHsgcC5vcCA9IHAub3QgPyBwLm90LmdldF9jb250YWluZXIoKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcigpOyB9XG5cdFx0XHRcdGlmKCEvXihiZWZvcmV8YWZ0ZXIpJC8udGVzdChwLnApICYmIHAub3AgJiYgcC5ucCAmJiBwLm9wWzBdID09PSBwLm5wWzBdICYmIHAuby5pbmRleCgpIDwgcC5jcCkgeyBwLmNwKys7IH1cblx0XHRcdFx0Ly9pZihwLnAgPT09IFwiYmVmb3JlXCIgJiYgcC5vcCAmJiBwLm5wICYmIHAub3BbMF0gPT09IHAubnBbMF0gJiYgcC5vLmluZGV4KCkgPCBwLmNwKSB7IHAuY3AtLTsgfVxuXHRcdFx0XHRwLm9yID0gcC5ucC5maW5kKFwiID4gdWwgPiBsaTpudGgtY2hpbGQoXCIgKyAocC5jcCArIDEpICsgXCIpXCIpO1xuXHRcdFx0XHRwcmVwYXJlZF9tb3ZlID0gcDtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHByZXBhcmVkX21vdmUpO1xuXHRcdFx0XHRpZihjYikgeyBjYi5jYWxsKHRoaXMsIHByZXBhcmVkX21vdmUpOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y2hlY2tfbW92ZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIG9iaiA9IHByZXBhcmVkX21vdmUsIHJldCA9IHRydWUsIHIgPSBvYmouciA9PT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKSA6IG9iai5yO1xuXHRcdFx0XHRpZighb2JqIHx8ICFvYmoubyB8fCBvYmoub3JbMF0gPT09IG9iai5vWzBdKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZighb2JqLmN5KSB7XG5cdFx0XHRcdFx0aWYob2JqLm9wICYmIG9iai5ucCAmJiBvYmoub3BbMF0gPT09IG9iai5ucFswXSAmJiBvYmouY3AgLSAxID09PSBvYmouby5pbmRleCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdG9iai5vLmVhY2goZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRcdGlmKHIucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmFuZFNlbGYoKS5pbmRleCh0aGlzKSAhPT0gLTEpIHsgcmV0ID0gZmFsc2U7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXHRcdFx0bW92ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcmVmLCBwb3NpdGlvbiwgaXNfY29weSwgaXNfcHJlcGFyZWQsIHNraXBfY2hlY2spIHtcblx0XHRcdFx0aWYoIWlzX3ByZXBhcmVkKSB7IFxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnByZXBhcmVfbW92ZShvYmosIHJlZiwgcG9zaXRpb24sIGZ1bmN0aW9uIChwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vdmVfbm9kZShwLCBmYWxzZSwgZmFsc2UsIGlzX2NvcHksIHRydWUsIHNraXBfY2hlY2spO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGlzX2NvcHkpIHsgXG5cdFx0XHRcdFx0cHJlcGFyZWRfbW92ZS5jeSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXNraXBfY2hlY2sgJiYgIXRoaXMuY2hlY2tfbW92ZSgpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHR2YXIgbyA9IGZhbHNlO1xuXHRcdFx0XHRpZihpc19jb3B5KSB7XG5cdFx0XHRcdFx0byA9IG9iai5vLmNsb25lKHRydWUpO1xuXHRcdFx0XHRcdG8uZmluZChcIipbaWRdXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuaWQpIHsgdGhpcy5pZCA9IFwiY29weV9cIiArIHRoaXMuaWQ7IH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgbyA9IG9iai5vOyB9XG5cblx0XHRcdFx0aWYob2JqLm9yLmxlbmd0aCkgeyBvYmoub3IuYmVmb3JlKG8pOyB9XG5cdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRpZighb2JqLm5wLmNoaWxkcmVuKFwidWxcIikubGVuZ3RoKSB7ICQoXCI8dWwgLz5cIikuYXBwZW5kVG8ob2JqLm5wKTsgfVxuXHRcdFx0XHRcdG9iai5ucC5jaGlsZHJlbihcInVsOmVxKDApXCIpLmFwcGVuZChvKTsgXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkgeyBcblx0XHRcdFx0XHRvYmoub3QuY2xlYW5fbm9kZShvYmoub3ApO1xuXHRcdFx0XHRcdG9iai5ydC5jbGVhbl9ub2RlKG9iai5ucCk7XG5cdFx0XHRcdFx0aWYoIW9iai5vcC5maW5kKFwiPiB1bCA+IGxpXCIpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0b2JqLm9wLnJlbW92ZUNsYXNzKFwianN0cmVlLW9wZW4ganN0cmVlLWNsb3NlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1sZWFmXCIpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IH1cblxuXHRcdFx0XHRpZihpc19jb3B5KSB7IFxuXHRcdFx0XHRcdHByZXBhcmVkX21vdmUuY3kgPSB0cnVlO1xuXHRcdFx0XHRcdHByZXBhcmVkX21vdmUub2MgPSBvOyBcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2socHJlcGFyZWRfbW92ZSk7XG5cdFx0XHRcdHJldHVybiBwcmVwYXJlZF9tb3ZlO1xuXHRcdFx0fSxcblx0XHRcdF9nZXRfbW92ZSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByZXBhcmVkX21vdmU7IH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgdWkgcGx1Z2luXG4gKiBUaGlzIHBsdWdpbnMgaGFuZGxlcyBzZWxlY3RpbmcvZGVzZWxlY3RpbmcvaG92ZXJpbmcvZGVob3ZlcmluZyBub2Rlc1xuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIHNjcm9sbGJhcl93aWR0aCwgZTEsIGUyO1xuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdGlmICgvbXNpZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRlMSA9ICQoJzx0ZXh0YXJlYSBjb2xzPVwiMTBcIiByb3dzPVwiMlwiPjwvdGV4dGFyZWE+JykuY3NzKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogLTEwMDAsIGxlZnQ6IDAgfSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdGUyID0gJCgnPHRleHRhcmVhIGNvbHM9XCIxMFwiIHJvd3M9XCIyXCIgc3R5bGU9XCJvdmVyZmxvdzogaGlkZGVuO1wiPjwvdGV4dGFyZWE+JykuY3NzKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogLTEwMDAsIGxlZnQ6IDAgfSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdHNjcm9sbGJhcl93aWR0aCA9IGUxLndpZHRoKCkgLSBlMi53aWR0aCgpO1xuXHRcdFx0ZTEuYWRkKGUyKS5yZW1vdmUoKTtcblx0XHR9IFxuXHRcdGVsc2Uge1xuXHRcdFx0ZTEgPSAkKCc8ZGl2IC8+JykuY3NzKHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAsIG92ZXJmbG93OiAnYXV0bycsIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IC0xMDAwLCBsZWZ0OiAwIH0pXG5cdFx0XHRcdFx0LnByZXBlbmRUbygnYm9keScpLmFwcGVuZCgnPGRpdiAvPicpLmZpbmQoJ2RpdicpLmNzcyh7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogMjAwIH0pO1xuXHRcdFx0c2Nyb2xsYmFyX3dpZHRoID0gMTAwIC0gZTEud2lkdGgoKTtcblx0XHRcdGUxLnBhcmVudCgpLnJlbW92ZSgpO1xuXHRcdH1cblx0fSk7XG5cdCQuanN0cmVlLnBsdWdpbihcInVpXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0dGhpcy5kYXRhLnVpLnNlbGVjdGVkID0gJCgpOyBcblx0XHRcdHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkID0gZmFsc2U7IFxuXHRcdFx0dGhpcy5kYXRhLnVpLmhvdmVyZWQgPSBudWxsO1xuXHRcdFx0dGhpcy5kYXRhLnVpLnRvX3NlbGVjdCA9IHRoaXMuZ2V0X3NldHRpbmdzKCkudWkuaW5pdGlhbGx5X3NlbGVjdDtcblxuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcImNsaWNrLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQuYmx1cigpO1xuXHRcdFx0XHRcdFx0aWYoISQoZXZlbnQuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRydWUsIGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcIm1vdXNlZW50ZXIuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRpZighJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaG92ZXJfbm9kZShldmVudC50YXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCJhXCIsIFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmKCEkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwianN0cmVlLWxvYWRpbmdcIikpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWhvdmVyX25vZGUoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJyZW9wZW4uanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRcdHRoaXMucmVzZWxlY3QoKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJnZXRfcm9sbGJhY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNhdmVfc2VsZWN0ZWQoKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJzZXRfcm9sbGJhY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRcdHRoaXMucmVzZWxlY3QoKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJjbG9zZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudWksXG5cdFx0XHRcdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopLFxuXHRcdFx0XHRcdFx0XHRjbGsgPSAob2JqICYmIG9iai5sZW5ndGgpID8gb2JqLmNoaWxkcmVuKFwidWxcIikuZmluZChcImEuanN0cmVlLWNsaWNrZWRcIikgOiAkKCksXG5cdFx0XHRcdFx0XHRcdF90aGlzID0gdGhpcztcblx0XHRcdFx0XHRcdGlmKHMuc2VsZWN0ZWRfcGFyZW50X2Nsb3NlID09PSBmYWxzZSB8fCAhY2xrLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdGNsay5lYWNoKGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRcdF90aGlzLmRlc2VsZWN0X25vZGUodGhpcyk7XG5cdFx0XHRcdFx0XHRcdGlmKHMuc2VsZWN0ZWRfcGFyZW50X2Nsb3NlID09PSBcInNlbGVjdF9wYXJlbnRcIikgeyBfdGhpcy5zZWxlY3Rfbm9kZShvYmopOyB9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkZWxldGVfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnVpLnNlbGVjdF9wcmV2X29uX2RlbGV0ZSxcblx0XHRcdFx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUoZGF0YS5yc2x0Lm9iaiksXG5cdFx0XHRcdFx0XHRcdGNsayA9IChvYmogJiYgb2JqLmxlbmd0aCkgPyBvYmouZmluZChcImEuanN0cmVlLWNsaWNrZWRcIikgOiBbXSxcblx0XHRcdFx0XHRcdFx0X3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRcdFx0Y2xrLmVhY2goZnVuY3Rpb24gKCkgeyBfdGhpcy5kZXNlbGVjdF9ub2RlKHRoaXMpOyB9KTtcblx0XHRcdFx0XHRcdGlmKHMgJiYgY2xrLmxlbmd0aCkgeyBcblx0XHRcdFx0XHRcdFx0ZGF0YS5yc2x0LnByZXYuZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMucGFyZW50Tm9kZSkgeyBfdGhpcy5zZWxlY3Rfbm9kZSh0aGlzKTsgcmV0dXJuIGZhbHNlOyAvKiBpZiByZXR1cm4gZmFsc2UgaXMgcmVtb3ZlZCBhbGwgcHJldiBub2RlcyB3aWxsIGJlIHNlbGVjdGVkICovfVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJtb3ZlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0aWYoZGF0YS5yc2x0LmN5KSB7IFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJzbHQub2MuZmluZChcImEuanN0cmVlLWNsaWNrZWRcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2xpY2tlZFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdHNlbGVjdF9saW1pdCA6IC0xLCAvLyAwLCAxLCAyIC4uLiBvciAtMSBmb3IgdW5saW1pdGVkXG5cdFx0XHRzZWxlY3RfbXVsdGlwbGVfbW9kaWZpZXIgOiBcImN0cmxcIiwgLy8gb24sIG9yIGN0cmwsIHNoaWZ0LCBhbHRcblx0XHRcdHNlbGVjdF9yYW5nZV9tb2RpZmllciA6IFwic2hpZnRcIixcblx0XHRcdHNlbGVjdGVkX3BhcmVudF9jbG9zZSA6IFwic2VsZWN0X3BhcmVudFwiLCAvLyBmYWxzZSwgXCJkZXNlbGVjdFwiLCBcInNlbGVjdF9wYXJlbnRcIlxuXHRcdFx0c2VsZWN0ZWRfcGFyZW50X29wZW4gOiB0cnVlLFxuXHRcdFx0c2VsZWN0X3ByZXZfb25fZGVsZXRlIDogdHJ1ZSxcblx0XHRcdGRpc2FibGVfc2VsZWN0aW5nX2NoaWxkcmVuIDogZmFsc2UsXG5cdFx0XHRpbml0aWFsbHlfc2VsZWN0IDogW11cblx0XHR9LFxuXHRcdF9mbiA6IHsgXG5cdFx0XHRfZ2V0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBhbGxvd19tdWx0aXBsZSkge1xuXHRcdFx0XHRpZih0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiIHx8IG9iaiA9PT0gbnVsbCkgeyByZXR1cm4gYWxsb3dfbXVsdGlwbGUgPyB0aGlzLmRhdGEudWkuc2VsZWN0ZWQgOiB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZDsgfVxuXHRcdFx0XHR2YXIgJG9iaiA9ICQob2JqLCB0aGlzLmdldF9jb250YWluZXIoKSk7IFxuXHRcdFx0XHRpZigkb2JqLmlzKFwiLmpzdHJlZVwiKSB8fCBvYmogPT0gLTEpIHsgcmV0dXJuIC0xOyB9IFxuXHRcdFx0XHQkb2JqID0gJG9iai5jbG9zZXN0KFwibGlcIiwgdGhpcy5nZXRfY29udGFpbmVyKCkpOyBcblx0XHRcdFx0cmV0dXJuICRvYmoubGVuZ3RoID8gJG9iaiA6IGZhbHNlOyBcblx0XHRcdH0sXG5cdFx0XHRfdWlfbm90aWZ5IDogZnVuY3Rpb24gKG4sIGRhdGEpIHtcblx0XHRcdFx0aWYoZGF0YS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUobiwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2F2ZV9zZWxlY3RlZCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdFx0dGhpcy5kYXRhLnVpLnRvX3NlbGVjdCA9IFtdO1xuXHRcdFx0XHR0aGlzLmRhdGEudWkuc2VsZWN0ZWQuZWFjaChmdW5jdGlvbiAoKSB7IGlmKHRoaXMuaWQpIHsgX3RoaXMuZGF0YS51aS50b19zZWxlY3QucHVzaChcIiNcIiArIHRoaXMuaWQudG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIikpOyB9IH0pO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2sodGhpcy5kYXRhLnVpLnRvX3NlbGVjdCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzZWxlY3QgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdFx0cyA9IHRoaXMuZGF0YS51aS50b19zZWxlY3Q7XG5cdFx0XHRcdHMgPSAkLm1hcCgkLm1ha2VBcnJheShzKSwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiI1wiICsgbi50b1N0cmluZygpLnJlcGxhY2UoL14jLyxcIlwiKS5yZXBsYWNlKC9cXFxcXFwvL2csXCIvXCIpLnJlcGxhY2UoL1xcLy9nLFwiXFxcXFxcL1wiKS5yZXBsYWNlKC9cXFxcXFwuL2csXCIuXCIpLnJlcGxhY2UoL1xcLi9nLFwiXFxcXC5cIikucmVwbGFjZSgvXFw6L2csXCJcXFxcOlwiKTsgfSk7XG5cdFx0XHRcdC8vIHRoaXMuZGVzZWxlY3RfYWxsKCk7IFdIWSBkZXNlbGVjdCwgYnJlYWtzIHBsdWdpbiBzdGF0ZSBub3RpZmllcj9cblx0XHRcdFx0JC5lYWNoKHMsIGZ1bmN0aW9uIChpLCB2YWwpIHsgaWYodmFsICYmIHZhbCAhPT0gXCIjXCIpIHsgX3RoaXMuc2VsZWN0X25vZGUodmFsKTsgfSB9KTtcblx0XHRcdFx0dGhpcy5kYXRhLnVpLnNlbGVjdGVkID0gdGhpcy5kYXRhLnVpLnNlbGVjdGVkLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcmVudE5vZGU7IH0pO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdH0sXG5cdFx0XHRyZWZyZXNoIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHR0aGlzLnNhdmVfc2VsZWN0ZWQoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX19jYWxsX29sZCgpO1xuXHRcdFx0fSxcblx0XHRcdGhvdmVyX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHQvL2lmKHRoaXMuZGF0YS51aS5ob3ZlcmVkICYmIG9iai5nZXQoMCkgPT09IHRoaXMuZGF0YS51aS5ob3ZlcmVkLmdldCgwKSkgeyByZXR1cm47IH1cblx0XHRcdFx0aWYoIW9iai5oYXNDbGFzcyhcImpzdHJlZS1ob3ZlcmVkXCIpKSB7IHRoaXMuZGVob3Zlcl9ub2RlKCk7IH1cblx0XHRcdFx0dGhpcy5kYXRhLnVpLmhvdmVyZWQgPSBvYmouY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwianN0cmVlLWhvdmVyZWRcIikucGFyZW50KCk7XG5cdFx0XHRcdHRoaXMuX2ZpeF9zY3JvbGwob2JqKTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdH0sXG5cdFx0XHRkZWhvdmVyX25vZGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBvYmogPSB0aGlzLmRhdGEudWkuaG92ZXJlZCwgcDtcblx0XHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0cCA9IG9iai5jaGlsZHJlbihcImFcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtaG92ZXJlZFwiKS5wYXJlbnQoKTtcblx0XHRcdFx0aWYodGhpcy5kYXRhLnVpLmhvdmVyZWRbMF0gPT09IHBbMF0pIHsgdGhpcy5kYXRhLnVpLmhvdmVyZWQgPSBudWxsOyB9XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7XG5cdFx0XHR9LFxuXHRcdFx0c2VsZWN0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBjaGVjaywgZSkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogPT0gLTEgfHwgIW9iaiB8fCAhb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS51aSxcblx0XHRcdFx0XHRpc19tdWx0aXBsZSA9IChzLnNlbGVjdF9tdWx0aXBsZV9tb2RpZmllciA9PSBcIm9uXCIgfHwgKHMuc2VsZWN0X211bHRpcGxlX21vZGlmaWVyICE9PSBmYWxzZSAmJiBlICYmIGVbcy5zZWxlY3RfbXVsdGlwbGVfbW9kaWZpZXIgKyBcIktleVwiXSkpLFxuXHRcdFx0XHRcdGlzX3JhbmdlID0gKHMuc2VsZWN0X3JhbmdlX21vZGlmaWVyICE9PSBmYWxzZSAmJiBlICYmIGVbcy5zZWxlY3RfcmFuZ2VfbW9kaWZpZXIgKyBcIktleVwiXSAmJiB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCAmJiB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZFswXSAhPT0gb2JqWzBdICYmIHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkLnBhcmVudCgpWzBdID09PSBvYmoucGFyZW50KClbMF0pLFxuXHRcdFx0XHRcdGlzX3NlbGVjdGVkID0gdGhpcy5pc19zZWxlY3RlZChvYmopLFxuXHRcdFx0XHRcdHByb2NlZWQgPSB0cnVlLFxuXHRcdFx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0XHRpZihjaGVjaykge1xuXHRcdFx0XHRcdGlmKHMuZGlzYWJsZV9zZWxlY3RpbmdfY2hpbGRyZW4gJiYgaXNfbXVsdGlwbGUgJiYgXG5cdFx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHRcdChvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwibGlcIikuY2hpbGRyZW4oXCJhLmpzdHJlZS1jbGlja2VkXCIpLmxlbmd0aCkgfHxcblx0XHRcdFx0XHRcdFx0KG9iai5jaGlsZHJlbihcInVsXCIpLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkOmVxKDApXCIpLmxlbmd0aClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2VlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHN3aXRjaCghMCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAoaXNfcmFuZ2UpOlxuXHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZC5hZGRDbGFzcyhcImpzdHJlZS1sYXN0LXNlbGVjdGVkXCIpO1xuXHRcdFx0XHRcdFx0XHRvYmogPSBvYmpbIG9iai5pbmRleCgpIDwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQuaW5kZXgoKSA/IFwibmV4dFVudGlsXCIgOiBcInByZXZVbnRpbFwiIF0oXCIuanN0cmVlLWxhc3Qtc2VsZWN0ZWRcIikuYW5kU2VsZigpO1xuXHRcdFx0XHRcdFx0XHRpZihzLnNlbGVjdF9saW1pdCA9PSAtMSB8fCBvYmoubGVuZ3RoIDwgcy5zZWxlY3RfbGltaXQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZC5yZW1vdmVDbGFzcyhcImpzdHJlZS1sYXN0LXNlbGVjdGVkXCIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZC5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMgIT09IHQuZGF0YS51aS5sYXN0X3NlbGVjdGVkWzBdKSB7IHQuZGVzZWxlY3Rfbm9kZSh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGlzX3NlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAoaXNfc2VsZWN0ZWQgJiYgIWlzX211bHRpcGxlKTogXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XG5cdFx0XHRcdFx0XHRcdGlzX3NlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdHByb2NlZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgKCFpc19zZWxlY3RlZCAmJiAhaXNfbXVsdGlwbGUpOiBcblx0XHRcdFx0XHRcdFx0aWYocy5zZWxlY3RfbGltaXQgPT0gLTEgfHwgcy5zZWxlY3RfbGltaXQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwoKTtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZWVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgKGlzX3NlbGVjdGVkICYmIGlzX211bHRpcGxlKTogXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgKCFpc19zZWxlY3RlZCAmJiBpc19tdWx0aXBsZSk6IFxuXHRcdFx0XHRcdFx0XHRpZihzLnNlbGVjdF9saW1pdCA9PSAtMSB8fCB0aGlzLmRhdGEudWkuc2VsZWN0ZWQubGVuZ3RoICsgMSA8PSBzLnNlbGVjdF9saW1pdCkgeyBcblx0XHRcdFx0XHRcdFx0XHRwcm9jZWVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocHJvY2VlZCAmJiAhaXNfc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRpZighaXNfcmFuZ2UpIHsgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgPSBvYmo7IH1cblx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwianN0cmVlLWNsaWNrZWRcIik7XG5cdFx0XHRcdFx0aWYocy5zZWxlY3RlZF9wYXJlbnRfb3Blbikge1xuXHRcdFx0XHRcdFx0b2JqLnBhcmVudHMoXCIuanN0cmVlLWNsb3NlZFwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgdC5vcGVuX25vZGUodGhpcywgZmFsc2UsIHRydWUpOyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5kYXRhLnVpLnNlbGVjdGVkID0gdGhpcy5kYXRhLnVpLnNlbGVjdGVkLmFkZChvYmopO1xuXHRcdFx0XHRcdHRoaXMuX2ZpeF9zY3JvbGwob2JqLmVxKDApKTtcblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcImVcIiA6IGUgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfZml4X3Njcm9sbCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0dmFyIGMgPSB0aGlzLmdldF9jb250YWluZXIoKVswXSwgdDtcblx0XHRcdFx0aWYoYy5zY3JvbGxIZWlnaHQgPiBjLm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT09IC0xIHx8ICFvYmoubGVuZ3RoIHx8ICFvYmouaXMoXCI6dmlzaWJsZVwiKSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHR0ID0gb2JqLm9mZnNldCgpLnRvcCAtIHRoaXMuZ2V0X2NvbnRhaW5lcigpLm9mZnNldCgpLnRvcDtcblx0XHRcdFx0XHRpZih0IDwgMCkgeyBcblx0XHRcdFx0XHRcdGMuc2Nyb2xsVG9wID0gYy5zY3JvbGxUb3AgKyB0IC0gMTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHQgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgKyAoYy5zY3JvbGxXaWR0aCA+IGMub2Zmc2V0V2lkdGggPyBzY3JvbGxiYXJfd2lkdGggOiAwKSA+IGMub2Zmc2V0SGVpZ2h0KSB7IFxuXHRcdFx0XHRcdFx0Yy5zY3JvbGxUb3AgPSBjLnNjcm9sbFRvcCArICh0IC0gYy5vZmZzZXRIZWlnaHQgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgKyAxICsgKGMuc2Nyb2xsV2lkdGggPiBjLm9mZnNldFdpZHRoID8gc2Nyb2xsYmFyX3dpZHRoIDogMCkpOyBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZXNlbGVjdF9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYodGhpcy5pc19zZWxlY3RlZChvYmopKSB7XG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYVwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbGlja2VkXCIpO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9IHRoaXMuZGF0YS51aS5zZWxlY3RlZC5ub3Qob2JqKTtcblx0XHRcdFx0XHRpZih0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZC5nZXQoMCkgPT09IG9iai5nZXQoMCkpIHsgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgPSB0aGlzLmRhdGEudWkuc2VsZWN0ZWQuZXEoMCk7IH1cblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dG9nZ2xlX3NlbGVjdCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKHRoaXMuaXNfc2VsZWN0ZWQob2JqKSkgeyB0aGlzLmRlc2VsZWN0X25vZGUob2JqKTsgfVxuXHRcdFx0XHRlbHNlIHsgdGhpcy5zZWxlY3Rfbm9kZShvYmopOyB9XG5cdFx0XHR9LFxuXHRcdFx0aXNfc2VsZWN0ZWQgOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0aGlzLmRhdGEudWkuc2VsZWN0ZWQuaW5kZXgodGhpcy5fZ2V0X25vZGUob2JqKSkgPj0gMDsgfSxcblx0XHRcdGdldF9zZWxlY3RlZCA6IGZ1bmN0aW9uIChjb250ZXh0KSB7IFxuXHRcdFx0XHRyZXR1cm4gY29udGV4dCA/ICQoY29udGV4dCkuZmluZChcImEuanN0cmVlLWNsaWNrZWRcIikucGFyZW50KCkgOiB0aGlzLmRhdGEudWkuc2VsZWN0ZWQ7IFxuXHRcdFx0fSxcblx0XHRcdGRlc2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0XHRcdHZhciByZXQgPSBjb250ZXh0ID8gJChjb250ZXh0KS5maW5kKFwiYS5qc3RyZWUtY2xpY2tlZFwiKS5wYXJlbnQoKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpLnBhcmVudCgpO1xuXHRcdFx0XHRyZXQuY2hpbGRyZW4oXCJhLmpzdHJlZS1jbGlja2VkXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWNsaWNrZWRcIik7XG5cdFx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9ICQoW10pO1xuXHRcdFx0XHR0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogcmV0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdC8vIGluY2x1ZGUgdGhlIHNlbGVjdGlvbiBwbHVnaW4gYnkgZGVmYXVsdFxuXHQkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJ1aVwiKTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qIFxuICoganNUcmVlIENSUk0gcGx1Z2luXG4gKiBIYW5kbGVzIGNyZWF0aW5nL3JlbmFtaW5nL3JlbW92aW5nL21vdmluZyBub2RlcyBieSB1c2VyIGludGVyYWN0aW9uLlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwiY3JybVwiLCB7IFxuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwibW92ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY3JybS5tb3ZlLm9wZW5fb25tb3ZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQubnAucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiKS5hbmRTZWxmKCkuZmlsdGVyKFwiLmpzdHJlZS1jbG9zZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHQub3Blbl9ub2RlKHRoaXMsIGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRpbnB1dF93aWR0aF9saW1pdCA6IDIwMCxcblx0XHRcdG1vdmUgOiB7XG5cdFx0XHRcdGFsd2F5c19jb3B5XHRcdFx0OiBmYWxzZSwgLy8gZmFsc2UsIHRydWUgb3IgXCJtdWx0aXRyZWVcIlxuXHRcdFx0XHRvcGVuX29ubW92ZVx0XHRcdDogdHJ1ZSxcblx0XHRcdFx0ZGVmYXVsdF9wb3NpdGlvblx0OiBcImxhc3RcIixcblx0XHRcdFx0Y2hlY2tfbW92ZVx0XHRcdDogZnVuY3Rpb24gKG0pIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdF9zaG93X2lucHV0IDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0dmFyIHJ0bCA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUucnRsLFxuXHRcdFx0XHRcdHcgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jcnJtLmlucHV0X3dpZHRoX2xpbWl0LFxuXHRcdFx0XHRcdHcxID0gb2JqLmNoaWxkcmVuKFwiaW5zXCIpLndpZHRoKCksXG5cdFx0XHRcdFx0dzIgPSBvYmouZmluZChcIj4gYTp2aXNpYmxlID4gaW5zXCIpLndpZHRoKCkgKiBvYmouZmluZChcIj4gYTp2aXNpYmxlID4gaW5zXCIpLmxlbmd0aCxcblx0XHRcdFx0XHR0ID0gdGhpcy5nZXRfdGV4dChvYmopLFxuXHRcdFx0XHRcdGgxID0gJChcIjxkaXYgLz5cIiwgeyBjc3MgOiB7IFwicG9zaXRpb25cIiA6IFwiYWJzb2x1dGVcIiwgXCJ0b3BcIiA6IFwiLTIwMHB4XCIsIFwibGVmdFwiIDogKHJ0bCA/IFwiMHB4XCIgOiBcIi0xMDAwcHhcIiksIFwidmlzaWJpbGl0eVwiIDogXCJoaWRkZW5cIiB9IH0pLmFwcGVuZFRvKFwiYm9keVwiKSxcblx0XHRcdFx0XHRoMiA9IG9iai5jc3MoXCJwb3NpdGlvblwiLFwicmVsYXRpdmVcIikuYXBwZW5kKFxuXHRcdFx0XHRcdCQoXCI8aW5wdXQgLz5cIiwgeyBcblx0XHRcdFx0XHRcdFwidmFsdWVcIiA6IHQsXG5cdFx0XHRcdFx0XHRcImNsYXNzXCIgOiBcImpzdHJlZS1yZW5hbWUtaW5wdXRcIixcblx0XHRcdFx0XHRcdC8vIFwic2l6ZVwiIDogdC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcImNzc1wiIDoge1xuXHRcdFx0XHRcdFx0XHRcInBhZGRpbmdcIiA6IFwiMFwiLFxuXHRcdFx0XHRcdFx0XHRcImJvcmRlclwiIDogXCIxcHggc29saWQgc2lsdmVyXCIsXG5cdFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIiA6IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHRcdFx0XCJsZWZ0XCIgIDogKHJ0bCA/IFwiYXV0b1wiIDogKHcxICsgdzIgKyA0KSArIFwicHhcIiksXG5cdFx0XHRcdFx0XHRcdFwicmlnaHRcIiA6IChydGwgPyAodzEgKyB3MiArIDQpICsgXCJweFwiIDogXCJhdXRvXCIpLFxuXHRcdFx0XHRcdFx0XHRcInRvcFwiIDogXCIwcHhcIixcblx0XHRcdFx0XHRcdFx0XCJoZWlnaHRcIiA6ICh0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgLSAyKSArIFwicHhcIixcblx0XHRcdFx0XHRcdFx0XCJsaW5lSGVpZ2h0XCIgOiAodGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0IC0gMikgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIiA6IFwiMTUwcHhcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImJsdXJcIiA6ICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IG9iai5jaGlsZHJlbihcIi5qc3RyZWUtcmVuYW1lLWlucHV0XCIpLFxuXHRcdFx0XHRcdFx0XHRcdHYgPSBpLnZhbCgpO1xuXHRcdFx0XHRcdFx0XHRpZih2ID09PSBcIlwiKSB7IHYgPSB0OyB9XG5cdFx0XHRcdFx0XHRcdGgxLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpLnJlbW92ZSgpOyAvLyByb2xsYmFjayBwdXJwb3Nlc1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldF90ZXh0KG9iaix0KTsgLy8gcm9sbGJhY2sgcHVycG9zZXNcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW5hbWVfbm9kZShvYmosIHYpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgdiwgdCk7XG5cdFx0XHRcdFx0XHRcdG9iai5jc3MoXCJwb3NpdGlvblwiLFwiXCIpO1xuXHRcdFx0XHRcdFx0fSwgdGhpcyksXG5cdFx0XHRcdFx0XHRcImtleXVwXCIgOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PSAyNykgeyB0aGlzLnZhbHVlID0gdDsgdGhpcy5ibHVyKCk7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmKGtleSA9PSAxMykgeyB0aGlzLmJsdXIoKTsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGgyLndpZHRoKE1hdGgubWluKGgxLnRleHQoXCJwV1wiICsgdGhpcy52YWx1ZSkud2lkdGgoKSx3KSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImtleXByZXNzXCIgOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0XHR2YXIga2V5ID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaDtcblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09IDEzKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdCkuY2hpbGRyZW4oXCIuanN0cmVlLXJlbmFtZS1pbnB1dFwiKTsgXG5cdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqLCBcIlwiKTtcblx0XHRcdFx0aDEuY3NzKHtcblx0XHRcdFx0XHRcdGZvbnRGYW1pbHlcdFx0OiBoMi5jc3MoJ2ZvbnRGYW1pbHknKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTaXplXHRcdDogaDIuY3NzKCdmb250U2l6ZScpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFdlaWdodFx0XHQ6IGgyLmNzcygnZm9udFdlaWdodCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFN0eWxlXHRcdDogaDIuY3NzKCdmb250U3R5bGUnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTdHJldGNoXHRcdDogaDIuY3NzKCdmb250U3RyZXRjaCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFZhcmlhbnRcdFx0OiBoMi5jc3MoJ2ZvbnRWYXJpYW50JylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRsZXR0ZXJTcGFjaW5nXHQ6IGgyLmNzcygnbGV0dGVyU3BhY2luZycpXHR8fCAnJyxcblx0XHRcdFx0XHRcdHdvcmRTcGFjaW5nXHRcdDogaDIuY3NzKCd3b3JkU3BhY2luZycpXHRcdHx8ICcnXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRoMi53aWR0aChNYXRoLm1pbihoMS50ZXh0KFwicFdcIiArIGgyWzBdLnZhbHVlKS53aWR0aCgpLHcpKVswXS5zZWxlY3QoKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5hbWUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHR2YXIgZiA9IHRoaXMuX19jYWxsYmFjaztcblx0XHRcdFx0dGhpcy5fc2hvd19pbnB1dChvYmosIGZ1bmN0aW9uIChvYmosIG5ld19uYW1lLCBvbGRfbmFtZSkgeyBcblx0XHRcdFx0XHRmLmNhbGwodGhpcywgeyBcIm9ialwiIDogb2JqLCBcIm5ld19uYW1lXCIgOiBuZXdfbmFtZSwgXCJvbGRfbmFtZVwiIDogb2xkX25hbWUgfSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZSA6IGZ1bmN0aW9uIChvYmosIHBvc2l0aW9uLCBqcywgY2FsbGJhY2ssIHNraXBfcmVuYW1lKSB7XG5cdFx0XHRcdHZhciB0LCBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmopIHsgb2JqID0gLTE7IH1cblx0XHRcdFx0dGhpcy5fX3JvbGxiYWNrKCk7XG5cdFx0XHRcdHQgPSB0aGlzLmNyZWF0ZV9ub2RlKG9iaiwgcG9zaXRpb24sIGpzLCBmdW5jdGlvbiAodCkge1xuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5fZ2V0X3BhcmVudCh0KSxcblx0XHRcdFx0XHRcdHBvcyA9ICQodCkuaW5kZXgoKTtcblx0XHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHQpOyB9XG5cdFx0XHRcdFx0aWYocC5sZW5ndGggJiYgcC5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgdGhpcy5vcGVuX25vZGUocCwgZmFsc2UsIHRydWUpOyB9XG5cdFx0XHRcdFx0aWYoIXNraXBfcmVuYW1lKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5fc2hvd19pbnB1dCh0LCBmdW5jdGlvbiAob2JqLCBuZXdfbmFtZSwgb2xkX25hbWUpIHsgXG5cdFx0XHRcdFx0XHRcdF90aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcIm5hbWVcIiA6IG5ld19uYW1lLCBcInBhcmVudFwiIDogcCwgXCJwb3NpdGlvblwiIDogcG9zIH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyBfdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IHQsIFwibmFtZVwiIDogdGhpcy5nZXRfdGV4dCh0KSwgXCJwYXJlbnRcIiA6IHAsIFwicG9zaXRpb25cIiA6IHBvcyB9KTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHQ7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHR2YXIgcCA9IHRoaXMuX2dldF9wYXJlbnQob2JqKSwgcHJldiA9IHRoaXMuX2dldF9wcmV2KG9iaik7XG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHRvYmogPSB0aGlzLmRlbGV0ZV9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iaiAhPT0gZmFsc2UpIHsgdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJwcmV2XCIgOiBwcmV2LCBcInBhcmVudFwiIDogcCB9KTsgfVxuXHRcdFx0fSxcblx0XHRcdGNoZWNrX21vdmUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmKCF0aGlzLl9fY2FsbF9vbGQoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jcnJtLm1vdmU7XG5cdFx0XHRcdGlmKCFzLmNoZWNrX21vdmUuY2FsbCh0aGlzLCB0aGlzLl9nZXRfbW92ZSgpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0bW92ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcmVmLCBwb3NpdGlvbiwgaXNfY29weSwgaXNfcHJlcGFyZWQsIHNraXBfY2hlY2spIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jcnJtLm1vdmU7XG5cdFx0XHRcdGlmKCFpc19wcmVwYXJlZCkgeyBcblx0XHRcdFx0XHRpZih0eXBlb2YgcG9zaXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHsgcG9zaXRpb24gPSBzLmRlZmF1bHRfcG9zaXRpb247IH1cblx0XHRcdFx0XHRpZihwb3NpdGlvbiA9PT0gXCJpbnNpZGVcIiAmJiAhcy5kZWZhdWx0X3Bvc2l0aW9uLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykpIHsgcG9zaXRpb24gPSBzLmRlZmF1bHRfcG9zaXRpb247IH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fX2NhbGxfb2xkKHRydWUsIG9iaiwgcmVmLCBwb3NpdGlvbiwgaXNfY29weSwgZmFsc2UsIHNraXBfY2hlY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBtb3ZlIGlzIGFscmVhZHkgcHJlcGFyZWRcblx0XHRcdFx0aWYocy5hbHdheXNfY29weSA9PT0gdHJ1ZSB8fCAocy5hbHdheXNfY29weSA9PT0gXCJtdWx0aXRyZWVcIiAmJiBvYmoucnQuZ2V0X2luZGV4KCkgIT09IG9iai5vdC5nZXRfaW5kZXgoKSApKSB7XG5cdFx0XHRcdFx0aXNfY29weSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX2NhbGxfb2xkKHRydWUsIG9iaiwgcmVmLCBwb3NpdGlvbiwgaXNfY29weSwgdHJ1ZSwgc2tpcF9jaGVjayk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjdXQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS5jcnJtLmNwX25vZGVzID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZGF0YS5jcnJtLmN0X25vZGVzID0gb2JqO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdGNvcHkgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS5jcnJtLmN0X25vZGVzID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZGF0YS5jcnJtLmNwX25vZGVzID0gb2JqO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdHBhc3RlIDogZnVuY3Rpb24gKG9iaikgeyBcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIG5vZGVzID0gdGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMgPyB0aGlzLmRhdGEuY3JybS5jdF9ub2RlcyA6IHRoaXMuZGF0YS5jcnJtLmNwX25vZGVzO1xuXHRcdFx0XHRpZighdGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMgJiYgIXRoaXMuZGF0YS5jcnJtLmNwX25vZGVzKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZih0aGlzLmRhdGEuY3JybS5jdF9ub2RlcykgeyB0aGlzLm1vdmVfbm9kZSh0aGlzLmRhdGEuY3JybS5jdF9ub2Rlcywgb2JqKTsgdGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMgPSBmYWxzZTsgfVxuXHRcdFx0XHRpZih0aGlzLmRhdGEuY3JybS5jcF9ub2RlcykgeyB0aGlzLm1vdmVfbm9kZSh0aGlzLmRhdGEuY3JybS5jcF9ub2Rlcywgb2JqLCBmYWxzZSwgdHJ1ZSk7IH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJub2Rlc1wiIDogbm9kZXMgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0Ly8gaW5jbHVkZSB0aGUgY3JyIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImNycm1cIik7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSB0aGVtZXMgcGx1Z2luXG4gKiBIYW5kbGVzIGxvYWRpbmcgYW5kIHNldHRpbmcgdGhlbWVzLCBhcyB3ZWxsIGFzIGRldGVjdGluZyBwYXRoIHRvIHRoZW1lcywgZXRjLlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIHRoZW1lc19sb2FkZWQgPSBbXTtcblx0Ly8gdGhpcyB2YXJpYWJsZSBzdG9yZXMgdGhlIHBhdGggdG8gdGhlIHRoZW1lcyBmb2xkZXIgLSBpZiBsZWZ0IGFzIGZhbHNlIC0gaXQgd2lsbCBiZSBhdXRvZGV0ZWN0ZWRcblx0JC5qc3RyZWUuX3RoZW1lcyA9IGZhbHNlO1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJ0aGVtZXNcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50aGVtZXM7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEudGhlbWVzLmRvdHMgPSBzLmRvdHM7IFxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLnRoZW1lcy5pY29ucyA9IHMuaWNvbnM7IFxuXHRcdFx0XHRcdFx0dGhpcy5zZXRfdGhlbWUocy50aGVtZSwgcy51cmwpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImxvYWRlZC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQvLyBib3VuZCBoZXJlIHRvbywgYXMgc2ltcGxlIEhUTUwgdHJlZSdzIHdvbid0IGhvbm9yIGRvdHMgJiBpY29ucyBvdGhlcndpc2Vcblx0XHRcdFx0XHRcdGlmKCF0aGlzLmRhdGEudGhlbWVzLmRvdHMpIHsgdGhpcy5oaWRlX2RvdHMoKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRoaXMuc2hvd19kb3RzKCk7IH1cblx0XHRcdFx0XHRcdGlmKCF0aGlzLmRhdGEudGhlbWVzLmljb25zKSB7IHRoaXMuaGlkZV9pY29ucygpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgdGhpcy5zaG93X2ljb25zKCk7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHR0aGVtZSA6IFwiZGVmYXVsdFwiLCBcblx0XHRcdHVybCA6IGZhbHNlLFxuXHRcdFx0ZG90cyA6IHRydWUsXG5cdFx0XHRpY29ucyA6IHRydWVcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdHNldF90aGVtZSA6IGZ1bmN0aW9uICh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcblx0XHRcdFx0aWYoIXRoZW1lX25hbWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKCF0aGVtZV91cmwpIHsgdGhlbWVfdXJsID0gJC5qc3RyZWUuX3RoZW1lcyArIHRoZW1lX25hbWUgKyAnL3N0eWxlLmNzcyc7IH1cblx0XHRcdFx0aWYoJC5pbkFycmF5KHRoZW1lX3VybCwgdGhlbWVzX2xvYWRlZCkgPT0gLTEpIHtcblx0XHRcdFx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgXCJ1cmxcIiA6IHRoZW1lX3VybCB9KTtcblx0XHRcdFx0XHR0aGVtZXNfbG9hZGVkLnB1c2godGhlbWVfdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLmRhdGEudGhlbWVzLnRoZW1lICE9IHRoZW1lX25hbWUpIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTtcblx0XHRcdFx0XHR0aGlzLmRhdGEudGhlbWVzLnRoZW1lID0gdGhlbWVfbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5hZGRDbGFzcygnanN0cmVlLScgKyB0aGVtZV9uYW1lKTtcblx0XHRcdFx0aWYoIXRoaXMuZGF0YS50aGVtZXMuZG90cykgeyB0aGlzLmhpZGVfZG90cygpOyB9XG5cdFx0XHRcdGVsc2UgeyB0aGlzLnNob3dfZG90cygpOyB9XG5cdFx0XHRcdGlmKCF0aGlzLmRhdGEudGhlbWVzLmljb25zKSB7IHRoaXMuaGlkZV9pY29ucygpOyB9XG5cdFx0XHRcdGVsc2UgeyB0aGlzLnNob3dfaWNvbnMoKTsgfVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRfdGhlbWVcdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhLnRoZW1lcy50aGVtZTsgfSxcblxuXHRcdFx0c2hvd19kb3RzXHQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5kYXRhLnRoZW1lcy5kb3RzID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpOyB9LFxuXHRcdFx0aGlkZV9kb3RzXHQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5kYXRhLnRoZW1lcy5kb3RzID0gZmFsc2U7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbm8tZG90c1wiKTsgfSxcblx0XHRcdHRvZ2dsZV9kb3RzXHQ6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5kYXRhLnRoZW1lcy5kb3RzKSB7IHRoaXMuaGlkZV9kb3RzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19kb3RzKCk7IH0gfSxcblxuXHRcdFx0c2hvd19pY29uc1x0OiBmdW5jdGlvbiAoKSB7IHRoaXMuZGF0YS50aGVtZXMuaWNvbnMgPSB0cnVlOyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWljb25zXCIpOyB9LFxuXHRcdFx0aGlkZV9pY29uc1x0OiBmdW5jdGlvbiAoKSB7IHRoaXMuZGF0YS50aGVtZXMuaWNvbnMgPSBmYWxzZTsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5hZGRDbGFzcyhcImpzdHJlZS1uby1pY29uc1wiKTsgfSxcblx0XHRcdHRvZ2dsZV9pY29uczogZnVuY3Rpb24gKCkgeyBpZih0aGlzLmRhdGEudGhlbWVzLmljb25zKSB7IHRoaXMuaGlkZV9pY29ucygpOyB9IGVsc2UgeyB0aGlzLnNob3dfaWNvbnMoKTsgfSB9XG5cdFx0fVxuXHR9KTtcblx0Ly8gYXV0b2RldGVjdCB0aGVtZXMgcGF0aFxuXHQkKGZ1bmN0aW9uICgpIHtcblx0XHRpZigkLmpzdHJlZS5fdGhlbWVzID09PSBmYWxzZSkge1xuXHRcdFx0JChcInNjcmlwdFwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdGlmKHRoaXMuc3JjLnRvU3RyaW5nKCkubWF0Y2goL2pxdWVyeVxcLmpzdHJlZVteXFwvXSo/XFwuanMoXFw/LiopPyQvKSkgeyBcblx0XHRcdFx0XHQkLmpzdHJlZS5fdGhlbWVzID0gdGhpcy5zcmMudG9TdHJpbmcoKS5yZXBsYWNlKC9qcXVlcnlcXC5qc3RyZWVbXlxcL10qP1xcLmpzKFxcPy4qKT8kLywgXCJcIikgKyAndGhlbWVzLyc7IFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZigkLmpzdHJlZS5fdGhlbWVzID09PSBmYWxzZSkgeyAkLmpzdHJlZS5fdGhlbWVzID0gXCJ0aGVtZXMvXCI7IH1cblx0fSk7XG5cdC8vIGluY2x1ZGUgdGhlIHRoZW1lcyBwbHVnaW4gYnkgZGVmYXVsdFxuXHQkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJ0aGVtZXNcIik7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuICoganNUcmVlIGhvdGtleXMgcGx1Z2luXG4gKiBFbmFibGVzIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGFsbCB0cmVlIGluc3RhbmNlc1xuICogRGVwZW5kcyBvbiB0aGUganN0cmVlIHVpICYganF1ZXJ5IGhvdGtleXMgcGx1Z2luc1xuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIGJvdW5kID0gW107XG5cdGZ1bmN0aW9uIGV4ZWMoaSwgZXZlbnQpIHtcblx0XHR2YXIgZiA9ICQuanN0cmVlLl9mb2N1c2VkKCksIHRtcDtcblx0XHRpZihmICYmIGYuZGF0YSAmJiBmLmRhdGEuaG90a2V5cyAmJiBmLmRhdGEuaG90a2V5cy5lbmFibGVkKSB7IFxuXHRcdFx0dG1wID0gZi5fZ2V0X3NldHRpbmdzKCkuaG90a2V5c1tpXTtcblx0XHRcdGlmKHRtcCkgeyByZXR1cm4gdG1wLmNhbGwoZiwgZXZlbnQpOyB9XG5cdFx0fVxuXHR9XG5cdCQuanN0cmVlLnBsdWdpbihcImhvdGtleXNcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHR5cGVvZiAkLmhvdGtleXMgPT09IFwidW5kZWZpbmVkXCIpIHsgdGhyb3cgXCJqc1RyZWUgaG90a2V5czogalF1ZXJ5IGhvdGtleXMgcGx1Z2luIG5vdCBpbmNsdWRlZC5cIjsgfVxuXHRcdFx0aWYoIXRoaXMuZGF0YS51aSkgeyB0aHJvdyBcImpzVHJlZSBob3RrZXlzOiBqc1RyZWUgVUkgcGx1Z2luIG5vdCBpbmNsdWRlZC5cIjsgfVxuXHRcdFx0JC5lYWNoKHRoaXMuX2dldF9zZXR0aW5ncygpLmhvdGtleXMsIGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdGlmKHYgIT09IGZhbHNlICYmICQuaW5BcnJheShpLCBib3VuZCkgPT0gLTEpIHtcblx0XHRcdFx0XHQkKGRvY3VtZW50KS5iaW5kKFwia2V5ZG93blwiLCBpLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV4ZWMoaSwgZXZlbnQpOyB9KTtcblx0XHRcdFx0XHRib3VuZC5wdXNoKGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwibG9jay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuaG90a2V5cy5lbmFibGVkKSB7IHRoaXMuZGF0YS5ob3RrZXlzLmVuYWJsZWQgPSBmYWxzZTsgdGhpcy5kYXRhLmhvdGtleXMucmV2ZXJ0ID0gdHJ1ZTsgfVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcInVubG9jay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuaG90a2V5cy5yZXZlcnQpIHsgdGhpcy5kYXRhLmhvdGtleXMuZW5hYmxlZCA9IHRydWU7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR0aGlzLmVuYWJsZV9ob3RrZXlzKCk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdFwidXBcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgfHwgLTE7XG5cdFx0XHRcdHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfcHJldihvKSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0XCJjdHJsK3VwXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0fSxcblx0XHRcdFwic2hpZnQrdXBcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgfHwgLTE7XG5cdFx0XHRcdHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfcHJldihvKSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0XCJkb3duXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJjdHJsK2Rvd25cIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgfHwgLTE7XG5cdFx0XHRcdHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfbmV4dChvKSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRcInNoaWZ0K2Rvd25cIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgfHwgLTE7XG5cdFx0XHRcdHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfbmV4dChvKSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRcImxlZnRcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKG8pIHtcblx0XHRcdFx0XHRpZihvLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgdGhpcy5jbG9zZV9ub2RlKG8pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfcHJldihvKSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJjdHJsK2xlZnRcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKG8pIHtcblx0XHRcdFx0XHRpZihvLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgdGhpcy5jbG9zZV9ub2RlKG8pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfcHJldihvKSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJzaGlmdCtsZWZ0XCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZihvKSB7XG5cdFx0XHRcdFx0aWYoby5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHRoaXMuY2xvc2Vfbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwicmlnaHRcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihvLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyB0aGlzLm9wZW5fbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwiY3RybCtyaWdodFwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIG8gPSB0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZDtcblx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkge1xuXHRcdFx0XHRcdGlmKG8uaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IHRoaXMub3Blbl9ub2RlKG8pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfbmV4dChvKSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJzaGlmdCtyaWdodFwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIG8gPSB0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZDtcblx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkge1xuXHRcdFx0XHRcdGlmKG8uaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IHRoaXMub3Blbl9ub2RlKG8pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHRoaXMuaG92ZXJfbm9kZSh0aGlzLl9nZXRfbmV4dChvKSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJzcGFjZVwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0aWYodGhpcy5kYXRhLnVpLmhvdmVyZWQpIHsgdGhpcy5kYXRhLnVpLmhvdmVyZWQuY2hpbGRyZW4oXCJhOmVxKDApXCIpLmNsaWNrKCk7IH0gXG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0XCJjdHJsK3NwYWNlXCIgOiBmdW5jdGlvbiAoZXZlbnQpIHsgXG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBcImNsaWNrXCI7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aS5ob3ZlcmVkKSB7IHRoaXMuZGF0YS51aS5ob3ZlcmVkLmNoaWxkcmVuKFwiYTplcSgwKVwiKS50cmlnZ2VyKGV2ZW50KTsgfSBcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdH0sXG5cdFx0XHRcInNoaWZ0K3NwYWNlXCIgOiBmdW5jdGlvbiAoZXZlbnQpIHsgXG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBcImNsaWNrXCI7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aS5ob3ZlcmVkKSB7IHRoaXMuZGF0YS51aS5ob3ZlcmVkLmNoaWxkcmVuKFwiYTplcSgwKVwiKS50cmlnZ2VyKGV2ZW50KTsgfSBcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdH0sXG5cdFx0XHRcImYyXCIgOiBmdW5jdGlvbiAoKSB7IHRoaXMucmVuYW1lKHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkKTsgfSxcblx0XHRcdFwiZGVsXCIgOiBmdW5jdGlvbiAoKSB7IHRoaXMucmVtb3ZlKHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuX2dldF9ub2RlKG51bGwpKTsgfVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0ZW5hYmxlX2hvdGtleXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5ob3RrZXlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVfaG90a2V5cyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kYXRhLmhvdGtleXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBKU09OIHBsdWdpblxuICogVGhlIEpTT04gZGF0YSBzdG9yZS4gRGF0YXN0b3JlcyBhcmUgYnVpbGQgYnkgb3ZlcnJpZGluZyB0aGUgYGxvYWRfbm9kZWAgYW5kIGBfaXNfbG9hZGVkYCBmdW5jdGlvbnMuXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJqc29uX2RhdGFcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5qc29uX2RhdGE7XG5cdFx0XHRpZihzLnByb2dyZXNzaXZlX3VubG9hZCkge1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5iaW5kKFwiYWZ0ZXJfY2xvc2UuanN0cmVlXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0ZGF0YS5yc2x0Lm9iai5jaGlsZHJlbihcInVsXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDogeyBcblx0XHRcdC8vIGBkYXRhYCBjYW4gYmUgYSBmdW5jdGlvbjpcblx0XHRcdC8vICAqIGFjY2VwdHMgdHdvIGFyZ3VtZW50cyAtIG5vZGUgYmVpbmcgbG9hZGVkIGFuZCBhIGNhbGxiYWNrIHRvIHBhc3MgdGhlIHJlc3VsdCB0b1xuXHRcdFx0Ly8gICogd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgY3VycmVudCB0cmVlJ3Mgc2NvcGUgJiBhamF4IHdvbid0IGJlIHN1cHBvcnRlZFxuXHRcdFx0ZGF0YSA6IGZhbHNlLCBcblx0XHRcdGFqYXggOiBmYWxzZSxcblx0XHRcdGNvcnJlY3Rfc3RhdGUgOiB0cnVlLFxuXHRcdFx0cHJvZ3Jlc3NpdmVfcmVuZGVyIDogZmFsc2UsXG5cdFx0XHRwcm9ncmVzc2l2ZV91bmxvYWQgOiBmYWxzZVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0bG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHsgdmFyIF90aGlzID0gdGhpczsgdGhpcy5sb2FkX25vZGVfanNvbihvYmosIGZ1bmN0aW9uICgpIHsgX3RoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBfdGhpcy5fZ2V0X25vZGUob2JqKSB9KTsgc19jYWxsLmNhbGwodGhpcyk7IH0sIGVfY2FsbCk7IH0sXG5cdFx0XHRfaXNfbG9hZGVkIDogZnVuY3Rpb24gKG9iaikgeyBcblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5qc29uX2RhdGE7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7IFxuXHRcdFx0XHRyZXR1cm4gb2JqID09IC0xIHx8ICFvYmogfHwgKCFzLmFqYXggJiYgIXMucHJvZ3Jlc3NpdmVfcmVuZGVyICYmICEkLmlzRnVuY3Rpb24ocy5kYXRhKSkgfHwgb2JqLmlzKFwiLmpzdHJlZS1vcGVuLCAuanN0cmVlLWxlYWZcIikgfHwgb2JqLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKS5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblx0XHRcdHJlZnJlc2ggOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuanNvbl9kYXRhO1xuXHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSAmJiBzLnByb2dyZXNzaXZlX3VubG9hZCAmJiAoJC5pc0Z1bmN0aW9uKHMuZGF0YSkgfHwgISFzLmFqYXgpKSB7XG5cdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfY2hpbGRyZW5cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX19jYWxsX29sZCgpO1xuXHRcdFx0fSxcblx0XHRcdGxvYWRfbm9kZV9qc29uIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLmdldF9zZXR0aW5ncygpLmpzb25fZGF0YSwgZCxcblx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKCkge30sXG5cdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cblx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEgJiYgKHMucHJvZ3Jlc3NpdmVfcmVuZGVyIHx8IHMucHJvZ3Jlc3NpdmVfdW5sb2FkKSAmJiAhb2JqLmlzKFwiLmpzdHJlZS1vcGVuLCAuanN0cmVlLWxlYWZcIikgJiYgb2JqLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKS5sZW5ndGggPT09IDAgJiYgb2JqLmRhdGEoXCJqc3RyZWVfY2hpbGRyZW5cIikpIHtcblx0XHRcdFx0XHRkID0gdGhpcy5fcGFyc2VfanNvbihvYmouZGF0YShcImpzdHJlZV9jaGlsZHJlblwiKSwgb2JqKTtcblx0XHRcdFx0XHRpZihkKSB7XG5cdFx0XHRcdFx0XHRvYmouYXBwZW5kKGQpO1xuXHRcdFx0XHRcdFx0aWYoIXMucHJvZ3Jlc3NpdmVfdW5sb2FkKSB7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2NoaWxkcmVuXCIpOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xKSB7XG5cdFx0XHRcdFx0aWYob2JqLmRhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRlbHNlIHsgb2JqLmRhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiLHRydWUpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoKCEwKSB7XG5cdFx0XHRcdFx0Y2FzZSAoIXMuZGF0YSAmJiAhcy5hamF4KTogdGhyb3cgXCJOZWl0aGVyIGRhdGEgbm9yIGFqYXggc2V0dGluZ3Mgc3VwcGxpZWQuXCI7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uIGFkZGVkIGhlcmUgZm9yIGVhc2llciBtb2RlbCBpbnRlZ3JhdGlvbiAoYWxzbyBzdXBwb3J0aW5nIGFzeW5jIC0gc2VlIGNhbGxiYWNrKVxuXHRcdFx0XHRcdGNhc2UgKCQuaXNGdW5jdGlvbihzLmRhdGEpKTpcblx0XHRcdFx0XHRcdHMuZGF0YS5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRkID0gdGhpcy5fcGFyc2VfanNvbihkLCBvYmopO1xuXHRcdFx0XHRcdFx0XHRpZighZCkgeyBcblx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7IH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IHRoaXMuY29ycmVjdF9zdGF0ZShvYmopOyB9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKGVfY2FsbCkgeyBlX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiA9PT0gLTEgfHwgIW9iaikgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCkuYXBwZW5kKGQuY2hpbGRyZW4oKSk7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgb2JqLmFwcGVuZChkKS5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTsgb2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghIXMuZGF0YSAmJiAhcy5hamF4KSB8fCAoISFzLmRhdGEgJiYgISFzLmFqYXggJiYgKCFvYmogfHwgb2JqID09PSAtMSkpOlxuXHRcdFx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZCA9IHRoaXMuX3BhcnNlX2pzb24ocy5kYXRhLCBvYmopO1xuXHRcdFx0XHRcdFx0XHRpZihkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoIXMuZGF0YSAmJiAhIXMuYWpheCkgfHwgKCEhcy5kYXRhICYmICEhcy5hamF4ICYmIG9iaiAmJiBvYmogIT09IC0xKTpcblx0XHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoeCwgdCwgZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZWYgPSB0aGlzLmdldF9zZXR0aW5ncygpLmpzb25fZGF0YS5hamF4LmVycm9yOyBcblx0XHRcdFx0XHRcdFx0aWYoZWYpIHsgZWYuY2FsbCh0aGlzLCB4LCB0LCBlKTsgfVxuXHRcdFx0XHRcdFx0XHRpZihvYmogIT0gLTEgJiYgb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihlX2NhbGwpIHsgZV9jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRzdWNjZXNzX2Z1bmMgPSBmdW5jdGlvbiAoZCwgdCwgeCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgc2YgPSB0aGlzLmdldF9zZXR0aW5ncygpLmpzb25fZGF0YS5hamF4LnN1Y2Nlc3M7IFxuXHRcdFx0XHRcdFx0XHRpZihzZikgeyBkID0gc2YuY2FsbCh0aGlzLGQsdCx4KSB8fCBkOyB9XG5cdFx0XHRcdFx0XHRcdGlmKGQgPT09IFwiXCIgfHwgKGQgJiYgZC50b1N0cmluZyAmJiBkLnRvU3RyaW5nKCkucmVwbGFjZSgvXltcXHNcXG5dKyQvLFwiXCIpID09PSBcIlwiKSB8fCAoISQuaXNBcnJheShkKSAmJiAhJC5pc1BsYWluT2JqZWN0KGQpKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcl9mdW5jLmNhbGwodGhpcywgeCwgdCwgXCJcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZCA9IHRoaXMuX3BhcnNlX2pzb24oZCwgb2JqKTtcblx0XHRcdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiA9PT0gLTEgfHwgIW9iaikgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCkuYXBwZW5kKGQuY2hpbGRyZW4oKSk7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgb2JqLmFwcGVuZChkKS5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTsgb2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiA9PT0gLTEgfHwgIW9iaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHMuYWpheC5jb250ZXh0ID0gdGhpcztcblx0XHRcdFx0XHRcdHMuYWpheC5lcnJvciA9IGVycm9yX2Z1bmM7XG5cdFx0XHRcdFx0XHRzLmFqYXguc3VjY2VzcyA9IHN1Y2Nlc3NfZnVuYztcblx0XHRcdFx0XHRcdGlmKCFzLmFqYXguZGF0YVR5cGUpIHsgcy5hamF4LmRhdGFUeXBlID0gXCJqc29uXCI7IH1cblx0XHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmFqYXgudXJsKSkgeyBzLmFqYXgudXJsID0gcy5hamF4LnVybC5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmFqYXguZGF0YSkpIHsgcy5hamF4LmRhdGEgPSBzLmFqYXguZGF0YS5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0XHRcdCQuYWpheChzLmFqYXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VfanNvbiA6IGZ1bmN0aW9uIChqcywgb2JqLCBpc19jYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgZCA9IGZhbHNlLCBcblx0XHRcdFx0XHRwID0gdGhpcy5fZ2V0X3NldHRpbmdzKCksXG5cdFx0XHRcdFx0cyA9IHAuanNvbl9kYXRhLFxuXHRcdFx0XHRcdHQgPSBwLmNvcmUuaHRtbF90aXRsZXMsXG5cdFx0XHRcdFx0dG1wLCBpLCBqLCB1bDEsIHVsMjtcblxuXHRcdFx0XHRpZighanMpIHsgcmV0dXJuIGQ7IH1cblx0XHRcdFx0aWYocy5wcm9ncmVzc2l2ZV91bmxvYWQgJiYgb2JqICYmIG9iaiAhPT0gLTEpIHsgXG5cdFx0XHRcdFx0b2JqLmRhdGEoXCJqc3RyZWVfY2hpbGRyZW5cIiwgZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJC5pc0FycmF5KGpzKSkge1xuXHRcdFx0XHRcdGQgPSAkKCk7XG5cdFx0XHRcdFx0aWYoIWpzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBqcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuX3BhcnNlX2pzb24oanNbaV0sIG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZih0bXAubGVuZ3RoKSB7IGQgPSBkLmFkZCh0bXApOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBqcyA9PSBcInN0cmluZ1wiKSB7IGpzID0geyBkYXRhIDoganMgfTsgfVxuXHRcdFx0XHRcdGlmKCFqcy5kYXRhICYmIGpzLmRhdGEgIT09IFwiXCIpIHsgcmV0dXJuIGQ7IH1cblx0XHRcdFx0XHRkID0gJChcIjxsaSAvPlwiKTtcblx0XHRcdFx0XHRpZihqcy5hdHRyKSB7IGQuYXR0cihqcy5hdHRyKTsgfVxuXHRcdFx0XHRcdGlmKGpzLm1ldGFkYXRhKSB7IGQuZGF0YShqcy5tZXRhZGF0YSk7IH1cblx0XHRcdFx0XHRpZihqcy5zdGF0ZSkgeyBkLmFkZENsYXNzKFwianN0cmVlLVwiICsganMuc3RhdGUpOyB9XG5cdFx0XHRcdFx0aWYoISQuaXNBcnJheShqcy5kYXRhKSkgeyB0bXAgPSBqcy5kYXRhOyBqcy5kYXRhID0gW107IGpzLmRhdGEucHVzaCh0bXApOyB9XG5cdFx0XHRcdFx0JC5lYWNoKGpzLmRhdGEsIGZ1bmN0aW9uIChpLCBtKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSAkKFwiPGEgLz5cIik7XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24obSkpIHsgbSA9IG0uY2FsbCh0aGlzLCBqcyk7IH1cblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBtID09IFwic3RyaW5nXCIpIHsgdG1wLmF0dHIoJ2hyZWYnLCcjJylbIHQgPyBcImh0bWxcIiA6IFwidGV4dFwiIF0obSk7IH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZighbS5hdHRyKSB7IG0uYXR0ciA9IHt9OyB9XG5cdFx0XHRcdFx0XHRcdGlmKCFtLmF0dHIuaHJlZikgeyBtLmF0dHIuaHJlZiA9ICcjJzsgfVxuXHRcdFx0XHRcdFx0XHR0bXAuYXR0cihtLmF0dHIpWyB0ID8gXCJodG1sXCIgOiBcInRleHRcIiBdKG0udGl0bGUpO1xuXHRcdFx0XHRcdFx0XHRpZihtLmxhbmd1YWdlKSB7IHRtcC5hZGRDbGFzcyhtLmxhbmd1YWdlKTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG1wLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpO1xuXHRcdFx0XHRcdFx0aWYoIW0uaWNvbiAmJiBqcy5pY29uKSB7IG0uaWNvbiA9IGpzLmljb247IH1cblx0XHRcdFx0XHRcdGlmKG0uaWNvbikgeyBcblx0XHRcdFx0XHRcdFx0aWYobS5pY29uLmluZGV4T2YoXCIvXCIpID09PSAtMSkgeyB0bXAuY2hpbGRyZW4oXCJpbnNcIikuYWRkQ2xhc3MobS5pY29uKTsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgdG1wLmNoaWxkcmVuKFwiaW5zXCIpLmNzcyhcImJhY2tncm91bmRcIixcInVybCgnXCIgKyBtLmljb24gKyBcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XCIpOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkLmFwcGVuZCh0bXApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGQucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIik7XG5cdFx0XHRcdFx0aWYoanMuY2hpbGRyZW4pIHsgXG5cdFx0XHRcdFx0XHRpZihzLnByb2dyZXNzaXZlX3JlbmRlciAmJiBqcy5zdGF0ZSAhPT0gXCJvcGVuXCIpIHtcblx0XHRcdFx0XHRcdFx0ZC5hZGRDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikuZGF0YShcImpzdHJlZV9jaGlsZHJlblwiLCBqcy5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYocy5wcm9ncmVzc2l2ZV91bmxvYWQpIHsgZC5kYXRhKFwianN0cmVlX2NoaWxkcmVuXCIsIGpzLmNoaWxkcmVuKTsgfVxuXHRcdFx0XHRcdFx0XHRpZigkLmlzQXJyYXkoanMuY2hpbGRyZW4pICYmIGpzLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuX3BhcnNlX2pzb24oanMuY2hpbGRyZW4sIG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dWwyID0gJChcIjx1bCAvPlwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdHVsMi5hcHBlbmQodG1wKTtcblx0XHRcdFx0XHRcdFx0XHRcdGQuYXBwZW5kKHVsMik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHRcdHVsMSA9ICQoXCI8dWwgLz5cIik7XG5cdFx0XHRcdFx0dWwxLmFwcGVuZChkKTtcblx0XHRcdFx0XHRkID0gdWwxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fSxcblx0XHRcdGdldF9qc29uIDogZnVuY3Rpb24gKG9iaiwgbGlfYXR0ciwgYV9hdHRyLCBpc19jYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gW10sIFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKSwgXG5cdFx0XHRcdFx0X3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdHRtcDEsIHRtcDIsIGxpLCBhLCB0LCBsYW5nO1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gLTEpIHsgb2JqID0gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKTsgfVxuXHRcdFx0XHRsaV9hdHRyID0gJC5pc0FycmF5KGxpX2F0dHIpID8gbGlfYXR0ciA6IFsgXCJpZFwiLCBcImNsYXNzXCIgXTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrICYmIHRoaXMuZGF0YS50eXBlcykgeyBsaV9hdHRyLnB1c2gocy50eXBlcy50eXBlX2F0dHIpOyB9XG5cdFx0XHRcdGFfYXR0ciA9ICQuaXNBcnJheShhX2F0dHIpID8gYV9hdHRyIDogWyBdO1xuXG5cdFx0XHRcdG9iai5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsaSA9ICQodGhpcyk7XG5cdFx0XHRcdFx0dG1wMSA9IHsgZGF0YSA6IFtdIH07XG5cdFx0XHRcdFx0aWYobGlfYXR0ci5sZW5ndGgpIHsgdG1wMS5hdHRyID0geyB9OyB9XG5cdFx0XHRcdFx0JC5lYWNoKGxpX2F0dHIsIGZ1bmN0aW9uIChpLCB2KSB7IFxuXHRcdFx0XHRcdFx0dG1wMiA9IGxpLmF0dHIodik7IFxuXHRcdFx0XHRcdFx0aWYodG1wMiAmJiB0bXAyLmxlbmd0aCAmJiB0bXAyLnJlcGxhY2UoL2pzdHJlZVteIF0qL2lnLCcnKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG1wMS5hdHRyW3ZdID0gKFwiIFwiICsgdG1wMikucmVwbGFjZSgvIGpzdHJlZVteIF0qL2lnLCcnKS5yZXBsYWNlKC9cXHMrJC9pZyxcIiBcIikucmVwbGFjZSgvXiAvLFwiXCIpLnJlcGxhY2UoLyAkLyxcIlwiKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYobGkuaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkgeyB0bXAxLnN0YXRlID0gXCJvcGVuXCI7IH1cblx0XHRcdFx0XHRpZihsaS5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgdG1wMS5zdGF0ZSA9IFwiY2xvc2VkXCI7IH1cblx0XHRcdFx0XHRpZihsaS5kYXRhKCkpIHsgdG1wMS5tZXRhZGF0YSA9IGxpLmRhdGEoKTsgfVxuXHRcdFx0XHRcdGEgPSBsaS5jaGlsZHJlbihcImFcIik7XG5cdFx0XHRcdFx0YS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHQgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRcdGFfYXR0ci5sZW5ndGggfHwgXG5cdFx0XHRcdFx0XHRcdCQuaW5BcnJheShcImxhbmd1YWdlc1wiLCBzLnBsdWdpbnMpICE9PSAtMSB8fCBcblx0XHRcdFx0XHRcdFx0dC5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuc3R5bGUuYmFja2dyb3VuZEltYWdlLmxlbmd0aCB8fCBcblx0XHRcdFx0XHRcdFx0KHQuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLmNsYXNzTmFtZSAmJiB0LmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5jbGFzc05hbWUucmVwbGFjZSgvanN0cmVlW14gXSp8JC9pZywnJykubGVuZ3RoKVxuXHRcdFx0XHRcdFx0KSB7IFxuXHRcdFx0XHRcdFx0XHRsYW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShcImxhbmd1YWdlc1wiLCBzLnBsdWdpbnMpICE9PSAtMSAmJiAkLmlzQXJyYXkocy5sYW5ndWFnZXMpICYmIHMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChzLmxhbmd1YWdlcywgZnVuY3Rpb24gKGwsIGx2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0Lmhhc0NsYXNzKGx2KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYW5nID0gbHY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0bXAyID0geyBhdHRyIDogeyB9LCB0aXRsZSA6IF90aGlzLmdldF90ZXh0KHQsIGxhbmcpIH07IFxuXHRcdFx0XHRcdFx0XHQkLmVhY2goYV9hdHRyLCBmdW5jdGlvbiAoaywgeikge1xuXHRcdFx0XHRcdFx0XHRcdHRtcDIuYXR0clt6XSA9IChcIiBcIiArICh0LmF0dHIoeikgfHwgXCJcIikpLnJlcGxhY2UoLyBqc3RyZWVbXiBdKi9pZywnJykucmVwbGFjZSgvXFxzKyQvaWcsXCIgXCIpLnJlcGxhY2UoL14gLyxcIlwiKS5yZXBsYWNlKC8gJC8sXCJcIik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZigkLmluQXJyYXkoXCJsYW5ndWFnZXNcIiwgcy5wbHVnaW5zKSAhPT0gLTEgJiYgJC5pc0FycmF5KHMubGFuZ3VhZ2VzKSAmJiBzLmxhbmd1YWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkLmVhY2gocy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrLCB6KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0Lmhhc0NsYXNzKHopKSB7IHRtcDIubGFuZ3VhZ2UgPSB6OyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHQuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKS5yZXBsYWNlKC9eXFxzKyQvaWcsXCJcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wMi5pY29uID0gdC5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsJycpLnJlcGxhY2UoL1xccyskL2lnLFwiIFwiKS5yZXBsYWNlKC9eIC8sXCJcIikucmVwbGFjZSgvICQvLFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHQuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLnN0eWxlLmJhY2tncm91bmRJbWFnZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAyLmljb24gPSB0LmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UucmVwbGFjZShcInVybChcIixcIlwiKS5yZXBsYWNlKFwiKVwiLFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dG1wMiA9IF90aGlzLmdldF90ZXh0KHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoYS5sZW5ndGggPiAxKSB7IHRtcDEuZGF0YS5wdXNoKHRtcDIpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgdG1wMS5kYXRhID0gdG1wMjsgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGxpID0gbGkuZmluZChcIj4gdWwgPiBsaVwiKTtcblx0XHRcdFx0XHRpZihsaS5sZW5ndGgpIHsgdG1wMS5jaGlsZHJlbiA9IF90aGlzLmdldF9qc29uKGxpLCBsaV9hdHRyLCBhX2F0dHIsIHRydWUpOyB9XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2godG1wMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBsYW5ndWFnZXMgcGx1Z2luXG4gKiBBZGRzIHN1cHBvcnQgZm9yIG11bHRpcGxlIGxhbmd1YWdlIHZlcnNpb25zIGluIG9uZSB0cmVlXG4gKiBUaGlzIGJhc2ljYWxseSBhbGxvd3MgZm9yIG1hbnkgdGl0bGVzIGNvZXhpc3RpbmcgaW4gb25lIG5vZGUsIGJ1dCBvbmx5IG9uZSBvZiB0aGVtIGJlaW5nIHZpc2libGUgYXQgYW55IGdpdmVuIHRpbWVcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWludGFpbmluZyB0aGUgc2FtZSBzdHJ1Y3R1cmUgaW4gbWFueSBsYW5ndWFnZXMgKGhlbmNlIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4pXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHR2YXIgc2ggPSBmYWxzZTtcblx0JC5qc3RyZWUucGx1Z2luKFwibGFuZ3VhZ2VzXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2xvYWRfY3NzKCk7ICB9LFxuXHRcdGRlZmF1bHRzIDogW10sXG5cdFx0X2ZuIDoge1xuXHRcdFx0c2V0X2xhbmcgOiBmdW5jdGlvbiAoaSkgeyBcblx0XHRcdFx0dmFyIGxhbmdzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkubGFuZ3VhZ2VzLFxuXHRcdFx0XHRcdHN0ID0gZmFsc2UsXG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBcIi5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpICsgJyBhJztcblx0XHRcdFx0aWYoISQuaXNBcnJheShsYW5ncykgfHwgbGFuZ3MubGVuZ3RoID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZigkLmluQXJyYXkoaSxsYW5ncykgPT0gLTEpIHtcblx0XHRcdFx0XHRpZighIWxhbmdzW2ldKSB7IGkgPSBsYW5nc1tpXTsgfVxuXHRcdFx0XHRcdGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihpID09IHRoaXMuZGF0YS5sYW5ndWFnZXMuY3VycmVudF9sYW5ndWFnZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRzdCA9ICQudmFrYXRhLmNzcy5nZXRfY3NzKHNlbGVjdG9yICsgXCIuXCIgKyB0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2UsIGZhbHNlLCBzaCk7XG5cdFx0XHRcdGlmKHN0ICE9PSBmYWxzZSkgeyBzdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IH1cblx0XHRcdFx0c3QgPSAkLnZha2F0YS5jc3MuZ2V0X2NzcyhzZWxlY3RvciArIFwiLlwiICsgaSwgZmFsc2UsIHNoKTtcblx0XHRcdFx0aWYoc3QgIT09IGZhbHNlKSB7IHN0LnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS5sYW5ndWFnZXMuY3VycmVudF9sYW5ndWFnZSA9IGk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayhpKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X2xhbmcgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2U7XG5cdFx0XHR9LFxuXHRcdFx0X2dldF9zdHJpbmcgOiBmdW5jdGlvbiAoa2V5LCBsYW5nKSB7XG5cdFx0XHRcdHZhciBsYW5ncyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmxhbmd1YWdlcyxcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5zdHJpbmdzO1xuXHRcdFx0XHRpZigkLmlzQXJyYXkobGFuZ3MpICYmIGxhbmdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGxhbmcgPSAobGFuZyAmJiAkLmluQXJyYXkobGFuZyxsYW5ncykgIT0gLTEpID8gbGFuZyA6IHRoaXMuZGF0YS5sYW5ndWFnZXMuY3VycmVudF9sYW5ndWFnZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzW2xhbmddICYmIHNbbGFuZ11ba2V5XSkgeyByZXR1cm4gc1tsYW5nXVtrZXldOyB9XG5cdFx0XHRcdGlmKHNba2V5XSkgeyByZXR1cm4gc1trZXldOyB9XG5cdFx0XHRcdHJldHVybiBrZXk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X3RleHQgOiBmdW5jdGlvbiAob2JqLCBsYW5nKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaikgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKCFvYmouc2l6ZSgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgbGFuZ3MgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5sYW5ndWFnZXMsXG5cdFx0XHRcdFx0cyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuaHRtbF90aXRsZXM7XG5cdFx0XHRcdGlmKCQuaXNBcnJheShsYW5ncykgJiYgbGFuZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bGFuZyA9IChsYW5nICYmICQuaW5BcnJheShsYW5nLGxhbmdzKSAhPSAtMSkgPyBsYW5nIDogdGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlO1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jaGlsZHJlbihcImEuXCIgKyBsYW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgb2JqID0gb2JqLmNoaWxkcmVuKFwiYTplcSgwKVwiKTsgfVxuXHRcdFx0XHRpZihzKSB7XG5cdFx0XHRcdFx0b2JqID0gb2JqLmNsb25lKCk7XG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiSU5TXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdHJldHVybiBvYmouaHRtbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgfSlbMF07XG5cdFx0XHRcdFx0cmV0dXJuIG9iai5ub2RlVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRfdGV4dCA6IGZ1bmN0aW9uIChvYmosIHZhbCwgbGFuZykge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZighb2JqLnNpemUoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIGxhbmdzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkubGFuZ3VhZ2VzLFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmh0bWxfdGl0bGVzLFxuXHRcdFx0XHRcdHRtcDtcblx0XHRcdFx0aWYoJC5pc0FycmF5KGxhbmdzKSAmJiBsYW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRsYW5nID0gKGxhbmcgJiYgJC5pbkFycmF5KGxhbmcsbGFuZ3MpICE9IC0xKSA/IGxhbmcgOiB0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2U7XG5cdFx0XHRcdFx0b2JqID0gb2JqLmNoaWxkcmVuKFwiYS5cIiArIGxhbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyBvYmogPSBvYmouY2hpbGRyZW4oXCJhOmVxKDApXCIpOyB9XG5cdFx0XHRcdGlmKHMpIHtcblx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGRyZW4oXCJJTlNcIikuY2xvbmUoKTtcblx0XHRcdFx0XHRvYmouaHRtbCh2YWwpLnByZXBlbmQodG1wKTtcblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcIm5hbWVcIiA6IHZhbCwgXCJsYW5nXCIgOiBsYW5nIH0pO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgfSlbMF07XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJuYW1lXCIgOiB2YWwsIFwibGFuZ1wiIDogbGFuZyB9KTtcblx0XHRcdFx0XHRyZXR1cm4gKG9iai5ub2RlVmFsdWUgPSB2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2xvYWRfY3NzIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgbGFuZ3MgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5sYW5ndWFnZXMsXG5cdFx0XHRcdFx0c3RyID0gXCIvKiBsYW5ndWFnZXMgY3NzICovXCIsXG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBcIi5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpICsgJyBhJyxcblx0XHRcdFx0XHRsbjtcblx0XHRcdFx0aWYoJC5pc0FycmF5KGxhbmdzKSAmJiBsYW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2UgPSBsYW5nc1swXTtcblx0XHRcdFx0XHRmb3IobG4gPSAwOyBsbiA8IGxhbmdzLmxlbmd0aDsgbG4rKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHNlbGVjdG9yICsgXCIuXCIgKyBsYW5nc1tsbl0gKyBcIiB7XCI7XG5cdFx0XHRcdFx0XHRpZihsYW5nc1tsbl0gIT0gdGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlKSB7IHN0ciArPSBcIiBkaXNwbGF5Om5vbmU7IFwiOyB9XG5cdFx0XHRcdFx0XHRzdHIgKz0gXCIgfSBcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2ggPSAkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgJ3N0cicgOiBzdHIsICd0aXRsZScgOiBcImpzdHJlZS1sYW5ndWFnZXNcIiB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcG9zaXRpb24sIGpzLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuX19jYWxsX29sZCh0cnVlLCBvYmosIHBvc2l0aW9uLCBqcywgZnVuY3Rpb24gKHQpIHtcblx0XHRcdFx0XHR2YXIgbGFuZ3MgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5sYW5ndWFnZXMsXG5cdFx0XHRcdFx0XHRhID0gdC5jaGlsZHJlbihcImFcIiksXG5cdFx0XHRcdFx0XHRsbjtcblx0XHRcdFx0XHRpZigkLmlzQXJyYXkobGFuZ3MpICYmIGxhbmdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Zm9yKGxuID0gMDsgbG4gPCBsYW5ncy5sZW5ndGg7IGxuKyspIHtcblx0XHRcdFx0XHRcdFx0aWYoIWEuaXMoXCIuXCIgKyBsYW5nc1tsbl0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0dC5hcHBlbmQoYS5lcSgwKS5jbG9uZSgpLnJlbW92ZUNsYXNzKGxhbmdzLmpvaW4oXCIgXCIpKS5hZGRDbGFzcyhsYW5nc1tsbl0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YS5ub3QoXCIuXCIgKyBsYW5ncy5qb2luKFwiLCAuXCIpKS5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCB0KTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4gKiBqc1RyZWUgY29va2llcyBwbHVnaW5cbiAqIFN0b3JlcyB0aGUgY3VycmVudGx5IG9wZW5lZC9zZWxlY3RlZCBub2RlcyBpbiBhIGNvb2tpZSBhbmQgdGhlbiByZXN0b3JlcyB0aGVtXG4gKiBEZXBlbmRzIG9uIHRoZSBqcXVlcnkuY29va2llIHBsdWdpblxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwiY29va2llc1wiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodHlwZW9mICQuY29va2llID09PSBcInVuZGVmaW5lZFwiKSB7IHRocm93IFwianNUcmVlIGNvb2tpZTogalF1ZXJ5IGNvb2tpZSBwbHVnaW4gbm90IGluY2x1ZGVkLlwiOyB9XG5cblx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29va2llcyxcblx0XHRcdFx0dG1wO1xuXHRcdFx0aWYoISFzLnNhdmVfbG9hZGVkKSB7XG5cdFx0XHRcdHRtcCA9ICQuY29va2llKHMuc2F2ZV9sb2FkZWQpO1xuXHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkgeyB0aGlzLmRhdGEuY29yZS50b19sb2FkID0gdG1wLnNwbGl0KFwiLFwiKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYoISFzLnNhdmVfb3BlbmVkKSB7XG5cdFx0XHRcdHRtcCA9ICQuY29va2llKHMuc2F2ZV9vcGVuZWQpO1xuXHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkgeyB0aGlzLmRhdGEuY29yZS50b19vcGVuID0gdG1wLnNwbGl0KFwiLFwiKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYoISFzLnNhdmVfc2VsZWN0ZWQpIHtcblx0XHRcdFx0dG1wID0gJC5jb29raWUocy5zYXZlX3NlbGVjdGVkKTtcblx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGggJiYgdGhpcy5kYXRhLnVpKSB7IHRoaXMuZGF0YS51aS50b19zZWxlY3QgPSB0bXAuc3BsaXQoXCIsXCIpOyB9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQub25lKCAoIHRoaXMuZGF0YS51aSA/IFwicmVzZWxlY3RcIiA6IFwicmVvcGVuXCIgKSArIFwiLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0LmJpbmQoXCJvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlIHNlbGVjdF9ub2RlLmpzdHJlZSBkZXNlbGVjdF9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNvb2tpZXMuYXV0b19zYXZlKSB7IHRoaXMuc2F2ZV9jb29raWUoKGUuaGFuZGxlT2JqLm5hbWVzcGFjZSArIGUuaGFuZGxlT2JqLnR5cGUpLnJlcGxhY2UoXCJqc3RyZWVcIixcIlwiKSk7IH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdHNhdmVfbG9hZGVkXHRcdDogXCJqc3RyZWVfbG9hZFwiLFxuXHRcdFx0c2F2ZV9vcGVuZWRcdFx0OiBcImpzdHJlZV9vcGVuXCIsXG5cdFx0XHRzYXZlX3NlbGVjdGVkXHQ6IFwianN0cmVlX3NlbGVjdFwiLFxuXHRcdFx0YXV0b19zYXZlXHRcdDogdHJ1ZSxcblx0XHRcdGNvb2tpZV9vcHRpb25zXHQ6IHt9XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRzYXZlX2Nvb2tpZSA6IGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5jb3JlLnJlZnJlc2hpbmcpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29va2llcztcblx0XHRcdFx0aWYoIWMpIHsgLy8gaWYgY2FsbGVkIG1hbnVhbGx5IGFuZCBub3QgYnkgZXZlbnRcblx0XHRcdFx0XHRpZihzLnNhdmVfbG9hZGVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNhdmVfbG9hZGVkKCk7XG5cdFx0XHRcdFx0XHQkLmNvb2tpZShzLnNhdmVfbG9hZGVkLCB0aGlzLmRhdGEuY29yZS50b19sb2FkLmpvaW4oXCIsXCIpLCBzLmNvb2tpZV9vcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocy5zYXZlX29wZW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5zYXZlX29wZW5lZCgpO1xuXHRcdFx0XHRcdFx0JC5jb29raWUocy5zYXZlX29wZW5lZCwgdGhpcy5kYXRhLmNvcmUudG9fb3Blbi5qb2luKFwiLFwiKSwgcy5jb29raWVfb3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHMuc2F2ZV9zZWxlY3RlZCAmJiB0aGlzLmRhdGEudWkpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9zZWxlY3RlZCgpO1xuXHRcdFx0XHRcdFx0JC5jb29raWUocy5zYXZlX3NlbGVjdGVkLCB0aGlzLmRhdGEudWkudG9fc2VsZWN0LmpvaW4oXCIsXCIpLCBzLmNvb2tpZV9vcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaChjKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIm9wZW5fbm9kZVwiOlxuXHRcdFx0XHRcdGNhc2UgXCJjbG9zZV9ub2RlXCI6XG5cdFx0XHRcdFx0XHRpZighIXMuc2F2ZV9vcGVuZWQpIHsgXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9vcGVuZWQoKTsgXG5cdFx0XHRcdFx0XHRcdCQuY29va2llKHMuc2F2ZV9vcGVuZWQsIHRoaXMuZGF0YS5jb3JlLnRvX29wZW4uam9pbihcIixcIiksIHMuY29va2llX29wdGlvbnMpOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCEhcy5zYXZlX2xvYWRlZCkgeyBcblx0XHRcdFx0XHRcdFx0dGhpcy5zYXZlX2xvYWRlZCgpOyBcblx0XHRcdFx0XHRcdFx0JC5jb29raWUocy5zYXZlX2xvYWRlZCwgdGhpcy5kYXRhLmNvcmUudG9fbG9hZC5qb2luKFwiLFwiKSwgcy5jb29raWVfb3B0aW9ucyk7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInNlbGVjdF9ub2RlXCI6XG5cdFx0XHRcdFx0Y2FzZSBcImRlc2VsZWN0X25vZGVcIjpcblx0XHRcdFx0XHRcdGlmKCEhcy5zYXZlX3NlbGVjdGVkICYmIHRoaXMuZGF0YS51aSkgeyBcblx0XHRcdFx0XHRcdFx0dGhpcy5zYXZlX3NlbGVjdGVkKCk7IFxuXHRcdFx0XHRcdFx0XHQkLmNvb2tpZShzLnNhdmVfc2VsZWN0ZWQsIHRoaXMuZGF0YS51aS50b19zZWxlY3Quam9pbihcIixcIiksIHMuY29va2llX29wdGlvbnMpOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0Ly8gaW5jbHVkZSBjb29raWVzIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwiY29va2llc1wiKTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4gKiBqc1RyZWUgc29ydCBwbHVnaW5cbiAqIFNvcnRzIGl0ZW1zIGFscGhhYmV0aWNhbGx5IChvciB1c2luZyBhbnkgb3RoZXIgZnVuY3Rpb24pXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJzb3J0XCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcImxvYWRfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIG9iaiA9IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopO1xuXHRcdFx0XHRcdFx0b2JqID0gb2JqID09PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikgOiBvYmouY2hpbGRyZW4oXCJ1bFwiKTtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChvYmopO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcInJlbmFtZV9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWUgY3JlYXRlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5yc2x0Lm9iai5wYXJlbnQoKSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwibW92ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgbSA9IGRhdGEucnNsdC5ucCA9PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpIDogZGF0YS5yc2x0Lm5wO1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KG0uY2hpbGRyZW4oXCJ1bFwiKSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gdGhpcy5nZXRfdGV4dChhKSA+IHRoaXMuZ2V0X3RleHQoYikgPyAxIDogLTE7IH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0c29ydCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5zb3J0LFxuXHRcdFx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0XHRvYmouYXBwZW5kKCQubWFrZUFycmF5KG9iai5jaGlsZHJlbihcImxpXCIpKS5zb3J0KCQucHJveHkocywgdCkpKTtcblx0XHRcdFx0b2JqLmZpbmQoXCI+IGxpID4gdWxcIikuZWFjaChmdW5jdGlvbigpIHsgdC5zb3J0KCQodGhpcykpOyB9KTtcblx0XHRcdFx0dGhpcy5jbGVhbl9ub2RlKG9iaik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4gKiBqc1RyZWUgRE5EIHBsdWdpblxuICogRHJhZyBhbmQgZHJvcCBwbHVnaW4gZm9yIG1vdmluZy9jb3B5aW5nIG5vZGVzXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHR2YXIgbyA9IGZhbHNlLFxuXHRcdHIgPSBmYWxzZSxcblx0XHRtID0gZmFsc2UsXG5cdFx0bWwgPSBmYWxzZSxcblx0XHRzbGkgPSBmYWxzZSxcblx0XHRzdGkgPSBmYWxzZSxcblx0XHRkaXIxID0gZmFsc2UsXG5cdFx0ZGlyMiA9IGZhbHNlLFxuXHRcdGxhc3RfcG9zID0gZmFsc2U7XG5cdCQudmFrYXRhLmRuZCA9IHtcblx0XHRpc19kb3duIDogZmFsc2UsXG5cdFx0aXNfZHJhZyA6IGZhbHNlLFxuXHRcdGhlbHBlciA6IGZhbHNlLFxuXHRcdHNjcm9sbF9zcGQgOiAxMCxcblx0XHRpbml0X3ggOiAwLFxuXHRcdGluaXRfeSA6IDAsXG5cdFx0dGhyZXNob2xkIDogNSxcblx0XHRoZWxwZXJfbGVmdCA6IDUsXG5cdFx0aGVscGVyX3RvcCA6IDEwLFxuXHRcdHVzZXJfZGF0YSA6IHt9LFxuXG5cdFx0ZHJhZ19zdGFydCA6IGZ1bmN0aW9uIChlLCBkYXRhLCBodG1sKSB7IFxuXHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcpIHsgJC52YWthdGEuZHJhZ19zdG9wKHt9KTsgfVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LnVuc2VsZWN0YWJsZSA9IFwib25cIjtcblx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXHRcdFx0XHRpZihlLmN1cnJlbnRUYXJnZXQuc3R5bGUpIHsgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjsgfVxuXHRcdFx0fSBjYXRjaChlcnIpIHsgfVxuXHRcdFx0JC52YWthdGEuZG5kLmluaXRfeCA9IGUucGFnZVg7XG5cdFx0XHQkLnZha2F0YS5kbmQuaW5pdF95ID0gZS5wYWdlWTtcblx0XHRcdCQudmFrYXRhLmRuZC51c2VyX2RhdGEgPSBkYXRhO1xuXHRcdFx0JC52YWthdGEuZG5kLmlzX2Rvd24gPSB0cnVlO1xuXHRcdFx0JC52YWthdGEuZG5kLmhlbHBlciA9ICQoXCI8ZGl2IGlkPSd2YWthdGEtZHJhZ2dlZCcgLz5cIikuaHRtbChodG1sKTsgLy8uZmFkZVRvKDEwLDAuMjUpO1xuXHRcdFx0JChkb2N1bWVudCkuYmluZChcIm1vdXNlbW92ZVwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XG5cdFx0XHQkKGRvY3VtZW50KS5iaW5kKFwibW91c2V1cFwiLCAkLnZha2F0YS5kbmQuZHJhZ19zdG9wKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGRyYWcgOiBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdGlmKCEkLnZha2F0YS5kbmQuaXNfZG93bikgeyByZXR1cm47IH1cblx0XHRcdGlmKCEkLnZha2F0YS5kbmQuaXNfZHJhZykge1xuXHRcdFx0XHRpZihNYXRoLmFicyhlLnBhZ2VYIC0gJC52YWthdGEuZG5kLmluaXRfeCkgPiA1IHx8IE1hdGguYWJzKGUucGFnZVkgLSAkLnZha2F0YS5kbmQuaW5pdF95KSA+IDUpIHsgXG5cdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5hcHBlbmRUbyhcImJvZHlcIik7XG5cdFx0XHRcdFx0JC52YWthdGEuZG5kLmlzX2RyYWcgPSB0cnVlO1xuXHRcdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZHJhZ19zdGFydC52YWthdGFcIiwgeyBcImV2ZW50XCIgOiBlLCBcImRhdGFcIiA6ICQudmFrYXRhLmRuZC51c2VyX2RhdGEgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IHJldHVybjsgfVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYXliZSB1c2UgYSBzY3JvbGxpbmcgcGFyZW50IGVsZW1lbnQgaW5zdGVhZCBvZiBkb2N1bWVudD9cblx0XHRcdGlmKGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIikgeyAvLyB0aG91Z2h0IG9mIGFkZGluZyBzY3JvbGwgaW4gb3JkZXIgdG8gbW92ZSB0aGUgaGVscGVyLCBidXQgbW91c2UgcG9pc2l0aW9uIGlzIG4vYVxuXHRcdFx0XHR2YXIgZCA9ICQoZG9jdW1lbnQpLCB0ID0gZC5zY3JvbGxUb3AoKSwgbCA9IGQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHRpZihlLnBhZ2VZIC0gdCA8IDIwKSB7IFxuXHRcdFx0XHRcdGlmKHN0aSAmJiBkaXIxID09PSBcImRvd25cIikgeyBjbGVhckludGVydmFsKHN0aSk7IHN0aSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0aWYoIXN0aSkgeyBkaXIxID0gXCJ1cFwiOyBzdGkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSAtICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkKTsgfSwgMTUwKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRpZihzdGkgJiYgZGlyMSA9PT0gXCJ1cFwiKSB7IGNsZWFySW50ZXJ2YWwoc3RpKTsgc3RpID0gZmFsc2U7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZS5wYWdlWSAtIHQpIDwgMjApIHtcblx0XHRcdFx0XHRpZihzdGkgJiYgZGlyMSA9PT0gXCJ1cFwiKSB7IGNsZWFySW50ZXJ2YWwoc3RpKTsgc3RpID0gZmFsc2U7IH1cblx0XHRcdFx0XHRpZighc3RpKSB7IGRpcjEgPSBcImRvd25cIjsgc3RpID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyAkLnZha2F0YS5kbmQuc2Nyb2xsX3NwZCk7IH0sIDE1MCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0aWYoc3RpICYmIGRpcjEgPT09IFwiZG93blwiKSB7IGNsZWFySW50ZXJ2YWwoc3RpKTsgc3RpID0gZmFsc2U7IH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGUucGFnZVggLSBsIDwgMjApIHtcblx0XHRcdFx0XHRpZihzbGkgJiYgZGlyMiA9PT0gXCJyaWdodFwiKSB7IGNsZWFySW50ZXJ2YWwoc2xpKTsgc2xpID0gZmFsc2U7IH1cblx0XHRcdFx0XHRpZighc2xpKSB7IGRpcjIgPSBcImxlZnRcIjsgc2xpID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkKTsgfSwgMTUwKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRpZihzbGkgJiYgZGlyMiA9PT0gXCJsZWZ0XCIpIHsgY2xlYXJJbnRlcnZhbChzbGkpOyBzbGkgPSBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCQod2luZG93KS53aWR0aCgpIC0gKGUucGFnZVggLSBsKSA8IDIwKSB7XG5cdFx0XHRcdFx0aWYoc2xpICYmIGRpcjIgPT09IFwibGVmdFwiKSB7IGNsZWFySW50ZXJ2YWwoc2xpKTsgc2xpID0gZmFsc2U7IH1cblx0XHRcdFx0XHRpZighc2xpKSB7IGRpcjIgPSBcInJpZ2h0XCI7IHNsaSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyAkLnZha2F0YS5kbmQuc2Nyb2xsX3NwZCk7IH0sIDE1MCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0aWYoc2xpICYmIGRpcjIgPT09IFwicmlnaHRcIikgeyBjbGVhckludGVydmFsKHNsaSk7IHNsaSA9IGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jc3MoeyBsZWZ0IDogKGUucGFnZVggKyAkLnZha2F0YS5kbmQuaGVscGVyX2xlZnQpICsgXCJweFwiLCB0b3AgOiAoZS5wYWdlWSArICQudmFrYXRhLmRuZC5oZWxwZXJfdG9wKSArIFwicHhcIiB9KTtcblx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZHJhZy52YWthdGFcIiwgeyBcImV2ZW50XCIgOiBlLCBcImRhdGFcIiA6ICQudmFrYXRhLmRuZC51c2VyX2RhdGEgfSk7XG5cdFx0fSxcblx0XHRkcmFnX3N0b3AgOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYoc2xpKSB7IGNsZWFySW50ZXJ2YWwoc2xpKTsgfVxuXHRcdFx0aWYoc3RpKSB7IGNsZWFySW50ZXJ2YWwoc3RpKTsgfVxuXHRcdFx0JChkb2N1bWVudCkudW5iaW5kKFwibW91c2Vtb3ZlXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcblx0XHRcdCQoZG9jdW1lbnQpLnVuYmluZChcIm1vdXNldXBcIiwgJC52YWthdGEuZG5kLmRyYWdfc3RvcCk7XG5cdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImRyYWdfc3RvcC52YWthdGFcIiwgeyBcImV2ZW50XCIgOiBlLCBcImRhdGFcIiA6ICQudmFrYXRhLmRuZC51c2VyX2RhdGEgfSk7XG5cdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLnJlbW92ZSgpO1xuXHRcdFx0JC52YWthdGEuZG5kLmluaXRfeCA9IDA7XG5cdFx0XHQkLnZha2F0YS5kbmQuaW5pdF95ID0gMDtcblx0XHRcdCQudmFrYXRhLmRuZC51c2VyX2RhdGEgPSB7fTtcblx0XHRcdCQudmFrYXRhLmRuZC5pc19kb3duID0gZmFsc2U7XG5cdFx0XHQkLnZha2F0YS5kbmQuaXNfZHJhZyA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblx0JChmdW5jdGlvbigpIHtcblx0XHR2YXIgY3NzX3N0cmluZyA9ICcjdmFrYXRhLWRyYWdnZWQgeyBkaXNwbGF5OmJsb2NrOyBtYXJnaW46MCAwIDAgMDsgcGFkZGluZzo0cHggNHB4IDRweCAyNHB4OyBwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOi0yMDAwcHg7IGxpbmUtaGVpZ2h0OjE2cHg7IHotaW5kZXg6MTAwMDA7IH0gJztcblx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgc3RyIDogY3NzX3N0cmluZywgdGl0bGUgOiBcInZha2F0YVwiIH0pO1xuXHR9KTtcblxuXHQkLmpzdHJlZS5wbHVnaW4oXCJkbmRcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZGF0YS5kbmQgPSB7XG5cdFx0XHRcdGFjdGl2ZSA6IGZhbHNlLFxuXHRcdFx0XHRhZnRlciA6IGZhbHNlLFxuXHRcdFx0XHRpbnNpZGUgOiBmYWxzZSxcblx0XHRcdFx0YmVmb3JlIDogZmFsc2UsXG5cdFx0XHRcdG9mZiA6IGZhbHNlLFxuXHRcdFx0XHRwcmVwYXJlZCA6IGZhbHNlLFxuXHRcdFx0XHR3IDogMCxcblx0XHRcdFx0dG8xIDogZmFsc2UsXG5cdFx0XHRcdHRvMiA6IGZhbHNlLFxuXHRcdFx0XHRjb2YgOiBmYWxzZSxcblx0XHRcdFx0Y3cgOiBmYWxzZSxcblx0XHRcdFx0Y2ggOiBmYWxzZSxcblx0XHRcdFx0aTEgOiBmYWxzZSxcblx0XHRcdFx0aTIgOiBmYWxzZSxcblx0XHRcdFx0bXRvIDogZmFsc2Vcblx0XHRcdH07XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcIm1vdXNlZW50ZXIuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS50aGVtZXMpIHtcblx0XHRcdFx0XHRcdFx0XHRtLmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUpOyBcblx0XHRcdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgfVxuXHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuYXR0cihcImNsYXNzXCIsIFwianN0cmVlLWRuZC1oZWxwZXIganN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly9pZigkKGUuY3VycmVudFRhcmdldCkuZmluZChcIj4gdWwgPiBsaVwiKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0ID09PSBlLnRhcmdldCAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLm9iaiAmJiAkKCQudmFrYXRhLmRuZC51c2VyX2RhdGEub2JqKS5sZW5ndGggJiYgJCgkLnZha2F0YS5kbmQudXNlcl9kYXRhLm9iaikucGFyZW50cyhcIi5qc3RyZWU6ZXEoMClcIilbMF0gIT09IGUudGFyZ2V0KSB7IC8vIG5vZGUgc2hvdWxkIG5vdCBiZSBmcm9tIHRoZSBzYW1lIHRyZWVcblx0XHRcdFx0XHRcdFx0XHR2YXIgdHIgPSAkLmpzdHJlZS5fcmVmZXJlbmNlKGUudGFyZ2V0KSwgZGM7XG5cdFx0XHRcdFx0XHRcdFx0aWYodHIuZGF0YS5kbmQuZm9yZWlnbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGMgPSB0ci5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyYWdfY2hlY2suY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiB0ci5nZXRfY29udGFpbmVyKCksIGlzX3Jvb3QgOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZGMgPT09IHRydWUgfHwgZGMuaW5zaWRlID09PSB0cnVlIHx8IGRjLmJlZm9yZSA9PT0gdHJ1ZSB8fCBkYy5hZnRlciA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLW9rXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyLnByZXBhcmVfbW92ZShvLCB0ci5nZXRfY29udGFpbmVyKCksIFwibGFzdFwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRyLmNoZWNrX21vdmUoKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLW9rXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcIm1vdXNldXAuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdC8vaWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUgJiYgJChlLmN1cnJlbnRUYXJnZXQpLmZpbmQoXCI+IHVsID4gbGlcIikubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSAmJiBlLmN1cnJlbnRUYXJnZXQgPT09IGUudGFyZ2V0ICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEub2JqICYmICQoJC52YWthdGEuZG5kLnVzZXJfZGF0YS5vYmopLmxlbmd0aCAmJiAkKCQudmFrYXRhLmRuZC51c2VyX2RhdGEub2JqKS5wYXJlbnRzKFwiLmpzdHJlZTplcSgwKVwiKVswXSAhPT0gZS50YXJnZXQpIHsgLy8gbm9kZSBzaG91bGQgbm90IGJlIGZyb20gdGhlIHNhbWUgdHJlZVxuXHRcdFx0XHRcdFx0XHR2YXIgdHIgPSAkLmpzdHJlZS5fcmVmZXJlbmNlKGUuY3VycmVudFRhcmdldCksIGRjO1xuXHRcdFx0XHRcdFx0XHRpZih0ci5kYXRhLmRuZC5mb3JlaWduKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGMgPSB0ci5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyYWdfY2hlY2suY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiB0ci5nZXRfY29udGFpbmVyKCksIGlzX3Jvb3QgOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGRjID09PSB0cnVlIHx8IGRjLmluc2lkZSA9PT0gdHJ1ZSB8fCBkYy5iZWZvcmUgPT09IHRydWUgfHwgZGMuYWZ0ZXIgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyLl9nZXRfc2V0dGluZ3MoKS5kbmQuZHJhZ19maW5pc2guY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiB0ci5nZXRfY29udGFpbmVyKCksIGlzX3Jvb3QgOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0ci5tb3ZlX25vZGUobywgdHIuZ2V0X2NvbnRhaW5lcigpLCBcImxhc3RcIiwgZVt0ci5fZ2V0X3NldHRpbmdzKCkuZG5kLmNvcHlfbW9kaWZpZXIgKyBcIktleVwiXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJtb3VzZWxlYXZlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnJlbGF0ZWRUYXJnZXQgJiYgZS5yZWxhdGVkVGFyZ2V0LmlkICYmIGUucmVsYXRlZFRhcmdldC5pZCA9PT0gXCJqc3RyZWUtbWFya2VyLWxpbmVcIikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMSkgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTEpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTIpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkyKTsgfVxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMSkgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzEpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudG8yKSB7IGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLnRvMik7IH1cblx0XHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5oYXNDbGFzcyhcImpzdHJlZS1va1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuY2hpbGRyZW4oXCJpbnNcIikuYXR0cihcImNsYXNzXCIsXCJqc3RyZWUtaW52YWxpZFwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcIm1vdXNlbW92ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNudCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpWzBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEhvcml6b250YWwgc2Nyb2xsXG5cdFx0XHRcdFx0XHRcdGlmKGUucGFnZVggKyAyNCA+IHRoaXMuZGF0YS5kbmQuY29mLmxlZnQgKyB0aGlzLmRhdGEuZG5kLmN3KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMSkgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTEpOyB9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pMSA9IHNldEludGVydmFsKCQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLnNjcm9sbExlZnQgKz0gJC52YWthdGEuZG5kLnNjcm9sbF9zcGQ7IH0sIGNudCksIDEwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihlLnBhZ2VYIC0gMjQgPCB0aGlzLmRhdGEuZG5kLmNvZi5sZWZ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMSkgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTEpOyB9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pMSA9IHNldEludGVydmFsKCQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLnNjcm9sbExlZnQgLT0gJC52YWthdGEuZG5kLnNjcm9sbF9zcGQ7IH0sIGNudCksIDEwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMSkgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTEpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBWZXJ0aWNhbCBzY3JvbGxcblx0XHRcdFx0XHRcdFx0aWYoZS5wYWdlWSArIDI0ID4gdGhpcy5kYXRhLmRuZC5jb2YudG9wICsgdGhpcy5kYXRhLmRuZC5jaCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTIpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkyKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaTIgPSBzZXRJbnRlcnZhbCgkLnByb3h5KGZ1bmN0aW9uICgpIHsgdGhpcy5zY3JvbGxUb3AgKz0gJC52YWthdGEuZG5kLnNjcm9sbF9zcGQ7IH0sIGNudCksIDEwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihlLnBhZ2VZIC0gMjQgPCB0aGlzLmRhdGEuZG5kLmNvZi50b3ApIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkyKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMik7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmkyID0gc2V0SW50ZXJ2YWwoJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMuc2Nyb2xsVG9wIC09ICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkOyB9LCBjbnQpLCAxMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTIpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkyKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJzY3JvbGwuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSAmJiBtICYmIG1sKSB7XG5cdFx0XHRcdFx0XHRcdG0uaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRtbC5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJtb3VzZWRvd24uanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0XHRpZihlLndoaWNoID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhcnRfZHJhZyhlLmN1cnJlbnRUYXJnZXQsIGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJtb3VzZWVudGVyLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kbmRfZW50ZXIoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcIm1vdXNlbW92ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFyIHx8ICFyLmxlbmd0aCB8fCByLmNoaWxkcmVuKFwiYVwiKVswXSAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kbmRfZW50ZXIoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgdGhpcy5kYXRhLmRuZC5vZmYudG9wID09PSBcInVuZGVmaW5lZFwiKSB7IHRoaXMuZGF0YS5kbmQub2ZmID0gJChlLnRhcmdldCkub2Zmc2V0KCk7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC53ID0gKGUucGFnZVkgLSAodGhpcy5kYXRhLmRuZC5vZmYudG9wIHx8IDApKSAlIHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodDtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC53IDwgMCkgeyB0aGlzLmRhdGEuZG5kLncgKz0gdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0OyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuZG5kX3Nob3coKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcIm1vdXNlbGVhdmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZihlLnJlbGF0ZWRUYXJnZXQgJiYgZS5yZWxhdGVkVGFyZ2V0LmlkICYmIGUucmVsYXRlZFRhcmdldC5pZCA9PT0gXCJqc3RyZWUtbWFya2VyLWxpbmVcIikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZihtKSB7IG0uaGlkZSgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYobWwpIHsgbWwuaGlkZSgpOyB9XG5cdFx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHRcdHZhciBlYyA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwibGlcIiksIFxuXHRcdFx0XHRcdFx0XHRcdGVyID0gJChlLnJlbGF0ZWRUYXJnZXQpLmNsb3Nlc3QoXCJsaVwiKTtcblx0XHRcdFx0XHRcdFx0aWYoZXJbMF0gIT09IGVjLnByZXYoKVswXSAmJiBlclswXSAhPT0gZWMubmV4dCgpWzBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYobSkgeyBtLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQubXRvID0gc2V0VGltZW91dCggXG5cdFx0XHRcdFx0XHRcdFx0KGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHQuZG5kX2xlYXZlKGUpOyB9OyB9KSh0aGlzKSxcblx0XHRcdFx0XHRcdFx0MCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImEsICNqc3RyZWUtbWFya2VyLWxpbmVcIiwgXCJtb3VzZXVwLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRuZF9maW5pc2goZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQuYmluZChcImRyYWdfc3RvcC52YWthdGFcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMSkgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzEpOyB9XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMikgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzIpOyB9XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkxKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMSk7IH1cblx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTIpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkyKTsgfVxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5hZnRlclx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5iZWZvcmVcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmluc2lkZVx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQub2ZmXHRcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnByZXBhcmVkXHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC53XHRcdFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQudG8xXHRcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMlx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pMVx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pMlx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5hY3RpdmVcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmZvcmVpZ25cdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHRpZihtKSB7IG0uY3NzKHsgXCJ0b3BcIiA6IFwiLTIwMDBweFwiIH0pOyB9XG5cdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5jc3MoeyBcInRvcFwiIDogXCItMjAwMHB4XCIgfSk7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkcmFnX3N0YXJ0LnZha2F0YVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZihkYXRhLmRhdGEuanN0cmVlKSB7IFxuXHRcdFx0XHRcdFx0XHR2YXIgZXQgPSAkKGRhdGEuZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0aWYoZXQuY2xvc2VzdChcIi5qc3RyZWVcIikuaGFzQ2xhc3MoXCJqc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpKSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZG5kX2VudGVyKGV0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0Lypcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duLmpzdHJlZS1cIiArIHRoaXMuZ2V0X2luZGV4KCkgKyBcIiBrZXl1cC5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlICYmICF0aGlzLmRhdGEuZG5kLmZvcmVpZ24pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGggPSAkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpO1xuXHRcdFx0XHRcdFx0XHRpZihlW3RoaXMuX2dldF9zZXR0aW5ncygpLmRuZC5jb3B5X21vZGlmaWVyICsgXCJLZXlcIl0gJiYgaC5oYXNDbGFzcyhcImpzdHJlZS1va1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdGgucGFyZW50KCkuaHRtbChoLnBhcmVudCgpLmh0bWwoKS5yZXBsYWNlKC8gXFwoQ29weVxcKSQvLCBcIlwiKSArIFwiIChDb3B5KVwiKTtcblx0XHRcdFx0XHRcdFx0fSBcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aC5wYXJlbnQoKS5odG1sKGgucGFyZW50KCkuaHRtbCgpLnJlcGxhY2UoLyBcXChDb3B5XFwpJC8sIFwiXCIpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTsgKi9cblxuXG5cblx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuZG5kO1xuXHRcdFx0aWYocy5kcmFnX3RhcmdldCkge1xuXHRcdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHRcdC5kZWxlZ2F0ZShzLmRyYWdfdGFyZ2V0LCBcIm1vdXNlZG93bi5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRvID0gZS50YXJnZXQ7XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuZHJhZ19zdGFydChlLCB7IGpzdHJlZSA6IHRydWUsIG9iaiA6IGUudGFyZ2V0IH0sIFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPjwvaW5zPlwiICsgJChlLnRhcmdldCkudGV4dCgpICk7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEudGhlbWVzKSB7IFxuXHRcdFx0XHRcdFx0XHRpZihtKSB7IG0uYXR0cihcImNsYXNzXCIsIFwianN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IH1cblx0XHRcdFx0XHRcdFx0aWYobWwpIHsgbWwuYXR0cihcImNsYXNzXCIsIFwianN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IH1cblx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtZG5kLWhlbHBlciBqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLWludmFsaWRcIik7XG5cdFx0XHRcdFx0XHR2YXIgY250ID0gdGhpcy5nZXRfY29udGFpbmVyKCk7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmNvZiA9IGNudC5vZmZzZXQoKTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuY3cgPSBwYXJzZUludChjbnQud2lkdGgoKSwxMCk7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmNoID0gcGFyc2VJbnQoY250LmhlaWdodCgpLDEwKTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuZm9yZWlnbiA9IHRydWU7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYocy5kcm9wX3RhcmdldCkge1xuXHRcdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHRcdC5kZWxlZ2F0ZShzLmRyb3BfdGFyZ2V0LCBcIm1vdXNlZW50ZXIuanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmFjdGl2ZSAmJiB0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQuZHJvcF9jaGVjay5jYWxsKHRoaXMsIHsgXCJvXCIgOiBvLCBcInJcIiA6ICQoZS50YXJnZXQpLCBcImVcIiA6IGUgfSkpIHtcblx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLW9rXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQuZGVsZWdhdGUocy5kcm9wX3RhcmdldCwgXCJtb3VzZWxlYXZlLmpzdHJlZS1cIiArIHRoaXMuZ2V0X2luZGV4KCksICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5hY3RpdmUpIHtcblx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLWludmFsaWRcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5kZWxlZ2F0ZShzLmRyb3BfdGFyZ2V0ICsgXCIsICNqc3RyZWUtbWFya2VyLWxpbmVcIiwgXCJtb3VzZXVwLmpzdHJlZS1cIiArIHRoaXMuZ2V0X2luZGV4KCksICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5hY3RpdmUgJiYgJC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5oYXNDbGFzcyhcImpzdHJlZS1va1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2dldF9zZXR0aW5ncygpLmRuZC5kcm9wX2ZpbmlzaC5jYWxsKHRoaXMsIHsgXCJvXCIgOiBvLCBcInJcIiA6ICQoZS50YXJnZXQpLCBcImVcIiA6IGUgfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0Y29weV9tb2RpZmllclx0OiBcImN0cmxcIixcblx0XHRcdGNoZWNrX3RpbWVvdXRcdDogMTAwLFxuXHRcdFx0b3Blbl90aW1lb3V0XHQ6IDUwMCxcblx0XHRcdGRyb3BfdGFyZ2V0XHRcdDogXCIuanN0cmVlLWRyb3BcIixcblx0XHRcdGRyb3BfY2hlY2tcdFx0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gdHJ1ZTsgfSxcblx0XHRcdGRyb3BfZmluaXNoXHRcdDogJC5ub29wLFxuXHRcdFx0ZHJhZ190YXJnZXRcdFx0OiBcIi5qc3RyZWUtZHJhZ2dhYmxlXCIsXG5cdFx0XHRkcmFnX2ZpbmlzaFx0XHQ6ICQubm9vcCxcblx0XHRcdGRyYWdfY2hlY2tcdFx0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4geyBhZnRlciA6IGZhbHNlLCBiZWZvcmUgOiBmYWxzZSwgaW5zaWRlIDogdHJ1ZSB9OyB9XG5cdFx0fSxcblx0XHRfX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyB1bmJpbmQgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzIHdoZW4gbGFzdCBpbnN0YW5jZSBpcyByZW1vdmVkXG5cdFx0XHQvLyAobm8gYWNjZXNzIHRvIHByaXZhdGUgJ2luc3RhbmNlcycgdmFyaWFibGUgZnJvbSBoZXJlKVxuXHRcdFx0aWYoJCgnLmpzdHJlZScpLmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdFx0LnVuYmluZChcImRyYWdfc3RhcnQudmFrYXRhXCIpXG5cdFx0XHRcdFx0LnVuYmluZChcImRyYWdfc3RvcC52YWthdGFcIik7XHRcblx0XHRcdH1cblx0XHRcdG8gPSBmYWxzZTtcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdGRuZF9wcmVwYXJlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZighciB8fCAhci5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQub2ZmID0gci5vZmZzZXQoKTtcblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5ydGwpIHtcblx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLm9mZi5yaWdodCA9IHRoaXMuZGF0YS5kbmQub2ZmLmxlZnQgKyByLndpZHRoKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5mb3JlaWduKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQuZHJhZ19jaGVjay5jYWxsKHRoaXMsIHsgXCJvXCIgOiBvLCBcInJcIiA6IHIgfSk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5hZnRlciA9IGEuYWZ0ZXI7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5iZWZvcmUgPSBhLmJlZm9yZTtcblx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmluc2lkZSA9IGEuaW5zaWRlO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQucHJlcGFyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRuZF9zaG93KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wcmVwYXJlX21vdmUobywgciwgXCJiZWZvcmVcIik7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuYmVmb3JlID0gdGhpcy5jaGVja19tb3ZlKCk7XG5cdFx0XHRcdHRoaXMucHJlcGFyZV9tb3ZlKG8sIHIsIFwiYWZ0ZXJcIik7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuYWZ0ZXIgPSB0aGlzLmNoZWNrX21vdmUoKTtcblx0XHRcdFx0aWYodGhpcy5faXNfbG9hZGVkKHIpKSB7XG5cdFx0XHRcdFx0dGhpcy5wcmVwYXJlX21vdmUobywgciwgXCJpbnNpZGVcIik7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pbnNpZGUgPSB0aGlzLmNoZWNrX21vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmluc2lkZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQucHJlcGFyZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kbmRfc2hvdygpO1xuXHRcdFx0fSxcblx0XHRcdGRuZF9zaG93IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZighdGhpcy5kYXRhLmRuZC5wcmVwYXJlZCkgeyByZXR1cm47IH1cblx0XHRcdFx0dmFyIG8gPSBbXCJiZWZvcmVcIixcImluc2lkZVwiLFwiYWZ0ZXJcIl0sXG5cdFx0XHRcdFx0ciA9IGZhbHNlLFxuXHRcdFx0XHRcdHJ0bCA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUucnRsLFxuXHRcdFx0XHRcdHBvcztcblx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC53IDwgdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0LzMpIHsgbyA9IFtcImJlZm9yZVwiLFwiaW5zaWRlXCIsXCJhZnRlclwiXTsgfVxuXHRcdFx0XHRlbHNlIGlmKHRoaXMuZGF0YS5kbmQudyA8PSB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQqMi8zKSB7XG5cdFx0XHRcdFx0byA9IHRoaXMuZGF0YS5kbmQudyA8IHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodC8yID8gW1wiaW5zaWRlXCIsXCJiZWZvcmVcIixcImFmdGVyXCJdIDogW1wiaW5zaWRlXCIsXCJhZnRlclwiLFwiYmVmb3JlXCJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyBvID0gW1wiYWZ0ZXJcIixcImluc2lkZVwiLFwiYmVmb3JlXCJdOyB9XG5cdFx0XHRcdCQuZWFjaChvLCAkLnByb3h5KGZ1bmN0aW9uIChpLCB2YWwpIHsgXG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZFt2YWxdKSB7XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLW9rXCIpO1xuXHRcdFx0XHRcdFx0ciA9IHZhbDtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0aWYociA9PT0gZmFsc2UpIHsgJC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1pbnZhbGlkXCIpOyB9XG5cdFx0XHRcdFxuXHRcdFx0XHRwb3MgPSBydGwgPyAodGhpcy5kYXRhLmRuZC5vZmYucmlnaHQgLSAxOCkgOiAodGhpcy5kYXRhLmRuZC5vZmYubGVmdCArIDEwKTtcblx0XHRcdFx0c3dpdGNoKHIpIHtcblx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0XHRtLmNzcyh7IFwibGVmdFwiIDogcG9zICsgXCJweFwiLCBcInRvcFwiIDogKHRoaXMuZGF0YS5kbmQub2ZmLnRvcCAtIDYpICsgXCJweFwiIH0pLnNob3coKTtcblx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmNzcyh7IFwibGVmdFwiIDogKHBvcyArIDgpICsgXCJweFwiLCBcInRvcFwiIDogKHRoaXMuZGF0YS5kbmQub2ZmLnRvcCAtIDEpICsgXCJweFwiIH0pLnNob3coKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImFmdGVyXCI6XG5cdFx0XHRcdFx0XHRtLmNzcyh7IFwibGVmdFwiIDogcG9zICsgXCJweFwiLCBcInRvcFwiIDogKHRoaXMuZGF0YS5kbmQub2ZmLnRvcCArIHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodCAtIDYpICsgXCJweFwiIH0pLnNob3coKTtcblx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmNzcyh7IFwibGVmdFwiIDogKHBvcyArIDgpICsgXCJweFwiLCBcInRvcFwiIDogKHRoaXMuZGF0YS5kbmQub2ZmLnRvcCArIHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodCAtIDEpICsgXCJweFwiIH0pLnNob3coKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRcdFx0bS5jc3MoeyBcImxlZnRcIiA6IHBvcyArICggcnRsID8gLTQgOiA0KSArIFwicHhcIiwgXCJ0b3BcIiA6ICh0aGlzLmRhdGEuZG5kLm9mZi50b3AgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQvMiAtIDUpICsgXCJweFwiIH0pLnNob3coKTtcblx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdG0uaGlkZSgpO1xuXHRcdFx0XHRcdFx0aWYobWwpIHsgbWwuaGlkZSgpOyB9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0X3BvcyA9IHI7XG5cdFx0XHRcdHJldHVybiByO1xuXHRcdFx0fSxcblx0XHRcdGRuZF9vcGVuIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMiA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLm9wZW5fbm9kZShyLCAkLnByb3h5KHRoaXMuZG5kX3ByZXBhcmUsdGhpcyksIHRydWUpO1xuXHRcdFx0fSxcblx0XHRcdGRuZF9maW5pc2ggOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmZvcmVpZ24pIHtcblx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmFmdGVyIHx8IHRoaXMuZGF0YS5kbmQuYmVmb3JlIHx8IHRoaXMuZGF0YS5kbmQuaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQuZHJhZ19maW5pc2guY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiByLCBcInBcIiA6IGxhc3RfcG9zIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmRuZF9wcmVwYXJlKCk7XG5cdFx0XHRcdFx0dGhpcy5tb3ZlX25vZGUobywgciwgbGFzdF9wb3MsIGVbdGhpcy5fZ2V0X3NldHRpbmdzKCkuZG5kLmNvcHlfbW9kaWZpZXIgKyBcIktleVwiXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0byA9IGZhbHNlO1xuXHRcdFx0XHRyID0gZmFsc2U7XG5cdFx0XHRcdG0uaGlkZSgpO1xuXHRcdFx0XHRpZihtbCkgeyBtbC5oaWRlKCk7IH1cblx0XHRcdH0sXG5cdFx0XHRkbmRfZW50ZXIgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQubXRvKSB7IFxuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLm10byk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5tdG8gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmRuZDtcblx0XHRcdFx0dGhpcy5kYXRhLmRuZC5wcmVwYXJlZCA9IGZhbHNlO1xuXHRcdFx0XHRyID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYocy5jaGVja190aW1lb3V0KSB7IFxuXHRcdFx0XHRcdC8vIGRvIHRoZSBjYWxjdWxhdGlvbnMgYWZ0ZXIgYSBtaW5pbWFsIHRpbWVvdXQgKHVzZXJzIHRlbmQgdG8gZHJhZyBxdWlja2x5IHRvIHRoZSBkZXNpcmVkIGxvY2F0aW9uKVxuXHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudG8xKSB7IGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLnRvMSk7IH1cblx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMSA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmRuZF9wcmVwYXJlLCB0aGlzKSwgcy5jaGVja190aW1lb3V0KTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdHRoaXMuZG5kX3ByZXBhcmUoKTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocy5vcGVuX3RpbWVvdXQpIHsgXG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzIpIHsgY2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5kbmQudG8yKTsgfVxuXHRcdFx0XHRcdGlmKHIgJiYgci5sZW5ndGggJiYgci5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9kZSBpcyBjbG9zZWQgLSBvcGVuIGl0LCB0aGVuIHJlY2FsY3VsYXRlXG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMiA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmRuZF9vcGVuLCB0aGlzKSwgcy5vcGVuX3RpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZihyICYmIHIubGVuZ3RoICYmIHIuaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5kbmRfb3BlbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRuZF9sZWF2ZSA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuYWZ0ZXJcdFx0PSBmYWxzZTtcblx0XHRcdFx0dGhpcy5kYXRhLmRuZC5iZWZvcmVcdD0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuaW5zaWRlXHQ9IGZhbHNlO1xuXHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLWludmFsaWRcIik7XG5cdFx0XHRcdG0uaGlkZSgpO1xuXHRcdFx0XHRpZihtbCkgeyBtbC5oaWRlKCk7IH1cblx0XHRcdFx0aWYociAmJiByWzBdID09PSBlLnRhcmdldC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzEpIHtcblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLnRvMSk7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMikge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5kbmQudG8yKTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQudG8yID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3RhcnRfZHJhZyA6IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdFx0byA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aSAmJiB0aGlzLmlzX3NlbGVjdGVkKG8pKSB7IG8gPSB0aGlzLl9nZXRfbm9kZShudWxsLCB0cnVlKTsgfVxuXHRcdFx0XHR2YXIgZHQgPSBvLmxlbmd0aCA+IDEgPyB0aGlzLl9nZXRfc3RyaW5nKFwibXVsdGlwbGVfc2VsZWN0aW9uXCIpIDogdGhpcy5nZXRfdGV4dChvKSxcblx0XHRcdFx0XHRjbnQgPSB0aGlzLmdldF9jb250YWluZXIoKTtcblx0XHRcdFx0aWYoIXRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuaHRtbF90aXRsZXMpIHsgZHQgPSBkdC5yZXBsYWNlKC88L2lnLFwiJmx0O1wiKS5yZXBsYWNlKC8+L2lnLFwiJmd0O1wiKTsgfVxuXHRcdFx0XHQkLnZha2F0YS5kbmQuZHJhZ19zdGFydChlLCB7IGpzdHJlZSA6IHRydWUsIG9iaiA6IG8gfSwgXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+PC9pbnM+XCIgKyBkdCApO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEudGhlbWVzKSB7IFxuXHRcdFx0XHRcdGlmKG0pIHsgbS5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgfVxuXHRcdFx0XHRcdGlmKG1sKSB7IG1sLmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUpOyB9XG5cdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtZG5kLWhlbHBlciBqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5kYXRhLmRuZC5jb2YgPSBjbnQub2Zmc2V0KCk7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuY3cgPSBwYXJzZUludChjbnQud2lkdGgoKSwxMCk7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuY2ggPSBwYXJzZUludChjbnQuaGVpZ2h0KCksMTApO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0JChmdW5jdGlvbigpIHtcblx0XHR2YXIgY3NzX3N0cmluZyA9ICcnICsgXG5cdFx0XHQnI3Zha2F0YS1kcmFnZ2VkIGlucyB7IGRpc3BsYXk6YmxvY2s7IHRleHQtZGVjb3JhdGlvbjpub25lOyB3aWR0aDoxNnB4OyBoZWlnaHQ6MTZweDsgbWFyZ2luOjAgMCAwIDA7IHBhZGRpbmc6MDsgcG9zaXRpb246YWJzb2x1dGU7IHRvcDo0cHg7IGxlZnQ6NHB4OyAnICsgXG5cdFx0XHQnIC1tb3otYm9yZGVyLXJhZGl1czo0cHg7IGJvcmRlci1yYWRpdXM6NHB4OyAtd2Via2l0LWJvcmRlci1yYWRpdXM6NHB4OyAnICtcblx0XHRcdCd9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWRyYWdnZWQgLmpzdHJlZS1vayB7IGJhY2tncm91bmQ6Z3JlZW47IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtZHJhZ2dlZCAuanN0cmVlLWludmFsaWQgeyBiYWNrZ3JvdW5kOnJlZDsgfSAnICsgXG5cdFx0XHQnI2pzdHJlZS1tYXJrZXIgeyBwYWRkaW5nOjA7IG1hcmdpbjowOyBmb250LXNpemU6MTJweDsgb3ZlcmZsb3c6aGlkZGVuOyBoZWlnaHQ6MTJweDsgd2lkdGg6OHB4OyBwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOi0zMHB4OyB6LWluZGV4OjEwMDAxOyBiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7IGRpc3BsYXk6bm9uZTsgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDsgdGV4dC1zaGFkb3c6MXB4IDFweCAxcHggd2hpdGU7IGNvbG9yOmJsYWNrOyBsaW5lLWhlaWdodDoxMHB4OyB9ICcgKyBcblx0XHRcdCcjanN0cmVlLW1hcmtlci1saW5lIHsgcGFkZGluZzowOyBtYXJnaW46MDsgbGluZS1oZWlnaHQ6MCU7IGZvbnQtc2l6ZToxcHg7IG92ZXJmbG93OmhpZGRlbjsgaGVpZ2h0OjFweDsgd2lkdGg6MTAwcHg7IHBvc2l0aW9uOmFic29sdXRlOyB0b3A6LTMwcHg7IHotaW5kZXg6MTAwMDA7IGJhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDsgZGlzcGxheTpub25lOyBiYWNrZ3JvdW5kLWNvbG9yOiM0NTZjNDM7ICcgKyBcblx0XHRcdCcgY3Vyc29yOnBvaW50ZXI7IGJvcmRlcjoxcHggc29saWQgI2VlZWVlZTsgYm9yZGVyLWxlZnQ6MDsgLW1vei1ib3gtc2hhZG93OiAwcHggMHB4IDJweCAjNjY2OyAtd2Via2l0LWJveC1zaGFkb3c6IDBweCAwcHggMnB4ICM2NjY7IGJveC1zaGFkb3c6IDBweCAwcHggMnB4ICM2NjY7ICcgKyBcblx0XHRcdCcgLW1vei1ib3JkZXItcmFkaXVzOjFweDsgYm9yZGVyLXJhZGl1czoxcHg7IC13ZWJraXQtYm9yZGVyLXJhZGl1czoxcHg7ICcgK1xuXHRcdFx0J30nICsgXG5cdFx0XHQnJztcblx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgc3RyIDogY3NzX3N0cmluZywgdGl0bGUgOiBcImpzdHJlZVwiIH0pO1xuXHRcdG0gPSAkKFwiPGRpdiAvPlwiKS5hdHRyKHsgaWQgOiBcImpzdHJlZS1tYXJrZXJcIiB9KS5oaWRlKCkuaHRtbChcIiZyYXF1bztcIilcblx0XHRcdC5iaW5kKFwibW91c2VsZWF2ZSBtb3VzZWVudGVyXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0bWwuaGlkZSgpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IFxuXHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdH0pXG5cdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdG1sID0gJChcIjxkaXYgLz5cIikuYXR0cih7IGlkIDogXCJqc3RyZWUtbWFya2VyLWxpbmVcIiB9KS5oaWRlKClcblx0XHRcdC5iaW5kKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0aWYociAmJiByLmxlbmd0aCkgeyBcblx0XHRcdFx0XHRyLmNoaWxkcmVuKFwiYVwiKS50cmlnZ2VyKGUpOyBcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IFxuXHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHRcdH0gXG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHR2YXIgcnQgPSAkKGUucmVsYXRlZFRhcmdldCk7XG5cdFx0XHRcdGlmKHJ0LmlzKFwiLmpzdHJlZVwiKSB8fCBydC5jbG9zZXN0KFwiLmpzdHJlZVwiKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRpZihyICYmIHIubGVuZ3RoKSB7IFxuXHRcdFx0XHRcdFx0ci5jaGlsZHJlbihcImFcIikudHJpZ2dlcihlKTsgXG5cdFx0XHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0XHRcdG1sLmhpZGUoKTtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgXG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHQkKGRvY3VtZW50KS5iaW5kKFwiZHJhZ19zdGFydC52YWthdGFcIiwgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdGlmKGRhdGEuZGF0YS5qc3RyZWUpIHsgbS5zaG93KCk7IGlmKG1sKSB7IG1sLnNob3coKTsgfSB9XG5cdFx0fSk7XG5cdFx0JChkb2N1bWVudCkuYmluZChcImRyYWdfc3RvcC52YWthdGFcIiwgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdGlmKGRhdGEuZGF0YS5qc3RyZWUpIHsgbS5oaWRlKCk7IGlmKG1sKSB7IG1sLmhpZGUoKTsgfSB9XG5cdFx0fSk7XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLypcbiAqIGpzVHJlZSBjaGVja2JveCBwbHVnaW5cbiAqIEluc2VydHMgY2hlY2tib3hlcyBpbiBmcm9udCBvZiBldmVyeSBub2RlXG4gKiBEZXBlbmRzIG9uIHRoZSB1aSBwbHVnaW5cbiAqIERPRVMgTk9UIFdPUksgTklDRUxZIFdJVEggTVVMVElUUkVFIERSQUcnTidEUk9QXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJjaGVja2JveFwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5kYXRhLmNoZWNrYm94Lm5vdWkgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC5vdmVycmlkZV91aTtcblx0XHRcdGlmKHRoaXMuZGF0YS51aSAmJiB0aGlzLmRhdGEuY2hlY2tib3gubm91aSkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlID0gdGhpcy5kZXNlbGVjdF9ub2RlID0gdGhpcy5kZXNlbGVjdF9hbGwgPSAkLm5vb3A7XG5cdFx0XHRcdHRoaXMuZ2V0X3NlbGVjdGVkID0gdGhpcy5nZXRfY2hlY2tlZDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJvcGVuX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZSBjbGVhbl9ub2RlLmpzdHJlZSByZWZyZXNoLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5fcHJlcGFyZV9jaGVja2JveGVzKGRhdGEucnNsdC5vYmopO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImxvYWRlZC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJlcGFyZV9jaGVja2JveGVzKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZSggKHRoaXMuZGF0YS51aSAmJiB0aGlzLmRhdGEuY2hlY2tib3gubm91aSA/IFwiYVwiIDogXCJpbnMuanN0cmVlLWNoZWNrYm94XCIpICwgXCJjbGljay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fZ2V0X25vZGUoZS50YXJnZXQpLmhhc0NsYXNzKFwianN0cmVlLWNoZWNrZWRcIikpIHsgdGhpcy51bmNoZWNrX25vZGUoZS50YXJnZXQpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgdGhpcy5jaGVja19ub2RlKGUudGFyZ2V0KTsgfVxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLnVpICYmIHRoaXMuZGF0YS5jaGVja2JveC5ub3VpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9zZWxlY3RlZCgpO1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuY29va2llcykgeyB0aGlzLnNhdmVfY29va2llKFwic2VsZWN0X25vZGVcIik7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRvdmVycmlkZV91aSA6IGZhbHNlLFxuXHRcdFx0dHdvX3N0YXRlIDogZmFsc2UsXG5cdFx0XHRyZWFsX2NoZWNrYm94ZXMgOiBmYWxzZSxcblx0XHRcdGNoZWNrZWRfcGFyZW50X29wZW4gOiB0cnVlLFxuXHRcdFx0cmVhbF9jaGVja2JveGVzX25hbWVzIDogZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFsgKFwiY2hlY2tfXCIgKyAoblswXS5pZCB8fCBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSkpICwgMV07IH1cblx0XHR9LFxuXHRcdF9fZGVzdHJveSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5maW5kKFwiaW5wdXQuanN0cmVlLXJlYWwtY2hlY2tib3hcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtcmVhbC1jaGVja2JveFwiKS5lbmQoKVxuXHRcdFx0XHQuZmluZChcImlucy5qc3RyZWUtY2hlY2tib3hcIikucmVtb3ZlKCk7XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRfY2hlY2tib3hfbm90aWZ5IDogZnVuY3Rpb24gKG4sIGRhdGEpIHtcblx0XHRcdFx0aWYoZGF0YS5jaGVja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGVja19ub2RlKG4sIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wcmVwYXJlX2NoZWNrYm94ZXMgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9ICFvYmogfHwgb2JqID09IC0xID8gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKSA6IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iaiA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9IC8vIGFkZGVkIGZvciByZW1vdmluZyByb290IG5vZGVzXG5cdFx0XHRcdHZhciBjLCBfdGhpcyA9IHRoaXMsIHQsIHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlLCByYyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnJlYWxfY2hlY2tib3hlcywgcmNuID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gucmVhbF9jaGVja2JveGVzX25hbWVzO1xuXHRcdFx0XHRvYmouZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0YyA9IHQuaXMoXCJsaVwiKSAmJiAodC5oYXNDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpIHx8IChyYyAmJiB0LmNoaWxkcmVuKFwiOmNoZWNrZWRcIikubGVuZ3RoKSkgPyBcImpzdHJlZS1jaGVja2VkXCIgOiBcImpzdHJlZS11bmNoZWNrZWRcIjtcblx0XHRcdFx0XHR0LmZpbmQoXCJsaVwiKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgJHQgPSAkKHRoaXMpLCBubTtcblx0XHRcdFx0XHRcdCR0LmNoaWxkcmVuKFwiYVwiICsgKF90aGlzLmRhdGEubGFuZ3VhZ2VzID8gXCJcIiA6IFwiOmVxKDApXCIpICkubm90KFwiOmhhcyguanN0cmVlLWNoZWNrYm94KVwiKS5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWNoZWNrYm94Jz4mIzE2MDs8L2lucz5cIikucGFyZW50KCkubm90KFwiLmpzdHJlZS1jaGVja2VkLCAuanN0cmVlLXVuY2hlY2tlZFwiKS5hZGRDbGFzcyggdHMgPyBcImpzdHJlZS11bmNoZWNrZWRcIiA6IGMgKTtcblx0XHRcdFx0XHRcdGlmKHJjKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCEkdC5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRubSA9IHJjbi5jYWxsKF90aGlzLCAkdCk7XG5cdFx0XHRcdFx0XHRcdFx0JHQucHJlcGVuZChcIjxpbnB1dCB0eXBlPSdjaGVja2JveCcgY2xhc3M9J2pzdHJlZS1yZWFsLWNoZWNrYm94JyBpZD0nXCIgKyBubVswXSArIFwiJyBuYW1lPSdcIiArIG5tWzBdICsgXCInIHZhbHVlPSdcIiArIG5tWzFdICsgXCInIC8+XCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdCR0LmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLmFkZENsYXNzKFwianN0cmVlLXJlYWwtY2hlY2tib3hcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCF0cykge1xuXHRcdFx0XHRcdFx0XHRpZihjID09PSBcImpzdHJlZS1jaGVja2VkXCIgfHwgJHQuaGFzQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKSB8fCAkdC5jaGlsZHJlbignOmNoZWNrZWQnKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkdC5maW5kKFwibGlcIikuYW5kU2VsZigpLmFkZENsYXNzKFwianN0cmVlLWNoZWNrZWRcIikuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZigkdC5oYXNDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpIHx8ICR0LmNoaWxkcmVuKCc6Y2hlY2tlZCcpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdCR0LmFkZENsYXNzKFwianN0cmVlLWNoZWNrZWRcIikuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKCF0cykge1xuXHRcdFx0XHRcdG9iai5maW5kKFwiLmpzdHJlZS1jaGVja2VkXCIpLnBhcmVudCgpLnBhcmVudCgpLmVhY2goZnVuY3Rpb24gKCkgeyBfdGhpcy5fcmVwYWlyX3N0YXRlKHRoaXMpOyB9KTsgXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2Vfc3RhdGUgOiBmdW5jdGlvbiAob2JqLCBzdGF0ZSkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgY29sbCA9IGZhbHNlLCByYyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnJlYWxfY2hlY2tib3hlcztcblx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRzdGF0ZSA9IChzdGF0ZSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IHRydWUpID8gc3RhdGUgOiBvYmouaGFzQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKTtcblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlKSB7XG5cdFx0XHRcdFx0aWYoc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRvYmoucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmNoZWNrZWRcIik7IFxuXHRcdFx0XHRcdFx0aWYocmMpIHsgb2JqLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0XHRvYmoucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtdW5jaGVja2VkXCIpLmFkZENsYXNzKFwianN0cmVlLWNoZWNrZWRcIik7IFxuXHRcdFx0XHRcdFx0aWYocmMpIHsgb2JqLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKHN0YXRlKSB7IFxuXHRcdFx0XHRcdFx0Y29sbCA9IG9iai5maW5kKFwibGlcIikuYW5kU2VsZigpO1xuXHRcdFx0XHRcdFx0aWYoIWNvbGwuZmlsdGVyKFwiLmpzdHJlZS1jaGVja2VkLCAuanN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHRjb2xsLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWQganN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmNoZWNrZWRcIik7IFxuXHRcdFx0XHRcdFx0aWYocmMpIHsgY29sbC5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdFx0Y29sbCA9IG9iai5maW5kKFwibGlcIikuYW5kU2VsZigpO1xuXHRcdFx0XHRcdFx0aWYoIWNvbGwuZmlsdGVyKFwiLmpzdHJlZS11bmNoZWNrZWQsIC5qc3RyZWUtdW5kZXRlcm1pbmVkXCIpLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdGNvbGwucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtdW5jaGVja2VkIGpzdHJlZS11bmRldGVybWluZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKTsgXG5cdFx0XHRcdFx0XHRpZihyYykgeyBjb2xsLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpOyB9XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEudWkpIHsgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgPSBvYmo7IH1cblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5jaGVja2JveC5sYXN0X3NlbGVjdGVkID0gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdFx0XHRcdGlmKHN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCR0aGlzLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaS5qc3RyZWUtY2hlY2tlZCwgbGkuanN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkdGhpcy5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsIFwibGlcIikuYW5kU2VsZigpLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWQganN0cmVlLXVuY2hlY2tlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmRldGVybWluZWRcIik7XG5cdFx0XHRcdFx0XHRcdFx0aWYocmMpIHsgJHRoaXMucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmFuZFNlbGYoKS5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7IH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0JHRoaXMucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZCBqc3RyZWUtdW5kZXRlcm1pbmVkXCIpLmFkZENsYXNzKFwianN0cmVlLXVuY2hlY2tlZFwiKTtcblx0XHRcdFx0XHRcdFx0XHRpZihyYykgeyAkdGhpcy5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKCR0aGlzLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaS5qc3RyZWUtdW5jaGVja2VkLCBsaS5qc3RyZWUtdW5kZXRlcm1pbmVkXCIpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdCR0aGlzLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5hbmRTZWxmKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZCBqc3RyZWUtdW5jaGVja2VkXCIpLmFkZENsYXNzKFwianN0cmVlLXVuZGV0ZXJtaW5lZFwiKTtcblx0XHRcdFx0XHRcdFx0XHRpZihyYykgeyAkdGhpcy5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsIFwibGlcIikuYW5kU2VsZigpLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQkdGhpcy5yZW1vdmVDbGFzcyhcImpzdHJlZS11bmNoZWNrZWQganN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHJjKSB7ICR0aGlzLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLmRhdGEudWkgJiYgdGhpcy5kYXRhLmNoZWNrYm94Lm5vdWkpIHsgdGhpcy5kYXRhLnVpLnNlbGVjdGVkID0gdGhpcy5nZXRfY2hlY2tlZCgpOyB9XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayhvYmopO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRjaGVja19ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5nZV9zdGF0ZShvYmosIGZhbHNlKSkgeyBcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LmNoZWNrZWRfcGFyZW50X29wZW4pIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gdGhpcztcblx0XHRcdFx0XHRcdG9iai5wYXJlbnRzKFwiLmpzdHJlZS1jbG9zZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7IHQub3Blbl9ub2RlKHRoaXMsIGZhbHNlLCB0cnVlKTsgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7IFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5jaGVja19ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5nZV9zdGF0ZShvYmosIHRydWUpKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiB0aGlzLl9nZXRfbm9kZShvYmopIH0pOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y2hlY2tfYWxsIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzLCBcblx0XHRcdFx0XHRjb2xsID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZmluZChcImxpXCIpIDogdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXCJsaVwiKTtcblx0XHRcdFx0Y29sbC5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRfdGhpcy5jaGFuZ2Vfc3RhdGUodGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5jaGVja19hbGwgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdFx0Y29sbCA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSA/IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoXCJsaVwiKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwibGlcIik7XG5cdFx0XHRcdGNvbGwuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0X3RoaXMuY2hhbmdlX3N0YXRlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc19jaGVja2VkIDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHJldHVybiBvYmoubGVuZ3RoID8gb2JqLmlzKFwiLmpzdHJlZS1jaGVja2VkXCIpIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X2NoZWNrZWQgOiBmdW5jdGlvbiAob2JqLCBnZXRfYWxsKSB7XG5cdFx0XHRcdG9iaiA9ICFvYmogfHwgb2JqID09PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpIDogdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0cmV0dXJuIGdldF9hbGwgfHwgdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlID8gb2JqLmZpbmQoXCIuanN0cmVlLWNoZWNrZWRcIikgOiBvYmouZmluZChcIj4gdWwgPiAuanN0cmVlLWNoZWNrZWQsIC5qc3RyZWUtdW5kZXRlcm1pbmVkID4gdWwgPiAuanN0cmVlLWNoZWNrZWRcIik7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X3VuY2hlY2tlZCA6IGZ1bmN0aW9uIChvYmosIGdldF9hbGwpIHsgXG5cdFx0XHRcdG9iaiA9ICFvYmogfHwgb2JqID09PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpIDogdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0cmV0dXJuIGdldF9hbGwgfHwgdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlID8gb2JqLmZpbmQoXCIuanN0cmVlLXVuY2hlY2tlZFwiKSA6IG9iai5maW5kKFwiPiB1bCA+IC5qc3RyZWUtdW5jaGVja2VkLCAuanN0cmVlLXVuZGV0ZXJtaW5lZCA+IHVsID4gLmpzdHJlZS11bmNoZWNrZWRcIik7XG5cdFx0XHR9LFxuXG5cdFx0XHRzaG93X2NoZWNrYm94ZXMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfSxcblx0XHRcdGhpZGVfY2hlY2tib3hlcyA6IGZ1bmN0aW9uICgpIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5hZGRDbGFzcyhcImpzdHJlZS1uby1jaGVja2JveGVzXCIpOyB9LFxuXG5cdFx0XHRfcmVwYWlyX3N0YXRlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gudHdvX3N0YXRlKSB7XG5cdFx0XHRcdFx0b2JqLmZpbmQoJ2xpJykuYW5kU2VsZigpLm5vdCgnLmpzdHJlZS1jaGVja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS11bmRldGVybWluZWQnKS5hZGRDbGFzcygnanN0cmVlLXVuY2hlY2tlZCcpLmNoaWxkcmVuKCc6Y2hlY2tib3gnKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByYyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnJlYWxfY2hlY2tib3hlcyxcblx0XHRcdFx0XHRhID0gb2JqLmZpbmQoXCI+IHVsID4gLmpzdHJlZS1jaGVja2VkXCIpLmxlbmd0aCxcblx0XHRcdFx0XHRiID0gb2JqLmZpbmQoXCI+IHVsID4gLmpzdHJlZS11bmRldGVybWluZWRcIikubGVuZ3RoLFxuXHRcdFx0XHRcdGMgPSBvYmouZmluZChcIj4gdWwgPiBsaVwiKS5sZW5ndGg7XG5cdFx0XHRcdGlmKGMgPT09IDApIHsgaWYob2JqLmhhc0NsYXNzKFwianN0cmVlLXVuZGV0ZXJtaW5lZFwiKSkgeyB0aGlzLmNoYW5nZV9zdGF0ZShvYmosIGZhbHNlKTsgfSB9XG5cdFx0XHRcdGVsc2UgaWYoYSA9PT0gMCAmJiBiID09PSAwKSB7IHRoaXMuY2hhbmdlX3N0YXRlKG9iaiwgdHJ1ZSk7IH1cblx0XHRcdFx0ZWxzZSBpZihhID09PSBjKSB7IHRoaXMuY2hhbmdlX3N0YXRlKG9iaiwgZmFsc2UpOyB9XG5cdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwibGlcIikuYW5kU2VsZigpLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWQganN0cmVlLXVuY2hlY2tlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmRldGVybWluZWRcIik7XG5cdFx0XHRcdFx0aWYocmMpIHsgb2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5hbmRTZWxmKCkuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNlbGVjdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYodGhpcy5kYXRhLnVpICYmIHRoaXMuZGF0YS5jaGVja2JveC5ub3VpKSB7IFxuXHRcdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdFx0XHRzID0gdGhpcy5kYXRhLnVpLnRvX3NlbGVjdDtcblx0XHRcdFx0XHRzID0gJC5tYXAoJC5tYWtlQXJyYXkocyksIGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIiNcIiArIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIik7IH0pO1xuXHRcdFx0XHRcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XG5cdFx0XHRcdFx0JC5lYWNoKHMsIGZ1bmN0aW9uIChpLCB2YWwpIHsgX3RoaXMuY2hlY2tfbm9kZSh2YWwpOyB9KTtcblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxfb2xkKCk7IFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2F2ZV9sb2FkZWQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQgPSBbXTtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZmluZChcImxpLmpzdHJlZS1jbG9zZWQuanN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZih0aGlzLmlkKSB7IF90aGlzLmRhdGEuY29yZS50b19sb2FkLnB1c2goXCIjXCIgKyB0aGlzLmlkKTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjc3Nfc3RyaW5nID0gJy5qc3RyZWUgLmpzdHJlZS1yZWFsLWNoZWNrYm94IHsgZGlzcGxheTpub25lOyB9ICc7XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJqc3RyZWVcIiB9KTtcblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBYTUwgcGx1Z2luXG4gKiBUaGUgWE1MIGRhdGEgc3RvcmUuIERhdGFzdG9yZXMgYXJlIGJ1aWxkIGJ5IG92ZXJyaWRpbmcgdGhlIGBsb2FkX25vZGVgIGFuZCBgX2lzX2xvYWRlZGAgZnVuY3Rpb25zLlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC52YWthdGEueHNsdCA9IGZ1bmN0aW9uICh4bWwsIHhzbCwgY2FsbGJhY2spIHtcblx0XHR2YXIgcnMgPSBcIlwiLCB4bSwgeHMsIHByb2Nlc3Nvciwgc3VwcG9ydDtcblx0XHQvLyBUT0RPOiBJRTkgbm8gWFNMVFByb2Nlc3Nvciwgbm8gZG9jdW1lbnQucmVjYWxjXG5cdFx0aWYoZG9jdW1lbnQucmVjYWxjKSB7XG5cdFx0XHR4bSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3htbCcpO1xuXHRcdFx0eHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4bWwnKTtcblx0XHRcdHhtLmlubmVySFRNTCA9IHhtbDtcblx0XHRcdHhzLmlubmVySFRNTCA9IHhzbDtcblx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh4bSkuYXBwZW5kKHhzKTtcblx0XHRcdHNldFRpbWVvdXQoIChmdW5jdGlvbiAoeG0sIHhzLCBjYWxsYmFjaykge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgeG0udHJhbnNmb3JtTm9kZSh4cy5YTUxEb2N1bWVudCkpO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoIChmdW5jdGlvbiAoeG0sIHhzKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7ICQoeG0pLnJlbW92ZSgpOyAkKHhzKS5yZW1vdmUoKTsgfTsgfSkoeG0sIHhzKSwgMjAwKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pKHhtLCB4cywgY2FsbGJhY2spLCAxMDApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiB3aW5kb3cuRE9NUGFyc2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5YU0xUUHJvY2Vzc29yID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR4bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbCwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdHhzbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeHNsLCBcInRleHQveG1sXCIpO1xuXHRcdFx0Ly8gYWxlcnQoeG1sLnRyYW5zZm9ybU5vZGUoKSk7XG5cdFx0XHQvLyBjYWxsYmFjay5jYWxsKG51bGwsIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcocnMpKTtcblx0XHRcdFxuXHRcdH1cblx0XHRpZih0eXBlb2Ygd2luZG93LkRPTVBhcnNlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuWFNMVFByb2Nlc3NvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0cHJvY2Vzc29yID0gbmV3IFhTTFRQcm9jZXNzb3IoKTtcblx0XHRcdHN1cHBvcnQgPSAkLmlzRnVuY3Rpb24ocHJvY2Vzc29yLnRyYW5zZm9ybURvY3VtZW50KSA/ICh0eXBlb2Ygd2luZG93LlhNTFNlcmlhbGl6ZXIgIT09IFwidW5kZWZpbmVkXCIpIDogdHJ1ZTtcblx0XHRcdGlmKCFzdXBwb3J0KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0eG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWwsIFwidGV4dC94bWxcIik7XG5cdFx0XHR4c2wgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhzbCwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdGlmKCQuaXNGdW5jdGlvbihwcm9jZXNzb3IudHJhbnNmb3JtRG9jdW1lbnQpKSB7XG5cdFx0XHRcdHJzID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoXCJcIiwgXCJcIiwgbnVsbCk7XG5cdFx0XHRcdHByb2Nlc3Nvci50cmFuc2Zvcm1Eb2N1bWVudCh4bWwsIHhzbCwgcnMsIG51bGwpO1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKG51bGwsIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcocnMpKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cHJvY2Vzc29yLmltcG9ydFN0eWxlc2hlZXQoeHNsKTtcblx0XHRcdFx0cnMgPSBwcm9jZXNzb3IudHJhbnNmb3JtVG9GcmFnbWVudCh4bWwsIGRvY3VtZW50KTtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbChudWxsLCAkKFwiPGRpdiAvPlwiKS5hcHBlbmQocnMpLmh0bWwoKSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cdHZhciB4c2wgPSB7XG5cdFx0J25lc3QnIDogJzwnICsgJz94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwidXRmLThcIiA/PicgKyBcblx0XHRcdCc8eHNsOnN0eWxlc2hlZXQgdmVyc2lvbj1cIjEuMFwiIHhtbG5zOnhzbD1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvWFNML1RyYW5zZm9ybVwiID4nICsgXG5cdFx0XHQnPHhzbDpvdXRwdXQgbWV0aG9kPVwiaHRtbFwiIGVuY29kaW5nPVwidXRmLThcIiBvbWl0LXhtbC1kZWNsYXJhdGlvbj1cInllc1wiIHN0YW5kYWxvbmU9XCJub1wiIGluZGVudD1cIm5vXCIgbWVkaWEtdHlwZT1cInRleHQvaHRtbFwiIC8+JyArIFxuXHRcdFx0Jzx4c2w6dGVtcGxhdGUgbWF0Y2g9XCIvXCI+JyArIFxuXHRcdFx0J1x0PHhzbDpjYWxsLXRlbXBsYXRlIG5hbWU9XCJub2Rlc1wiPicgKyBcblx0XHRcdCdcdFx0PHhzbDp3aXRoLXBhcmFtIG5hbWU9XCJub2RlXCIgc2VsZWN0PVwiL3Jvb3RcIiAvPicgKyBcblx0XHRcdCdcdDwveHNsOmNhbGwtdGVtcGxhdGU+JyArIFxuXHRcdFx0JzwveHNsOnRlbXBsYXRlPicgKyBcblx0XHRcdCc8eHNsOnRlbXBsYXRlIG5hbWU9XCJub2Rlc1wiPicgKyBcblx0XHRcdCdcdDx4c2w6cGFyYW0gbmFtZT1cIm5vZGVcIiAvPicgKyBcblx0XHRcdCdcdDx1bD4nICsgXG5cdFx0XHQnXHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cIiRub2RlL2l0ZW1cIj4nICsgXG5cdFx0XHQnXHRcdDx4c2w6dmFyaWFibGUgbmFtZT1cImNoaWxkcmVuXCIgc2VsZWN0PVwiY291bnQoLi9pdGVtKSAmZ3Q7IDBcIiAvPicgKyBcblx0XHRcdCdcdFx0PGxpPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwiY2xhc3NcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJwb3NpdGlvbigpID0gbGFzdCgpXCI+anN0cmVlLWxhc3QgPC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDpjaG9vc2U+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOndoZW4gdGVzdD1cIkBzdGF0ZSA9IFxcJ29wZW5cXCdcIj5qc3RyZWUtb3BlbiA8L3hzbDp3aGVuPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCIkY2hpbGRyZW4gb3IgQGhhc0NoaWxkcmVuIG9yIEBzdGF0ZSA9IFxcJ2Nsb3NlZFxcJ1wiPmpzdHJlZS1jbG9zZWQgPC94c2w6d2hlbj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6b3RoZXJ3aXNlPmpzdHJlZS1sZWFmIDwveHNsOm90aGVyd2lzZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L3hzbDpjaG9vc2U+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAY2xhc3NcIiAvPicgKyBcblx0XHRcdCdcdFx0XHQ8L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiQCpcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJuYW1lKCkgIT0gXFwnY2xhc3NcXCcgYW5kIG5hbWUoKSAhPSBcXCdzdGF0ZVxcJyBhbmQgbmFtZSgpICE9IFxcJ2hhc0NoaWxkcmVuXFwnXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwie25hbWUoKX1cIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIi5cIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdFx0PC94c2w6Zm9yLWVhY2g+JyArIFxuXHRcdFx0J1x0PGlucyBjbGFzcz1cImpzdHJlZS1pY29uXCI+PHhzbDp0ZXh0PiYjeGEwOzwveHNsOnRleHQ+PC9pbnM+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiY29udGVudC9uYW1lXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0PGE+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImhyZWZcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCJAaHJlZlwiPjx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGhyZWZcIiAvPjwveHNsOndoZW4+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOm90aGVyd2lzZT4jPC94c2w6b3RoZXJ3aXNlPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PC94c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0XHRcdDwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwiY2xhc3NcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBsYW5nXCIgLz4gPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAY2xhc3NcIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwic3R5bGVcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBzdHlsZVwiIC8+PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiQCpcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6aWYgdGVzdD1cIm5hbWUoKSAhPSBcXCdzdHlsZVxcJyBhbmQgbmFtZSgpICE9IFxcJ2NsYXNzXFwnIGFuZCBuYW1lKCkgIT0gXFwnaHJlZlxcJ1wiPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwie25hbWUoKX1cIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIi5cIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0XHRcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PGlucz4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+anN0cmVlLWljb24gJyArIFxuXHRcdFx0J1x0XHRcdFx0XHRcdFx0PHhzbDppZiB0ZXN0PVwic3RyaW5nLWxlbmd0aChhdHRyaWJ1dGU6Omljb24pID4gMCBhbmQgbm90KGNvbnRhaW5zKEBpY29uLFxcJy9cXCcpKVwiPjx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGljb25cIiAvPjwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0XHQ8L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHRcdDx4c2w6aWYgdGVzdD1cInN0cmluZy1sZW5ndGgoYXR0cmlidXRlOjppY29uKSA+IDAgYW5kIGNvbnRhaW5zKEBpY29uLFxcJy9cXCcpXCI+PHhzbDphdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCI+YmFja2dyb3VuZDp1cmwoPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAaWNvblwiIC8+KSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdDs8L3hzbDphdHRyaWJ1dGU+PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHRcdDx4c2w6dGV4dD4mI3hhMDs8L3hzbDp0ZXh0PicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PC9pbnM+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOmNvcHktb2Ygc2VsZWN0PVwiLi9jaGlsZDo6bm9kZSgpXCIgLz4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L2E+JyArIFxuXHRcdFx0J1x0XHRcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmlmIHRlc3Q9XCIkY2hpbGRyZW4gb3IgQGhhc0NoaWxkcmVuXCI+PHhzbDpjYWxsLXRlbXBsYXRlIG5hbWU9XCJub2Rlc1wiPjx4c2w6d2l0aC1wYXJhbSBuYW1lPVwibm9kZVwiIHNlbGVjdD1cImN1cnJlbnQoKVwiIC8+PC94c2w6Y2FsbC10ZW1wbGF0ZT48L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdDwvbGk+JyArIFxuXHRcdFx0J1x0PC94c2w6Zm9yLWVhY2g+JyArIFxuXHRcdFx0J1x0PC91bD4nICsgXG5cdFx0XHQnPC94c2w6dGVtcGxhdGU+JyArIFxuXHRcdFx0JzwveHNsOnN0eWxlc2hlZXQ+JyxcblxuXHRcdCdmbGF0JyA6ICc8JyArICc/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCIgPz4nICsgXG5cdFx0XHQnPHhzbDpzdHlsZXNoZWV0IHZlcnNpb249XCIxLjBcIiB4bWxuczp4c2w9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L1hTTC9UcmFuc2Zvcm1cIiA+JyArIFxuXHRcdFx0Jzx4c2w6b3V0cHV0IG1ldGhvZD1cImh0bWxcIiBlbmNvZGluZz1cInV0Zi04XCIgb21pdC14bWwtZGVjbGFyYXRpb249XCJ5ZXNcIiBzdGFuZGFsb25lPVwibm9cIiBpbmRlbnQ9XCJub1wiIG1lZGlhLXR5cGU9XCJ0ZXh0L3htbFwiIC8+JyArIFxuXHRcdFx0Jzx4c2w6dGVtcGxhdGUgbWF0Y2g9XCIvXCI+JyArIFxuXHRcdFx0J1x0PHVsPicgKyBcblx0XHRcdCdcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiLy9pdGVtW25vdChAcGFyZW50X2lkKSBvciBAcGFyZW50X2lkPTAgb3Igbm90KEBwYXJlbnRfaWQgPSAvL2l0ZW0vQGlkKV1cIj4nICsgLyogdGhlIGxhc3QgYG9yYCBtYXkgYmUgcmVtb3ZlZCAqL1xuXHRcdFx0J1x0XHQ8eHNsOmNhbGwtdGVtcGxhdGUgbmFtZT1cIm5vZGVzXCI+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6d2l0aC1wYXJhbSBuYW1lPVwibm9kZVwiIHNlbGVjdD1cIi5cIiAvPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOndpdGgtcGFyYW0gbmFtZT1cImlzX2xhc3RcIiBzZWxlY3Q9XCJudW1iZXIocG9zaXRpb24oKSA9IGxhc3QoKSlcIiAvPicgKyBcblx0XHRcdCdcdFx0PC94c2w6Y2FsbC10ZW1wbGF0ZT4nICsgXG5cdFx0XHQnXHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHQ8L3VsPicgKyBcblx0XHRcdCc8L3hzbDp0ZW1wbGF0ZT4nICsgXG5cdFx0XHQnPHhzbDp0ZW1wbGF0ZSBuYW1lPVwibm9kZXNcIj4nICsgXG5cdFx0XHQnXHQ8eHNsOnBhcmFtIG5hbWU9XCJub2RlXCIgLz4nICsgXG5cdFx0XHQnXHQ8eHNsOnBhcmFtIG5hbWU9XCJpc19sYXN0XCIgLz4nICsgXG5cdFx0XHQnXHQ8eHNsOnZhcmlhYmxlIG5hbWU9XCJjaGlsZHJlblwiIHNlbGVjdD1cImNvdW50KC8vaXRlbVtAcGFyZW50X2lkPSRub2RlL2F0dHJpYnV0ZTo6aWRdKSAmZ3Q7IDBcIiAvPicgKyBcblx0XHRcdCdcdDxsaT4nICsgXG5cdFx0XHQnXHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwiY2xhc3NcIj4nICsgXG5cdFx0XHQnXHRcdDx4c2w6aWYgdGVzdD1cIiRpc19sYXN0ID0gdHJ1ZSgpXCI+anN0cmVlLWxhc3QgPC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCJAc3RhdGUgPSBcXCdvcGVuXFwnXCI+anN0cmVlLW9wZW4gPC94c2w6d2hlbj4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCIkY2hpbGRyZW4gb3IgQGhhc0NoaWxkcmVuIG9yIEBzdGF0ZSA9IFxcJ2Nsb3NlZFxcJ1wiPmpzdHJlZS1jbG9zZWQgPC94c2w6d2hlbj4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDpvdGhlcndpc2U+anN0cmVlLWxlYWYgPC94c2w6b3RoZXJ3aXNlPicgKyBcblx0XHRcdCdcdFx0PC94c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAY2xhc3NcIiAvPicgKyBcblx0XHRcdCdcdDwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cIkAqXCI+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmlmIHRlc3Q9XCJuYW1lKCkgIT0gXFwncGFyZW50X2lkXFwnIGFuZCBuYW1lKCkgIT0gXFwnaGFzQ2hpbGRyZW5cXCcgYW5kIG5hbWUoKSAhPSBcXCdjbGFzc1xcJyBhbmQgbmFtZSgpICE9IFxcJ3N0YXRlXFwnXCI+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwie25hbWUoKX1cIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIi5cIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdDwveHNsOmlmPicgKyBcblx0XHRcdCdcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdDxpbnMgY2xhc3M9XCJqc3RyZWUtaWNvblwiPjx4c2w6dGV4dD4mI3hhMDs8L3hzbDp0ZXh0PjwvaW5zPicgKyBcblx0XHRcdCdcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiY29udGVudC9uYW1lXCI+JyArIFxuXHRcdFx0J1x0XHQ8YT4nICsgXG5cdFx0XHQnXHRcdDx4c2w6YXR0cmlidXRlIG5hbWU9XCJocmVmXCI+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOndoZW4gdGVzdD1cIkBocmVmXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAaHJlZlwiIC8+PC94c2w6d2hlbj4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDpvdGhlcndpc2U+IzwveHNsOm90aGVyd2lzZT4nICsgXG5cdFx0XHQnXHRcdFx0PC94c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAbGFuZ1wiIC8+IDx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGNsYXNzXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwic3R5bGVcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBzdHlsZVwiIC8+PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0PHhzbDpmb3ItZWFjaCBzZWxlY3Q9XCJAKlwiPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJuYW1lKCkgIT0gXFwnc3R5bGVcXCcgYW5kIG5hbWUoKSAhPSBcXCdjbGFzc1xcJyBhbmQgbmFtZSgpICE9IFxcJ2hyZWZcXCdcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwie25hbWUoKX1cIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIi5cIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHRcdFx0PGlucz4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwiY2xhc3NcIj5qc3RyZWUtaWNvbiAnICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6aWYgdGVzdD1cInN0cmluZy1sZW5ndGgoYXR0cmlidXRlOjppY29uKSA+IDAgYW5kIG5vdChjb250YWlucyhAaWNvbixcXCcvXFwnKSlcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBpY29uXCIgLz48L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDppZiB0ZXN0PVwic3RyaW5nLWxlbmd0aChhdHRyaWJ1dGU6Omljb24pID4gMCBhbmQgY29udGFpbnMoQGljb24sXFwnL1xcJylcIj48eHNsOmF0dHJpYnV0ZSBuYW1lPVwic3R5bGVcIj5iYWNrZ3JvdW5kOnVybCg8eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBpY29uXCIgLz4pIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0OzwveHNsOmF0dHJpYnV0ZT48L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOnRleHQ+JiN4YTA7PC94c2w6dGV4dD4nICsgXG5cdFx0XHQnXHRcdFx0PC9pbnM+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6Y29weS1vZiBzZWxlY3Q9XCIuL2NoaWxkOjpub2RlKClcIiAvPicgKyBcblx0XHRcdCdcdFx0PC9hPicgKyBcblx0XHRcdCdcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdDx4c2w6aWYgdGVzdD1cIiRjaGlsZHJlblwiPicgKyBcblx0XHRcdCdcdFx0PHVsPicgKyBcblx0XHRcdCdcdFx0PHhzbDpmb3ItZWFjaCBzZWxlY3Q9XCIvL2l0ZW1bQHBhcmVudF9pZD0kbm9kZS9hdHRyaWJ1dGU6OmlkXVwiPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmNhbGwtdGVtcGxhdGUgbmFtZT1cIm5vZGVzXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDp3aXRoLXBhcmFtIG5hbWU9XCJub2RlXCIgc2VsZWN0PVwiLlwiIC8+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDp3aXRoLXBhcmFtIG5hbWU9XCJpc19sYXN0XCIgc2VsZWN0PVwibnVtYmVyKHBvc2l0aW9uKCkgPSBsYXN0KCkpXCIgLz4nICsgXG5cdFx0XHQnXHRcdFx0PC94c2w6Y2FsbC10ZW1wbGF0ZT4nICsgXG5cdFx0XHQnXHRcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdFx0PC91bD4nICsgXG5cdFx0XHQnXHQ8L3hzbDppZj4nICsgXG5cdFx0XHQnXHQ8L2xpPicgKyBcblx0XHRcdCc8L3hzbDp0ZW1wbGF0ZT4nICsgXG5cdFx0XHQnPC94c2w6c3R5bGVzaGVldD4nXG5cdH0sXG5cdGVzY2FwZV94bWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHQudG9TdHJpbmcoKVxuXHRcdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jylcblx0XHRcdC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcblx0fTtcblx0JC5qc3RyZWUucGx1Z2luKFwieG1sX2RhdGFcIiwge1xuXHRcdGRlZmF1bHRzIDogeyBcblx0XHRcdGRhdGEgOiBmYWxzZSxcblx0XHRcdGFqYXggOiBmYWxzZSxcblx0XHRcdHhzbCA6IFwiZmxhdFwiLFxuXHRcdFx0Y2xlYW5fbm9kZSA6IGZhbHNlLFxuXHRcdFx0Y29ycmVjdF9zdGF0ZSA6IHRydWUsXG5cdFx0XHRnZXRfc2tpcF9lbXB0eSA6IGZhbHNlLFxuXHRcdFx0Z2V0X2luY2x1ZGVfcHJlYW1ibGUgOiB0cnVlXG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRsb2FkX25vZGUgOiBmdW5jdGlvbiAob2JqLCBzX2NhbGwsIGVfY2FsbCkgeyB2YXIgX3RoaXMgPSB0aGlzOyB0aGlzLmxvYWRfbm9kZV94bWwob2JqLCBmdW5jdGlvbiAoKSB7IF90aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogX3RoaXMuX2dldF9ub2RlKG9iaikgfSk7IHNfY2FsbC5jYWxsKHRoaXMpOyB9LCBlX2NhbGwpOyB9LFxuXHRcdFx0X2lzX2xvYWRlZCA6IGZ1bmN0aW9uIChvYmopIHsgXG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkueG1sX2RhdGE7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHJldHVybiBvYmogPT0gLTEgfHwgIW9iaiB8fCAoIXMuYWpheCAmJiAhJC5pc0Z1bmN0aW9uKHMuZGF0YSkpIHx8IG9iai5pcyhcIi5qc3RyZWUtb3BlbiwgLmpzdHJlZS1sZWFmXCIpIHx8IG9iai5jaGlsZHJlbihcInVsXCIpLmNoaWxkcmVuKFwibGlcIikuc2l6ZSgpID4gMDtcblx0XHRcdH0sXG5cdFx0XHRsb2FkX25vZGVfeG1sIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLmdldF9zZXR0aW5ncygpLnhtbF9kYXRhLFxuXHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoKSB7fSxcblx0XHRcdFx0XHRzdWNjZXNzX2Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmKG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIikpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIix0cnVlKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCghMCkge1xuXHRcdFx0XHRcdGNhc2UgKCFzLmRhdGEgJiYgIXMuYWpheCk6IHRocm93IFwiTmVpdGhlciBkYXRhIG5vciBhamF4IHNldHRpbmdzIHN1cHBsaWVkLlwiO1xuXHRcdFx0XHRcdGNhc2UgKCQuaXNGdW5jdGlvbihzLmRhdGEpKTpcblx0XHRcdFx0XHRcdHMuZGF0YS5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhcnNlX3htbChkLCAkLnByb3h5KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZCA9IGQucmVwbGFjZSgvID94bWxucz1cIlteXCJdKlwiL2lnLCBcIlwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZCA9ICQoZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKG9iaiA9PT0gLTEgfHwgIW9iaikgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCkuYXBwZW5kKGQuY2hpbGRyZW4oKSk7IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7IG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTsgb2JqLmFwcGVuZChkKTsgb2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNsZWFuX25vZGUpIHsgdGhpcy5jbGVhbl9ub2RlKG9iaik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jb3JyZWN0X3N0YXRlKG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCEhcy5kYXRhICYmICFzLmFqYXgpIHx8ICghIXMuZGF0YSAmJiAhIXMuYWpheCAmJiAoIW9iaiB8fCBvYmogPT09IC0xKSk6XG5cdFx0XHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhcnNlX3htbChzLmRhdGEsICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkID0gZC5yZXBsYWNlKC8gP3htbG5zPVwiW15cIl0qXCIvaWcsIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5sZW5ndGggPiAxMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkID0gJChkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNsZWFuX25vZGUpIHsgdGhpcy5jbGVhbl9ub2RlKG9iaik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghcy5kYXRhICYmICEhcy5hamF4KSB8fCAoISFzLmRhdGEgJiYgISFzLmFqYXggJiYgb2JqICYmIG9iaiAhPT0gLTEpOlxuXHRcdFx0XHRcdFx0ZXJyb3JfZnVuYyA9IGZ1bmN0aW9uICh4LCB0LCBlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlZiA9IHRoaXMuZ2V0X3NldHRpbmdzKCkueG1sX2RhdGEuYWpheC5lcnJvcjsgXG5cdFx0XHRcdFx0XHRcdGlmKGVmKSB7IGVmLmNhbGwodGhpcywgeCwgdCwgZSk7IH1cblx0XHRcdFx0XHRcdFx0aWYob2JqICE9PSAtMSAmJiBvYmoubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0aWYodCA9PT0gXCJzdWNjZXNzXCIgJiYgcy5jb3JyZWN0X3N0YXRlKSB7IHRoaXMuY29ycmVjdF9zdGF0ZShvYmopOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodCA9PT0gXCJzdWNjZXNzXCIgJiYgcy5jb3JyZWN0X3N0YXRlKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGVfY2FsbCkgeyBlX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHN1Y2Nlc3NfZnVuYyA9IGZ1bmN0aW9uIChkLCB0LCB4KSB7XG5cdFx0XHRcdFx0XHRcdGQgPSB4LnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRcdFx0dmFyIHNmID0gdGhpcy5nZXRfc2V0dGluZ3MoKS54bWxfZGF0YS5hamF4LnN1Y2Nlc3M7IFxuXHRcdFx0XHRcdFx0XHRpZihzZikgeyBkID0gc2YuY2FsbCh0aGlzLGQsdCx4KSB8fCBkOyB9XG5cdFx0XHRcdFx0XHRcdGlmKGQgPT09IFwiXCIgfHwgKGQgJiYgZC50b1N0cmluZyAmJiBkLnRvU3RyaW5nKCkucmVwbGFjZSgvXltcXHNcXG5dKyQvLFwiXCIpID09PSBcIlwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcl9mdW5jLmNhbGwodGhpcywgeCwgdCwgXCJcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJzZV94bWwoZCwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQgPSBkLnJlcGxhY2UoLyA/eG1sbnM9XCJbXlwiXSpcIi9pZywgXCJcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmxlbmd0aCA+IDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGQgPSAkKGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgeyBvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7IG9iai5hcHBlbmQoZCk7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jbGVhbl9ub2RlKSB7IHRoaXMuY2xlYW5fbm9kZShvYmopOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuY29ycmVjdF9zdGF0ZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cy5hamF4LmNvbnRleHQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0cy5hamF4LmVycm9yID0gZXJyb3JfZnVuYztcblx0XHRcdFx0XHRcdHMuYWpheC5zdWNjZXNzID0gc3VjY2Vzc19mdW5jO1xuXHRcdFx0XHRcdFx0aWYoIXMuYWpheC5kYXRhVHlwZSkgeyBzLmFqYXguZGF0YVR5cGUgPSBcInhtbFwiOyB9XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LnVybCkpIHsgcy5hamF4LnVybCA9IHMuYWpheC51cmwuY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LmRhdGEpKSB7IHMuYWpheC5kYXRhID0gcy5hamF4LmRhdGEuY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdFx0XHQkLmFqYXgocy5hamF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cGFyc2VfeG1sIDogZnVuY3Rpb24gKHhtbCwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS54bWxfZGF0YTtcblx0XHRcdFx0JC52YWthdGEueHNsdCh4bWwsIHhzbFtzLnhzbF0sIGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRfeG1sIDogZnVuY3Rpb24gKHRwLCBvYmosIGxpX2F0dHIsIGFfYXR0ciwgaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFwiXCIsIFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKSwgXG5cdFx0XHRcdFx0X3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdHRtcDEsIHRtcDIsIGxpLCBhLCBsYW5nO1xuXHRcdFx0XHRpZighdHApIHsgdHAgPSBcImZsYXRcIjsgfVxuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHsgaXNfY2FsbGJhY2sgPSAwOyB9XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSkgeyBvYmogPSB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpXCIpOyB9XG5cdFx0XHRcdGxpX2F0dHIgPSAkLmlzQXJyYXkobGlfYXR0cikgPyBsaV9hdHRyIDogWyBcImlkXCIsIFwiY2xhc3NcIiBdO1xuXHRcdFx0XHRpZighaXNfY2FsbGJhY2sgJiYgdGhpcy5kYXRhLnR5cGVzICYmICQuaW5BcnJheShzLnR5cGVzLnR5cGVfYXR0ciwgbGlfYXR0cikgPT09IC0xKSB7IGxpX2F0dHIucHVzaChzLnR5cGVzLnR5cGVfYXR0cik7IH1cblxuXHRcdFx0XHRhX2F0dHIgPSAkLmlzQXJyYXkoYV9hdHRyKSA/IGFfYXR0ciA6IFsgXTtcblxuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHsgXG5cdFx0XHRcdFx0aWYocy54bWxfZGF0YS5nZXRfaW5jbHVkZV9wcmVhbWJsZSkgeyBcblx0XHRcdFx0XHRcdHJlc3VsdCArPSAnPCcgKyAnP3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPycgKyAnPic7IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8cm9vdD5cIjsgXG5cdFx0XHRcdH1cblx0XHRcdFx0b2JqLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBcIjxpdGVtXCI7XG5cdFx0XHRcdFx0bGkgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdCQuZWFjaChsaV9hdHRyLCBmdW5jdGlvbiAoaSwgdikgeyBcblx0XHRcdFx0XHRcdHZhciB0ID0gbGkuYXR0cih2KTtcblx0XHRcdFx0XHRcdGlmKCFzLnhtbF9kYXRhLmdldF9za2lwX2VtcHR5IHx8IHR5cGVvZiB0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIiBcIiArIHYgKyBcIj1cXFwiXCIgKyBlc2NhcGVfeG1sKChcIiBcIiArICh0IHx8IFwiXCIpKS5yZXBsYWNlKC8ganN0cmVlW14gXSovaWcsJycpLnJlcGxhY2UoL1xccyskL2lnLFwiIFwiKS5yZXBsYWNlKC9eIC8sXCJcIikucmVwbGFjZSgvICQvLFwiXCIpKSArIFwiXFxcIlwiOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZihsaS5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHJlc3VsdCArPSBcIiBzdGF0ZT1cXFwib3BlblxcXCJcIjsgfVxuXHRcdFx0XHRcdGlmKGxpLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyByZXN1bHQgKz0gXCIgc3RhdGU9XFxcImNsb3NlZFxcXCJcIjsgfVxuXHRcdFx0XHRcdGlmKHRwID09PSBcImZsYXRcIikgeyByZXN1bHQgKz0gXCIgcGFyZW50X2lkPVxcXCJcIiArIGVzY2FwZV94bWwoaXNfY2FsbGJhY2spICsgXCJcXFwiXCI7IH1cblx0XHRcdFx0XHRyZXN1bHQgKz0gXCI+XCI7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiPGNvbnRlbnQ+XCI7XG5cdFx0XHRcdFx0YSA9IGxpLmNoaWxkcmVuKFwiYVwiKTtcblx0XHRcdFx0XHRhLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dG1wMSA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHRsYW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8bmFtZVwiO1xuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KFwibGFuZ3VhZ2VzXCIsIHMucGx1Z2lucykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdCQuZWFjaChzLmxhbmd1YWdlcywgZnVuY3Rpb24gKGssIHopIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0bXAxLmhhc0NsYXNzKHopKSB7IHJlc3VsdCArPSBcIiBsYW5nPVxcXCJcIiArIGVzY2FwZV94bWwoeikgKyBcIlxcXCJcIjsgbGFuZyA9IHo7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGFfYXR0ci5sZW5ndGgpIHsgXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhX2F0dHIsIGZ1bmN0aW9uIChrLCB6KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHQgPSB0bXAxLmF0dHIoeik7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIXMueG1sX2RhdGEuZ2V0X3NraXBfZW1wdHkgfHwgdHlwZW9mIHQgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIiBcIiArIHogKyBcIj1cXFwiXCIgKyBlc2NhcGVfeG1sKChcIiBcIiArIHQgfHwgXCJcIikucmVwbGFjZSgvIGpzdHJlZVteIF0qL2lnLCcnKS5yZXBsYWNlKC9cXHMrJC9pZyxcIiBcIikucmVwbGFjZSgvXiAvLFwiXCIpLnJlcGxhY2UoLyAkLyxcIlwiKSkgKyBcIlxcXCJcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodG1wMS5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsJycpLnJlcGxhY2UoL15cXHMrJC9pZyxcIlwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9ICcgaWNvbj1cIicgKyBlc2NhcGVfeG1sKHRtcDEuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKS5yZXBsYWNlKC9cXHMrJC9pZyxcIiBcIikucmVwbGFjZSgvXiAvLFwiXCIpLnJlcGxhY2UoLyAkLyxcIlwiKSkgKyAnXCInO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodG1wMS5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuc3R5bGUuYmFja2dyb3VuZEltYWdlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gJyBpY29uPVwiJyArIGVzY2FwZV94bWwodG1wMS5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuc3R5bGUuYmFja2dyb3VuZEltYWdlLnJlcGxhY2UoXCJ1cmwoXCIsXCJcIikucmVwbGFjZShcIilcIixcIlwiKS5yZXBsYWNlKC8nL2lnLFwiXCIpLnJlcGxhY2UoL1wiL2lnLFwiXCIpKSArICdcIic7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI+XCI7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8IVtDREFUQVtcIiArIF90aGlzLmdldF90ZXh0KHRtcDEsIGxhbmcpICsgXCJdXT5cIjtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIjwvbmFtZT5cIjtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8L2NvbnRlbnQ+XCI7XG5cdFx0XHRcdFx0dG1wMiA9IGxpWzBdLmlkIHx8IHRydWU7XG5cdFx0XHRcdFx0bGkgPSBsaS5maW5kKFwiPiB1bCA+IGxpXCIpO1xuXHRcdFx0XHRcdGlmKGxpLmxlbmd0aCkgeyB0bXAyID0gX3RoaXMuZ2V0X3htbCh0cCwgbGksIGxpX2F0dHIsIGFfYXR0ciwgdG1wMik7IH1cblx0XHRcdFx0XHRlbHNlIHsgdG1wMiA9IFwiXCI7IH1cblx0XHRcdFx0XHRpZih0cCA9PSBcIm5lc3RcIikgeyByZXN1bHQgKz0gdG1wMjsgfVxuXHRcdFx0XHRcdHJlc3VsdCArPSBcIjwvaXRlbT5cIjtcblx0XHRcdFx0XHRpZih0cCA9PSBcImZsYXRcIikgeyByZXN1bHQgKz0gdG1wMjsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7IHJlc3VsdCArPSBcIjwvcm9vdD5cIjsgfVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuICoganNUcmVlIHNlYXJjaCBwbHVnaW5cbiAqIEVuYWJsZXMgYm90aCBzeW5jIGFuZCBhc3luYyBzZWFyY2ggb24gdGhlIHRyZWVcbiAqIERPRVMgTk9UIFdPUksgV0lUSCBKU09OIFBST0dSRVNTSVZFIFJFTkRFUlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5leHByWyc6J10uanN0cmVlX2NvbnRhaW5zID0gZnVuY3Rpb24oYSxpLG0pe1xuXHRcdHJldHVybiAoYS50ZXh0Q29udGVudCB8fCBhLmlubmVyVGV4dCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YobVszXS50b0xvd2VyQ2FzZSgpKT49MDtcblx0fTtcblx0JC5leHByWyc6J10uanN0cmVlX3RpdGxlX2NvbnRhaW5zID0gZnVuY3Rpb24oYSxpLG0pIHtcblx0XHRyZXR1cm4gKGEuZ2V0QXR0cmlidXRlKFwidGl0bGVcIikgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1bM10udG9Mb3dlckNhc2UoKSk+PTA7XG5cdH07XG5cdCQuanN0cmVlLnBsdWdpbihcInNlYXJjaFwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5zdHIgPSBcIlwiO1xuXHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQgPSAkKCk7XG5cdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5zZWFyY2guc2hvd19vbmx5X21hdGNoZXMpIHtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHQuYmluZChcInNlYXJjaC5qc3RyZWVcIiwgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdCQodGhpcykuY2hpbGRyZW4oXCJ1bFwiKS5maW5kKFwibGlcIikuaGlkZSgpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxhc3RcIik7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQubm9kZXMucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiKS5hbmRTZWxmKCkuc2hvdygpXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoXCJ1bFwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgJCh0aGlzKS5jaGlsZHJlbihcImxpOnZpc2libGVcIikuZXEoLTEpLmFkZENsYXNzKFwianN0cmVlLWxhc3RcIik7IH0pO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmJpbmQoXCJjbGVhcl9zZWFyY2guanN0cmVlXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdCQodGhpcykuY2hpbGRyZW4oXCJ1bFwiKS5maW5kKFwibGlcIikuY3NzKFwiZGlzcGxheVwiLFwiXCIpLmVuZCgpLmVuZCgpLmpzdHJlZShcImNsZWFuX25vZGVcIiwgLTEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRhamF4IDogZmFsc2UsXG5cdFx0XHRzZWFyY2hfbWV0aG9kIDogXCJqc3RyZWVfY29udGFpbnNcIiwgLy8gZm9yIGNhc2UgaW5zZW5zaXRpdmUgLSBqc3RyZWVfY29udGFpbnNcblx0XHRcdHNob3dfb25seV9tYXRjaGVzIDogZmFsc2Vcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdHNlYXJjaCA6IGZ1bmN0aW9uIChzdHIsIHNraXBfYXN5bmMpIHtcblx0XHRcdFx0aWYoJC50cmltKHN0cikgPT09IFwiXCIpIHsgdGhpcy5jbGVhcl9zZWFyY2goKTsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBzID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5zZWFyY2gsIFxuXHRcdFx0XHRcdHQgPSB0aGlzLFxuXHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoKSB7IH0sXG5cdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKCkgeyB9O1xuXHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnN0ciA9IHN0cjtcblxuXHRcdFx0XHRpZighc2tpcF9hc3luYyAmJiBzLmFqYXggIT09IGZhbHNlICYmIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoXCJsaS5qc3RyZWUtY2xvc2VkOm5vdCg6aGFzKHVsKSk6ZXEoMClcIikubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHRoaXMuc2VhcmNoLnN1cHJlc3NfY2FsbGJhY2sgPSB0cnVlO1xuXHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoKSB7IH07XG5cdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKGQsIHQsIHgpIHtcblx0XHRcdFx0XHRcdHZhciBzZiA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuc2VhcmNoLmFqYXguc3VjY2VzczsgXG5cdFx0XHRcdFx0XHRpZihzZikgeyBkID0gc2YuY2FsbCh0aGlzLGQsdCx4KSB8fCBkOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnRvX29wZW4gPSBkO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VhcmNoX29wZW4oKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHMuYWpheC5jb250ZXh0ID0gdGhpcztcblx0XHRcdFx0XHRzLmFqYXguZXJyb3IgPSBlcnJvcl9mdW5jO1xuXHRcdFx0XHRcdHMuYWpheC5zdWNjZXNzID0gc3VjY2Vzc19mdW5jO1xuXHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmFqYXgudXJsKSkgeyBzLmFqYXgudXJsID0gcy5hamF4LnVybC5jYWxsKHRoaXMsIHN0cik7IH1cblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LmRhdGEpKSB7IHMuYWpheC5kYXRhID0gcy5hamF4LmRhdGEuY2FsbCh0aGlzLCBzdHIpOyB9XG5cdFx0XHRcdFx0aWYoIXMuYWpheC5kYXRhKSB7IHMuYWpheC5kYXRhID0geyBcInNlYXJjaF9zdHJpbmdcIiA6IHN0ciB9OyB9XG5cdFx0XHRcdFx0aWYoIXMuYWpheC5kYXRhVHlwZSB8fCAvXmpzb24vLmV4ZWMocy5hamF4LmRhdGFUeXBlKSkgeyBzLmFqYXguZGF0YVR5cGUgPSBcImpzb25cIjsgfVxuXHRcdFx0XHRcdCQuYWpheChzLmFqYXgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLmRhdGEuc2VhcmNoLnJlc3VsdC5sZW5ndGgpIHsgdGhpcy5jbGVhcl9zZWFyY2goKTsgfVxuXHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnJlc3VsdCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCJhXCIgKyAodGhpcy5kYXRhLmxhbmd1YWdlcyA/IFwiLlwiICsgdGhpcy5nZXRfbGFuZygpIDogXCJcIiApICsgXCI6XCIgKyAocy5zZWFyY2hfbWV0aG9kKSArIFwiKFwiICsgdGhpcy5kYXRhLnNlYXJjaC5zdHIgKyBcIilcIik7XG5cdFx0XHRcdHRoaXMuZGF0YS5zZWFyY2gucmVzdWx0LmFkZENsYXNzKFwianN0cmVlLXNlYXJjaFwiKS5wYXJlbnQoKS5wYXJlbnRzKFwiLmpzdHJlZS1jbG9zZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dC5vcGVuX25vZGUodGhpcywgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgbm9kZXMgOiB0aGlzLmRhdGEuc2VhcmNoLnJlc3VsdCwgc3RyIDogc3RyIH0pO1xuXHRcdFx0fSxcblx0XHRcdGNsZWFyX3NlYXJjaCA6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtc2VhcmNoXCIpO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2sodGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQpO1xuXHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnJlc3VsdCA9ICQoKTtcblx0XHRcdH0sXG5cdFx0XHRfc2VhcmNoX29wZW4gOiBmdW5jdGlvbiAoaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcyxcblx0XHRcdFx0XHRkb25lID0gdHJ1ZSxcblx0XHRcdFx0XHRjdXJyZW50ID0gW10sXG5cdFx0XHRcdFx0cmVtYWluaW5nID0gW107XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5zZWFyY2gudG9fb3Blbi5sZW5ndGgpIHtcblx0XHRcdFx0XHQkLmVhY2godGhpcy5kYXRhLnNlYXJjaC50b19vcGVuLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRpZih2YWwgPT0gXCIjXCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdGlmKCQodmFsKS5sZW5ndGggJiYgJCh2YWwpLmlzKFwiLmpzdHJlZS1jbG9zZWRcIikpIHsgY3VycmVudC5wdXNoKHZhbCk7IH1cblx0XHRcdFx0XHRcdGVsc2UgeyByZW1haW5pbmcucHVzaCh2YWwpOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYoY3VycmVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5zZWFyY2gudG9fb3BlbiA9IHJlbWFpbmluZztcblx0XHRcdFx0XHRcdCQuZWFjaChjdXJyZW50LCBmdW5jdGlvbiAoaSwgdmFsKSB7IFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5vcGVuX25vZGUodmFsLCBmdW5jdGlvbiAoKSB7IF90aGlzLl9zZWFyY2hfb3Blbih0cnVlKTsgfSk7IFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGRvbmUpIHsgdGhpcy5zZWFyY2godGhpcy5kYXRhLnNlYXJjaC5zdHIsIHRydWUpOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qIFxuICoganNUcmVlIGNvbnRleHRtZW51IHBsdWdpblxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC52YWthdGEuY29udGV4dCA9IHtcblx0XHRoaWRlX29uX21vdXNlbGVhdmUgOiBmYWxzZSxcblxuXHRcdGNudFx0XHQ6ICQoXCI8ZGl2IGlkPSd2YWthdGEtY29udGV4dG1lbnUnIC8+XCIpLFxuXHRcdHZpc1x0XHQ6IGZhbHNlLFxuXHRcdHRndFx0XHQ6IGZhbHNlLFxuXHRcdHBhclx0XHQ6IGZhbHNlLFxuXHRcdGZ1bmNcdDogZmFsc2UsXG5cdFx0ZGF0YVx0OiBmYWxzZSxcblx0XHRydGxcdFx0OiBmYWxzZSxcblx0XHRzaG93XHQ6IGZ1bmN0aW9uIChzLCB0LCB4LCB5LCBkLCBwLCBydGwpIHtcblx0XHRcdCQudmFrYXRhLmNvbnRleHQucnRsID0gISFydGw7XG5cdFx0XHR2YXIgaHRtbCA9ICQudmFrYXRhLmNvbnRleHQucGFyc2UocyksIGgsIHc7XG5cdFx0XHRpZighaHRtbCkgeyByZXR1cm47IH1cblx0XHRcdCQudmFrYXRhLmNvbnRleHQudmlzID0gdHJ1ZTtcblx0XHRcdCQudmFrYXRhLmNvbnRleHQudGd0ID0gdDtcblx0XHRcdCQudmFrYXRhLmNvbnRleHQucGFyID0gcCB8fCB0IHx8IG51bGw7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LmRhdGEgPSBkIHx8IG51bGw7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudFxuXHRcdFx0XHQuaHRtbChodG1sKVxuXHRcdFx0XHQuY3NzKHsgXCJ2aXNpYmlsaXR5XCIgOiBcImhpZGRlblwiLCBcImRpc3BsYXlcIiA6IFwiYmxvY2tcIiwgXCJsZWZ0XCIgOiAwLCBcInRvcFwiIDogMCB9KTtcblxuXHRcdFx0aWYoJC52YWthdGEuY29udGV4dC5oaWRlX29uX21vdXNlbGVhdmUpIHtcblx0XHRcdFx0JC52YWthdGEuY29udGV4dC5jbnRcblx0XHRcdFx0XHQub25lKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihlKSB7ICQudmFrYXRhLmNvbnRleHQuaGlkZSgpOyB9KTtcblx0XHRcdH1cblxuXHRcdFx0aCA9ICQudmFrYXRhLmNvbnRleHQuY250LmhlaWdodCgpO1xuXHRcdFx0dyA9ICQudmFrYXRhLmNvbnRleHQuY250LndpZHRoKCk7XG5cdFx0XHRpZih4ICsgdyA+ICQoZG9jdW1lbnQpLndpZHRoKCkpIHsgXG5cdFx0XHRcdHggPSAkKGRvY3VtZW50KS53aWR0aCgpIC0gKHcgKyA1KTsgXG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCJsaSA+IHVsXCIpLmFkZENsYXNzKFwicmlnaHRcIik7IFxuXHRcdFx0fVxuXHRcdFx0aWYoeSArIGggPiAkKGRvY3VtZW50KS5oZWlnaHQoKSkgeyBcblx0XHRcdFx0eSA9IHkgLSAoaCArIHRbMF0ub2Zmc2V0SGVpZ2h0KTsgXG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCJsaSA+IHVsXCIpLmFkZENsYXNzKFwiYm90dG9tXCIpOyBcblx0XHRcdH1cblxuXHRcdFx0JC52YWthdGEuY29udGV4dC5jbnRcblx0XHRcdFx0LmNzcyh7IFwibGVmdFwiIDogeCwgXCJ0b3BcIiA6IHkgfSlcblx0XHRcdFx0LmZpbmQoXCJsaTpoYXModWwpXCIpXG5cdFx0XHRcdFx0LmJpbmQoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0dmFyIHcgPSAkKGRvY3VtZW50KS53aWR0aCgpLFxuXHRcdFx0XHRcdFx0XHRoID0gJChkb2N1bWVudCkuaGVpZ2h0KCksXG5cdFx0XHRcdFx0XHRcdHVsID0gJCh0aGlzKS5jaGlsZHJlbihcInVsXCIpLnNob3coKTsgXG5cdFx0XHRcdFx0XHRpZih3ICE9PSAkKGRvY3VtZW50KS53aWR0aCgpKSB7IHVsLnRvZ2dsZUNsYXNzKFwicmlnaHRcIik7IH1cblx0XHRcdFx0XHRcdGlmKGggIT09ICQoZG9jdW1lbnQpLmhlaWdodCgpKSB7IHVsLnRvZ2dsZUNsYXNzKFwiYm90dG9tXCIpOyB9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYmluZChcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNoaWxkcmVuKFwidWxcIikuaGlkZSgpOyBcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHQuY3NzKHsgXCJ2aXNpYmlsaXR5XCIgOiBcInZpc2libGVcIiB9KVxuXHRcdFx0XHQuc2hvdygpO1xuXHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJjb250ZXh0X3Nob3cudmFrYXRhXCIpO1xuXHRcdH0sXG5cdFx0aGlkZVx0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnZpcyA9IGZhbHNlO1xuXHRcdFx0JC52YWthdGEuY29udGV4dC5jbnQuYXR0cihcImNsYXNzXCIsXCJcIikuY3NzKHsgXCJ2aXNpYmlsaXR5XCIgOiBcImhpZGRlblwiIH0pO1xuXHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJjb250ZXh0X2hpZGUudmFrYXRhXCIpO1xuXHRcdH0sXG5cdFx0cGFyc2VcdDogZnVuY3Rpb24gKHMsIGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRpZighcykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBzdHIgPSBcIlwiLFxuXHRcdFx0XHR0bXAgPSBmYWxzZSxcblx0XHRcdFx0d2FzX3NlcCA9IHRydWU7XG5cdFx0XHRpZighaXNfY2FsbGJhY2spIHsgJC52YWthdGEuY29udGV4dC5mdW5jID0ge307IH1cblx0XHRcdHN0ciArPSBcIjx1bD5cIjtcblx0XHRcdCQuZWFjaChzLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdGlmKCF2YWwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0JC52YWthdGEuY29udGV4dC5mdW5jW2ldID0gdmFsLmFjdGlvbjtcblx0XHRcdFx0aWYoIXdhc19zZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcblx0XHRcdFx0XHRzdHIgKz0gXCI8bGkgY2xhc3M9J3Zha2F0YS1zZXBhcmF0b3IgdmFrYXRhLXNlcGFyYXRvci1iZWZvcmUnPjwvbGk+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FzX3NlcCA9IGZhbHNlO1xuXHRcdFx0XHRzdHIgKz0gXCI8bGkgY2xhc3M9J1wiICsgKHZhbC5fY2xhc3MgfHwgXCJcIikgKyAodmFsLl9kaXNhYmxlZCA/IFwiIGpzdHJlZS1jb250ZXh0bWVudS1kaXNhYmxlZCBcIiA6IFwiXCIpICsgXCInPjxpbnMgXCI7XG5cdFx0XHRcdGlmKHZhbC5pY29uICYmIHZhbC5pY29uLmluZGV4T2YoXCIvXCIpID09PSAtMSkgeyBzdHIgKz0gXCIgY2xhc3M9J1wiICsgdmFsLmljb24gKyBcIicgXCI7IH1cblx0XHRcdFx0aWYodmFsLmljb24gJiYgdmFsLmljb24uaW5kZXhPZihcIi9cIikgIT09IC0xKSB7IHN0ciArPSBcIiBzdHlsZT0nYmFja2dyb3VuZDp1cmwoXCIgKyB2YWwuaWNvbiArIFwiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdDsnIFwiOyB9XG5cdFx0XHRcdHN0ciArPSBcIj4mIzE2MDs8L2lucz48YSBocmVmPScjJyByZWw9J1wiICsgaSArIFwiJz5cIjtcblx0XHRcdFx0aWYodmFsLnN1Ym1lbnUpIHtcblx0XHRcdFx0XHRzdHIgKz0gXCI8c3BhbiBzdHlsZT0nZmxvYXQ6XCIgKyAoJC52YWthdGEuY29udGV4dC5ydGwgPyBcImxlZnRcIiA6IFwicmlnaHRcIikgKyBcIjsnPiZyYXF1bzs8L3NwYW4+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyICs9IHZhbC5sYWJlbCArIFwiPC9hPlwiO1xuXHRcdFx0XHRpZih2YWwuc3VibWVudSkge1xuXHRcdFx0XHRcdHRtcCA9ICQudmFrYXRhLmNvbnRleHQucGFyc2UodmFsLnN1Ym1lbnUsIHRydWUpO1xuXHRcdFx0XHRcdGlmKHRtcCkgeyBzdHIgKz0gdG1wOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyICs9IFwiPC9saT5cIjtcblx0XHRcdFx0aWYodmFsLnNlcGFyYXRvcl9hZnRlcikge1xuXHRcdFx0XHRcdHN0ciArPSBcIjxsaSBjbGFzcz0ndmFrYXRhLXNlcGFyYXRvciB2YWthdGEtc2VwYXJhdG9yLWFmdGVyJz48L2xpPlwiO1xuXHRcdFx0XHRcdHdhc19zZXAgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKC88bGkgY2xhc3NcXD0ndmFrYXRhLXNlcGFyYXRvciB2YWthdGEtc2VwYXJhdG9yLWFmdGVyJ1xcPjxcXC9saVxcPiQvLFwiXCIpO1xuXHRcdFx0c3RyICs9IFwiPC91bD5cIjtcblx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiY29udGV4dF9wYXJzZS52YWthdGFcIik7XG5cdFx0XHRyZXR1cm4gc3RyLmxlbmd0aCA+IDEwID8gc3RyIDogZmFsc2U7XG5cdFx0fSxcblx0XHRleGVjXHQ6IGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oJC52YWthdGEuY29udGV4dC5mdW5jW2ldKSkge1xuXHRcdFx0XHQvLyBpZiBpcyBzdHJpbmcgLSBldmFsIGFuZCBjYWxsIGl0IVxuXHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmZ1bmNbaV0uY2FsbCgkLnZha2F0YS5jb250ZXh0LmRhdGEsICQudmFrYXRhLmNvbnRleHQucGFyKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHR9O1xuXHQkKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3NzX3N0cmluZyA9ICcnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSB7IGRpc3BsYXk6YmxvY2s7IHZpc2liaWxpdHk6aGlkZGVuOyBsZWZ0OjA7IHRvcDotMjAwcHg7IHBvc2l0aW9uOmFic29sdXRlOyBtYXJnaW46MDsgcGFkZGluZzowOyBtaW4td2lkdGg6MTgwcHg7IGJhY2tncm91bmQ6I2ViZWJlYjsgYm9yZGVyOjFweCBzb2xpZCBzaWx2ZXI7IHotaW5kZXg6MTAwMDA7ICp3aWR0aDoxODBweDsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSB1bCB7IG1pbi13aWR0aDoxODBweDsgKndpZHRoOjE4MHB4OyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IHVsLCAjdmFrYXRhLWNvbnRleHRtZW51IGxpIHsgbWFyZ2luOjA7IHBhZGRpbmc6MDsgbGlzdC1zdHlsZS10eXBlOm5vbmU7IGRpc3BsYXk6YmxvY2s7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgbGkgeyBsaW5lLWhlaWdodDoyMHB4OyBtaW4taGVpZ2h0OjIwcHg7IHBvc2l0aW9uOnJlbGF0aXZlOyBwYWRkaW5nOjBweDsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSBsaSBhIHsgcGFkZGluZzoxcHggNnB4OyBsaW5lLWhlaWdodDoxN3B4OyBkaXNwbGF5OmJsb2NrOyB0ZXh0LWRlY29yYXRpb246bm9uZTsgbWFyZ2luOjFweCAxcHggMCAxcHg7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgbGkgaW5zIHsgZmxvYXQ6bGVmdDsgd2lkdGg6MTZweDsgaGVpZ2h0OjE2cHg7IHRleHQtZGVjb3JhdGlvbjpub25lOyBtYXJnaW4tcmlnaHQ6MnB4OyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IGxpIGE6aG92ZXIsICN2YWthdGEtY29udGV4dG1lbnUgbGkudmFrYXRhLWhvdmVyID4gYSB7IGJhY2tncm91bmQ6Z3JheTsgY29sb3I6d2hpdGU7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgbGkgdWwgeyBkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOyB0b3A6LTJweDsgbGVmdDoxMDAlOyBiYWNrZ3JvdW5kOiNlYmViZWI7IGJvcmRlcjoxcHggc29saWQgZ3JheTsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSAucmlnaHQgeyByaWdodDoxMDAlOyBsZWZ0OmF1dG87IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgLmJvdHRvbSB7IGJvdHRvbTotMXB4OyB0b3A6YXV0bzsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSBsaS52YWthdGEtc2VwYXJhdG9yIHsgbWluLWhlaWdodDowOyBoZWlnaHQ6MXB4OyBsaW5lLWhlaWdodDoxcHg7IGZvbnQtc2l6ZToxcHg7IG92ZXJmbG93OmhpZGRlbjsgbWFyZ2luOjAgMnB4OyBiYWNrZ3JvdW5kOnNpbHZlcjsgLyogYm9yZGVyLXRvcDoxcHggc29saWQgI2ZlZmVmZTsgKi8gcGFkZGluZzowOyB9ICc7XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJ2YWthdGFcIiB9KTtcblx0XHQkLnZha2F0YS5jb250ZXh0LmNudFxuXHRcdFx0LmRlbGVnYXRlKFwiYVwiLFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9KVxuXHRcdFx0LmRlbGVnYXRlKFwiYVwiLFwibW91c2V1cFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZighJCh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcyhcImpzdHJlZS1jb250ZXh0bWVudS1kaXNhYmxlZFwiKSAmJiAkLnZha2F0YS5jb250ZXh0LmV4ZWMoJCh0aGlzKS5hdHRyKFwicmVsXCIpKSkge1xuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyAkKHRoaXMpLmJsdXIoKTsgfVxuXHRcdFx0fSlcblx0XHRcdC5kZWxlZ2F0ZShcImFcIixcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCIudmFrYXRhLWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWhvdmVyXCIpO1xuXHRcdFx0fSlcblx0XHRcdC5hcHBlbmRUbyhcImJvZHlcIik7XG5cdFx0JChkb2N1bWVudCkuYmluZChcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkgeyBpZigkLnZha2F0YS5jb250ZXh0LnZpcyAmJiAhJC5jb250YWlucygkLnZha2F0YS5jb250ZXh0LmNudFswXSwgZS50YXJnZXQpKSB7ICQudmFrYXRhLmNvbnRleHQuaGlkZSgpOyB9IH0pO1xuXHRcdGlmKHR5cGVvZiAkLmhvdGtleXMgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdC5iaW5kKFwia2V5ZG93blwiLCBcInVwXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQudmlzKSB7IFxuXHRcdFx0XHRcdFx0dmFyIG8gPSAkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwidWw6dmlzaWJsZVwiKS5sYXN0KCkuY2hpbGRyZW4oXCIudmFrYXRhLWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWhvdmVyXCIpLnByZXZBbGwoXCJsaTpub3QoLnZha2F0YS1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7XG5cdFx0XHRcdFx0XHRpZighby5sZW5ndGgpIHsgbyA9ICQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmxhc3QoKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLXNlcGFyYXRvcilcIikubGFzdCgpOyB9XG5cdFx0XHRcdFx0XHRvLmFkZENsYXNzKFwidmFrYXRhLWhvdmVyXCIpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duXCIsIFwiZG93blwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnZpcykgeyBcblx0XHRcdFx0XHRcdHZhciBvID0gJC52YWthdGEuY29udGV4dC5jbnQuZmluZChcInVsOnZpc2libGVcIikubGFzdCgpLmNoaWxkcmVuKFwiLnZha2F0YS1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1ob3ZlclwiKS5uZXh0QWxsKFwibGk6bm90KC52YWthdGEtc2VwYXJhdG9yKVwiKS5maXJzdCgpO1xuXHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IG8gPSAkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwidWw6dmlzaWJsZVwiKS5sYXN0KCkuY2hpbGRyZW4oXCJsaTpub3QoLnZha2F0YS1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7IH1cblx0XHRcdFx0XHRcdG8uYWRkQ2xhc3MoXCJ2YWthdGEtaG92ZXJcIik7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZChcImtleWRvd25cIiwgXCJyaWdodFwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnZpcykgeyBcblx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCIudmFrYXRhLWhvdmVyXCIpLmNoaWxkcmVuKFwidWxcIikuc2hvdygpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtc2VwYXJhdG9yKVwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1ob3ZlclwiKS5maXJzdCgpLmFkZENsYXNzKFwidmFrYXRhLWhvdmVyXCIpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duXCIsIFwibGVmdFwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnZpcykgeyBcblx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCIudmFrYXRhLWhvdmVyXCIpLmNoaWxkcmVuKFwidWxcIikuaGlkZSgpLmNoaWxkcmVuKFwiLnZha2F0YS1zZXBhcmF0b3JcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtaG92ZXJcIik7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZChcImtleWRvd25cIiwgXCJlc2NcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7IFxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duXCIsIFwic3BhY2VcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5jbnQuZmluZChcIi52YWthdGEtaG92ZXJcIikubGFzdCgpLmNoaWxkcmVuKFwiYVwiKS5jbGljaygpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHQkLmpzdHJlZS5wbHVnaW4oXCJjb250ZXh0bWVudVwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcImNvbnRleHRtZW51LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRpZighJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwianN0cmVlLWxvYWRpbmdcIikpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93X2NvbnRleHRtZW51KGUuY3VycmVudFRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJjbGljay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvbnRleHRtZW51KSB7XG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImRlc3Ryb3kuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogbW92ZSB0aGlzIHRvIGRlc2NydWN0IG1ldGhvZFxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvbnRleHRtZW51KSB7XG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJjb250ZXh0X2hpZGUudmFrYXRhXCIsICQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLmRhdGEuY29udGV4dG1lbnUgPSBmYWxzZTsgfSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0X19kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHVuYmluZCBnbG9iYWwgZXZlbnQgaGFuZGxlcnMgd2hlbiBsYXN0IGluc3RhbmNlIGlzIHJlbW92ZWRcblx0XHRcdC8vIChubyBhY2Nlc3MgdG8gcHJpdmF0ZSAnaW5zdGFuY2VzJyB2YXJpYWJsZSBmcm9tIGhlcmUpXG5cdFx0XHRpZigkKCcuanN0cmVlJykubGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0JChkb2N1bWVudCkudW5iaW5kKFwiY29udGV4dF9oaWRlLnZha2F0YVwiKTtcdFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7IFxuXHRcdFx0c2VsZWN0X25vZGUgOiBmYWxzZSwgLy8gcmVxdWlyZXMgVUkgcGx1Z2luXG5cdFx0XHRzaG93X2F0X25vZGUgOiB0cnVlLFxuXHRcdFx0aXRlbXMgOiB7IC8vIENvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIHRoaXMgb25lXG5cdFx0XHRcdFwiY3JlYXRlXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiB0cnVlLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkNyZWF0ZVwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChvYmopIHsgdGhpcy5jcmVhdGUob2JqKTsgfVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInJlbmFtZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiUmVuYW1lXCIsXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKG9iaikgeyB0aGlzLnJlbmFtZShvYmopOyB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwicmVtb3ZlXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJEZWxldGVcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAob2JqKSB7IGlmKHRoaXMuaXNfc2VsZWN0ZWQob2JqKSkgeyB0aGlzLnJlbW92ZSgpOyB9IGVsc2UgeyB0aGlzLnJlbW92ZShvYmopOyB9IH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjY3BcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiB0cnVlLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiRWRpdFwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic3VibWVudVwiIDogeyBcblx0XHRcdFx0XHRcdFwiY3V0XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJDdXRcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKG9iaikgeyB0aGlzLmN1dChvYmopOyB9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJjb3B5XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ29weVwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAob2JqKSB7IHRoaXMuY29weShvYmopOyB9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJwYXN0ZVwiIDoge1xuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIlBhc3RlXCIsXG5cdFx0XHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChvYmopIHsgdGhpcy5wYXN0ZShvYmopOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRzaG93X2NvbnRleHRtZW51IDogZnVuY3Rpb24gKG9iaiwgeCwgeSkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgcyA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuY29udGV4dG1lbnUsXG5cdFx0XHRcdFx0YSA9IG9iai5jaGlsZHJlbihcImE6dmlzaWJsZTplcSgwKVwiKSxcblx0XHRcdFx0XHRvID0gZmFsc2UsXG5cdFx0XHRcdFx0aSA9IGZhbHNlO1xuXHRcdFx0XHRpZihzLnNlbGVjdF9ub2RlICYmIHRoaXMuZGF0YS51aSAmJiAhdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XG5cdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwoKTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocy5zaG93X2F0X25vZGUgfHwgdHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHkgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRvID0gYS5vZmZzZXQoKTtcblx0XHRcdFx0XHR4ID0gby5sZWZ0O1xuXHRcdFx0XHRcdHkgPSBvLnRvcCArIHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gb2JqLmRhdGEoXCJqc3RyZWVcIikgJiYgb2JqLmRhdGEoXCJqc3RyZWVcIikuY29udGV4dG1lbnUgPyBvYmouZGF0YShcImpzdHJlZVwiKS5jb250ZXh0bWVudSA6IHMuaXRlbXM7XG5cdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihpKSkgeyBpID0gaS5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0dGhpcy5kYXRhLmNvbnRleHRtZW51ID0gdHJ1ZTtcblx0XHRcdFx0JC52YWthdGEuY29udGV4dC5zaG93KGksIGEsIHgsIHksIHRoaXMsIG9iaiwgdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5ydGwpO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEudGhlbWVzKSB7ICQudmFrYXRhLmNvbnRleHQuY250LmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUgKyBcIi1jb250ZXh0XCIpOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qIFxuICoganNUcmVlIHR5cGVzIHBsdWdpblxuICogQWRkcyBzdXBwb3J0IHR5cGVzIG9mIG5vZGVzXG4gKiBZb3UgY2FuIHNldCBhbiBhdHRyaWJ1dGUgb24gZWFjaCBsaSBub2RlLCB0aGF0IHJlcHJlc2VudHMgaXRzIHR5cGUuXG4gKiBBY2NvcmRpbmcgdG8gdGhlIHR5cGUgc2V0dGluZyB0aGUgbm9kZSBtYXkgZ2V0IGN1c3RvbSBpY29uL3ZhbGlkYXRpb24gcnVsZXNcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcInR5cGVzXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzO1xuXHRcdFx0dGhpcy5kYXRhLnR5cGVzLmF0dGFjaF90byA9IFtdO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHR2YXIgdHlwZXMgPSBzLnR5cGVzLCBcblx0XHRcdFx0XHRcdFx0YXR0ciAgPSBzLnR5cGVfYXR0ciwgXG5cdFx0XHRcdFx0XHRcdGljb25zX2NzcyA9IFwiXCIsIFxuXHRcdFx0XHRcdFx0XHRfdGhpcyA9IHRoaXM7XG5cblx0XHRcdFx0XHRcdCQuZWFjaCh0eXBlcywgZnVuY3Rpb24gKGksIHRwKSB7XG5cdFx0XHRcdFx0XHRcdCQuZWFjaCh0cCwgZnVuY3Rpb24gKGssIHYpIHsgXG5cdFx0XHRcdFx0XHRcdFx0aWYoIS9eKG1heF9kZXB0aHxtYXhfY2hpbGRyZW58aWNvbnx2YWxpZF9jaGlsZHJlbikkLy50ZXN0KGspKSB7IF90aGlzLmRhdGEudHlwZXMuYXR0YWNoX3RvLnB1c2goayk7IH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlmKCF0cC5pY29uKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHRcdGlmKCB0cC5pY29uLmltYWdlIHx8IHRwLmljb24ucG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpZihpID09IFwiZGVmYXVsdFwiKVx0eyBpY29uc19jc3MgKz0gJy5qc3RyZWUtJyArIF90aGlzLmdldF9pbmRleCgpICsgJyBhID4gLmpzdHJlZS1pY29uIHsgJzsgfVxuXHRcdFx0XHRcdFx0XHRcdGVsc2VcdFx0XHRcdHsgaWNvbnNfY3NzICs9ICcuanN0cmVlLScgKyBfdGhpcy5nZXRfaW5kZXgoKSArICcgbGlbJyArIGF0dHIgKyAnPVwiJyArIGkgKyAnXCJdID4gYSA+IC5qc3RyZWUtaWNvbiB7ICc7IH1cblx0XHRcdFx0XHRcdFx0XHRpZih0cC5pY29uLmltYWdlKVx0eyBpY29uc19jc3MgKz0gJyBiYWNrZ3JvdW5kLWltYWdlOnVybCgnICsgdHAuaWNvbi5pbWFnZSArICcpOyAnOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYodHAuaWNvbi5wb3NpdGlvbil7IGljb25zX2NzcyArPSAnIGJhY2tncm91bmQtcG9zaXRpb246JyArIHRwLmljb24ucG9zaXRpb24gKyAnOyAnOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZVx0XHRcdFx0eyBpY29uc19jc3MgKz0gJyBiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMDsgJzsgfVxuXHRcdFx0XHRcdFx0XHRcdGljb25zX2NzcyArPSAnfSAnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmKGljb25zX2NzcyAhPT0gXCJcIikgeyAkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgJ3N0cicgOiBpY29uc19jc3MsIHRpdGxlIDogXCJqc3RyZWUtdHlwZXNcIiB9KTsgfVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImJlZm9yZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdHZhciBzLCB0LCBcblx0XHRcdFx0XHRcdFx0byA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzLnVzZV9kYXRhID8gdGhpcy5fZ2V0X25vZGUoZGF0YS5hcmdzWzBdKSA6IGZhbHNlLCBcblx0XHRcdFx0XHRcdFx0ZCA9IG8gJiYgbyAhPT0gLTEgJiYgby5sZW5ndGggPyBvLmRhdGEoXCJqc3RyZWVcIikgOiBmYWxzZTtcblx0XHRcdFx0XHRcdGlmKGQgJiYgZC50eXBlcyAmJiBkLnR5cGVzW2RhdGEuZnVuY10gPT09IGZhbHNlKSB7IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KGRhdGEuZnVuYywgdGhpcy5kYXRhLnR5cGVzLmF0dGFjaF90bykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFkYXRhLmFyZ3NbMF0gfHwgKCFkYXRhLmFyZ3NbMF0udGFnTmFtZSAmJiAhZGF0YS5hcmdzWzBdLmpxdWVyeSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcy50eXBlcztcblx0XHRcdFx0XHRcdFx0dCA9IHRoaXMuX2dldF90eXBlKGRhdGEuYXJnc1swXSk7XG5cdFx0XHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0XHRcdCggXG5cdFx0XHRcdFx0XHRcdFx0XHQoc1t0XSAmJiB0eXBlb2Ygc1t0XVtkYXRhLmZ1bmNdICE9PSBcInVuZGVmaW5lZFwiKSB8fCBcblx0XHRcdFx0XHRcdFx0XHRcdChzW1wiZGVmYXVsdFwiXSAmJiB0eXBlb2Ygc1tcImRlZmF1bHRcIl1bZGF0YS5mdW5jXSAhPT0gXCJ1bmRlZmluZWRcIikgXG5cdFx0XHRcdFx0XHRcdFx0KSAmJiB0aGlzLl9jaGVjayhkYXRhLmZ1bmMsIGRhdGEuYXJnc1swXSkgPT09IGZhbHNlXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYoaXNfaWU2KSB7XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0LmJpbmQoXCJsb2FkX25vZGUuanN0cmVlIHNldF90eXBlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByID0gZGF0YSAmJiBkYXRhLnJzbHQgJiYgZGF0YS5yc2x0Lm9iaiAmJiBkYXRhLnJzbHQub2JqICE9PSAtMSA/IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopLnBhcmVudCgpIDogdGhpcy5nZXRfY29udGFpbmVyX3VsKCksXG5cdFx0XHRcdFx0XHRcdFx0YyA9IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcztcblx0XHRcdFx0XHRcdFx0JC5lYWNoKHMudHlwZXMsIGZ1bmN0aW9uIChpLCB0cCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRwLmljb24gJiYgKHRwLmljb24uaW1hZ2UgfHwgdHAuaWNvbi5wb3NpdGlvbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgPSBpID09PSBcImRlZmF1bHRcIiA/IHIuZmluZChcImxpID4gYSA+IC5qc3RyZWUtaWNvblwiKSA6IHIuZmluZChcImxpW1wiICsgcy50eXBlX2F0dHIgKyBcIj0nXCIgKyBpICsgXCInXSA+IGEgPiAuanN0cmVlLWljb25cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0cC5pY29uLmltYWdlKSB7IGMuY3NzKFwiYmFja2dyb3VuZEltYWdlXCIsXCJ1cmwoXCIgKyB0cC5pY29uLmltYWdlICsgXCIpXCIpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRjLmNzcyhcImJhY2tncm91bmRQb3NpdGlvblwiLCB0cC5pY29uLnBvc2l0aW9uIHx8IFwiMCAwXCIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdC8vIGRlZmluZXMgbWF4aW11bSBudW1iZXIgb2Ygcm9vdCBub2RlcyAoLTEgbWVhbnMgdW5saW1pdGVkLCAtMiBtZWFucyBkaXNhYmxlIG1heF9jaGlsZHJlbiBjaGVja2luZylcblx0XHRcdG1heF9jaGlsZHJlblx0XHQ6IC0xLFxuXHRcdFx0Ly8gZGVmaW5lcyB0aGUgbWF4aW11bSBkZXB0aCBvZiB0aGUgdHJlZSAoLTEgbWVhbnMgdW5saW1pdGVkLCAtMiBtZWFucyBkaXNhYmxlIG1heF9kZXB0aCBjaGVja2luZylcblx0XHRcdG1heF9kZXB0aFx0XHRcdDogLTEsXG5cdFx0XHQvLyBkZWZpbmVzIHZhbGlkIG5vZGUgdHlwZXMgZm9yIHRoZSByb290IG5vZGVzXG5cdFx0XHR2YWxpZF9jaGlsZHJlblx0XHQ6IFwiYWxsXCIsXG5cblx0XHRcdC8vIHdoZXRoZXIgdG8gdXNlICQuZGF0YVxuXHRcdFx0dXNlX2RhdGEgOiBmYWxzZSwgXG5cdFx0XHQvLyB3aGVyZSBpcyB0aGUgdHlwZSBzdG9yZXMgKHRoZSByZWwgYXR0cmlidXRlIG9mIHRoZSBMSSBlbGVtZW50KVxuXHRcdFx0dHlwZV9hdHRyIDogXCJyZWxcIixcblx0XHRcdC8vIGEgbGlzdCBvZiB0eXBlc1xuXHRcdFx0dHlwZXMgOiB7XG5cdFx0XHRcdC8vIHRoZSBkZWZhdWx0IHR5cGVcblx0XHRcdFx0XCJkZWZhdWx0XCIgOiB7XG5cdFx0XHRcdFx0XCJtYXhfY2hpbGRyZW5cIlx0OiAtMSxcblx0XHRcdFx0XHRcIm1heF9kZXB0aFwiXHRcdDogLTEsXG5cdFx0XHRcdFx0XCJ2YWxpZF9jaGlsZHJlblwiOiBcImFsbFwiXG5cblx0XHRcdFx0XHQvLyBCb3VuZCBmdW5jdGlvbnMgLSB5b3UgY2FuIGJpbmQgYW55IG90aGVyIGZ1bmN0aW9uIGhlcmUgKHVzaW5nIGJvb2xlYW4gb3IgZnVuY3Rpb24pXG5cdFx0XHRcdFx0Ly9cInNlbGVjdF9ub2RlXCJcdDogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRfdHlwZXNfbm90aWZ5IDogZnVuY3Rpb24gKG4sIGRhdGEpIHtcblx0XHRcdFx0aWYoZGF0YS50eXBlICYmIHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzLnVzZV9kYXRhKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRfdHlwZShkYXRhLnR5cGUsIG4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2dldF90eXBlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRyZXR1cm4gKCFvYmogfHwgIW9iai5sZW5ndGgpID8gZmFsc2UgOiBvYmouYXR0cih0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcy50eXBlX2F0dHIpIHx8IFwiZGVmYXVsdFwiO1xuXHRcdFx0fSxcblx0XHRcdHNldF90eXBlIDogZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHZhciByZXQgPSAoIW9iai5sZW5ndGggfHwgIXN0cikgPyBmYWxzZSA6IG9iai5hdHRyKHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzLnR5cGVfYXR0ciwgc3RyKTtcblx0XHRcdFx0aWYocmV0KSB7IHRoaXMuX19jYWxsYmFjayh7IG9iaiA6IG9iaiwgdHlwZSA6IHN0cn0pOyB9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXHRcdFx0X2NoZWNrIDogZnVuY3Rpb24gKHJ1bGUsIG9iaiwgb3B0cykge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgdiA9IGZhbHNlLCB0ID0gdGhpcy5fZ2V0X3R5cGUob2JqKSwgZCA9IDAsIF90aGlzID0gdGhpcywgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzLCBkYXRhID0gZmFsc2U7XG5cdFx0XHRcdGlmKG9iaiA9PT0gLTEpIHsgXG5cdFx0XHRcdFx0aWYoISFzW3J1bGVdKSB7IHYgPSBzW3J1bGVdOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHJldHVybjsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKHQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdGRhdGEgPSBzLnVzZV9kYXRhID8gb2JqLmRhdGEoXCJqc3RyZWVcIikgOiBmYWxzZTtcblx0XHRcdFx0XHRpZihkYXRhICYmIGRhdGEudHlwZXMgJiYgdHlwZW9mIGRhdGEudHlwZXNbcnVsZV0gIT09IFwidW5kZWZpbmVkXCIpIHsgdiA9IGRhdGEudHlwZXNbcnVsZV07IH1cblx0XHRcdFx0XHRlbHNlIGlmKCEhcy50eXBlc1t0XSAmJiB0eXBlb2Ygcy50eXBlc1t0XVtydWxlXSAhPT0gXCJ1bmRlZmluZWRcIikgeyB2ID0gcy50eXBlc1t0XVtydWxlXTsgfVxuXHRcdFx0XHRcdGVsc2UgaWYoISFzLnR5cGVzW1wiZGVmYXVsdFwiXSAmJiB0eXBlb2Ygcy50eXBlc1tcImRlZmF1bHRcIl1bcnVsZV0gIT09IFwidW5kZWZpbmVkXCIpIHsgdiA9IHMudHlwZXNbXCJkZWZhdWx0XCJdW3J1bGVdOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHYpKSB7IHYgPSB2LmNhbGwodGhpcywgb2JqKTsgfVxuXHRcdFx0XHRpZihydWxlID09PSBcIm1heF9kZXB0aFwiICYmIG9iaiAhPT0gLTEgJiYgb3B0cyAhPT0gZmFsc2UgJiYgcy5tYXhfZGVwdGggIT09IC0yICYmIHYgIT09IDApIHtcblx0XHRcdFx0XHQvLyBhbHNvIGluY2x1ZGUgdGhlIG5vZGUgaXRzZWxmIC0gb3RoZXJ3aXNlIGlmIHJvb3Qgbm9kZSBpdCBpcyBub3QgY2hlY2tlZFxuXHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImE6ZXEoMClcIikucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwibGlcIikuZWFjaChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgY3VycmVudCBkZXB0aCBhbHJlYWR5IGV4Y2VlZHMgZ2xvYmFsIHRyZWUgZGVwdGhcblx0XHRcdFx0XHRcdGlmKHMubWF4X2RlcHRoICE9PSAtMSAmJiBzLm1heF9kZXB0aCAtIChpICsgMSkgPD0gMCkgeyB2ID0gMDsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHRkID0gKGkgPT09IDApID8gdiA6IF90aGlzLl9jaGVjayhydWxlLCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiBjdXJyZW50IG5vZGUgbWF4IGRlcHRoIGlzIGFscmVhZHkgbWF0Y2hlZCBvciBleGNlZWRlZFxuXHRcdFx0XHRcdFx0aWYoZCAhPT0gLTEgJiYgZCAtIChpICsgMSkgPD0gMCkgeyB2ID0gMDsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgLSBzZXQgdGhlIG1heCBkZXB0aCB0byB0aGUgY3VycmVudCB2YWx1ZSBtaW51cyBjdXJyZW50IGRlcHRoXG5cdFx0XHRcdFx0XHRpZihkID49IDAgJiYgKGQgLSAoaSArIDEpIDwgdiB8fCB2IDwgMCkgKSB7IHYgPSBkIC0gKGkgKyAxKTsgfVxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGdsb2JhbCB0cmVlIGRlcHRoIGV4aXN0cyBhbmQgaXQgbWludXMgdGhlIG5vZGVzIGNhbGN1bGF0ZWQgc28gZmFyIGlzIGxlc3MgdGhhbiBgdmAgb3IgYHZgIGlzIHVubGltaXRlZFxuXHRcdFx0XHRcdFx0aWYocy5tYXhfZGVwdGggPj0gMCAmJiAocy5tYXhfZGVwdGggLSAoaSArIDEpIDwgdiB8fCB2IDwgMCkgKSB7IHYgPSBzLm1heF9kZXB0aCAtIChpICsgMSk7IH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0sXG5cdFx0XHRjaGVja19tb3ZlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZighdGhpcy5fX2NhbGxfb2xkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBtICA9IHRoaXMuX2dldF9tb3ZlKCksXG5cdFx0XHRcdFx0cyAgPSBtLnJ0Ll9nZXRfc2V0dGluZ3MoKS50eXBlcyxcblx0XHRcdFx0XHRtYyA9IG0ucnQuX2NoZWNrKFwibWF4X2NoaWxkcmVuXCIsIG0uY3IpLFxuXHRcdFx0XHRcdG1kID0gbS5ydC5fY2hlY2soXCJtYXhfZGVwdGhcIiwgbS5jciksXG5cdFx0XHRcdFx0dmMgPSBtLnJ0Ll9jaGVjayhcInZhbGlkX2NoaWxkcmVuXCIsIG0uY3IpLFxuXHRcdFx0XHRcdGNoID0gMCwgZCA9IDEsIHQ7XG5cblx0XHRcdFx0aWYodmMgPT09IFwibm9uZVwiKSB7IHJldHVybiBmYWxzZTsgfSBcblx0XHRcdFx0aWYoJC5pc0FycmF5KHZjKSAmJiBtLm90ICYmIG0ub3QuX2dldF90eXBlKSB7XG5cdFx0XHRcdFx0bS5vLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KG0ub3QuX2dldF90eXBlKHRoaXMpLCB2YykgPT09IC0xKSB7IGQgPSBmYWxzZTsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYoZCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocy5tYXhfY2hpbGRyZW4gIT09IC0yICYmIG1jICE9PSAtMSkge1xuXHRcdFx0XHRcdGNoID0gbS5jciA9PT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpXCIpLm5vdChtLm8pLmxlbmd0aCA6IG0uY3IuZmluZChcIj4gdWwgPiBsaVwiKS5ub3QobS5vKS5sZW5ndGg7XG5cdFx0XHRcdFx0aWYoY2ggKyBtLm8ubGVuZ3RoID4gbWMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocy5tYXhfZGVwdGggIT09IC0yICYmIG1kICE9PSAtMSkge1xuXHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdGlmKG1kID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdGlmKHR5cGVvZiBtLm8uZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogZGVhbCB3aXRoIHByb2dyZXNzaXZlIHJlbmRlcmluZyBhbmQgYXN5bmMgd2hlbiBjaGVja2luZyBtYXhfZGVwdGggKGhvdyB0byBrbm93IHRoZSBkZXB0aCBvZiB0aGUgbW92ZWQgbm9kZSlcblx0XHRcdFx0XHRcdHQgPSBtLm87XG5cdFx0XHRcdFx0XHR3aGlsZSh0Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0dCA9IHQuZmluZChcIj4gdWwgPiBsaVwiKTtcblx0XHRcdFx0XHRcdFx0ZCArKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG0uby5kID0gZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYobWQgLSBtLm8uZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBwb3NpdGlvbiwganMsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHNraXBfY2hlY2spIHtcblx0XHRcdFx0aWYoIXNraXBfY2hlY2sgJiYgKGlzX2xvYWRlZCB8fCB0aGlzLl9pc19sb2FkZWQob2JqKSkpIHtcblx0XHRcdFx0XHR2YXIgcCAgPSAodHlwZW9mIHBvc2l0aW9uID09IFwic3RyaW5nXCIgJiYgcG9zaXRpb24ubWF0Y2goL15iZWZvcmV8YWZ0ZXIkL2kpICYmIG9iaiAhPT0gLTEpID8gdGhpcy5fZ2V0X3BhcmVudChvYmopIDogdGhpcy5fZ2V0X25vZGUob2JqKSxcblx0XHRcdFx0XHRcdHMgID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudHlwZXMsXG5cdFx0XHRcdFx0XHRtYyA9IHRoaXMuX2NoZWNrKFwibWF4X2NoaWxkcmVuXCIsIHApLFxuXHRcdFx0XHRcdFx0bWQgPSB0aGlzLl9jaGVjayhcIm1heF9kZXB0aFwiLCBwKSxcblx0XHRcdFx0XHRcdHZjID0gdGhpcy5fY2hlY2soXCJ2YWxpZF9jaGlsZHJlblwiLCBwKSxcblx0XHRcdFx0XHRcdGNoO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBqcyA9PT0gXCJzdHJpbmdcIikgeyBqcyA9IHsgZGF0YSA6IGpzIH07IH1cblx0XHRcdFx0XHRpZighanMpIHsganMgPSB7fTsgfVxuXHRcdFx0XHRcdGlmKHZjID09PSBcIm5vbmVcIikgeyByZXR1cm4gZmFsc2U7IH0gXG5cdFx0XHRcdFx0aWYoJC5pc0FycmF5KHZjKSkge1xuXHRcdFx0XHRcdFx0aWYoIWpzLmF0dHIgfHwgIWpzLmF0dHJbcy50eXBlX2F0dHJdKSB7IFxuXHRcdFx0XHRcdFx0XHRpZighanMuYXR0cikgeyBqcy5hdHRyID0ge307IH1cblx0XHRcdFx0XHRcdFx0anMuYXR0cltzLnR5cGVfYXR0cl0gPSB2Y1swXTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KGpzLmF0dHJbcy50eXBlX2F0dHJdLCB2YykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzLm1heF9jaGlsZHJlbiAhPT0gLTIgJiYgbWMgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRjaCA9IHAgPT09IC0xID8gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKS5sZW5ndGggOiBwLmZpbmQoXCI+IHVsID4gbGlcIikubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYoY2ggKyAxID4gbWMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHMubWF4X2RlcHRoICE9PSAtMiAmJiBtZCAhPT0gLTEgJiYgKG1kIC0gMSkgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fY2FsbF9vbGQodHJ1ZSwgb2JqLCBwb3NpdGlvbiwganMsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHNraXBfY2hlY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBIVE1MIHBsdWdpblxuICogVGhlIEhUTUwgZGF0YSBzdG9yZS4gRGF0YXN0b3JlcyBhcmUgYnVpbGQgYnkgcmVwbGFjaW5nIHRoZSBgbG9hZF9ub2RlYCBhbmQgYF9pc19sb2FkZWRgIGZ1bmN0aW9ucy5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcImh0bWxfZGF0YVwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdC8vIHRoaXMgdXNlZCB0byB1c2UgaHRtbCgpIGFuZCBjbGVhbiB0aGUgd2hpdGVzcGFjZSwgYnV0IHRoaXMgd2F5IGFueSBhdHRhY2hlZCBkYXRhIHdhcyBsb3N0XG5cdFx0XHR0aGlzLmRhdGEuaHRtbF9kYXRhLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sID0gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIiA+IHVsID4gbGlcIikuY2xvbmUodHJ1ZSk7XG5cdFx0XHQvLyByZW1vdmUgd2hpdGUgc3BhY2UgZnJvbSBMSSBub2RlIC0gb3RoZXJ3aXNlIG5vZGVzIGFwcGVhciBhIGJpdCB0byB0aGUgcmlnaHRcblx0XHRcdHRoaXMuZGF0YS5odG1sX2RhdGEub3JpZ2luYWxfY29udGFpbmVyX2h0bWwuZmluZChcImxpXCIpLmFuZFNlbGYoKS5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgfSkucmVtb3ZlKCk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHRkYXRhIDogZmFsc2UsXG5cdFx0XHRhamF4IDogZmFsc2UsXG5cdFx0XHRjb3JyZWN0X3N0YXRlIDogdHJ1ZVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0bG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHsgdmFyIF90aGlzID0gdGhpczsgdGhpcy5sb2FkX25vZGVfaHRtbChvYmosIGZ1bmN0aW9uICgpIHsgX3RoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBfdGhpcy5fZ2V0X25vZGUob2JqKSB9KTsgc19jYWxsLmNhbGwodGhpcyk7IH0sIGVfY2FsbCk7IH0sXG5cdFx0XHRfaXNfbG9hZGVkIDogZnVuY3Rpb24gKG9iaikgeyBcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTsgXG5cdFx0XHRcdHJldHVybiBvYmogPT0gLTEgfHwgIW9iaiB8fCAoIXRoaXMuX2dldF9zZXR0aW5ncygpLmh0bWxfZGF0YS5hamF4ICYmICEkLmlzRnVuY3Rpb24odGhpcy5fZ2V0X3NldHRpbmdzKCkuaHRtbF9kYXRhLmRhdGEpKSB8fCBvYmouaXMoXCIuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZlwiKSB8fCBvYmouY2hpbGRyZW4oXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpLnNpemUoKSA+IDA7XG5cdFx0XHR9LFxuXHRcdFx0bG9hZF9ub2RlX2h0bWwgOiBmdW5jdGlvbiAob2JqLCBzX2NhbGwsIGVfY2FsbCkge1xuXHRcdFx0XHR2YXIgZCxcblx0XHRcdFx0XHRzID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5odG1sX2RhdGEsXG5cdFx0XHRcdFx0ZXJyb3JfZnVuYyA9IGZ1bmN0aW9uICgpIHt9LFxuXHRcdFx0XHRcdHN1Y2Nlc3NfZnVuYyA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmKG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIikpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIix0cnVlKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCghMCkge1xuXHRcdFx0XHRcdGNhc2UgKCQuaXNGdW5jdGlvbihzLmRhdGEpKTpcblx0XHRcdFx0XHRcdHMuZGF0YS5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQgIT09IFwiXCIgJiYgZC50b1N0cmluZyAmJiBkLnRvU3RyaW5nKCkucmVwbGFjZSgvXltcXHNcXG5dKyQvLFwiXCIpICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZCA9ICQoZCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIWQuaXMoXCJ1bFwiKSkgeyBkID0gJChcIjx1bCAvPlwiKS5hcHBlbmQoZCk7IH1cblx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT0gLTEgfHwgIW9iaikgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCkuYXBwZW5kKGQuY2hpbGRyZW4oKSkuZmluZChcImxpLCBhXCIpLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5maXJzdENoaWxkIHx8ICF0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSB8fCB0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSAhPT0gXCJJTlNcIjsgfSkucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIikuZW5kKCkuZmlsdGVyKFwiYVwiKS5jaGlsZHJlbihcImluczpmaXJzdC1jaGlsZFwiKS5ub3QoXCIuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJqc3RyZWUtaWNvblwiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgeyBvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7IG9iai5hcHBlbmQoZCkuY2hpbGRyZW4oXCJ1bFwiKS5maW5kKFwibGksIGFcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmZpcnN0Q2hpbGQgfHwgIXRoaXMuZmlyc3RDaGlsZC50YWdOYW1lIHx8IHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lICE9PSBcIklOU1wiOyB9KS5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKS5lbmQoKS5maWx0ZXIoXCJhXCIpLmNoaWxkcmVuKFwiaW5zOmZpcnN0LWNoaWxkXCIpLm5vdChcIi5qc3RyZWUtaWNvblwiKS5hZGRDbGFzcyhcImpzdHJlZS1pY29uXCIpOyBvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpOyB9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jbGVhbl9ub2RlKG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuY29ycmVjdF9zdGF0ZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfSBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCFzLmRhdGEgJiYgIXMuYWpheCk6XG5cdFx0XHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0XHRcdC5jaGlsZHJlbihcInVsXCIpLmVtcHR5KClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKHRoaXMuZGF0YS5odG1sX2RhdGEub3JpZ2luYWxfY29udGFpbmVyX2h0bWwpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbmQoXCJsaSwgYVwiKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZmlyc3RDaGlsZCB8fCAhdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgfHwgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgIT09IFwiSU5TXCI7IH0pLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihcImFcIikuY2hpbGRyZW4oXCJpbnM6Zmlyc3QtY2hpbGRcIikubm90KFwiLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwianN0cmVlLWljb25cIik7XG5cdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghIXMuZGF0YSAmJiAhcy5hamF4KSB8fCAoISFzLmRhdGEgJiYgISFzLmFqYXggJiYgKCFvYmogfHwgb2JqID09PSAtMSkpOlxuXHRcdFx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZCA9ICQocy5kYXRhKTtcblx0XHRcdFx0XHRcdFx0aWYoIWQuaXMoXCJ1bFwiKSkgeyBkID0gJChcIjx1bCAvPlwiKS5hcHBlbmQoZCk7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbmQoXCJsaSwgYVwiKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZmlyc3RDaGlsZCB8fCAhdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgfHwgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgIT09IFwiSU5TXCI7IH0pLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihcImFcIikuY2hpbGRyZW4oXCJpbnM6Zmlyc3QtY2hpbGRcIikubm90KFwiLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwianN0cmVlLWljb25cIik7XG5cdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghcy5kYXRhICYmICEhcy5hamF4KSB8fCAoISFzLmRhdGEgJiYgISFzLmFqYXggJiYgb2JqICYmIG9iaiAhPT0gLTEpOlxuXHRcdFx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoeCwgdCwgZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZWYgPSB0aGlzLmdldF9zZXR0aW5ncygpLmh0bWxfZGF0YS5hamF4LmVycm9yOyBcblx0XHRcdFx0XHRcdFx0aWYoZWYpIHsgZWYuY2FsbCh0aGlzLCB4LCB0LCBlKTsgfVxuXHRcdFx0XHRcdFx0XHRpZihvYmogIT0gLTEgJiYgb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihlX2NhbGwpIHsgZV9jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRzdWNjZXNzX2Z1bmMgPSBmdW5jdGlvbiAoZCwgdCwgeCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgc2YgPSB0aGlzLmdldF9zZXR0aW5ncygpLmh0bWxfZGF0YS5hamF4LnN1Y2Nlc3M7IFxuXHRcdFx0XHRcdFx0XHRpZihzZikgeyBkID0gc2YuY2FsbCh0aGlzLGQsdCx4KSB8fCBkOyB9XG5cdFx0XHRcdFx0XHRcdGlmKGQgPT09IFwiXCIgfHwgKGQgJiYgZC50b1N0cmluZyAmJiBkLnRvU3RyaW5nKCkucmVwbGFjZSgvXltcXHNcXG5dKyQvLFwiXCIpID09PSBcIlwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcl9mdW5jLmNhbGwodGhpcywgeCwgdCwgXCJcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0XHRcdGQgPSAkKGQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKCFkLmlzKFwidWxcIikpIHsgZCA9ICQoXCI8dWwgLz5cIikuYXBwZW5kKGQpOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYob2JqID09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpLmZpbmQoXCJsaSwgYVwiKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZmlyc3RDaGlsZCB8fCAhdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgfHwgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgIT09IFwiSU5TXCI7IH0pLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpLmVuZCgpLmZpbHRlcihcImFcIikuY2hpbGRyZW4oXCJpbnM6Zmlyc3QtY2hpbGRcIikubm90KFwiLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwianN0cmVlLWljb25cIik7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgb2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpOyBvYmouYXBwZW5kKGQpLmNoaWxkcmVuKFwidWxcIikuZmluZChcImxpLCBhXCIpLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5maXJzdENoaWxkIHx8ICF0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSB8fCB0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSAhPT0gXCJJTlNcIjsgfSkucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIikuZW5kKCkuZmlsdGVyKFwiYVwiKS5jaGlsZHJlbihcImluczpmaXJzdC1jaGlsZFwiKS5ub3QoXCIuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJqc3RyZWUtaWNvblwiKTsgb2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cy5hamF4LmNvbnRleHQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0cy5hamF4LmVycm9yID0gZXJyb3JfZnVuYztcblx0XHRcdFx0XHRcdHMuYWpheC5zdWNjZXNzID0gc3VjY2Vzc19mdW5jO1xuXHRcdFx0XHRcdFx0aWYoIXMuYWpheC5kYXRhVHlwZSkgeyBzLmFqYXguZGF0YVR5cGUgPSBcImh0bWxcIjsgfVxuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuYWpheC51cmwpKSB7IHMuYWpheC51cmwgPSBzLmFqYXgudXJsLmNhbGwodGhpcywgb2JqKTsgfVxuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuYWpheC5kYXRhKSkgeyBzLmFqYXguZGF0YSA9IHMuYWpheC5kYXRhLmNhbGwodGhpcywgb2JqKTsgfVxuXHRcdFx0XHRcdFx0JC5hamF4KHMuYWpheCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdC8vIGluY2x1ZGUgdGhlIEhUTUwgZGF0YSBwbHVnaW4gYnkgZGVmYXVsdFxuXHQkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJodG1sX2RhdGFcIik7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSB0aGVtZXJvbGxlciBwbHVnaW5cbiAqIEFkZHMgc3VwcG9ydCBmb3IgalF1ZXJ5IFVJIHRoZW1lcy4gSW5jbHVkZSB0aGlzIGF0IHRoZSBlbmQgb2YgeW91ciBwbHVnaW5zIGxpc3QsIGFsc28gbWFrZSBzdXJlIFwidGhlbWVzXCIgaXMgbm90IGluY2x1ZGVkLlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwidGhlbWVyb2xsZXJcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudGhlbWVyb2xsZXI7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoXCJ1aS13aWRnZXQtY29udGVudFwiKVxuXHRcdFx0XHQuYWRkQ2xhc3MoXCJqc3RyZWUtdGhlbWVyb2xsZXJcIilcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLFwibW91c2VlbnRlci5qc3RyZWVcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZighJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwianN0cmVlLWxvYWRpbmdcIikpIHtcblx0XHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3Mocy5pdGVtX2gpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3Mocy5pdGVtX2gpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZChcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHRkYXRhLmluc3QuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGkgPiAuanN0cmVlLWxvYWRpbmcgPiBpbnNcIikuYWRkQ2xhc3MoXCJ1aS1pY29uLXJlZnJlc2hcIik7XG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcihkYXRhLmluc3QuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGlcIikpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcIm9wZW5fbm9kZS5qc3RyZWUgY3JlYXRlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcihkYXRhLnJzbHQub2JqKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJsb2FkZWQuanN0cmVlIHJlZnJlc2guanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lcm9sbGVyKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiY2xvc2Vfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGhlbWVyb2xsZXIoZGF0YS5yc2x0Lm9iaik7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZGVsZXRlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lcm9sbGVyKGRhdGEucnNsdC5wYXJlbnQpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImNvcnJlY3Rfc3RhdGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGRhdGEucnNsdC5vYmpcblx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiaW5zLmpzdHJlZS1pY29uXCIpLnJlbW92ZUNsYXNzKHMub3BlbmVkICsgXCIgXCIgKyBzLmNsb3NlZCArIFwiIHVpLWljb25cIikuZW5kKClcblx0XHRcdFx0XHRcdFx0LmZpbmQoXCI+IGEgPiBpbnMudWktaWNvblwiKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2xhc3NOYW1lLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2Uocy5pdGVtX2Nsc2QsXCJcIikucmVwbGFjZShzLml0ZW1fb3BlbixcIlwiKS5yZXBsYWNlKHMuaXRlbV9sZWFmLFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5pbmRleE9mKFwidWktaWNvbi1cIikgPT09IC0xOyBcblx0XHRcdFx0XHRcdFx0XHR9KS5yZW1vdmVDbGFzcyhzLml0ZW1fb3BlbiArIFwiIFwiICsgcy5pdGVtX2Nsc2QpLmFkZENsYXNzKHMuaXRlbV9sZWFmIHx8IFwianN0cmVlLW5vLWljb25cIik7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwic2VsZWN0X25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGRhdGEucnNsdC5vYmouY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKHMuaXRlbV9hKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkZXNlbGVjdF9ub2RlLmpzdHJlZSBkZXNlbGVjdF9hbGwuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0XHRcdC5maW5kKFwiYS5cIiArIHMuaXRlbV9hKS5yZW1vdmVDbGFzcyhzLml0ZW1fYSkuZW5kKClcblx0XHRcdFx0XHRcdFx0LmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpLmFkZENsYXNzKHMuaXRlbV9hKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkZWhvdmVyX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGRhdGEucnNsdC5vYmouY2hpbGRyZW4oXCJhXCIpLnJlbW92ZUNsYXNzKHMuaXRlbV9oKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJob3Zlcl9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0XHQuZmluZChcImEuXCIgKyBzLml0ZW1faCkubm90KGRhdGEucnNsdC5vYmopLnJlbW92ZUNsYXNzKHMuaXRlbV9oKTtcblx0XHRcdFx0XHRcdGRhdGEucnNsdC5vYmouY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKHMuaXRlbV9oKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJtb3ZlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lcm9sbGVyKGRhdGEucnNsdC5vKTtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lcm9sbGVyKGRhdGEucnNsdC5vcCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0X19kZXN0cm95IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50aGVtZXJvbGxlcixcblx0XHRcdFx0YyA9IFsgXCJ1aS1pY29uXCIgXTtcblx0XHRcdCQuZWFjaChzLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHR2ID0gdi5zcGxpdChcIiBcIik7XG5cdFx0XHRcdGlmKHYubGVuZ3RoKSB7IGMgPSBjLmNvbmNhdCh2KTsgfVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS13aWRnZXQtY29udGVudFwiKVxuXHRcdFx0XHQuZmluZChcIi5cIiArIGMuam9pbihcIiwgLlwiKSkucmVtb3ZlQ2xhc3MoYy5qb2luKFwiIFwiKSk7XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRfdGhlbWVyb2xsZXIgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudGhlbWVyb2xsZXI7XG5cdFx0XHRcdG9iaiA9ICghb2JqIHx8IG9iaiA9PSAtMSkgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdG9iaiA9ICghb2JqIHx8IG9iaiA9PSAtMSkgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IG9iai5wYXJlbnQoKTtcblx0XHRcdFx0b2JqXG5cdFx0XHRcdFx0LmZpbmQoXCJsaS5qc3RyZWUtY2xvc2VkXCIpXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJpbnMuanN0cmVlLWljb25cIikucmVtb3ZlQ2xhc3Mocy5vcGVuZWQpLmFkZENsYXNzKFwidWktaWNvbiBcIiArIHMuY2xvc2VkKS5lbmQoKVxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhzLml0ZW0pXG5cdFx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImlucy5qc3RyZWUtaWNvblwiKS5hZGRDbGFzcyhcInVpLWljb25cIilcblx0XHRcdFx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNsYXNzTmFtZS50b1N0cmluZygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKHMuaXRlbV9jbHNkLFwiXCIpLnJlcGxhY2Uocy5pdGVtX29wZW4sXCJcIikucmVwbGFjZShzLml0ZW1fbGVhZixcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuaW5kZXhPZihcInVpLWljb24tXCIpID09PSAtMTsgXG5cdFx0XHRcdFx0XHRcdFx0fSkucmVtb3ZlQ2xhc3Mocy5pdGVtX2xlYWYgKyBcIiBcIiArIHMuaXRlbV9vcGVuKS5hZGRDbGFzcyhzLml0ZW1fY2xzZCB8fCBcImpzdHJlZS1uby1pY29uXCIpXG5cdFx0XHRcdFx0XHRcdFx0LmVuZCgpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmVuZCgpXG5cdFx0XHRcdFx0LmVuZCgpXG5cdFx0XHRcdFx0LmZpbmQoXCJsaS5qc3RyZWUtb3BlblwiKVxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiaW5zLmpzdHJlZS1pY29uXCIpLnJlbW92ZUNsYXNzKHMuY2xvc2VkKS5hZGRDbGFzcyhcInVpLWljb24gXCIgKyBzLm9wZW5lZCkuZW5kKClcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3Mocy5pdGVtKVxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJpbnMuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJ1aS1pY29uXCIpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFzc05hbWUudG9TdHJpbmcoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZShzLml0ZW1fY2xzZCxcIlwiKS5yZXBsYWNlKHMuaXRlbV9vcGVuLFwiXCIpLnJlcGxhY2Uocy5pdGVtX2xlYWYsXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmluZGV4T2YoXCJ1aS1pY29uLVwiKSA9PT0gLTE7IFxuXHRcdFx0XHRcdFx0XHRcdH0pLnJlbW92ZUNsYXNzKHMuaXRlbV9sZWFmICsgXCIgXCIgKyBzLml0ZW1fY2xzZCkuYWRkQ2xhc3Mocy5pdGVtX29wZW4gfHwgXCJqc3RyZWUtbm8taWNvblwiKVxuXHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdC5maW5kKFwibGkuanN0cmVlLWxlYWZcIilcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImlucy5qc3RyZWUtaWNvblwiKS5yZW1vdmVDbGFzcyhzLmNsb3NlZCArIFwiIHVpLWljb24gXCIgKyBzLm9wZW5lZCkuZW5kKClcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3Mocy5pdGVtKVxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJpbnMuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJ1aS1pY29uXCIpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFzc05hbWUudG9TdHJpbmcoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZShzLml0ZW1fY2xzZCxcIlwiKS5yZXBsYWNlKHMuaXRlbV9vcGVuLFwiXCIpLnJlcGxhY2Uocy5pdGVtX2xlYWYsXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmluZGV4T2YoXCJ1aS1pY29uLVwiKSA9PT0gLTE7IFxuXHRcdFx0XHRcdFx0XHRcdH0pLnJlbW92ZUNsYXNzKHMuaXRlbV9jbHNkICsgXCIgXCIgKyBzLml0ZW1fb3BlbikuYWRkQ2xhc3Mocy5pdGVtX2xlYWYgfHwgXCJqc3RyZWUtbm8taWNvblwiKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0XCJvcGVuZWRcIlx0OiBcInVpLWljb24tdHJpYW5nbGUtMS1zZVwiLFxuXHRcdFx0XCJjbG9zZWRcIlx0OiBcInVpLWljb24tdHJpYW5nbGUtMS1lXCIsXG5cdFx0XHRcIml0ZW1cIlx0XHQ6IFwidWktc3RhdGUtZGVmYXVsdFwiLFxuXHRcdFx0XCJpdGVtX2hcIlx0OiBcInVpLXN0YXRlLWhvdmVyXCIsXG5cdFx0XHRcIml0ZW1fYVwiXHQ6IFwidWktc3RhdGUtYWN0aXZlXCIsXG5cdFx0XHRcIml0ZW1fb3BlblwiXHQ6IFwidWktaWNvbi1mb2xkZXItb3BlblwiLFxuXHRcdFx0XCJpdGVtX2Nsc2RcIlx0OiBcInVpLWljb24tZm9sZGVyLWNvbGxhcHNlZFwiLFxuXHRcdFx0XCJpdGVtX2xlYWZcIlx0OiBcInVpLWljb24tZG9jdW1lbnRcIlxuXHRcdH1cblx0fSk7XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNzc19zdHJpbmcgPSAnJyArIFxuXHRcdFx0Jy5qc3RyZWUtdGhlbWVyb2xsZXIgLnVpLWljb24geyBvdmVyZmxvdzp2aXNpYmxlOyB9ICcgKyBcblx0XHRcdCcuanN0cmVlLXRoZW1lcm9sbGVyIGEgeyBwYWRkaW5nOjAgMnB4OyB9ICcgKyBcblx0XHRcdCcuanN0cmVlLXRoZW1lcm9sbGVyIC5qc3RyZWUtbm8taWNvbiB7IGRpc3BsYXk6bm9uZTsgfSc7XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJqc3RyZWVcIiB9KTtcblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSB1bmlxdWUgcGx1Z2luXG4gKiBGb3JjZXMgZGlmZmVyZW50IG5hbWVzIGFtb25nc3Qgc2libGluZ3MgKHN0aWxsIGEgYml0IGV4cGVyaW1lbnRhbClcbiAqIE5PVEU6IGRvZXMgbm90IGNoZWNrIGxhbmd1YWdlIHZlcnNpb25zIChpdCB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byBoYXZlIG5vZGVzIHdpdGggdGhlIHNhbWUgdGl0bGUsIGV2ZW4gaW4gZGlmZmVyZW50IGxhbmd1YWdlcylcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcInVuaXF1ZVwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJiZWZvcmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR2YXIgbm1zID0gW10sIHJlcyA9IHRydWUsIHAsIHQ7XG5cdFx0XHRcdFx0XHRpZihkYXRhLmZ1bmMgPT0gXCJtb3ZlX25vZGVcIikge1xuXHRcdFx0XHRcdFx0XHQvLyBvYmosIHJlZiwgcG9zaXRpb24sIGlzX2NvcHksIGlzX3ByZXBhcmVkLCBza2lwX2NoZWNrXG5cdFx0XHRcdFx0XHRcdGlmKGRhdGEuYXJnc1s0XSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKGRhdGEuYXJnc1swXS5vICYmIGRhdGEuYXJnc1swXS5vLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5hcmdzWzBdLm8uY2hpbGRyZW4oXCJhXCIpLmVhY2goZnVuY3Rpb24gKCkgeyBubXMucHVzaCgkKHRoaXMpLnRleHQoKS5yZXBsYWNlKC9eXFxzKy9nLFwiXCIpKTsgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMgPSB0aGlzLl9jaGVja191bmlxdWUobm1zLCBkYXRhLmFyZ3NbMF0ubnAuZmluZChcIj4gdWwgPiBsaVwiKS5ub3QoZGF0YS5hcmdzWzBdLm8pLCBcIm1vdmVfbm9kZVwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGRhdGEuZnVuYyA9PSBcImNyZWF0ZV9ub2RlXCIpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb2JqLCBwb3NpdGlvbiwganMsIGNhbGxiYWNrLCBpc19sb2FkZWRcblx0XHRcdFx0XHRcdFx0aWYoZGF0YS5hcmdzWzRdIHx8IHRoaXMuX2lzX2xvYWRlZChkYXRhLmFyZ3NbMF0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX2dldF9ub2RlKGRhdGEuYXJnc1swXSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZGF0YS5hcmdzWzFdICYmIChkYXRhLmFyZ3NbMV0gPT09IFwiYmVmb3JlXCIgfHwgZGF0YS5hcmdzWzFdID09PSBcImFmdGVyXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fZ2V0X3BhcmVudChkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIXAgfHwgcCA9PT0gLTEpIHsgcCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpOyB9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhLmFyZ3NbMl0gPT09IFwic3RyaW5nXCIpIHsgbm1zLnB1c2goZGF0YS5hcmdzWzJdKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYoIWRhdGEuYXJnc1syXSB8fCAhZGF0YS5hcmdzWzJdLmRhdGEpIHsgbm1zLnB1c2godGhpcy5fZ2V0X3N0cmluZyhcIm5ld19ub2RlXCIpKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgeyBubXMucHVzaChkYXRhLmFyZ3NbMl0uZGF0YSk7IH1cblx0XHRcdFx0XHRcdFx0XHRyZXMgPSB0aGlzLl9jaGVja191bmlxdWUobm1zLCBwLmZpbmQoXCI+IHVsID4gbGlcIiksIFwiY3JlYXRlX25vZGVcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGRhdGEuZnVuYyA9PSBcInJlbmFtZV9ub2RlXCIpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb2JqLCB2YWxcblx0XHRcdFx0XHRcdFx0bm1zLnB1c2goZGF0YS5hcmdzWzFdKTtcblx0XHRcdFx0XHRcdFx0dCA9IHRoaXMuX2dldF9ub2RlKGRhdGEuYXJnc1swXSk7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9nZXRfcGFyZW50KHQpO1xuXHRcdFx0XHRcdFx0XHRpZighcCB8fCBwID09PSAtMSkgeyBwID0gdGhpcy5nZXRfY29udGFpbmVyKCk7IH1cblx0XHRcdFx0XHRcdFx0cmVzID0gdGhpcy5fY2hlY2tfdW5pcXVlKG5tcywgcC5maW5kKFwiPiB1bCA+IGxpXCIpLm5vdCh0KSwgXCJyZW5hbWVfbm9kZVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCFyZXMpIHtcblx0XHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdGRlZmF1bHRzIDogeyBcblx0XHRcdGVycm9yX2NhbGxiYWNrIDogJC5ub29wXG5cdFx0fSxcblx0XHRfZm4gOiB7IFxuXHRcdFx0X2NoZWNrX3VuaXF1ZSA6IGZ1bmN0aW9uIChubXMsIHAsIGZ1bmMpIHtcblx0XHRcdFx0dmFyIGNubXMgPSBbXSwgb2sgPSB0cnVlO1xuXHRcdFx0XHRwLmNoaWxkcmVuKFwiYVwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgY25tcy5wdXNoKCQodGhpcykudGV4dCgpLnJlcGxhY2UoL15cXHMrL2csXCJcIikpOyB9KTtcblx0XHRcdFx0aWYoIWNubXMubGVuZ3RoIHx8ICFubXMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdCQuZWFjaChubXMsIGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0aWYoJC5pbkFycmF5KHYsIGNubXMpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZighb2spIHtcblx0XHRcdFx0XHR0aGlzLl9nZXRfc2V0dGluZ3MoKS51bmlxdWUuZXJyb3JfY2FsbGJhY2suY2FsbChudWxsLCBubXMsIHAsIGZ1bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvaztcblx0XHRcdH0sXG5cdFx0XHRjaGVja19tb3ZlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZighdGhpcy5fX2NhbGxfb2xkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBwID0gdGhpcy5fZ2V0X21vdmUoKSwgbm1zID0gW107XG5cdFx0XHRcdGlmKHAubyAmJiBwLm8ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cC5vLmNoaWxkcmVuKFwiYVwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgbm1zLnB1c2goJCh0aGlzKS50ZXh0KCkucmVwbGFjZSgvXlxccysvZyxcIlwiKSk7IH0pO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9jaGVja191bmlxdWUobm1zLCBwLm5wLmZpbmQoXCI+IHVsID4gbGlcIikubm90KHAubyksIFwiY2hlY2tfbW92ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLypcbiAqIGpzVHJlZSB3aG9sZXJvdyBwbHVnaW5cbiAqIE1ha2VzIHNlbGVjdCBhbmQgaG92ZXIgd29yayBvbiB0aGUgZW50aXJlIHdpZHRoIG9mIHRoZSBub2RlXG4gKiBNQVkgQkUgSEVBVlkgSU4gTEFSR0UgRE9NXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJ3aG9sZXJvd1wiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoIXRoaXMuZGF0YS51aSkgeyB0aHJvdyBcImpzVHJlZSB3aG9sZXJvdzoganNUcmVlIFVJIHBsdWdpbiBub3QgaW5jbHVkZWQuXCI7IH1cblx0XHRcdHRoaXMuZGF0YS53aG9sZXJvdy5odG1sID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRhdGEud2hvbGVyb3cudG8gPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwiaW5pdC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuYW5pbWF0aW9uID0gMDtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJvcGVuX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZSBjbGVhbl9ub2RlLmpzdHJlZSBsb2FkZWQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLl9wcmVwYXJlX3dob2xlcm93X3NwYW4oIGRhdGEgJiYgZGF0YS5yc2x0ICYmIGRhdGEucnNsdC5vYmogPyBkYXRhLnJzbHQub2JqIDogLTEgKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJzZWFyY2guanN0cmVlIGNsZWFyX3NlYXJjaC5qc3RyZWUgcmVvcGVuLmpzdHJlZSBhZnRlcl9vcGVuLmpzdHJlZSBhZnRlcl9jbG9zZS5qc3RyZWUgY3JlYXRlX25vZGUuanN0cmVlIGRlbGV0ZV9ub2RlLmpzdHJlZSBjbGVhbl9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLnRvKSB7IGNsZWFyVGltZW91dCh0aGlzLmRhdGEudG8pOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEudG8gPSBzZXRUaW1lb3V0KCAoZnVuY3Rpb24gKHQsIG8pIHsgcmV0dXJuIGZ1bmN0aW9uKCkgeyB0Ll9wcmVwYXJlX3dob2xlcm93X3VsKG8pOyB9OyB9KSh0aGlzLCAgZGF0YSAmJiBkYXRhLnJzbHQgJiYgZGF0YS5yc2x0Lm9iaiA/IGRhdGEucnNsdC5vYmogOiAtMSksIDApO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImRlc2VsZWN0X2FsbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCIgPiAuanN0cmVlLXdob2xlcm93IC5qc3RyZWUtY2xpY2tlZFwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbGlja2VkIFwiICsgKHRoaXMuZGF0YS50aGVtZXJvbGxlciA/IHRoaXMuX2dldF9zZXR0aW5ncygpLnRoZW1lcm9sbGVyLml0ZW1fYSA6IFwiXCIgKSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwic2VsZWN0X25vZGUuanN0cmVlIGRlc2VsZWN0X25vZGUuanN0cmVlIFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0ZGF0YS5yc2x0Lm9iai5lYWNoKGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRcdHZhciByZWYgPSBkYXRhLmluc3QuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCIgPiAuanN0cmVlLXdob2xlcm93IGxpOnZpc2libGU6ZXEoXCIgKyAoIHBhcnNlSW50KCgoJCh0aGlzKS5vZmZzZXQoKS50b3AgLSBkYXRhLmluc3QuZ2V0X2NvbnRhaW5lcigpLm9mZnNldCgpLnRvcCArIGRhdGEuaW5zdC5nZXRfY29udGFpbmVyKClbMF0uc2Nyb2xsVG9wKSAvIGRhdGEuaW5zdC5kYXRhLmNvcmUubGlfaGVpZ2h0KSwxMCkpICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHQvLyByZWYuY2hpbGRyZW4oXCJhXCIpW2UudHlwZSA9PT0gXCJzZWxlY3Rfbm9kZVwiID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShcImpzdHJlZS1jbGlja2VkXCIpO1xuXHRcdFx0XHRcdFx0XHRyZWYuY2hpbGRyZW4oXCJhXCIpLmF0dHIoXCJjbGFzc1wiLGRhdGEucnNsdC5vYmouY2hpbGRyZW4oXCJhXCIpLmF0dHIoXCJjbGFzc1wiKSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiID4gLmpzdHJlZS13aG9sZXJvdyAuanN0cmVlLWhvdmVyZWRcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtaG92ZXJlZCBcIiArICh0aGlzLmRhdGEudGhlbWVyb2xsZXIgPyB0aGlzLl9nZXRfc2V0dGluZ3MoKS50aGVtZXJvbGxlci5pdGVtX2ggOiBcIlwiICkpO1xuXHRcdFx0XHRcdFx0aWYoZS50eXBlID09PSBcImhvdmVyX25vZGVcIikge1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVmID0gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIiA+IC5qc3RyZWUtd2hvbGVyb3cgbGk6dmlzaWJsZTplcShcIiArICggcGFyc2VJbnQoKChkYXRhLnJzbHQub2JqLm9mZnNldCgpLnRvcCAtIHRoaXMuZ2V0X2NvbnRhaW5lcigpLm9mZnNldCgpLnRvcCArIHRoaXMuZ2V0X2NvbnRhaW5lcigpWzBdLnNjcm9sbFRvcCkgLyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQpLDEwKSkgKyBcIilcIik7XG5cdFx0XHRcdFx0XHRcdC8vIHJlZi5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3MoXCJqc3RyZWUtaG92ZXJlZFwiKTtcblx0XHRcdFx0XHRcdFx0cmVmLmNoaWxkcmVuKFwiYVwiKS5hdHRyKFwiY2xhc3NcIixkYXRhLnJzbHQub2JqLmNoaWxkcmVuKFwiLmpzdHJlZS1ob3ZlcmVkXCIpLmF0dHIoXCJjbGFzc1wiKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcIi5qc3RyZWUtd2hvbGVyb3ctc3BhbiwgaW5zLmpzdHJlZS1pY29uLCBsaVwiLCBcImNsaWNrLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dmFyIG4gPSAkKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldC50YWdOYW1lID09PSBcIkFcIiB8fCAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJJTlNcIiAmJiBuLmNsb3Nlc3QoXCJsaVwiKS5pcyhcIi5qc3RyZWUtb3BlbiwgLmpzdHJlZS1jbG9zZWRcIikpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0bi5jbG9zZXN0KFwibGlcIikuY2hpbGRyZW4oXCJhOnZpc2libGU6ZXEoMClcIikuY2xpY2soKTtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0LmRlbGVnYXRlKFwibGlcIiwgXCJtb3VzZW92ZXIuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRpZigkKGUuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oXCIuanN0cmVlLWhvdmVyZWQsIC5qc3RyZWUtY2xpY2tlZFwiKS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmRlbGVnYXRlKFwibGlcIiwgXCJtb3VzZWxlYXZlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZigkKGUuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oXCJhXCIpLmhhc0NsYXNzKFwianN0cmVlLWhvdmVyZWRcIikubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0dGhpcy5kZWhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRpZihpc19pZTcgfHwgaXNfaWU2KSB7XG5cdFx0XHRcdCQudmFrYXRhLmNzcy5hZGRfc2hlZXQoeyBzdHIgOiBcIi5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpICsgXCIgeyBwb3NpdGlvbjpyZWxhdGl2ZTsgfSBcIiwgdGl0bGUgOiBcImpzdHJlZVwiIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0fSxcblx0XHRfX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcIi5qc3RyZWUtd2hvbGVyb3dcIikucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiLmpzdHJlZS13aG9sZXJvdy1zcGFuXCIpLnJlbW92ZSgpO1xuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0X3ByZXBhcmVfd2hvbGVyb3dfc3BhbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gIW9iaiB8fCBvYmogPT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpXCIpIDogdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09PSBmYWxzZSkgeyByZXR1cm47IH0gLy8gYWRkZWQgZm9yIHJlbW92aW5nIHJvb3Qgbm9kZXNcblx0XHRcdFx0b2JqLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQodGhpcykuZmluZChcImxpXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHRpZigkdC5jaGlsZHJlbihcIi5qc3RyZWUtd2hvbGVyb3ctc3BhblwiKS5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdCR0LnByZXBlbmQoXCI8c3BhbiBjbGFzcz0nanN0cmVlLXdob2xlcm93LXNwYW4nIHN0eWxlPSd3aWR0aDpcIiArICgkdC5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsXCJsaVwiKS5sZW5ndGggKiAxOCkgKyBcInB4Oyc+JiMxNjA7PC9zcGFuPlwiKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0X3ByZXBhcmVfd2hvbGVyb3dfdWwgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBvID0gdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lcSgwKSwgaCA9IG8uaHRtbCgpO1xuXHRcdFx0XHRvLmFkZENsYXNzKFwianN0cmVlLXdob2xlcm93LXJlYWxcIik7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS53aG9sZXJvdy5sYXN0X2h0bWwgIT09IGgpIHtcblx0XHRcdFx0XHR0aGlzLmRhdGEud2hvbGVyb3cubGFzdF9odG1sID0gaDtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcIi5qc3RyZWUtd2hvbGVyb3dcIikucmVtb3ZlKCk7XG5cdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuYXBwZW5kKFxuXHRcdFx0XHRcdFx0by5jbG9uZSgpLnJlbW92ZUNsYXNzKFwianN0cmVlLXdob2xlcm93LXJlYWxcIilcblx0XHRcdFx0XHRcdFx0LndyYXBBbGwoXCI8ZGl2IGNsYXNzPSdqc3RyZWUtd2hvbGVyb3cnIC8+XCIpLnBhcmVudCgpXG5cdFx0XHRcdFx0XHRcdC53aWR0aChvLnBhcmVudCgpWzBdLnNjcm9sbFdpZHRoKVxuXHRcdFx0XHRcdFx0XHQuY3NzKFwidG9wXCIsIChvLmhlaWdodCgpICsgKCBpc19pZTcgPyA1IDogMCkpICogLTEgKVxuXHRcdFx0XHRcdFx0XHQuZmluZChcImxpW2lkXVwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTsgfSkuZW5kKClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0JChmdW5jdGlvbigpIHtcblx0XHR2YXIgY3NzX3N0cmluZyA9ICcnICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LXJlYWwgeyBwb3NpdGlvbjpyZWxhdGl2ZTsgei1pbmRleDoxOyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3ctcmVhbCBsaSB7IGN1cnNvcjpwb2ludGVyOyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3ctcmVhbCBhIHsgYm9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQgIWltcG9ydGFudDsgYm9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7IH0gJyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyB7IHBvc2l0aW9uOnJlbGF0aXZlOyB6LWluZGV4OjA7IGhlaWdodDowOyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgdWwsIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBsaSB7IHdpZHRoOjEwMCU7IH0gJyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IHVsLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgbGksIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBhIHsgbWFyZ2luOjAgIWltcG9ydGFudDsgcGFkZGluZzowICFpbXBvcnRhbnQ7IH0gJyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IHVsLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgbGkgeyBiYWNrZ3JvdW5kOnRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7IH0nICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGlucywgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IHNwYW4sIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBpbnB1dCB7IGRpc3BsYXk6bm9uZSAhaW1wb3J0YW50OyB9JyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBhLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgYTpob3ZlciB7IHRleHQtaW5kZW50Oi05OTk5cHg7ICFpbXBvcnRhbnQ7IHdpZHRoOjEwMCU7IHBhZGRpbmc6MCAhaW1wb3J0YW50OyBib3JkZXItcmlnaHQtd2lkdGg6MHB4ICFpbXBvcnRhbnQ7IGJvcmRlci1sZWZ0LXdpZHRoOjBweCAhaW1wb3J0YW50OyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3ctc3BhbiB7IHBvc2l0aW9uOmFic29sdXRlOyBsZWZ0OjA7IG1hcmdpbjowcHg7IHBhZGRpbmc6MDsgaGVpZ2h0OjE4cHg7IGJvcmRlci13aWR0aDowOyBwYWRkaW5nOjA7IHotaW5kZXg6MDsgfSc7XG5cdFx0aWYoaXNfZmYyKSB7XG5cdFx0XHRjc3Nfc3RyaW5nICs9ICcnICsgXG5cdFx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgYSB7IGRpc3BsYXk6YmxvY2s7IGhlaWdodDoxOHB4OyBtYXJnaW46MDsgcGFkZGluZzowOyBib3JkZXI6MDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3ctcmVhbCBhIHsgYm9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7IH0gJztcblx0XHR9XG5cdFx0aWYoaXNfaWU3IHx8IGlzX2llNikge1xuXHRcdFx0Y3NzX3N0cmluZyArPSAnJyArIFxuXHRcdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgbGksIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyB1bCwgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGEgeyBtYXJnaW46MDsgcGFkZGluZzowOyBsaW5lLWhlaWdodDoxOHB4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBhIHsgZGlzcGxheTpibG9jazsgaGVpZ2h0OjE4cHg7IGxpbmUtaGVpZ2h0OjE4cHg7IG92ZXJmbG93OmhpZGRlbjsgfSAnO1xuXHRcdH1cblx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgc3RyIDogY3NzX3N0cmluZywgdGl0bGUgOiBcImpzdHJlZVwiIH0pO1xuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4qIGpzVHJlZSBtb2RlbCBwbHVnaW5cbiogVGhpcyBwbHVnaW4gZ2V0cyBqc3RyZWUgdG8gdXNlIGEgY2xhc3MgbW9kZWwgdG8gcmV0cmlldmUgZGF0YSwgY3JlYXRpbmcgZ3JlYXQgZHluYW1pc21cbiovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIG5vZGVJbnRlcmZhY2UgPSBbXCJnZXRDaGlsZHJlblwiLFwiZ2V0Q2hpbGRyZW5Db3VudFwiLFwiZ2V0QXR0clwiLFwiZ2V0TmFtZVwiLFwiZ2V0UHJvcHNcIl0sXG5cdFx0dmFsaWRhdGVJbnRlcmZhY2UgPSBmdW5jdGlvbihvYmosIGludGVyKSB7XG5cdFx0XHR2YXIgdmFsaWQgPSB0cnVlO1xuXHRcdFx0b2JqID0gb2JqIHx8IHt9O1xuXHRcdFx0aW50ZXIgPSBbXS5jb25jYXQoaW50ZXIpO1xuXHRcdFx0JC5lYWNoKGludGVyLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRpZighJC5pc0Z1bmN0aW9uKG9ialt2XSkpIHsgdmFsaWQgPSBmYWxzZTsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB2YWxpZDtcblx0XHR9O1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJtb2RlbFwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoIXRoaXMuZGF0YS5qc29uX2RhdGEpIHsgdGhyb3cgXCJqc1RyZWUgbW9kZWw6IGpzVHJlZSBqc29uX2RhdGEgcGx1Z2luIG5vdCBpbmNsdWRlZC5cIjsgfVxuXHRcdFx0dGhpcy5fZ2V0X3NldHRpbmdzKCkuanNvbl9kYXRhLmRhdGEgPSBmdW5jdGlvbiAobiwgYikge1xuXHRcdFx0XHR2YXIgb2JqID0gKG4gPT0gLTEpID8gdGhpcy5fZ2V0X3NldHRpbmdzKCkubW9kZWwub2JqZWN0IDogbi5kYXRhKFwianN0cmVlX21vZGVsXCIpO1xuXHRcdFx0XHRpZighdmFsaWRhdGVJbnRlcmZhY2Uob2JqLCBub2RlSW50ZXJmYWNlKSkgeyByZXR1cm4gYi5jYWxsKG51bGwsIGZhbHNlKTsgfVxuXHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5tb2RlbC5hc3luYykge1xuXHRcdFx0XHRcdG9iai5nZXRDaGlsZHJlbigkLnByb3h5KGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vZGVsX2RvbmUoZGF0YSwgYik7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubW9kZWxfZG9uZShvYmouZ2V0Q2hpbGRyZW4oKSwgYik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdG9iamVjdCA6IGZhbHNlLFxuXHRcdFx0aWRfcHJlZml4IDogZmFsc2UsXG5cdFx0XHRhc3luYyA6IGZhbHNlXG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRtb2RlbF9kb25lIDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciByZXQgPSBbXSwgXG5cdFx0XHRcdFx0cyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLFxuXHRcdFx0XHRcdF90aGlzID0gdGhpcztcblxuXHRcdFx0XHRpZighJC5pc0FycmF5KGRhdGEpKSB7IGRhdGEgPSBbZGF0YV07IH1cblx0XHRcdFx0JC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChpLCBuZCkge1xuXHRcdFx0XHRcdHZhciByID0gbmQuZ2V0UHJvcHMoKSB8fCB7fTtcblx0XHRcdFx0XHRyLmF0dHIgPSBuZC5nZXRBdHRyKCkgfHwge307XG5cdFx0XHRcdFx0aWYobmQuZ2V0Q2hpbGRyZW5Db3VudCgpKSB7IHIuc3RhdGUgPSBcImNsb3NlZFwiOyB9XG5cdFx0XHRcdFx0ci5kYXRhID0gbmQuZ2V0TmFtZSgpO1xuXHRcdFx0XHRcdGlmKCEkLmlzQXJyYXkoci5kYXRhKSkgeyByLmRhdGEgPSBbci5kYXRhXTsgfVxuXHRcdFx0XHRcdGlmKF90aGlzLmRhdGEudHlwZXMgJiYgJC5pc0Z1bmN0aW9uKG5kLmdldFR5cGUpKSB7XG5cdFx0XHRcdFx0XHRyLmF0dHJbcy50eXBlcy50eXBlX2F0dHJdID0gbmQuZ2V0VHlwZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihyLmF0dHIuaWQgJiYgcy5tb2RlbC5pZF9wcmVmaXgpIHsgci5hdHRyLmlkID0gcy5tb2RlbC5pZF9wcmVmaXggKyByLmF0dHIuaWQ7IH1cblx0XHRcdFx0XHRpZighci5tZXRhZGF0YSkgeyByLm1ldGFkYXRhID0geyB9OyB9XG5cdFx0XHRcdFx0ci5tZXRhZGF0YS5qc3RyZWVfbW9kZWwgPSBuZDtcblx0XHRcdFx0XHRyZXQucHVzaChyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgcmV0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxufSkoKTsiLCIvKlxuICogTGlnaHR3ZWlnaHQgY2xpZW50c2lkZSBpMThuIGltcGxlbWVudGF0aW9uLlxuICogQ2F1dGlvbjogT25seSBhdmFpbGFibGUgYWZ0ZXIgRE9NIGxvYWRlZCBiZWNhdXNlIHdlIG5lZWQgdG8gZGV0ZWN0IHRoZSBsYW5ndWFnZVxuICogXG4gKiBGb3Igbm9uLWkxOG4gc3R1YiBpbXBsZW1lbnRhdGlvbiwgc2VlIGZyYW1ld29yay9qYXZhc2NyaXB0L3NyYy9pMThueC5qc1xuICogXG4gKiBCYXNlZCBvbiBqUXVlcnkgaTE4biBwbHVnaW46IDEuMC4wICBGZWItMTAtMjAwOFxuICogXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlczpcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqICAgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKlxuICogQmFzZWQgb24gJ2phdmFzY3JpcHQgaTE4biB0aGF0IGFsbW9zdCBkb2Vzbid0IHN1Y2snIGJ5IG1hcmtvc1xuICogaHR0cDovL21hcmtvcy5nYWl2by5uZXQvYmxvZy8/cD0xMDBcbiAqL1xuXG5jbGFzcyBpMThuIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5jdXJyZW50TG9jYWxlID0gbnVsbDtcblx0XHR0aGlzLmRlZmF1bHRMb2NhbGUgPSAnZW5fVVMnO1xuXHRcdHRoaXMubGFuZyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBsb2NhbGUgaW4gbG9uZyBmb3JtYXQsIGUuZy4gXCJkZV9BVFwiIGZvciBBdXN0cmlhbiBHZXJtYW4uXG5cdCAqXG5cdCAqIEBwYXJhbSBzdHJpbmcgbG9jYWxlXG5cdCAqL1xuXHRzZXRMb2NhbGUobG9jYWxlKSB7XG5cdFx0dGhpcy5jdXJyZW50TG9jYWxlID0gbG9jYWxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBsb2NhbGUgaW4gbG9uZyBmb3JtYXQuIEZhbGxzIGJhY2sgdG8gaTE4bi5kZWZhdXRfbG9jYWxlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHN0cmluZ1xuXHQgKi9cblx0Z2V0TG9jYWxlKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRMb2NhbGUgIT09IG51bGwgPyB0aGlzLmN1cnJlbnRMb2NhbGUgOiB0aGlzLmRlZmF1bHRMb2NhbGU7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGFjdHVhbCB0cmFuc2xhdGlvbiBmdW5jdGlvbi4gTG9va3MgdGhlIGdpdmVuIHN0cmluZyB1cCBpbiB0aGUgXG5cdCAqIGRpY3Rpb25hcnkgYW5kIHJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGlmIG9uZSBleGlzdHMuIElmIGEgdHJhbnNsYXRpb24gXG5cdCAqIGlzIG5vdCBmb3VuZCwgcmV0dXJucyB0aGUgb3JpZ2luYWwgd29yZC5cblx0ICpcblx0ICogQHBhcmFtIHN0cmluZyBlbnRpdHkgLSBBIFwibG9uZ1wiIGxvY2FsZSBmb3JtYXQsIGUuZy4gXCJkZV9ERVwiIChSZXF1aXJlZClcblx0ICogQHBhcmFtIHN0cmluZyBmYWxsYmFja1N0cmluZyAtIChSZXF1aXJlZClcblx0ICogQHBhcmFtIGludCBwcmlvcml0eSAtIChub3QgdXNlZClcblx0ICogQHBhcmFtIHN0cmluZyBjb250ZXh0IC0gR2l2ZSB0cmFuc2xhdG9ycyBjb250ZXh0IGZvciB0aGUgc3RyaW5nXG5cdCAqIEByZXR1cm4gc3RyaW5nIDogVHJhbnNsYXRlZCB3b3JkXG5cdCAqL1xuXHRfdChlbnRpdHksIGZhbGxiYWNrU3RyaW5nLCBwcmlvcml0eSwgY29udGV4dCkge1xuXHRcdGNvbnN0IGxhbmdOYW1lID0gdGhpcy5nZXRMb2NhbGUoKS5yZXBsYWNlKC9fW1xcd10rL2ksICcnKTtcblx0XHRjb25zdCBkZWZhdWx0bGFuZ05hbWUgPSB0aGlzLmRlZmF1bHRMb2NhbGUucmVwbGFjZSgvX1tcXHddKy9pLCAnJyk7XG5cblx0XHRpZiAodGhpcy5sYW5nICYmIHRoaXMubGFuZ1t0aGlzLmdldExvY2FsZSgpXSAmJiB0aGlzLmxhbmdbdGhpcy5nZXRMb2NhbGUoKV1bZW50aXR5XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGFuZ1t0aGlzLmdldExvY2FsZSgpXVtlbnRpdHldO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5sYW5nICYmIHRoaXMubGFuZ1tsYW5nTmFtZV0gJiYgdGhpcy5sYW5nW2xhbmdOYW1lXVtlbnRpdHldKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sYW5nW2xhbmdOYW1lXVtlbnRpdHldO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5sYW5nICYmIHRoaXMubGFuZ1t0aGlzLmRlZmF1bHRMb2NhbGVdICYmIHRoaXMubGFuZ1t0aGlzLmRlZmF1bHRMb2NhbGVdW2VudGl0eV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmxhbmdbdGhpcy5kZWZhdWx0TG9jYWxlXVtlbnRpdHldO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5sYW5nICYmIHRoaXMubGFuZ1tkZWZhdWx0bGFuZ05hbWVdICYmIHRoaXMubGFuZ1tkZWZhdWx0bGFuZ05hbWVdW2VudGl0eV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmxhbmdbZGVmYXVsdGxhbmdOYW1lXVtlbnRpdHldOyBcblx0XHR9IGVsc2UgaWYoZmFsbGJhY2tTdHJpbmcpIHtcblx0XHRcdHJldHVybiBmYWxsYmFja1N0cmluZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgZW50aXRpZXMgdG8gYSBkaWN0aW9uYXJ5LiBJZiBhIGRpY3Rpb25hcnkgZG9lc24ndFxuXHQgKiBleGlzdCBmb3IgdGhpcyBsb2NhbGUsIGl0cyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXG5cdCAqIEV4aXN0aW5nIGVudGl0aWVzIGFyZSBvdmVyd3JpdHRlbi5cblx0ICogXG5cdCAqIEBwYXJhbSBzdHJpbmcgbG9jYWxlXG5cdCAqIEBwYXJhbSBPYmplY3QgZGljdFxuXHQgKi9cblx0YWRkRGljdGlvbmFyeShsb2NhbGUsIGRpY3QpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMubGFuZ1tsb2NhbGVdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5sYW5nW2xvY2FsZV0gPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBlbnRpdHkgaW4gZGljdCkge1xuXHRcdFx0dGhpcy5sYW5nW2xvY2FsZV1bZW50aXR5XSA9IGRpY3RbZW50aXR5XTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGRpY3Rpb25hcnkgZm9yIGEgc3BlY2lmaWMgbG9jYWxlLlxuXHQgKiBcblx0ICogQHBhcmFtIHN0cmluZyBsb2NhbGVcblx0ICovXG5cdGdldERpY3Rpb25hcnkobG9jYWxlKSB7XG5cdFx0cmV0dXJuIHRoaXMubGFuZ1tsb2NhbGVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSBzdHJpbmcgc3RyIC0gVGhlIHN0cmluZyB0byBzdHJpcC5cblx0ICogQHJldHVybiBzdHJpbmcgcmVzdWx0IC0gU3RyaXBwZWQgc3RyaW5nLlxuXHQgKlxuXHQgKi9cblx0c3RyaXBTdHIoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gc3RyaW5nIHN0ciAtIFRoZSBtdWx0aS1saW5lIHN0cmluZyB0byBzdHJpcC5cblx0ICogQHJldHVybiBzdHJpbmcgcmVzdWx0IC0gU3RyaXBwZWQgc3RyaW5nLlxuXHQgKlxuXHQgKi9cblx0c3RyaXBTdHJNTChzdHIpIHtcblx0XHQvLyBTcGxpdCBiZWNhdXNlIG0gZmxhZyBkb2Vzbid0IGV4aXN0IGJlZm9yZSBKUzEuNSBhbmQgd2UgbmVlZCB0b1xuXHRcdC8vIHN0cmlwIG5ld2xpbmVzIGFueXdheVxuXHRcdHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnXFxuJyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IHN0cmlwU3RyKHBhcnRzW2ldKTtcblx0XHR9XG5cblx0XHQvLyBEb24ndCBqb2luIHdpdGggZW1wdHkgc3RyaW5ncywgYmVjYXVzZSBpdCBcImNvbmNhdHNcIiB3b3Jkc1xuXHRcdC8vIEFuZCBzdHJpcCBhZ2FpblxuXHRcdHJldHVybiBzdHJpcFN0cihwYXJ0cy5qb2luKCcgJykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnN0aXR1dGVzICVzIHdpdGggcGFyYW1ldGVyc1xuIFx0ICogZ2l2ZW4gaW4gbGlzdC4gJSVzIGlzIHVzZWQgdG8gZXNjYXBlICVzLlxuIFx0ICogXG5cdCAqIEBwYXJhbSBzdHJpbmcgcyAtIFRoZSBzdHJpbmcgdG8gcGVyZm9ybSB0aGUgc3Vic3RpdHV0aW9ucyBvbi5cblx0ICogQHJldHVybiBzdHJpbmcgLSBUaGUgbmV3IHN0cmluZyB3aXRoIHN1YnN0aXR1dGlvbnMgbWFkZS5cblx0ICovXG5cdHNwcmludGYocywgLi4ucGFyYW1zKSB7XG5cdFx0aWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBzO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlZ3ggPSBuZXcgUmVnRXhwKCcoLj8pKCVzKScsICdnJyk7XG5cblx0XHRsZXQgaSA9IDA7XG5cblx0XHRyZXR1cm4gcy5yZXBsYWNlKHJlZ3gsIGZ1bmN0aW9uIChtYXRjaCwgc3ViTWF0Y2gxLCBzdWJNYXRjaDIsIG9mZnNldCwgc3RyaW5nKSB7XG5cdFx0XHQvLyBza2lwICUlc1xuXHRcdFx0aWYgKHN1Yk1hdGNoMSA9PT0gJyUnKSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaDsgXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdWJNYXRjaDEgKyBwYXJhbXNbaSArPSAxXTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJzdGl0dXRlcyB2YXJpYWJsZXMgd2l0aCBhIGxpc3Qgb2YgaW5qZWN0aW9ucy4gXG4gXHQgKiBcblx0ICogQHBhcmFtIHN0cmluZyBzIC0gVGhlIHN0cmluZyB0byBwZXJmb3JtIHRoZSBzdWJzdGl0dXRpb25zIG9uLlxuXHQgKiBAcGFyYW0gb2JqZWN0IG1hcCAtIEFuIG9iamVjdCB3aXRoIHRoZSBzdWJzdGl0aW9ucyBtYXAgZS5nLiB7dmFyOiB2YWx1ZX0uXG5cdCAqIEByZXR1cm4gc3RyaW5nIC0gVGhlIG5ldyBzdHJpbmcgd2l0aCBzdWJzdGl0dXRpb25zIG1hZGUuXG5cdCAqL1xuXHRpbmplY3QocywgbWFwKSB7XG5cdFx0Y29uc3QgcmVneCA9IG5ldyBSZWdFeHAoJ1xceyhbQS1aYS16MC05X10qKVxcfScsICdnJyk7XG5cblx0XHRyZXR1cm4gcy5yZXBsYWNlKHJlZ3gsIGZ1bmN0aW9uIChtYXRjaCwga2V5LCBvZmZzZXQsIHN0cmluZykge1xuXHRcdFx0cmV0dXJuIChtYXBba2V5XSkgPyBtYXBba2V5XSA6IG1hdGNoO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVjdCBkb2N1bWVudCBsYW5ndWFnZSBzZXR0aW5ncyBieSBsb29raW5nIGF0IDxtZXRhPiB0YWdzLlxuXHQgKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgcmV0dXJucyB0aGlzLmRlZmF1bHRMb2NhbGUuXG5cdCAqIFxuXHQgKiBAdG9kbyBnZXQgYnkgPGh0bWwgbGFuZz0nJz4gLSBuZWVkcyBtb2RpZmljYXRpb24gb2YgU1NWaWV3ZXJcblx0ICogXG5cdCAqIEByZXR1cm4gc3RyaW5nIC0gTG9jYWxlIGluIG1peGVkIGxvd2VyY2FzZS91cHBlcmNhc2UgZm9ybWF0IHN1aXRhYmxlXG5cdCAqIGZvciB1c2FnZSBpbiBpMThuLmxhbmcgYXJyYXlzIChlLmcuICdlbl9VUycpLlxuXHQgKi9cblx0ZGV0ZWN0TG9jYWxlKCkge1xuXHRcdHZhciByYXdMb2NhbGU7XG5cdFx0dmFyIGRldGVjdGVkTG9jYWxlO1xuXG5cdFx0Ly8gR2V0IGJ5IGNvbnRhaW5lciB0YWdcblx0XHRyYXdMb2NhbGUgPSBqUXVlcnkoJ2JvZHknKS5hdHRyKCdsYW5nJyk7XG5cblx0XHQvLyBHZXQgYnkgbWV0YVxuXHRcdGlmICghcmF3TG9jYWxlKSB7XG5cdFx0XHR2YXIgbWV0YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbWV0YScpO1xuXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bWV0YXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG1ldGFzW2ldLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXSAmJiBtZXRhc1tpXS5hdHRyaWJ1dGVzWydodHRwLWVxdWl2J10ubm9kZVZhbHVlLnRvTG93ZXJDYXNlKCkgPT0gJ2NvbnRlbnQtbGFuZ3VhZ2UnKSB7XG5cdFx0XHRcdFx0cmF3TG9jYWxlID0gbWV0YXNbaV0uYXR0cmlidXRlc1snY29udGVudCddLm5vZGVWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgbG9jYWxlXG5cdFx0aWYgKCFyYXdMb2NhbGUpIHtcblx0XHRcdHJhd0xvY2FsZSA9IHRoaXMuZGVmYXVsdExvY2FsZTtcblx0XHR9XG5cblx0XHR2YXIgcmF3TG9jYWxlUGFydHMgPSByYXdMb2NhbGUubWF0Y2goLyhbXi18X10qKVstfF9dKC4qKS8pO1xuXHRcdC8vIEdldCBsb2NhbGUgKGUuZy4gJ2VuX1VTJykgZnJvbSBjb21tb24gbmFtZSAoZS5nLiAnZW4nKVxuXHRcdC8vIGJ5IGxvb2tpbmcgYXQgaTE4bi5sYW5nIHRhYmxlc1xuXHRcdGlmIChyYXdMb2NhbGUubGVuZ3RoID09IDIpIHtcblx0XHRcdGZvciAobGV0IGNvbXBhcmVMb2NhbGUgaW4gaTE4bi5sYW5nKSB7XG5cdFx0XHRcdGlmIChjb21wYXJlTG9jYWxlLnN1YnN0cigwLDIpLnRvTG93ZXJDYXNlKCkgPT0gcmF3TG9jYWxlLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRkZXRlY3RlZExvY2FsZSA9IGNvbXBhcmVMb2NhbGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHJhd0xvY2FsZVBhcnRzKSB7XG5cdFx0XHRkZXRlY3RlZExvY2FsZSA9IHJhd0xvY2FsZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgKyAnXycgKyByYXdMb2NhbGVQYXJ0c1syXS50b1VwcGVyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZXRlY3RlZExvY2FsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGdpdmVuIG9iamVjdC5cblx0ICogTW9kZWxlZCBhZnRlciBiZWhhdmlvdXIuanMsIGJ1dCBleHRlcm5hbGl6ZWRcblx0ICogdG8ga2VlcCB0aGUgaTE4biBsaWJyYXJ5IHN0YW5kYWxvbmUgZm9yIG5vdy5cblx0ICovXG5cdGFkZEV2ZW50KG9iaiwgZXZUeXBlLCBmbiwgdXNlQ2FwdHVyZSkge1xuXHRcdGlmIChvYmouYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZUeXBlLCBmbiwgdXNlQ2FwdHVyZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKG9iai5hdHRhY2hFdmVudCkge1xuXHRcdFx0cmV0dXJuIG9iai5hdHRhY2hFdmVudCgnb24nICsgZXZUeXBlLCBmbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdIYW5kbGVyIGNvdWxkIG5vdCBiZSBhdHRhY2hlZCcpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgX2kxOG4gPSBuZXcgaTE4bigpO1xuXG4vLyBUaGlzIG1vZHVsZSBoYXMgdG8gc3VwcG9ydCBsZWdhY3kgbG9hZGluZy4uLlxud2luZG93LnNzID0gdHlwZW9mIHdpbmRvdy5zcyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuc3MgOiB7fTtcbndpbmRvdy5zcy5pMThuID0gd2luZG93LmkxOG4gPSBfaTE4bjtcblxuZXhwb3J0IGRlZmF1bHQgX2kxOG47XG4iLCIvKipcbiAqIFRoaXMgd3JhcHMgdGhlIGdsb2JhbCBqUXVlcnkgc28galF1ZXJ5IGNhbiBiZSBpbXBvcnRlZFxuICogbGlrZSBvdGhlciBtb2R1bGVzLiBPbmNlIGpRdWVyeSBpcyB1cGRhdGVkIGFuZCBtYW5hZ2VkXG4gKiBieSBucG0gd2UgY2FuIGdldCByaWQgb2YgdGhpcyB3cmFwcGVyLlxuICovXG52YXIgalF1ZXJ5ID0gdHlwZW9mIHdpbmRvdy5qUXVlcnkgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmpRdWVyeSA6IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGpRdWVyeTtcbiJdfQ==
